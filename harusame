#!/usr/bin/env perl
#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Char/Class/XML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHAR_CLASS_XML';
  
  ## This file is auto-generated.  Do not edit by hand!
  use strict;
  
  package Char::Class::XML;
  our $VERSION = '3.0';
  use Carp;
  
  our @EXPORT;
  our @EXPORT_OK;
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
  } # import
  
  
  =head1 NAME
  
  Char::Class::XML - Regular Expression Character Classes - C<XML>
  
  
  =cut
  @EXPORT_OK = qw(InXMLBaseChar InXMLChar10 InXMLChar11 InXMLCombiningChar InXMLDigit InXMLExtender InXMLIdeographic InXMLLetter InXMLNCNameChar10_1 InXMLNCNameChar10_5 InXMLNCNameChar11 InXMLNCNameStartChar10_5 InXMLNCNameStartChar11 InXMLNameChar10_1 InXMLNameChar10_5 InXMLNameChar11 InXMLNameStartChar10_5 InXMLNameStartChar11 InXMLPubidChar InXMLRestrictedChar11 InXMLS InXMLVersionNum InXML_NCNameStartChar10_1 InXML_NameStartChar10_1 InXML_UnrestrictedChar10 InXML_UnrestrictedChar11 InXML_deprecated_noncharacter InXML_unicode_xml_not_suitable InXML_unicode_xml_suitable_format_character InXMLChar InXMLNCNameChar InXMLNCNameChar10 InXMLNCNameStartChar InXMLNCNameStartChar10 InXMLNameChar InXMLNameChar10 InXMLNameStartChar InXMLNameStartChar10 InXMLRestrictedChar InXML_NCNameStartChar InXML_NCNameStartChar10 InXML_NameStartChar InXML_NameStartChar10 InXML_UnrestrictedChar);
  
  sub InXMLBaseChar {
  <<EOH;
  0041	005A	
  0061	007A	
  00C0	00D6	
  00D8	00F6	
  00F8	0131	
  0134	013E	
  0141	0148	
  014A	017E	
  0180	01C3	
  01CD	01F0	
  01F4	01F5	
  01FA	0217	
  0250	02A8	
  02BB	02C1	
  0386
  0388	038A	
  038C
  038E	03A1	
  03A3	03CE	
  03D0	03D6	
  03DA
  03DC
  03DE
  03E0
  03E2	03F3	
  0401	040C	
  040E	044F	
  0451	045C	
  045E	0481	
  0490	04C4	
  04C7	04C8	
  04CB	04CC	
  04D0	04EB	
  04EE	04F5	
  04F8	04F9	
  0531	0556	
  0559
  0561	0586	
  05D0	05EA	
  05F0	05F2	
  0621	063A	
  0641	064A	
  0671	06B7	
  06BA	06BE	
  06C0	06CE	
  06D0	06D3	
  06D5
  06E5	06E6	
  0905	0939	
  093D
  0958	0961	
  0985	098C	
  098F	0990	
  0993	09A8	
  09AA	09B0	
  09B2
  09B6	09B9	
  09DC	09DD	
  09DF	09E1	
  09F0	09F1	
  0A05	0A0A	
  0A0F	0A10	
  0A13	0A28	
  0A2A	0A30	
  0A32	0A33	
  0A35	0A36	
  0A38	0A39	
  0A59	0A5C	
  0A5E
  0A72	0A74	
  0A85	0A8B	
  0A8D
  0A8F	0A91	
  0A93	0AA8	
  0AAA	0AB0	
  0AB2	0AB3	
  0AB5	0AB9	
  0ABD
  0AE0
  0B05	0B0C	
  0B0F	0B10	
  0B13	0B28	
  0B2A	0B30	
  0B32	0B33	
  0B36	0B39	
  0B3D
  0B5C	0B5D	
  0B5F	0B61	
  0B85	0B8A	
  0B8E	0B90	
  0B92	0B95	
  0B99	0B9A	
  0B9C
  0B9E	0B9F	
  0BA3	0BA4	
  0BA8	0BAA	
  0BAE	0BB5	
  0BB7	0BB9	
  0C05	0C0C	
  0C0E	0C10	
  0C12	0C28	
  0C2A	0C33	
  0C35	0C39	
  0C60	0C61	
  0C85	0C8C	
  0C8E	0C90	
  0C92	0CA8	
  0CAA	0CB3	
  0CB5	0CB9	
  0CDE
  0CE0	0CE1	
  0D05	0D0C	
  0D0E	0D10	
  0D12	0D28	
  0D2A	0D39	
  0D60	0D61	
  0E01	0E2E	
  0E30
  0E32	0E33	
  0E40	0E45	
  0E81	0E82	
  0E84
  0E87	0E88	
  0E8A
  0E8D
  0E94	0E97	
  0E99	0E9F	
  0EA1	0EA3	
  0EA5
  0EA7
  0EAA	0EAB	
  0EAD	0EAE	
  0EB0
  0EB2	0EB3	
  0EBD
  0EC0	0EC4	
  0F40	0F47	
  0F49	0F69	
  10A0	10C5	
  10D0	10F6	
  1100
  1102	1103	
  1105	1107	
  1109
  110B	110C	
  110E	1112	
  113C
  113E
  1140
  114C
  114E
  1150
  1154	1155	
  1159
  115F	1161	
  1163
  1165
  1167
  1169
  116D	116E	
  1172	1173	
  1175
  119E
  11A8
  11AB
  11AE	11AF	
  11B7	11B8	
  11BA
  11BC	11C2	
  11EB
  11F0
  11F9
  1E00	1E9B	
  1EA0	1EF9	
  1F00	1F15	
  1F18	1F1D	
  1F20	1F45	
  1F48	1F4D	
  1F50	1F57	
  1F59
  1F5B
  1F5D
  1F5F	1F7D	
  1F80	1FB4	
  1FB6	1FBC	
  1FBE
  1FC2	1FC4	
  1FC6	1FCC	
  1FD0	1FD3	
  1FD6	1FDB	
  1FE0	1FEC	
  1FF2	1FF4	
  1FF6	1FFC	
  2126
  212A	212B	
  212E
  2180	2182	
  3041	3094	
  30A1	30FA	
  3105	312C	
  AC00	D7A3	
  EOH
  }
  
  sub InXMLChar10 {
  <<EOH;
  0009	000A	
  000D
  0020	D7FF	
  E000	FFFD	
  10000	10FFFF	
  EOH
  }
  
  sub InXMLChar11 {
  <<EOH;
  0001	D7FF	
  E000	FFFD	
  10000	10FFFF	
  EOH
  }
  
  sub InXMLCombiningChar {
  <<EOH;
  0300	0345	
  0360	0361	
  0483	0486	
  0591	05A1	
  05A3	05B9	
  05BB	05BD	
  05BF
  05C1	05C2	
  05C4
  064B	0652	
  0670
  06D6	06E4	
  06E7	06E8	
  06EA	06ED	
  0901	0903	
  093C
  093E	094D	
  0951	0954	
  0962	0963	
  0981	0983	
  09BC
  09BE	09C4	
  09C7	09C8	
  09CB	09CD	
  09D7
  09E2	09E3	
  0A02
  0A3C
  0A3E	0A42	
  0A47	0A48	
  0A4B	0A4D	
  0A70	0A71	
  0A81	0A83	
  0ABC
  0ABE	0AC5	
  0AC7	0AC9	
  0ACB	0ACD	
  0B01	0B03	
  0B3C
  0B3E	0B43	
  0B47	0B48	
  0B4B	0B4D	
  0B56	0B57	
  0B82	0B83	
  0BBE	0BC2	
  0BC6	0BC8	
  0BCA	0BCD	
  0BD7
  0C01	0C03	
  0C3E	0C44	
  0C46	0C48	
  0C4A	0C4D	
  0C55	0C56	
  0C82	0C83	
  0CBE	0CC4	
  0CC6	0CC8	
  0CCA	0CCD	
  0CD5	0CD6	
  0D02	0D03	
  0D3E	0D43	
  0D46	0D48	
  0D4A	0D4D	
  0D57
  0E31
  0E34	0E3A	
  0E47	0E4E	
  0EB1
  0EB4	0EB9	
  0EBB	0EBC	
  0EC8	0ECD	
  0F18	0F19	
  0F35
  0F37
  0F39
  0F3E	0F3F	
  0F71	0F84	
  0F86	0F8B	
  0F90	0F95	
  0F97
  0F99	0FAD	
  0FB1	0FB7	
  0FB9
  20D0	20DC	
  20E1
  302A	302F	
  3099	309A	
  EOH
  }
  
  sub InXMLDigit {
  <<EOH;
  0030	0039	
  0660	0669	
  06F0	06F9	
  0966	096F	
  09E6	09EF	
  0A66	0A6F	
  0AE6	0AEF	
  0B66	0B6F	
  0BE7	0BEF	
  0C66	0C6F	
  0CE6	0CEF	
  0D66	0D6F	
  0E50	0E59	
  0ED0	0ED9	
  0F20	0F29	
  EOH
  }
  
  sub InXMLExtender {
  <<EOH;
  00B7
  02D0	02D1	
  0387
  0640
  0E46
  0EC6
  3005
  3031	3035	
  309D	309E	
  30FC	30FE	
  EOH
  }
  
  sub InXMLIdeographic {
  <<EOH;
  3007
  3021	3029	
  4E00	9FA5	
  EOH
  }
  
  sub InXMLLetter {
  <<EOH;
  0041	005A	
  0061	007A	
  00C0	00D6	
  00D8	00F6	
  00F8	0131	
  0134	013E	
  0141	0148	
  014A	017E	
  0180	01C3	
  01CD	01F0	
  01F4	01F5	
  01FA	0217	
  0250	02A8	
  02BB	02C1	
  0386
  0388	038A	
  038C
  038E	03A1	
  03A3	03CE	
  03D0	03D6	
  03DA
  03DC
  03DE
  03E0
  03E2	03F3	
  0401	040C	
  040E	044F	
  0451	045C	
  045E	0481	
  0490	04C4	
  04C7	04C8	
  04CB	04CC	
  04D0	04EB	
  04EE	04F5	
  04F8	04F9	
  0531	0556	
  0559
  0561	0586	
  05D0	05EA	
  05F0	05F2	
  0621	063A	
  0641	064A	
  0671	06B7	
  06BA	06BE	
  06C0	06CE	
  06D0	06D3	
  06D5
  06E5	06E6	
  0905	0939	
  093D
  0958	0961	
  0985	098C	
  098F	0990	
  0993	09A8	
  09AA	09B0	
  09B2
  09B6	09B9	
  09DC	09DD	
  09DF	09E1	
  09F0	09F1	
  0A05	0A0A	
  0A0F	0A10	
  0A13	0A28	
  0A2A	0A30	
  0A32	0A33	
  0A35	0A36	
  0A38	0A39	
  0A59	0A5C	
  0A5E
  0A72	0A74	
  0A85	0A8B	
  0A8D
  0A8F	0A91	
  0A93	0AA8	
  0AAA	0AB0	
  0AB2	0AB3	
  0AB5	0AB9	
  0ABD
  0AE0
  0B05	0B0C	
  0B0F	0B10	
  0B13	0B28	
  0B2A	0B30	
  0B32	0B33	
  0B36	0B39	
  0B3D
  0B5C	0B5D	
  0B5F	0B61	
  0B85	0B8A	
  0B8E	0B90	
  0B92	0B95	
  0B99	0B9A	
  0B9C
  0B9E	0B9F	
  0BA3	0BA4	
  0BA8	0BAA	
  0BAE	0BB5	
  0BB7	0BB9	
  0C05	0C0C	
  0C0E	0C10	
  0C12	0C28	
  0C2A	0C33	
  0C35	0C39	
  0C60	0C61	
  0C85	0C8C	
  0C8E	0C90	
  0C92	0CA8	
  0CAA	0CB3	
  0CB5	0CB9	
  0CDE
  0CE0	0CE1	
  0D05	0D0C	
  0D0E	0D10	
  0D12	0D28	
  0D2A	0D39	
  0D60	0D61	
  0E01	0E2E	
  0E30
  0E32	0E33	
  0E40	0E45	
  0E81	0E82	
  0E84
  0E87	0E88	
  0E8A
  0E8D
  0E94	0E97	
  0E99	0E9F	
  0EA1	0EA3	
  0EA5
  0EA7
  0EAA	0EAB	
  0EAD	0EAE	
  0EB0
  0EB2	0EB3	
  0EBD
  0EC0	0EC4	
  0F40	0F47	
  0F49	0F69	
  10A0	10C5	
  10D0	10F6	
  1100
  1102	1103	
  1105	1107	
  1109
  110B	110C	
  110E	1112	
  113C
  113E
  1140
  114C
  114E
  1150
  1154	1155	
  1159
  115F	1161	
  1163
  1165
  1167
  1169
  116D	116E	
  1172	1173	
  1175
  119E
  11A8
  11AB
  11AE	11AF	
  11B7	11B8	
  11BA
  11BC	11C2	
  11EB
  11F0
  11F9
  1E00	1E9B	
  1EA0	1EF9	
  1F00	1F15	
  1F18	1F1D	
  1F20	1F45	
  1F48	1F4D	
  1F50	1F57	
  1F59
  1F5B
  1F5D
  1F5F	1F7D	
  1F80	1FB4	
  1FB6	1FBC	
  1FBE
  1FC2	1FC4	
  1FC6	1FCC	
  1FD0	1FD3	
  1FD6	1FDB	
  1FE0	1FEC	
  1FF2	1FF4	
  1FF6	1FFC	
  2126
  212A	212B	
  212E
  2180	2182	
  3007
  3021	3029	
  3041	3094	
  30A1	30FA	
  3105	312C	
  4E00	9FA5	
  AC00	D7A3	
  EOH
  }
  
  sub InXMLNCNameChar10_1 {
  <<EOH;
  002D	002E	
  0030	0039	
  0041	005A	
  005F
  0061	007A	
  00B7
  00C0	00D6	
  00D8	00F6	
  00F8	0131	
  0134	013E	
  0141	0148	
  014A	017E	
  0180	01C3	
  01CD	01F0	
  01F4	01F5	
  01FA	0217	
  0250	02A8	
  02BB	02C1	
  02D0	02D1	
  0300	0345	
  0360	0361	
  0386	038A	
  038C
  038E	03A1	
  03A3	03CE	
  03D0	03D6	
  03DA
  03DC
  03DE
  03E0
  03E2	03F3	
  0401	040C	
  040E	044F	
  0451	045C	
  045E	0481	
  0483	0486	
  0490	04C4	
  04C7	04C8	
  04CB	04CC	
  04D0	04EB	
  04EE	04F5	
  04F8	04F9	
  0531	0556	
  0559
  0561	0586	
  0591	05A1	
  05A3	05B9	
  05BB	05BD	
  05BF
  05C1	05C2	
  05C4
  05D0	05EA	
  05F0	05F2	
  0621	063A	
  0640	0652	
  0660	0669	
  0670	06B7	
  06BA	06BE	
  06C0	06CE	
  06D0	06D3	
  06D5	06E8	
  06EA	06ED	
  06F0	06F9	
  0901	0903	
  0905	0939	
  093C	094D	
  0951	0954	
  0958	0963	
  0966	096F	
  0981	0983	
  0985	098C	
  098F	0990	
  0993	09A8	
  09AA	09B0	
  09B2
  09B6	09B9	
  09BC
  09BE	09C4	
  09C7	09C8	
  09CB	09CD	
  09D7
  09DC	09DD	
  09DF	09E3	
  09E6	09F1	
  0A02
  0A05	0A0A	
  0A0F	0A10	
  0A13	0A28	
  0A2A	0A30	
  0A32	0A33	
  0A35	0A36	
  0A38	0A39	
  0A3C
  0A3E	0A42	
  0A47	0A48	
  0A4B	0A4D	
  0A59	0A5C	
  0A5E
  0A66	0A74	
  0A81	0A83	
  0A85	0A8B	
  0A8D
  0A8F	0A91	
  0A93	0AA8	
  0AAA	0AB0	
  0AB2	0AB3	
  0AB5	0AB9	
  0ABC	0AC5	
  0AC7	0AC9	
  0ACB	0ACD	
  0AE0
  0AE6	0AEF	
  0B01	0B03	
  0B05	0B0C	
  0B0F	0B10	
  0B13	0B28	
  0B2A	0B30	
  0B32	0B33	
  0B36	0B39	
  0B3C	0B43	
  0B47	0B48	
  0B4B	0B4D	
  0B56	0B57	
  0B5C	0B5D	
  0B5F	0B61	
  0B66	0B6F	
  0B82	0B83	
  0B85	0B8A	
  0B8E	0B90	
  0B92	0B95	
  0B99	0B9A	
  0B9C
  0B9E	0B9F	
  0BA3	0BA4	
  0BA8	0BAA	
  0BAE	0BB5	
  0BB7	0BB9	
  0BBE	0BC2	
  0BC6	0BC8	
  0BCA	0BCD	
  0BD7
  0BE7	0BEF	
  0C01	0C03	
  0C05	0C0C	
  0C0E	0C10	
  0C12	0C28	
  0C2A	0C33	
  0C35	0C39	
  0C3E	0C44	
  0C46	0C48	
  0C4A	0C4D	
  0C55	0C56	
  0C60	0C61	
  0C66	0C6F	
  0C82	0C83	
  0C85	0C8C	
  0C8E	0C90	
  0C92	0CA8	
  0CAA	0CB3	
  0CB5	0CB9	
  0CBE	0CC4	
  0CC6	0CC8	
  0CCA	0CCD	
  0CD5	0CD6	
  0CDE
  0CE0	0CE1	
  0CE6	0CEF	
  0D02	0D03	
  0D05	0D0C	
  0D0E	0D10	
  0D12	0D28	
  0D2A	0D39	
  0D3E	0D43	
  0D46	0D48	
  0D4A	0D4D	
  0D57
  0D60	0D61	
  0D66	0D6F	
  0E01	0E2E	
  0E30	0E3A	
  0E40	0E4E	
  0E50	0E59	
  0E81	0E82	
  0E84
  0E87	0E88	
  0E8A
  0E8D
  0E94	0E97	
  0E99	0E9F	
  0EA1	0EA3	
  0EA5
  0EA7
  0EAA	0EAB	
  0EAD	0EAE	
  0EB0	0EB9	
  0EBB	0EBD	
  0EC0	0EC4	
  0EC6
  0EC8	0ECD	
  0ED0	0ED9	
  0F18	0F19	
  0F20	0F29	
  0F35
  0F37
  0F39
  0F3E	0F47	
  0F49	0F69	
  0F71	0F84	
  0F86	0F8B	
  0F90	0F95	
  0F97
  0F99	0FAD	
  0FB1	0FB7	
  0FB9
  10A0	10C5	
  10D0	10F6	
  1100
  1102	1103	
  1105	1107	
  1109
  110B	110C	
  110E	1112	
  113C
  113E
  1140
  114C
  114E
  1150
  1154	1155	
  1159
  115F	1161	
  1163
  1165
  1167
  1169
  116D	116E	
  1172	1173	
  1175
  119E
  11A8
  11AB
  11AE	11AF	
  11B7	11B8	
  11BA
  11BC	11C2	
  11EB
  11F0
  11F9
  1E00	1E9B	
  1EA0	1EF9	
  1F00	1F15	
  1F18	1F1D	
  1F20	1F45	
  1F48	1F4D	
  1F50	1F57	
  1F59
  1F5B
  1F5D
  1F5F	1F7D	
  1F80	1FB4	
  1FB6	1FBC	
  1FBE
  1FC2	1FC4	
  1FC6	1FCC	
  1FD0	1FD3	
  1FD6	1FDB	
  1FE0	1FEC	
  1FF2	1FF4	
  1FF6	1FFC	
  20D0	20DC	
  20E1
  2126
  212A	212B	
  212E
  2180	2182	
  3005
  3007
  3021	302F	
  3031	3035	
  3041	3094	
  3099	309A	
  309D	309E	
  30A1	30FA	
  30FC	30FE	
  3105	312C	
  4E00	9FA5	
  AC00	D7A3	
  EOH
  }
  
  sub InXMLNCNameChar10_5 {
  <<EOH;
  002D	002E	
  0030	0039	
  0041	005A	
  005F
  0061	007A	
  00B7
  00C0	00D6	
  00D8	00F6	
  00F8	037D	
  037F	1FFF	
  200C	200D	
  203F	2040	
  2070	218F	
  2C00	2FEF	
  3001	D7FF	
  F900	FDCF	
  FDF0	FFFD	
  10000	EFFFF	
  EOH
  }
  
  sub InXMLNCNameChar11 {
  <<EOH;
  002D	002E	
  0030	0039	
  0041	005A	
  005F
  0061	007A	
  00B7
  00C0	00D6	
  00D8	00F6	
  00F8	037D	
  037F	1FFF	
  200C	200D	
  203F	2040	
  2070	218F	
  2C00	2FEF	
  3001	D7FF	
  F900	FDCF	
  FDF0	FFFD	
  10000	EFFFF	
  EOH
  }
  
  sub InXMLNCNameStartChar10_5 {
  <<EOH;
  0041	005A	
  005F
  0061	007A	
  00C0	00D6	
  00D8	00F6	
  00F8	02FF	
  0370	037D	
  037F	1FFF	
  200C	200D	
  2070	218F	
  2C00	2FEF	
  3001	D7FF	
  F900	FDCF	
  FDF0	FFFD	
  10000	EFFFF	
  EOH
  }
  
  sub InXMLNCNameStartChar11 {
  <<EOH;
  0041	005A	
  005F
  0061	007A	
  00C0	00D6	
  00D8	00F6	
  00F8	02FF	
  0370	037D	
  037F	1FFF	
  200C	200D	
  2070	218F	
  2C00	2FEF	
  3001	D7FF	
  F900	FDCF	
  FDF0	FFFD	
  10000	EFFFF	
  EOH
  }
  
  sub InXMLNameChar10_1 {
  <<EOH;
  002D	002E	
  0030	003A	
  0041	005A	
  005F
  0061	007A	
  00B7
  00C0	00D6	
  00D8	00F6	
  00F8	0131	
  0134	013E	
  0141	0148	
  014A	017E	
  0180	01C3	
  01CD	01F0	
  01F4	01F5	
  01FA	0217	
  0250	02A8	
  02BB	02C1	
  02D0	02D1	
  0300	0345	
  0360	0361	
  0386	038A	
  038C
  038E	03A1	
  03A3	03CE	
  03D0	03D6	
  03DA
  03DC
  03DE
  03E0
  03E2	03F3	
  0401	040C	
  040E	044F	
  0451	045C	
  045E	0481	
  0483	0486	
  0490	04C4	
  04C7	04C8	
  04CB	04CC	
  04D0	04EB	
  04EE	04F5	
  04F8	04F9	
  0531	0556	
  0559
  0561	0586	
  0591	05A1	
  05A3	05B9	
  05BB	05BD	
  05BF
  05C1	05C2	
  05C4
  05D0	05EA	
  05F0	05F2	
  0621	063A	
  0640	0652	
  0660	0669	
  0670	06B7	
  06BA	06BE	
  06C0	06CE	
  06D0	06D3	
  06D5	06E8	
  06EA	06ED	
  06F0	06F9	
  0901	0903	
  0905	0939	
  093C	094D	
  0951	0954	
  0958	0963	
  0966	096F	
  0981	0983	
  0985	098C	
  098F	0990	
  0993	09A8	
  09AA	09B0	
  09B2
  09B6	09B9	
  09BC
  09BE	09C4	
  09C7	09C8	
  09CB	09CD	
  09D7
  09DC	09DD	
  09DF	09E3	
  09E6	09F1	
  0A02
  0A05	0A0A	
  0A0F	0A10	
  0A13	0A28	
  0A2A	0A30	
  0A32	0A33	
  0A35	0A36	
  0A38	0A39	
  0A3C
  0A3E	0A42	
  0A47	0A48	
  0A4B	0A4D	
  0A59	0A5C	
  0A5E
  0A66	0A74	
  0A81	0A83	
  0A85	0A8B	
  0A8D
  0A8F	0A91	
  0A93	0AA8	
  0AAA	0AB0	
  0AB2	0AB3	
  0AB5	0AB9	
  0ABC	0AC5	
  0AC7	0AC9	
  0ACB	0ACD	
  0AE0
  0AE6	0AEF	
  0B01	0B03	
  0B05	0B0C	
  0B0F	0B10	
  0B13	0B28	
  0B2A	0B30	
  0B32	0B33	
  0B36	0B39	
  0B3C	0B43	
  0B47	0B48	
  0B4B	0B4D	
  0B56	0B57	
  0B5C	0B5D	
  0B5F	0B61	
  0B66	0B6F	
  0B82	0B83	
  0B85	0B8A	
  0B8E	0B90	
  0B92	0B95	
  0B99	0B9A	
  0B9C
  0B9E	0B9F	
  0BA3	0BA4	
  0BA8	0BAA	
  0BAE	0BB5	
  0BB7	0BB9	
  0BBE	0BC2	
  0BC6	0BC8	
  0BCA	0BCD	
  0BD7
  0BE7	0BEF	
  0C01	0C03	
  0C05	0C0C	
  0C0E	0C10	
  0C12	0C28	
  0C2A	0C33	
  0C35	0C39	
  0C3E	0C44	
  0C46	0C48	
  0C4A	0C4D	
  0C55	0C56	
  0C60	0C61	
  0C66	0C6F	
  0C82	0C83	
  0C85	0C8C	
  0C8E	0C90	
  0C92	0CA8	
  0CAA	0CB3	
  0CB5	0CB9	
  0CBE	0CC4	
  0CC6	0CC8	
  0CCA	0CCD	
  0CD5	0CD6	
  0CDE
  0CE0	0CE1	
  0CE6	0CEF	
  0D02	0D03	
  0D05	0D0C	
  0D0E	0D10	
  0D12	0D28	
  0D2A	0D39	
  0D3E	0D43	
  0D46	0D48	
  0D4A	0D4D	
  0D57
  0D60	0D61	
  0D66	0D6F	
  0E01	0E2E	
  0E30	0E3A	
  0E40	0E4E	
  0E50	0E59	
  0E81	0E82	
  0E84
  0E87	0E88	
  0E8A
  0E8D
  0E94	0E97	
  0E99	0E9F	
  0EA1	0EA3	
  0EA5
  0EA7
  0EAA	0EAB	
  0EAD	0EAE	
  0EB0	0EB9	
  0EBB	0EBD	
  0EC0	0EC4	
  0EC6
  0EC8	0ECD	
  0ED0	0ED9	
  0F18	0F19	
  0F20	0F29	
  0F35
  0F37
  0F39
  0F3E	0F47	
  0F49	0F69	
  0F71	0F84	
  0F86	0F8B	
  0F90	0F95	
  0F97
  0F99	0FAD	
  0FB1	0FB7	
  0FB9
  10A0	10C5	
  10D0	10F6	
  1100
  1102	1103	
  1105	1107	
  1109
  110B	110C	
  110E	1112	
  113C
  113E
  1140
  114C
  114E
  1150
  1154	1155	
  1159
  115F	1161	
  1163
  1165
  1167
  1169
  116D	116E	
  1172	1173	
  1175
  119E
  11A8
  11AB
  11AE	11AF	
  11B7	11B8	
  11BA
  11BC	11C2	
  11EB
  11F0
  11F9
  1E00	1E9B	
  1EA0	1EF9	
  1F00	1F15	
  1F18	1F1D	
  1F20	1F45	
  1F48	1F4D	
  1F50	1F57	
  1F59
  1F5B
  1F5D
  1F5F	1F7D	
  1F80	1FB4	
  1FB6	1FBC	
  1FBE
  1FC2	1FC4	
  1FC6	1FCC	
  1FD0	1FD3	
  1FD6	1FDB	
  1FE0	1FEC	
  1FF2	1FF4	
  1FF6	1FFC	
  20D0	20DC	
  20E1
  2126
  212A	212B	
  212E
  2180	2182	
  3005
  3007
  3021	302F	
  3031	3035	
  3041	3094	
  3099	309A	
  309D	309E	
  30A1	30FA	
  30FC	30FE	
  3105	312C	
  4E00	9FA5	
  AC00	D7A3	
  EOH
  }
  
  sub InXMLNameChar10_5 {
  <<EOH;
  002D	002E	
  0030	003A	
  0041	005A	
  005F
  0061	007A	
  00B7
  00C0	00D6	
  00D8	00F6	
  00F8	037D	
  037F	1FFF	
  200C	200D	
  203F	2040	
  2070	218F	
  2C00	2FEF	
  3001	D7FF	
  F900	FDCF	
  FDF0	FFFD	
  10000	EFFFF	
  EOH
  }
  
  sub InXMLNameChar11 {
  <<EOH;
  002D	002E	
  0030	003A	
  0041	005A	
  005F
  0061	007A	
  00B7
  00C0	00D6	
  00D8	00F6	
  00F8	037D	
  037F	1FFF	
  200C	200D	
  203F	2040	
  2070	218F	
  2C00	2FEF	
  3001	D7FF	
  F900	FDCF	
  FDF0	FFFD	
  10000	EFFFF	
  EOH
  }
  
  sub InXMLNameStartChar10_5 {
  <<EOH;
  003A
  0041	005A	
  005F
  0061	007A	
  00C0	00D6	
  00D8	00F6	
  00F8	02FF	
  0370	037D	
  037F	1FFF	
  200C	200D	
  2070	218F	
  2C00	2FEF	
  3001	D7FF	
  F900	FDCF	
  FDF0	FFFD	
  10000	EFFFF	
  EOH
  }
  
  sub InXMLNameStartChar11 {
  <<EOH;
  003A
  0041	005A	
  005F
  0061	007A	
  00C0	00D6	
  00D8	00F6	
  00F8	02FF	
  0370	037D	
  037F	1FFF	
  200C	200D	
  2070	218F	
  2C00	2FEF	
  3001	D7FF	
  F900	FDCF	
  FDF0	FFFD	
  10000	EFFFF	
  EOH
  }
  
  sub InXMLPubidChar {
  <<EOH;
  000A
  000D
  0020	0021	
  0023	0025	
  0027	003B	
  003D
  003F	005A	
  005F
  0061	007A	
  EOH
  }
  
  sub InXMLRestrictedChar11 {
  <<EOH;
  0001	0008	
  000B	000C	
  000E	001F	
  007F	0084	
  0086	009F	
  EOH
  }
  
  sub InXMLS {
  <<EOH;
  0009	000A	
  000D
  0020
  EOH
  }
  
  sub InXMLVersionNum {
  <<EOH;
  002E
  0030	0039	
  EOH
  }
  
  sub InXML_NCNameStartChar10_1 {
  <<EOH;
  0041	005A	
  005F
  0061	007A	
  00C0	00D6	
  00D8	00F6	
  00F8	0131	
  0134	013E	
  0141	0148	
  014A	017E	
  0180	01C3	
  01CD	01F0	
  01F4	01F5	
  01FA	0217	
  0250	02A8	
  02BB	02C1	
  0386
  0388	038A	
  038C
  038E	03A1	
  03A3	03CE	
  03D0	03D6	
  03DA
  03DC
  03DE
  03E0
  03E2	03F3	
  0401	040C	
  040E	044F	
  0451	045C	
  045E	0481	
  0490	04C4	
  04C7	04C8	
  04CB	04CC	
  04D0	04EB	
  04EE	04F5	
  04F8	04F9	
  0531	0556	
  0559
  0561	0586	
  05D0	05EA	
  05F0	05F2	
  0621	063A	
  0641	064A	
  0671	06B7	
  06BA	06BE	
  06C0	06CE	
  06D0	06D3	
  06D5
  06E5	06E6	
  0905	0939	
  093D
  0958	0961	
  0985	098C	
  098F	0990	
  0993	09A8	
  09AA	09B0	
  09B2
  09B6	09B9	
  09DC	09DD	
  09DF	09E1	
  09F0	09F1	
  0A05	0A0A	
  0A0F	0A10	
  0A13	0A28	
  0A2A	0A30	
  0A32	0A33	
  0A35	0A36	
  0A38	0A39	
  0A59	0A5C	
  0A5E
  0A72	0A74	
  0A85	0A8B	
  0A8D
  0A8F	0A91	
  0A93	0AA8	
  0AAA	0AB0	
  0AB2	0AB3	
  0AB5	0AB9	
  0ABD
  0AE0
  0B05	0B0C	
  0B0F	0B10	
  0B13	0B28	
  0B2A	0B30	
  0B32	0B33	
  0B36	0B39	
  0B3D
  0B5C	0B5D	
  0B5F	0B61	
  0B85	0B8A	
  0B8E	0B90	
  0B92	0B95	
  0B99	0B9A	
  0B9C
  0B9E	0B9F	
  0BA3	0BA4	
  0BA8	0BAA	
  0BAE	0BB5	
  0BB7	0BB9	
  0C05	0C0C	
  0C0E	0C10	
  0C12	0C28	
  0C2A	0C33	
  0C35	0C39	
  0C60	0C61	
  0C85	0C8C	
  0C8E	0C90	
  0C92	0CA8	
  0CAA	0CB3	
  0CB5	0CB9	
  0CDE
  0CE0	0CE1	
  0D05	0D0C	
  0D0E	0D10	
  0D12	0D28	
  0D2A	0D39	
  0D60	0D61	
  0E01	0E2E	
  0E30
  0E32	0E33	
  0E40	0E45	
  0E81	0E82	
  0E84
  0E87	0E88	
  0E8A
  0E8D
  0E94	0E97	
  0E99	0E9F	
  0EA1	0EA3	
  0EA5
  0EA7
  0EAA	0EAB	
  0EAD	0EAE	
  0EB0
  0EB2	0EB3	
  0EBD
  0EC0	0EC4	
  0F40	0F47	
  0F49	0F69	
  10A0	10C5	
  10D0	10F6	
  1100
  1102	1103	
  1105	1107	
  1109
  110B	110C	
  110E	1112	
  113C
  113E
  1140
  114C
  114E
  1150
  1154	1155	
  1159
  115F	1161	
  1163
  1165
  1167
  1169
  116D	116E	
  1172	1173	
  1175
  119E
  11A8
  11AB
  11AE	11AF	
  11B7	11B8	
  11BA
  11BC	11C2	
  11EB
  11F0
  11F9
  1E00	1E9B	
  1EA0	1EF9	
  1F00	1F15	
  1F18	1F1D	
  1F20	1F45	
  1F48	1F4D	
  1F50	1F57	
  1F59
  1F5B
  1F5D
  1F5F	1F7D	
  1F80	1FB4	
  1FB6	1FBC	
  1FBE
  1FC2	1FC4	
  1FC6	1FCC	
  1FD0	1FD3	
  1FD6	1FDB	
  1FE0	1FEC	
  1FF2	1FF4	
  1FF6	1FFC	
  2126
  212A	212B	
  212E
  2180	2182	
  3007
  3021	3029	
  3041	3094	
  30A1	30FA	
  3105	312C	
  4E00	9FA5	
  AC00	D7A3	
  EOH
  }
  
  sub InXML_NameStartChar10_1 {
  <<EOH;
  003A
  0041	005A	
  005F
  0061	007A	
  00C0	00D6	
  00D8	00F6	
  00F8	0131	
  0134	013E	
  0141	0148	
  014A	017E	
  0180	01C3	
  01CD	01F0	
  01F4	01F5	
  01FA	0217	
  0250	02A8	
  02BB	02C1	
  0386
  0388	038A	
  038C
  038E	03A1	
  03A3	03CE	
  03D0	03D6	
  03DA
  03DC
  03DE
  03E0
  03E2	03F3	
  0401	040C	
  040E	044F	
  0451	045C	
  045E	0481	
  0490	04C4	
  04C7	04C8	
  04CB	04CC	
  04D0	04EB	
  04EE	04F5	
  04F8	04F9	
  0531	0556	
  0559
  0561	0586	
  05D0	05EA	
  05F0	05F2	
  0621	063A	
  0641	064A	
  0671	06B7	
  06BA	06BE	
  06C0	06CE	
  06D0	06D3	
  06D5
  06E5	06E6	
  0905	0939	
  093D
  0958	0961	
  0985	098C	
  098F	0990	
  0993	09A8	
  09AA	09B0	
  09B2
  09B6	09B9	
  09DC	09DD	
  09DF	09E1	
  09F0	09F1	
  0A05	0A0A	
  0A0F	0A10	
  0A13	0A28	
  0A2A	0A30	
  0A32	0A33	
  0A35	0A36	
  0A38	0A39	
  0A59	0A5C	
  0A5E
  0A72	0A74	
  0A85	0A8B	
  0A8D
  0A8F	0A91	
  0A93	0AA8	
  0AAA	0AB0	
  0AB2	0AB3	
  0AB5	0AB9	
  0ABD
  0AE0
  0B05	0B0C	
  0B0F	0B10	
  0B13	0B28	
  0B2A	0B30	
  0B32	0B33	
  0B36	0B39	
  0B3D
  0B5C	0B5D	
  0B5F	0B61	
  0B85	0B8A	
  0B8E	0B90	
  0B92	0B95	
  0B99	0B9A	
  0B9C
  0B9E	0B9F	
  0BA3	0BA4	
  0BA8	0BAA	
  0BAE	0BB5	
  0BB7	0BB9	
  0C05	0C0C	
  0C0E	0C10	
  0C12	0C28	
  0C2A	0C33	
  0C35	0C39	
  0C60	0C61	
  0C85	0C8C	
  0C8E	0C90	
  0C92	0CA8	
  0CAA	0CB3	
  0CB5	0CB9	
  0CDE
  0CE0	0CE1	
  0D05	0D0C	
  0D0E	0D10	
  0D12	0D28	
  0D2A	0D39	
  0D60	0D61	
  0E01	0E2E	
  0E30
  0E32	0E33	
  0E40	0E45	
  0E81	0E82	
  0E84
  0E87	0E88	
  0E8A
  0E8D
  0E94	0E97	
  0E99	0E9F	
  0EA1	0EA3	
  0EA5
  0EA7
  0EAA	0EAB	
  0EAD	0EAE	
  0EB0
  0EB2	0EB3	
  0EBD
  0EC0	0EC4	
  0F40	0F47	
  0F49	0F69	
  10A0	10C5	
  10D0	10F6	
  1100
  1102	1103	
  1105	1107	
  1109
  110B	110C	
  110E	1112	
  113C
  113E
  1140
  114C
  114E
  1150
  1154	1155	
  1159
  115F	1161	
  1163
  1165
  1167
  1169
  116D	116E	
  1172	1173	
  1175
  119E
  11A8
  11AB
  11AE	11AF	
  11B7	11B8	
  11BA
  11BC	11C2	
  11EB
  11F0
  11F9
  1E00	1E9B	
  1EA0	1EF9	
  1F00	1F15	
  1F18	1F1D	
  1F20	1F45	
  1F48	1F4D	
  1F50	1F57	
  1F59
  1F5B
  1F5D
  1F5F	1F7D	
  1F80	1FB4	
  1FB6	1FBC	
  1FBE
  1FC2	1FC4	
  1FC6	1FCC	
  1FD0	1FD3	
  1FD6	1FDB	
  1FE0	1FEC	
  1FF2	1FF4	
  1FF6	1FFC	
  2126
  212A	212B	
  212E
  2180	2182	
  3007
  3021	3029	
  3041	3094	
  30A1	30FA	
  3105	312C	
  4E00	9FA5	
  AC00	D7A3	
  EOH
  }
  
  sub InXML_UnrestrictedChar10 {
  <<EOH;
  0009	000A	
  000D
  0020	D7FF	
  E000	FFFD	
  10000	10FFFF	
  EOH
  }
  
  sub InXML_UnrestrictedChar11 {
  <<EOH;
  0009	000A	
  000D
  0020	007E	
  0085
  00A0	D7FF	
  E000	FFFD	
  10000	10FFFF	
  EOH
  }
  
  sub InXML_deprecated_noncharacter {
  <<EOH;
  007F	0084	
  0086	009F	
  FDD0	FDEF	
  1FFFE	1FFFF	
  2FFFE	2FFFF	
  3FFFE	3FFFF	
  4FFFE	4FFFF	
  5FFFE	5FFFF	
  6FFFE	6FFFF	
  7FFFE	7FFFF	
  8FFFE	8FFFF	
  9FFFE	9FFFF	
  AFFFE	AFFFF	
  BFFFE	BFFFF	
  CFFFE	CFFFF	
  DFFFE	DFFFF	
  EFFFE	EFFFF	
  FFFFE	FFFFF	
  10FFFE	10FFFF	
  EOH
  }
  
  sub InXML_unicode_xml_not_suitable {
  <<EOH;
  2028	202E	
  206A	206F	
  FEFF
  FFF9	FFFC	
  1D173	1D17A	
  E0000	E007F	
  EOH
  }
  
  sub InXML_unicode_xml_suitable_format_character {
  <<EOH;
  00A0
  00AD
  0363
  0600	0603	
  06DD
  070C
  0F0C
  180B	180E	
  200C	200F	
  2011
  202F
  2044
  2060	2063	
  2FF0	2FFB	
  303E
  FE00	FE0F	
  E0100	E01DF	
  EOH
  }
  
  *InXMLChar = \&InXMLChar11;
  
  *InXMLNCNameChar = \&InXMLNCNameChar10_5;
  
  *InXMLNCNameChar10 = \&InXMLNCNameChar10_5;
  
  *InXMLNCNameStartChar = \&InXMLNCNameStartChar10_5;
  
  *InXMLNCNameStartChar10 = \&InXMLNCNameStartChar10_5;
  
  *InXMLNameChar = \&InXMLNameChar10_5;
  
  *InXMLNameChar10 = \&InXMLNameChar10_5;
  
  *InXMLNameStartChar = \&InXMLNameStartChar10_5;
  
  *InXMLNameStartChar10 = \&InXMLNameStartChar10_5;
  
  *InXMLRestrictedChar = \&InXMLRestrictedChar11;
  
  *InXML_NCNameStartChar = \&InXMLNCNameStartChar10_5;
  
  *InXML_NCNameStartChar10 = \&InXMLNCNameStartChar10_5;
  
  *InXML_NameStartChar = \&InXMLNameStartChar10_5;
  
  *InXML_NameStartChar10 = \&InXMLNameStartChar10_5;
  
  *InXML_UnrestrictedChar = \&InXML_UnrestrictedChar11;
  
  =head1 COLLECTION NAMES
  
  =over 4
  
  =item C<InXMLBaseChar>
  
  =item C<InXMLChar>
  
  An alias for InXMLChar11.
  
  =item C<InXMLChar10>
  
  =item C<InXMLChar11>
  
  =item C<InXMLCombiningChar>
  
  =item C<InXMLDigit>
  
  =item C<InXMLExtender>
  
  =item C<InXMLIdeographic>
  
  =item C<InXMLLetter>
  
  =item C<InXMLNCNameChar>
  
  An alias for InXMLNCNameChar10_5.
  
  =item C<InXMLNCNameChar10>
  
  An alias for InXMLNCNameChar10_5.
  
  =item C<InXMLNCNameChar10_1>
  
  =item C<InXMLNCNameChar10_5>
  
  =item C<InXMLNCNameChar11>
  
  =item C<InXMLNCNameStartChar>
  
  An alias for InXMLNCNameStartChar10_5.
  
  =item C<InXMLNCNameStartChar10>
  
  An alias for InXMLNCNameStartChar10_5.
  
  =item C<InXMLNCNameStartChar10_5>
  
  =item C<InXMLNCNameStartChar11>
  
  =item C<InXMLNameChar>
  
  An alias for InXMLNameChar10_5.
  
  =item C<InXMLNameChar10>
  
  An alias for InXMLNameChar10_5.
  
  =item C<InXMLNameChar10_1>
  
  =item C<InXMLNameChar10_5>
  
  =item C<InXMLNameChar11>
  
  =item C<InXMLNameStartChar>
  
  An alias for InXMLNameStartChar10_5.
  
  =item C<InXMLNameStartChar10>
  
  An alias for InXMLNameStartChar10_5.
  
  =item C<InXMLNameStartChar10_5>
  
  =item C<InXMLNameStartChar11>
  
  =item C<InXMLPubidChar>
  
  =item C<InXMLRestrictedChar>
  
  An alias for InXMLRestrictedChar11.
  
  =item C<InXMLRestrictedChar11>
  
  =item C<InXMLS>
  
  =item C<InXMLVersionNum>
  
  =item C<InXML_NCNameStartChar>
  
  An alias for InXMLNCNameStartChar10_5.
  
  =item C<InXML_NCNameStartChar10>
  
  An alias for InXMLNCNameStartChar10_5.
  
  =item C<InXML_NCNameStartChar10_1>
  
  =item C<InXML_NameStartChar>
  
  An alias for InXMLNameStartChar10_5.
  
  =item C<InXML_NameStartChar10>
  
  An alias for InXMLNameStartChar10_5.
  
  =item C<InXML_NameStartChar10_1>
  
  =item C<InXML_UnrestrictedChar>
  
  An alias for InXML_UnrestrictedChar11.
  
  =item C<InXML_UnrestrictedChar10>
  
  =item C<InXML_UnrestrictedChar11>
  
  =item C<InXML_deprecated_noncharacter>
  
  =item C<InXML_unicode_xml_not_suitable>
  
  =item C<InXML_unicode_xml_suitable_format_character>
  
  =back
  
  =cut
  
  
  =head1 EXAMPLE
  
   use Char::Class::XML qw(InXMLBaseChar);
   if ($s =~ /\p{InXMLBaseChar}/) {
     print "Match!\n";
   }
  
  =head1 LICENSE
  
  Copyright 2016 Wakaba <wakaba@suikawiki.org>.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
  ### XML.pm ends here
CHAR_CLASS_XML

$fatpacked{"Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.17016"; 
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub _throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&_throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  use Scalar::Util ();
  
  sub import {
      shift;
      my @tags = @_;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      
      @tags = grep { 
         if( $_ eq ':warndie' ) {
            Error::WarnDie->import();
            0;
         }
         else {
            1;
         }
      } @tags;
  
      Error::subs->import(@tags);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
      
      unless (@_) {
         $LAST = undef;
         return;
      }
      
      my $pkg = shift;
      return unless ref($pkg);
     
      undef $ERROR{$pkg} if defined $ERROR{$pkg}; 
  } 
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
      
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->($err));
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(Scalar::Util::blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN, $@);
  			my $ok = eval {
  			    $@ = $err;
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = $@ || $Error::THROWN;
  				$err = $Error::ObjectifyCallback->({'text' =>$err})
  					unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
          local($Error::THROWN, $@);
  	    my $ok = eval {
  		$@ = $err;
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = $@ || $Error::THROWN;
  
  		$err = $Error::ObjectifyCallback->({'text' =>$err}) 
  			unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
  	local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = $@ || $Error::THROWN
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
      unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (Scalar::Util::blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
      
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  
  package Error::WarnDie;
  
  sub gen_callstack($)
  {
      my ( $start ) = @_;
  
      require Carp;
      local $Carp::CarpLevel = $start;
      my $trace = Carp::longmess("");
      # Remove try calls from the trace
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      my @callstack = split( m/\n/, $trace );
      return @callstack;
  }
  
  my $old_DIE;
  my $old_WARN;
  
  sub DEATH
  {
      my ( $e ) = @_;
  
      local $SIG{__DIE__} = $old_DIE if( defined $old_DIE );
  
      die @_ if $^S;
  
      my ( $etype, $message, $location, @callstack );
      if ( ref($e) && $e->isa( "Error" ) ) {
          $etype = "exception of type " . ref( $e );
          $message = $e->text;
          $location = $e->file . ":" . $e->line;
          @callstack = split( m/\n/, $e->stacktrace );
      }
      else {
          # Don't apply subsequent layer of message formatting
          die $e if( $e =~ m/^\nUnhandled perl error caught at toplevel:\n\n/ );
          $etype = "perl error";
          my $stackdepth = 0;
          while( caller( $stackdepth ) =~ m/^Error(?:$|::)/ ) {
              $stackdepth++
          }
  
          @callstack = gen_callstack( $stackdepth + 1 );
  
          $message = "$e";
          chomp $message;
  
          if ( $message =~ s/ at (.*?) line (\d+)\.$// ) {
              $location = $1 . ":" . $2;
          }
          else {
              my @caller = caller( $stackdepth );
              $location = $caller[1] . ":" . $caller[2];
          }
      }
  
      shift @callstack;
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      die "\nUnhandled $etype caught at toplevel:\n\n  $message\n\nThrown from: $location\n\nFull stack trace:\n\n$callstack\n";
  }
  
  sub TAXES
  {
      my ( $message ) = @_;
  
      local $SIG{__WARN__} = $old_WARN if( defined $old_WARN );
  
      $message =~ s/ at .*? line \d+\.$//;
      chomp $message;
  
      my @callstack = gen_callstack( 1 );
      my $location = shift @callstack;
  
      # $location already starts in a leading space
      $message .= $location;
  
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      warn "$message:\n$callstack";
  }
  
  sub import
  {
      $old_DIE  = $SIG{__DIE__};
      $old_WARN = $SIG{__WARN__};
  
      $SIG{__DIE__}  = \&DEATH;
      $SIG{__WARN__} = \&TAXES;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 WARNING
  
  Using the "Error" module is B<no longer recommended> due to the black-magical
  nature of its syntactic sugar, which often tends to break. Its maintainers 
  have stopped actively writing code that uses it, and discourage people
  from doing so. See the "SEE ALSO" section below for better recommendations.
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
   
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found. The error will also be available in C<$@>.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed. The error will also be available in C<$@>.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 COMPATIBILITY
  
  L<Moose> exports a keyword called C<with> which clashes with Error's. This
  example returns a prototype mismatch error:
  
      package MyTest;
  
      use warnings;
      use Moose;
      use Error qw(:try);
  
  (Thanks to C<maik.hentsche@amd.com> for the report.).
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to it's constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item Error->new()
  
  See the Error::Simple documentation.
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =item $err->associate($obj)
  
  Associates an error with an object to allow error propagation. I.e:
  
      $ber->encode(...) or
          return Error->prior($ber)->associate($ldap);
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =head2 Error::Simple
  
  This class can be used to hold simple error strings and values. It's
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this infomation will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overrided by the user.
  
  It accepts a single argument which is a hash reference to named parameters. 
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =cut
  
  =head1 MESSAGE HANDLERS
  
  C<Error> also provides handlers to extend the output of the C<warn()> perl
  function, and to handle the printing of a thrown C<Error> that is not caught
  or otherwise handled. These are not installed by default, but are requested
  using the C<:warndie> tag in the C<use> line.
  
   use Error qw( :warndie );
  
  These new error handlers are installed in C<$SIG{__WARN__}> and
  C<$SIG{__DIE__}>. If these handlers are already defined when the tag is
  imported, the old values are stored, and used during the new code. Thus, to
  arrange for custom handling of warnings and errors, you will need to perform
  something like the following:
  
   BEGIN {
     $SIG{__WARN__} = sub {
       print STDERR "My special warning handler: $_[0]"
     };
   }
  
   use Error qw( :warndie );
  
  Note that setting C<$SIG{__WARN__}> after the C<:warndie> tag has been
  imported will overwrite the handler that C<Error> provides. If this cannot be
  avoided, then the tag can be explicitly C<import>ed later
  
   use Error;
  
   $SIG{__WARN__} = ...;
  
   import Error qw( :warndie );
  
  =head2 EXAMPLE
  
  The C<__DIE__> handler turns messages such as
  
   Can't call method "foo" on an undefined value at examples/warndie.pl line 16.
  
  into
  
   Unhandled perl error caught at toplevel:
  
     Can't call method "foo" on an undefined value
  
   Thrown from: examples/warndie.pl:16
  
   Full stack trace:
  
           main::inner('undef') called at examples/warndie.pl line 20
           main::outer('undef') called at examples/warndie.pl line 23
  
  =cut
  
  =head1 SEE ALSO
  
  See L<Exception::Class> for a different module providing Object-Oriented
  exception handling, along with a convenient syntax for declaring hierarchies
  for them. It doesn't provide Error's syntactic sugar of C<try { ... }>,
  C<catch { ... }>, etc. which may be a good thing or a bad thing based
  on what you want. (Because Error's syntactic sugar tends to break.)
  
  L<Error::Exception> aims to combine L<Error> and L<Exception::Class>
  "with correct stringification".
  
  L<TryCatch> and L<Try::Tiny> are similar in concept to Error.pm only providing 
  a syntax that hopefully breaks less.
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  C<:warndie> handlers added by Paul Evans <leonerd@leonerd.org.uk>
  
  =head1 MAINTAINER
  
  Shlomi Fish <shlomif@iglu.org.il>
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8  Graham Barr. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
ERROR

$fatpacked{"Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER';
  package Exporter;
  
  require 5.006;
  
  # Be lean.
  #use strict;
  #no strict 'refs';
  
  our $Debug = 0;
  our $ExportLevel = 0;
  our $Verbose ||= 0;
  our $VERSION = '5.74';
  our (%Cache);
  
  sub as_heavy {
    require Exporter::Heavy;
    # Unfortunately, this does not work if the caller is aliased as *name = \&foo
    # Thus the need to create a lot of identical subroutines
    my $c = (caller(1))[3];
    $c =~ s/.*:://;
    \&{"Exporter::Heavy::heavy_$c"};
  }
  
  sub export {
    goto &{as_heavy()};
  }
  
  sub import {
    my $pkg = shift;
    my $callpkg = caller($ExportLevel);
  
    if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
      *{$callpkg."::import"} = \&import;
      return;
    }
  
    # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
    my $exports = \@{"$pkg\::EXPORT"};
    # But, avoid creating things if they don't exist, which saves a couple of
    # hundred bytes per package processed.
    my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
    return export $pkg, $callpkg, @_
      if $Verbose or $Debug or $fail && @$fail > 1;
    my $export_cache = ($Cache{$pkg} ||= {});
    my $args = @_ or @_ = @$exports;
  
    if ($args and not %$export_cache) {
      s/^&//, $export_cache->{$_} = 1
        foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    }
    my $heavy;
    # Try very hard not to use {} and hence have to  enter scope on the foreach
    # We bomb out of the loop with last as soon as heavy is set.
    if ($args or $fail) {
      ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                 or $fail and @$fail and $_ eq $fail->[0])) and last
                   foreach (@_);
    } else {
      ($heavy = /\W/) and last
        foreach (@_);
    }
    return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    local $SIG{__WARN__} = 
  	sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
    # shortcut for the common case of no type character
    *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  }
  
  # Default methods
  
  sub export_fail {
      my $self = shift;
      @_;
  }
  
  # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
  # *name = \&foo.  Thus the need to create a lot of identical subroutines
  # Otherwise we could have aliased them to export().
  
  sub export_to_level {
    goto &{as_heavy()};
  }
  
  sub export_tags {
    goto &{as_heavy()};
  }
  
  sub export_ok_tags {
    goto &{as_heavy()};
  }
  
  sub require_version {
    goto &{as_heavy()};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Exporter - Implements default import method for modules
  
  =head1 SYNOPSIS
  
  In module F<YourModule.pm>:
  
    package YourModule;
    require Exporter;
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    use Exporter 'import'; # gives you Exporter's import() method directly
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  In other files which wish to use C<YourModule>:
  
    use YourModule qw(frobnicate);      # import listed symbols
    frobnicate ($left, $right)          # calls YourModule::frobnicate
  
  Take a look at L</Good Practices> for some variants
  you will like to use in modern Perl code.
  
  =head1 DESCRIPTION
  
  The Exporter module implements an C<import> method which allows a module
  to export functions and variables to its users' namespaces.  Many modules
  use Exporter rather than implementing their own C<import> method because
  Exporter provides a highly flexible interface, with an implementation optimised
  for the common case.
  
  Perl automatically calls the C<import> method when processing a
  C<use> statement for a module.  Modules and C<use> are documented
  in L<perlfunc> and L<perlmod>.  Understanding the concept of
  modules and how the C<use> statement operates is important to
  understanding the Exporter.
  
  =head2 How to Export
  
  The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
  symbols that are going to be exported into the users name space by
  default, or which they can request to be exported, respectively.  The
  symbols can represent functions, scalars, arrays, hashes, or typeglobs.
  The symbols must be given by full name with the exception that the
  ampersand in front of a function is optional, e.g.
  
      our @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
      our @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
  
  If you are only exporting function names it is recommended to omit the
  ampersand, as the implementation is faster this way.
  
  =head2 Selecting What to Export
  
  Do B<not> export method names!
  
  Do B<not> export anything else by default without a good reason!
  
  Exports pollute the namespace of the module user.  If you must export
  try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
  common symbol names to reduce the risk of name clashes.
  
  Generally anything not exported is still accessible from outside the
  module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
  syntax.  By convention you can use a leading underscore on names to
  informally indicate that they are 'internal' and not for public use.
  
  (It is actually possible to get private functions by saying:
  
    my $subref = sub { ... };
    $subref->(@args);            # Call it as a function
    $obj->$subref(@args);        # Use it as a method
  
  However if you use them for methods it is up to you to figure out
  how to make inheritance work.)
  
  As a general rule, if the module is trying to be object oriented
  then export nothing.  If it's just a collection of functions then
  C<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and
  method names use barewords in preference to names prefixed with
  ampersands for the export lists.
  
  Other module design guidelines can be found in L<perlmod>.
  
  =head2 How to Import
  
  In other files which wish to use your module there are three basic ways for
  them to load your module and import its symbols:
  
  =over 4
  
  =item C<use YourModule;>
  
  This imports all the symbols from YourModule's C<@EXPORT> into the namespace
  of the C<use> statement.
  
  =item C<use YourModule ();>
  
  This causes perl to load your module but does not import any symbols.
  
  =item C<use YourModule qw(...);>
  
  This imports only the symbols listed by the caller into their namespace.
  All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
  occurs.  The advanced export features of Exporter are accessed like this,
  but with list entries that are syntactically distinct from symbol names.
  
  =back
  
  Unless you want to use its advanced features, this is probably all you
  need to know to use Exporter.
  
  =head1 Advanced Features
  
  =head2 Specialised Import Lists
  
  If any of the entries in an import list begins with !, : or / then
  the list is treated as a series of specifications which either add to
  or delete from the list of names to import.  They are processed left to
  right. Specifications are in the form:
  
      [!]name         This name only
      [!]:DEFAULT     All names in @EXPORT
      [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array
      [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
  
  A leading ! indicates that matching names should be deleted from the
  list of names to import.  If the first specification is a deletion it
  is treated as though preceded by :DEFAULT.  If you just want to import
  extra names in addition to the default set you will still need to
  include :DEFAULT explicitly.
  
  e.g., F<Module.pm> defines:
  
      our @EXPORT      = qw(A1 A2 A3 A4 A5);
      our @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
      our %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
  
  Note that you cannot use tags in @EXPORT or @EXPORT_OK.
  
  Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
  
  An application using Module can say something like:
  
      use Module qw(:DEFAULT :T2 !B3 A3);
  
  Other examples include:
  
      use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
      use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
  
  Remember that most patterns (using //) will need to be anchored
  with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
  
  You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
  specifications are being processed and what is actually being imported
  into modules.
  
  =head2 Exporting Without Using Exporter's import Method
  
  Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's
  import method.  The export_to_level
  method looks like:
  
      MyPackage->export_to_level(
  	$where_to_export, $package, @what_to_export
      );
  
  where C<$where_to_export> is an integer telling how far up the calling stack
  to export your symbols, and C<@what_to_export> is an array telling what
  symbols *to* export (usually this is C<@_>).  The C<$package> argument is
  currently unused.
  
  For example, suppose that you have a module, A, which already has an
  import function:
  
      package A;
  
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw($b);
  
      sub import
      {
  	$A::b = 1;     # not a very useful import method
      }
  
  and you want to Export symbol C<$A::b> back to the module that called 
  package A.  Since Exporter relies on the import method to work, via 
  inheritance, as it stands Exporter::import() will never get called. 
  Instead, say the following:
  
      package A;
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw($b);
  
      sub import
      {
  	$A::b = 1;
  	A->export_to_level(1, @_);
      }
  
  This will export the symbols one level 'above' the current package - ie: to 
  the program or module that used package A. 
  
  Note: Be careful not to modify C<@_> at all before you call export_to_level
  - or people using your package will get very unexplained results!
  
  =head2 Exporting Without Inheriting from Exporter
  
  By including Exporter in your C<@ISA> you inherit an Exporter's import() method
  but you also inherit several other helper methods which you probably don't
  want.  To avoid this you can do:
  
    package YourModule;
    use Exporter qw(import);
  
  which will export Exporter's own import() method into YourModule.
  Everything will work as before but you won't need to include Exporter in
  C<@YourModule::ISA>.
  
  Note: This feature was introduced in version 5.57
  of Exporter, released with perl 5.8.3.
  
  =head2 Module Version Checking
  
  The Exporter module will convert an attempt to import a number from a
  module into a call to C<< $module_name->VERSION($value) >>.  This can
  be used to validate that the version of the module being used is
  greater than or equal to the required version.
  
  For historical reasons, Exporter supplies a C<require_version> method that
  simply delegates to C<VERSION>.  Originally, before C<UNIVERSAL::VERSION>
  existed, Exporter would call C<require_version>.
  
  Since the C<UNIVERSAL::VERSION> method treats the C<$VERSION> number as
  a simple numeric value it will regard version 1.10 as lower than
  1.9.  For this reason it is strongly recommended that you use numbers
  with at least two decimal places, e.g., 1.09.
  
  =head2 Managing Unknown Symbols
  
  In some situations you may want to prevent certain symbols from being
  exported.  Typically this applies to extensions which have functions
  or constants that may not exist on some systems.
  
  The names of any symbols that cannot be exported should be listed
  in the C<@EXPORT_FAIL> array.
  
  If a module attempts to import any of these symbols the Exporter
  will give the module an opportunity to handle the situation before
  generating an error.  The Exporter will call an export_fail method
  with a list of the failed symbols:
  
    @failed_symbols = $module_name->export_fail(@failed_symbols);
  
  If the C<export_fail> method returns an empty list then no error is
  recorded and all the requested symbols are exported.  If the returned
  list is not empty then an error is generated for each symbol and the
  export fails.  The Exporter provides a default C<export_fail> method which
  simply returns the list unchanged.
  
  Uses for the C<export_fail> method include giving better error messages
  for some symbols and performing lazy architectural checks (put more
  symbols into C<@EXPORT_FAIL> by default and then take them out if someone
  actually tries to use them and an expensive check shows that they are
  usable on that platform).
  
  =head2 Tag Handling Utility Functions
  
  Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
  C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
  you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
  
    our %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
    Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
  
  Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
  unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
  names being silently added to C<@EXPORT> or C<@EXPORT_OK>.  Future versions
  may make this a fatal error.
  
  =head2 Generating Combined Tags
  
  If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
  useful to create the utility ":all" to simplify "use" statements.
  
  The simplest way to do this is:
  
   our  %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    # add all the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
    }
  
  F<CGI.pm> creates an ":all" tag which contains some (but not really
  all) of its categories.  That could be done with one small
  change:
  
    # add some of the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
          foreach qw/html2 html3 netscape form cgi internal/;
    }
  
  Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
  
  =head2 C<AUTOLOAD>ed Constants
  
  Many modules make use of C<AUTOLOAD>ing for constant subroutines to
  avoid having to compile and waste memory on rarely used values (see
  L<perlsub> for details on constant subroutines).  Calls to such
  constant subroutines are not optimized away at compile time because
  they can't be checked at compile time for constancy.
  
  Even if a prototype is available at compile time, the body of the
  subroutine is not (it hasn't been C<AUTOLOAD>ed yet).  perl needs to
  examine both the C<()> prototype and the body of a subroutine at
  compile time to detect that it can safely replace calls to that
  subroutine with the constant value.
  
  A workaround for this is to call the constants once in a C<BEGIN> block:
  
     package My ;
  
     use Socket ;
  
     foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
     BEGIN { SO_LINGER }
     foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
  
  This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
  SO_LINGER is encountered later in C<My> package.
  
  If you are writing a package that C<AUTOLOAD>s, consider forcing
  an C<AUTOLOAD> for any constants explicitly imported by other packages
  or which are usually used when your package is C<use>d.
  
  =head1 Good Practices
  
  =head2 Declaring C<@EXPORT_OK> and Friends
  
  When using C<Exporter> with the standard C<strict> and C<warnings>
  pragmas, the C<our> keyword is needed to declare the package
  variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
  
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);
  
  If backward compatibility for Perls B<under> 5.6 is important,
  one must write instead a C<use vars> statement.
  
    use vars qw(@ISA @EXPORT_OK);
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);
  
  =head2 Playing Safe
  
  There are some caveats with the use of runtime statements
  like C<require Exporter> and the assignment to package
  variables, which can be very subtle for the unaware programmer.
  This may happen for instance with mutually recursive
  modules, which are affected by the time the relevant
  constructions are executed.
  
  The ideal (but a bit ugly) way to never have to think
  about that is to use C<BEGIN> blocks.  So the first part
  of the L</SYNOPSIS> code could be rewritten as:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    our (@ISA, @EXPORT_OK);
    BEGIN {
       require Exporter;
       @ISA = qw(Exporter);
       @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  The C<BEGIN> will assure that the loading of F<Exporter.pm>
  and the assignments to C<@ISA> and C<@EXPORT_OK> happen
  immediately, leaving no room for something to get awry
  or just plain wrong.
  
  With respect to loading C<Exporter> and inheriting, there
  are alternatives with the use of modules like C<base> and C<parent>.
  
    use base qw(Exporter);
    # or
    use parent qw(Exporter);
  
  Any of these statements are nice replacements for
  C<BEGIN { require Exporter; @ISA = qw(Exporter); }>
  with the same compile-time effect.  The basic difference
  is that C<base> code interacts with declared C<fields>
  while C<parent> is a streamlined version of the older
  C<base> code to just establish the IS-A relationship.
  
  For more details, see the documentation and code of
  L<base> and L<parent>.
  
  Another thorough remedy to that runtime
  vs. compile-time trap is to use L<Exporter::Easy>,
  which is a wrapper of Exporter that allows all
  boilerplate code at a single gulp in the
  use statement.
  
     use Exporter::Easy (
         OK => [ qw(munge frobnicate) ],
     );
     # @ISA setup is automatic
     # all assignments happen at compile time
  
  =head2 What Not to Export
  
  You have been warned already in L</Selecting What to Export>
  to not export:
  
  =over 4
  
  =item *
  
  method names (because you don't need to
  and that's likely to not do what you want),
  
  =item *
  
  anything by default (because you don't want to surprise your users...
  badly)
  
  =item *
  
  anything you don't need to (because less is more)
  
  =back
  
  There's one more item to add to this list.  Do B<not>
  export variable names.  Just because C<Exporter> lets you
  do that, it does not mean you should.
  
    @EXPORT_OK = qw($svar @avar %hvar); # DON'T!
  
  Exporting variables is not a good idea.  They can
  change under the hood, provoking horrible
  effects at-a-distance that are too hard to track
  and to fix.  Trust me: they are not worth it.
  
  To provide the capability to set/get class-wide
  settings, it is best instead to provide accessors
  as subroutines or class methods instead.
  
  =head1 SEE ALSO
  
  C<Exporter> is definitely not the only module with
  symbol exporter capabilities.  At CPAN, you may find
  a bunch of them.  Some are lighter.  Some
  provide improved APIs and features.  Pick the one
  that fits your needs.  The following is
  a sample list of such modules.
  
      Exporter::Easy
      Exporter::Lite
      Exporter::Renaming
      Exporter::Tidy
      Sub::Exporter / Sub::Installer
      Perl6::Export / Perl6::Export::Attrs
  
  =head1 LICENSE
  
  This library is free software.  You can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
  
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_HEAVY';
  package Exporter::Heavy;
  
  use strict;
  no strict 'refs';
  
  # On one line so MakeMaker will see it.
  require Exporter;  our $VERSION = $Exporter::VERSION;
  
  =head1 NAME
  
  Exporter::Heavy - Exporter guts
  
  =head1 SYNOPSIS
  
  (internal use only)
  
  =head1 DESCRIPTION
  
  No user-serviceable parts inside.
  
  =cut
  
  #
  # We go to a lot of trouble not to 'require Carp' at file scope,
  #  because Carp requires Exporter, and something has to give.
  #
  
  sub _rebuild_cache {
      my ($pkg, $exports, $cache) = @_;
      s/^&// foreach @$exports;
      @{$cache}{@$exports} = (1) x @$exports;
      my $ok = \@{"${pkg}::EXPORT_OK"};
      if (@$ok) {
  	s/^&// foreach @$ok;
  	@{$cache}{@$ok} = (1) x @$ok;
      }
  }
  
  sub heavy_export {
  
      # Save the old __WARN__ handler in case it was defined
      my $oldwarn = $SIG{__WARN__};
  
      # First make import warnings look like they're coming from the "use".
      local $SIG{__WARN__} = sub {
  	# restore it back so proper stacking occurs
  	local $SIG{__WARN__} = $oldwarn;
  	my $text = shift;
  	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
  	    require Carp;
  	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	    Carp::carp($text);
  	}
  	else {
  	    warn $text;
  	}
      };
      local $SIG{__DIE__} = sub {
  	require Carp;
  	local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
  	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
      };
  
      my($pkg, $callpkg, @imports) = @_;
      my($type, $sym, $cache_is_current, $oops);
      my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                     $Exporter::Cache{$pkg} ||= {});
  
      if (@imports) {
  	if (!%$export_cache) {
  	    _rebuild_cache ($pkg, $exports, $export_cache);
  	    $cache_is_current = 1;
  	}
  
  	if (grep m{^[/!:]}, @imports) {
  	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
  	    my $tagdata;
  	    my %imports;
  	    my($remove, $spec, @names, @allexports);
  	    # negated first item implies starting with default set:
  	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
  	    foreach $spec (@imports){
  		$remove = $spec =~ s/^!//;
  
  		if ($spec =~ s/^://){
  		    if ($spec eq 'DEFAULT'){
  			@names = @$exports;
  		    }
  		    elsif ($tagdata = $tagsref->{$spec}) {
  			@names = @$tagdata;
  		    }
  		    else {
  			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
  			++$oops;
  			next;
  		    }
  		}
  		elsif ($spec =~ m:^/(.*)/$:){
  		    my $patn = $1;
  		    @allexports = keys %$export_cache unless @allexports; # only do keys once
  		    @names = grep(/$patn/, @allexports); # not anchored by default
  		}
  		else {
  		    @names = ($spec); # is a normal symbol name
  		}
  
  		warn "Import ".($remove ? "del":"add").": @names "
  		    if $Exporter::Verbose;
  
  		if ($remove) {
  		   foreach $sym (@names) { delete $imports{$sym} } 
  		}
  		else {
  		    @imports{@names} = (1) x @names;
  		}
  	    }
  	    @imports = keys %imports;
  	}
  
          my @carp;
  	foreach $sym (@imports) {
  	    if (!$export_cache->{$sym}) {
  		if ($sym =~ m/^\d/) {
  		    $pkg->VERSION($sym); # inherit from UNIVERSAL
  		    # If the version number was the only thing specified
  		    # then we should act as if nothing was specified:
  		    if (@imports == 1) {
  			@imports = @$exports;
  			last;
  		    }
  		    # We need a way to emulate 'use Foo ()' but still
  		    # allow an easy version check: "use Foo 1.23, ''";
  		    if (@imports == 2 and !$imports[1]) {
  			@imports = ();
  			last;
  		    }
  		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
  		    # Last chance - see if they've updated EXPORT_OK since we
  		    # cached it.
  
  		    unless ($cache_is_current) {
  			%$export_cache = ();
  			_rebuild_cache ($pkg, $exports, $export_cache);
  			$cache_is_current = 1;
  		    }
  
  		    if (!$export_cache->{$sym}) {
  			# accumulate the non-exports
  			push @carp,
  			  qq["$sym" is not exported by the $pkg module];
  			$oops++;
  		    }
  		}
  	    }
  	}
  	if ($oops) {
  	    require Carp;
  	    Carp::croak(join("\n", @carp, "Can't continue after import errors"));
  	}
      }
      else {
  	@imports = @$exports;
      }
  
      my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                $Exporter::FailCache{$pkg} ||= {});
  
      if (@$fail) {
  	if (!%$fail_cache) {
  	    # Build cache of symbols. Optimise the lookup by adding
  	    # barewords twice... both with and without a leading &.
  	    # (Technique could be applied to $export_cache at cost of memory)
  	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
  	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
  	    @{$fail_cache}{@expanded} = (1) x @expanded;
  	}
  	my @failed;
  	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
  	if (@failed) {
  	    @failed = $pkg->export_fail(@failed);
  	    foreach $sym (@failed) {
                  require Carp;
  		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
  			"on this architecture");
  	    }
  	    if (@failed) {
  		require Carp;
  		Carp::croak("Can't continue after import errors");
  	    }
  	}
      }
  
      warn "Importing into $callpkg from $pkg: ",
  		join(", ",sort @imports) if $Exporter::Verbose;
  
      foreach $sym (@imports) {
  	# shortcut for the common case of no type character
  	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
  	    unless $sym =~ s/^(\W)//;
  	$type = $1;
  	no warnings 'once';
  	*{"${callpkg}::$sym"} =
  	    $type eq '&' ? \&{"${pkg}::$sym"} :
  	    $type eq '$' ? \${"${pkg}::$sym"} :
  	    $type eq '@' ? \@{"${pkg}::$sym"} :
  	    $type eq '%' ? \%{"${pkg}::$sym"} :
  	    $type eq '*' ?  *{"${pkg}::$sym"} :
  	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  sub heavy_export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;			# XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  # Utility functions
  
  sub _push_tags {
      my($pkg, $var, $syms) = @_;
      my @nontag = ();
      my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
      push(@{"${pkg}::$var"},
  	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                   : scalar(push(@nontag,$_),$_) }
  		(@$syms) ? @$syms : keys %$export_tags);
      if (@nontag and $^W) {
  	# This may change to a die one day
  	require Carp;
  	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
      }
  }
  
  sub heavy_require_version {
      my($self, $wanted) = @_;
      my $pkg = ref $self || $self;
      return ${pkg}->VERSION($wanted);
  }
  
  sub heavy_export_tags {
    _push_tags((caller)[0], "EXPORT",    \@_);
  }
  
  sub heavy_export_ok_tags {
    _push_tags((caller)[0], "EXPORT_OK", \@_);
  }
  
  1;
EXPORTER_HEAVY

$fatpacked{"Exporter/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_LITE';
  package Exporter::Lite;
  
  require 5.006;
  use warnings;
  use strict;
  
  our $VERSION = '0.09';
  our @EXPORT = qw(import);
  
  
  sub import {
      my($exporter, @imports)  = @_;
      my($caller, $file, $line) = caller;
  
      no strict 'refs';
  
      unless( @imports ) {        # Default import.
          @imports = @{$exporter.'::EXPORT'};
      }
      else {
          # Because @EXPORT_OK = () would indicate that nothing is
          # to be exported, we cannot simply check the length of @EXPORT_OK.
          # We must do oddness to see if the variable exists at all as
          # well as avoid autovivification.
          # XXX idea stolen from base.pm, this might be all unnecessary
          my $eokglob;
          if( $eokglob = ${$exporter.'::'}{EXPORT_OK} and *$eokglob{ARRAY} ) {
              if( @{$exporter.'::EXPORT_OK'} ) {
                  # This can also be cached.
                  my %ok = map { s/^&//; $_ => 1 } @{$exporter.'::EXPORT_OK'},
                                                   @{$exporter.'::EXPORT'};
  
                  my($denied) = grep {s/^&//; !$ok{$_}} @imports;
                  _not_exported($denied, $exporter, $file, $line) if $denied;
              }
              else {      # We don't export anything.
                  _not_exported($imports[0], $exporter, $file, $line);
              }
          }
      }
  
      _export($caller, $exporter, @imports);
  }
  
  
  
  sub _export {
      my($caller, $exporter, @imports) = @_;
  
      no strict 'refs';
  
      # Stole this from Exporter::Heavy.  I'm sure it can be written better
      # but I'm lazy at the moment.
      foreach my $sym (@imports) {
          # shortcut for the common case of no type character
          (*{$caller.'::'.$sym} = \&{$exporter.'::'.$sym}, next)
              unless $sym =~ s/^(\W)//;
  
          my $type = $1;
          my $caller_sym = $caller.'::'.$sym;
          my $export_sym = $exporter.'::'.$sym;
          *{$caller_sym} =
              $type eq '&' ? \&{$export_sym} :
              $type eq '$' ? \${$export_sym} :
              $type eq '@' ? \@{$export_sym} :
              $type eq '%' ? \%{$export_sym} :
              $type eq '*' ?  *{$export_sym} :
              do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  
  #"#
  sub _not_exported {
      my($thing, $exporter, $file, $line) = @_;
      die sprintf qq|"%s" is not exported by the %s module at %s line %d\n|,
          $thing, $exporter, $file, $line;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Exporter::Lite - lightweight exporting of functions and variables
  
  =head1 SYNOPSIS
  
    package Foo;
    use Exporter::Lite;
  
    our @EXPORT    = qw($This That);      # default exports
    our @EXPORT_OK = qw(@Left %Right);    # optional exports
  
  Then in code using the module:
  
    use Foo;
    # $This and &That are imported here
  
  You have to explicitly ask for optional exports:
  
   use Foo qw/ @Left %Right /;
  
  =head1 DESCRIPTION
  
  Exporter::Lite is an alternative to L<Exporter>,
  intended to provide a lightweight subset
  of the most commonly-used functionality.
  It supports C<import()>, C<@EXPORT> and
  C<@EXPORT_OK> and not a whole lot else.
  
  Exporter::Lite simply exports its import() function into your namespace.
  This might be called a "mix-in" or a "role".
  
  When C<Exporter::Lite> was written, if you wanted to use C<Exporter>
  you had to write something like this:
  
   use Exporter;
   our @ISA = qw/ Exporter /;
  
  C<Exporter::Lite> saved you from writing that second line.
  But since before 2010 you've been able to write:
  
   use Exporter qw/ import /;
  
  Which imports the C<import> function into your namespace from C<Exporter>.
  As a result, I would recommend that you use C<Exporter> now,
  as it's a core module (shipped with Perl).
  
  To make sure you get a version of C<Exporter> that supports the
  above usage, specify a minimum version when you C<use> it:
  
   use Exporter 5.57 qw/ import /;
  
  =head2 Back to C<Exporter::Lite>
  
  Setting up a module to export its variables and functions is simple:
  
      package My::Module;
      use Exporter::Lite;
  
      our @EXPORT = qw($Foo bar);
  
  Functions and variables listed in the C<@EXPORT> package variable
  are automatically exported if you use the module and don't explicitly
  list any imports.
  Now, when you C<use My::Module>, C<$Foo> and C<bar()> will show up.
  
  Optional exports are listed in the C<@EXPORT_OK> package variable:
  
      package My::Module;
      use Exporter::Lite;
  
      our @EXPORT_OK = qw($Foo bar);
  
  When My::Module is used, C<$Foo> and C<bar()> will I<not> show up,
  unless you explicitly ask for them:
  
      use My::Module qw($Foo bar);
  
  Note that when you specify one or more functions or variables to import,
  then you must also explicitly list any of the default symbols you want to use.
  So if you have an exporting module:
  
      package Games;
      our @EXPORT    = qw/ pacman defender  /;
      our @EXPORT_OK = qw/ galaga centipede /;
  
  Then if you want to use both C<pacman> and C<galaga>, then you'd write:
  
      use Games qw/ pacman galaga /;
  
  =head1 Methods
  
  Export::Lite has one public method, import(), which is called
  automatically when your modules is use()'d.  
  
  In normal usage you don't have to worry about this at all.
  
  =over 4
  
  =item B<import>
  
    Some::Module->import;
    Some::Module->import(@symbols);
  
  Works just like C<Exporter::import()> excepting it only honors
  @Some::Module::EXPORT and @Some::Module::EXPORT_OK.
  
  The given @symbols are exported to the current package provided they
  are in @Some::Module::EXPORT or @Some::Module::EXPORT_OK.  Otherwise
  an exception is thrown (ie. the program dies).
  
  If @symbols is not given, everything in @Some::Module::EXPORT is
  exported.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item '"%s" is not exported by the %s module'
  
  Attempted to import a symbol which is not in @EXPORT or @EXPORT_OK.
  
  =item 'Can\'t export symbol: %s'
  
  Attempted to import a symbol of an unknown type (ie. the leading $@% salad
  wasn't recognized).
  
  =back
  
  
  =head1 SEE ALSO
  
  L<Exporter> is the grandaddy of all Exporter modules, and bundled with Perl
  itself, unlike the rest of the modules listed here.
  
  L<Attribute::Exporter> defines attributes which you use to mark
  which subs and variables you want to export, and how.
  
  L<Exporter::Simple> also uses attributes to control the export of
  functions and variables from your module.
  
  L<Const::Exporter> makes it easy to create a module that exports constants.
  
  L<Constant::Exporter> is another module that makes it easy to create
  modules that define and export constants.
  
  L<Sub::Exporter> is a "sophisticated exporter for custom-built routines";
  it lets you provide generators that can be used to customise what
  gets imported when someone uses your module.
  
  L<Exporter::Tiny> provides the same features as L<Sub::Exporter>,
  but relying only on core dependencies.
  
  L<Exporter::Shiny> is a shortcut for L<Exporter::Tiny> that
  provides a more concise notation for providing optional exports.
  
  L<Exporter::Declare> provides syntactic sugar to make the export
  status of your functions part of their declaration. Kind of.
  
  L<AppConfig::Exporter> lets you export part of an L<AppConfig>-based
  configuration.
  
  L<Exporter::Lexical> lets you export lexical subs from your module.
  
  L<Constant::Export::Lazy> lets you write a module that exports
  function-style constants, which are instantiated lazily.
  
  L<Exporter::Auto> will export everything from your module that
  it thinks is a public function (name doesn't start with an underscore).
  
  L<Class::Exporter> lets you export class methods as regular subroutines.
  
  L<Xporter> is like Exporter, but with persistent defaults and auto-ISA.
  
  
  =head1 REPOSITORY
  
  L<https://github.com/neilb/Exporter-Lite>
  
  =head1 AUTHORS
  
  Michael G Schwern <schwern@pobox.com>
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
EXPORTER_LITE

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Tue Aug 18 14:48:05 2020
  # Update Count    : 1739
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.52;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.52";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION_STRING ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		my $given = $opt;
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    given   => $given,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && ( $order == $PERMUTE || $passthrough ) ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Aliases
  		     (?: \| (?: . [^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    if ( $type eq 'I' ) {
  		# Fake incremental type.
  		my @c = @$ctl;
  		$c[CTL_TYPE] = '+';
  		return (1, $opt, \@c, 1);
  	    }
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand || $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1] if @_ > 1;
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  sub given {
      my $self = shift;
      $self->{given};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Callback object
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  The callback object has the following methods:
  
  =over
  
  =item name
  
  The name of the option, unabbreviated. For an option with multiple
  names it return the first (canonical) name.
  
  =item given
  
  The name of the option as actually used, unabbreveated.
  
  =back
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument. See the next section.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options (and any of their auto-abbreviated shortened forms) B<must>
  always start with a double dash C<--> to avoid ambiguity. For example,
  when C<vax>, C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>. To disable, prefix with C<no> or C<no_>, e.g.
  C<no_ignore_case>. Case does not matter. Multiple calls to Configure()
  are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  (and any of their auto-abbreviated shortened forms) I<must> be
  introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also
  supported in aliases with Getopt::Long of at version 2.39. Note that
  the characters C<!>, C<|>, C<+>, C<=>, and C<:> can only appear as the
  first (or only) character of an alias.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Message/DOM/Attr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_ATTR';
  package Message::DOM::Attr;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.11 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::DOM::Node', 'Message::IF::Attr';
  require Message::DOM::Node;
  
  sub ____new ($$$$$$) {
    my $self = shift->SUPER::____new (shift);
    ($$self->{owner_element},
     $$self->{namespace_uri},
     $$self->{prefix},
     $$self->{local_name}) = @_;
    Scalar::Util::weaken ($$self->{owner_element});
    $$self->{child_nodes} = [];
    $$self->{specified} = 1;
    return $self;
  } # ____new
               
  sub AUTOLOAD {
    my $method_name = our $AUTOLOAD;
    $method_name =~ s/.*:://;
    return if $method_name eq 'DESTROY';
  
    if ({
      ## Read-only attributes (trivial accessors)
      namespace_uri => 1,
      owner_element => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$) {
          return \${\$_[0]}->{$method_name}; 
        }
      };
      goto &{ $AUTOLOAD };
    } else {
      require Carp;
      Carp::croak (qq<Can't locate method "$AUTOLOAD">);
    }
  } # AUTOLOAD
  
  ## |AttributeDefinition| constants
  
  ## |DeclaredValueType|
  sub NO_TYPE_ATTR () { 0 }
  sub CDATA_ATTR () { 1 }
  sub ID_ATTR () { 2 }
  sub IDREF_ATTR () { 3 }
  sub IDREFS_ATTR () { 4 }
  sub ENTITY_ATTR () { 5 }
  sub ENTITIES_ATTR () { 6 }
  sub NMTOKEN_ATTR () { 7 }
  sub NMTOKENS_ATTR () { 8 }
  sub NOTATION_ATTR () { 9 }
  sub ENUMERATION_ATTR () { 10 }
  sub UNKNOWN_ATTR () { 11 }
  
  ## |Node| attributes
  
  sub base_uri ($) {
    my $self = $_[0];
    local $Error::Depth = $Error::Depth + 1;
    my $oe = $self->owner_element;
    if ($oe) {
      my $ln = $self->manakai_local_name;
      my $nsuri = $self->namespace_uri;
      if (($ln eq 'base' and
           defined $nsuri and $nsuri eq 'http://www.w3.org/XML/1998/namespace') or
          ($ln eq 'xml:base' and not defined $nsuri)) {
        my $oep = $oe->parent_node;
        if ($oep) {
          return $oep->base_uri;
        } else {
          return $self->owner_document->base_uri;
        }
      } else {
        return $oe->base_uri;
      }
    } else {
      return $self->owner_document->base_uri;
    }
  } # base_uri
  
  sub local_name ($) {
    ## TODO: HTML5
    return ${+shift}->{local_name};
  } # local_name
  
  sub manakai_local_name ($) {
    return ${$_[0]}->{local_name};
  } # manakai_local_name
  
  sub namespace_uri ($);
  
  *node_name = \&name;
  
  sub node_type () { 2 } # ATTRIBUTE_NODE
  
  *node_value = \&Message::DOM::Node::text_content;
  
  sub owner_element ($);
  
  sub prefix ($;$) {
    ## NOTE: No check for new value as Firefox doesn't do.
    ## See <http://suika.fam.cx/gate/2005/sw/prefix>.
  
    ## NOTE: Same as trivial setter except "" -> undef
  
    ## NOTE: Same as |Element|'s |prefix|.
    
    if (@_ > 1) {
      if (${${$_[0]}->{owner_document}}->{strict_error_checking} and 
          ${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
      if (defined $_[1] and $_[1] ne '') {
        ${$_[0]}->{prefix} = ''.$_[1];
      } else {
        delete ${$_[0]}->{prefix};
      }
    }
    return ${$_[0]}->{prefix}; 
  } # prefix
  
  ## |Node| methods
  
  sub append_child ($$) {
    my $self = $_[0];
    
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, @{$_[1]->child_nodes};
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self_od ne $child_od and $child_od->node_type != 10) {
        report Message::DOM::DOMException # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ({
                 3, 1, 5, 1, # TEXT_NODE, ENTITY_REFERENCE_NODE
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      ## NOTE: Ancestor check here in |Node|.
    }
  
    ## NOTE: "Insert at" code only in insert_before and replace_child
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    push @{$$self->{child_nodes}}, @new_child;
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[1];
  } # apepnd_child
  
  sub insert_before ($$) {
    my $self = $_[0];
  
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, @{$_[1]->child_nodes};
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self_od ne $child_od and $child_od->node_type != 10) {
        report Message::DOM::DOMException # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ({
                 3, 1, 5, 1, # TEXT_NODE, ENTITY_REFERENCE_NODE
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      ## NOTE: Ancestor check here in |Node|.
    }
    
    ## -- Insert at... ## NOTE: Only in insert_before and replace_child
    my $index = -1; # last
    if (defined $_[2]) {
      ## error if $_[1] eq $_[2];
      
      my $cns = $self->child_nodes;
      my $cnsl = @$cns;
      C: {
        $index = 0;
        for my $i (0..($cnsl-1)) {
          my $cn = $cns->[$i];
          if ($cn eq $_[2]) {
            $index += $i;
            last C;
          } elsif ($cn eq $_[1]) {
            $index = -1; # offset
          }
        }
        
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_FOUND_ERR',
            -subtype => 'NOT_CHILD_ERR';
      } # C
    }
    ## NOTE: "else" only in replace_child
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    if ($index == -1) {
      push @{$$self->{child_nodes}}, @new_child;
    } else {
      splice @{$$self->{child_nodes}}, $index, 0, @new_child;
    }
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[1];
  } # insert_before
  
  sub replace_child ($$) {
    my $self = $_[0];
  
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, @{$_[1]->child_nodes};
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self_od ne $child_od and $child_od->node_type != 10) {
        report Message::DOM::DOMException # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ({
                 3, 1, 5, 1, # TEXT_NODE, ENTITY_REFERENCE_NODE
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      ## NOTE: Ancestor check here in |Node|.
    }
    
    ## -- Insert at... ## NOTE: Only in insertBefore and replaceChild
    my $index = -1; # last
    if (defined $_[2]) {
      ## error if $_[1] eq $_[2];
      
      my $cns = $self->child_nodes;
      my $cnsl = @$cns;
      C: {
        $index = 0;
        for my $i (0..($cnsl-1)) {
          my $cn = $cns->[$i];
          if ($cn eq $_[2]) {
            $index += $i;
            last C;
          } elsif ($cn eq $_[1]) {
            $index = -1; # offset
          }
        }
        
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_FOUND_ERR',
            -subtype => 'NOT_CHILD_ERR';
      } # C
    } else {
      ## NOTE: Only in replaceChild
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    }
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    splice @{$$self->{child_nodes}}, $index, 1, @new_child;
    delete ${$_[2]}->{parent_node};
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[2];
  } # replace_child
  
  ## |Attr| attributes
  
  sub manakai_attribute_type ($;$) {
    my $self = $_[0];
    if (@_ > 1) {
      if (${$$self->{owner_document}}->{strict_error_checking}) {
        if ($$self->{manakai_read_only}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NO_MODIFICATION_ALLOWED_ERR',
              -subtype => 'READ_ONLY_NODE_ERR';
        }
      }
      if ($_[1]) {
        $$self->{manakai_attribute_type} = 0+$_[1];
      } else {
        delete $$self->{manakai_attribute_type};
      }
    }
    
    return $$self->{manakai_attribute_type} || 0;
  } # manakai_attribute_type
  
  sub is_id ($;$) {
    my $self = $_[0];
  
    if (@_ > 1) {
      ## NOTE: The setter is a manakai extension.
      ## TODO: Document.
  
      if (${$$self->{owner_document}}->{strict_error_checking}) {
        if ($$self->{manakai_read_only}) {
          report Message::DOM::DOMException
                -object => $self,
                -type => 'NO_MODIFICATION_ALLOWED_ERR',
                -subtype => 'READ_ONLY_NODE_ERR';
        }
      }
  
      if ($_[1]) {
        $$self->{manakai_user_determined_id} = 1;
      } else {
        delete $$self->{manakai_user_determined_id};
      }
    }
    return unless defined wantarray;
    
    ## DTD Attribute Type
    my $type = $$self->{manakai_attribute_type};
    if (defined $type and $type == 2) { # ID_ATTR
      return 1;
    }
    
    ## User-determined ID
    if ($$self->{manakai_user_determined_id}) {
      return 1;
    }
  
    ## Application-determined ID
    my $nsuri = $self->namespace_uri;
    my $ln = $self->manakai_local_name;
    if (defined $nsuri) {
      if ($ln eq 'id') {
        if ($nsuri eq q<http://www.w3.org/XML/1998/namespace>) {
          return 1;
        }
      }
    } else {
      if ($ln eq 'xml:id') {
        return 1;
      }
  
      my $oe = $$self->{owner_element};
      if ($oe) {
        my $oe_nsuri = $oe->namespace_uri;
        if (defined $oe_nsuri) {
          if ($ln eq 'id') {
            if ($oe_nsuri eq q<http://www.w3.org/1999/xhtml>) {
              return 1;
            }
          }
        }
      }
    }
  
    return 0;
  } # is_id
  
  ## TODO: HTML5 case stuff?
  sub name ($) {
    my $self = shift;
    if (defined $$self->{prefix}) {
      return $$self->{prefix} . ':' . $$self->{local_name};
    } else {
      return $$self->{local_name};
    }
  } # name
  
  ## TODO: Documentation
  sub manakai_name ($) {
    my $self = shift;
    if (defined $$self->{prefix}) {
      return $$self->{prefix} . ':' . $$self->{local_name};
    } else {
      return $$self->{local_name};
    }
  } # manakai_name
  
  sub schema_type_info ($) {
    require Message::DOM::TypeInfo;
    my $v = ${$_[0]}->{manakai_attribute_type} || 0;
    return bless \$v, 'Message::DOM::TypeInfo';
  } # schema_type_info
  
  sub specified ($;$) {
    if (@_ > 1) {
      ## NOTE: A manakai extension.
      if (${${$_[0]}->{owner_document}}->{strict_error_checking} and 
          ${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
      if ($_[1] or not defined ${$_[0]}->{owner_element}) {
        ${$_[0]}->{specified} = 1;
      } else {
        delete ${$_[0]}->{specified};
      }
    }
    return ${$_[0]}->{specified}; 
  } # specified
  
  *value = \&node_value;
  
  package Message::IF::Attr;
  
  package Message::DOM::Document;
  
  sub create_attribute ($$) {
    if (${$_[0]}->{strict_error_checking}) {
      my $xv = $_[0]->xml_version;
      ## TODO: HTML Document ??
      if (defined $xv) {
        if ($xv eq '1.0' and
            $_[1] =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
          #
        } elsif ($xv eq '1.1' and
                 $_[1] =~ /\A\p{InXMLNameStartChar11}\p{InXMLNameChar11}*\z/) {
          # 
        } else {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'INVALID_CHARACTER_ERR',
              -subtype => 'MALFORMED_NAME_ERR';
        }
      }
    }
    ## TODO: HTML5
    return Message::DOM::Attr->____new ($_[0], undef, undef, undef, $_[1]);
  } # create_attribute
  
  sub create_attribute_ns ($$$) {
    my ($prefix, $lname);
    if (ref $_[2] eq 'ARRAY') {
      ($prefix, $lname) = @{$_[2]};
    } else {
      ($prefix, $lname) = split /:/, $_[2], 2;
      ($prefix, $lname) = (undef, $prefix) unless defined $lname;
    }
    my $nsuri = defined $_[1] ? $_[1] eq '' ? undef : $_[1] : undef;
  
    if (${$_[0]}->{strict_error_checking}) {
      my $xv = $_[0]->xml_version;
      ## TODO: HTML Document ?? (NOT_SUPPORTED_ERR is different from what Web browsers do)
      if (defined $xv) {
        if ($xv eq '1.0') {
          if (ref $_[2] eq 'ARRAY' or
              $_[2] =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
            if (defined $prefix) {
              if ($prefix =~ /\A\p{InXML_NCNameStartChar10}\p{InXMLNCNameChar10}*\z/) {
                #
              } else {
                report Message::DOM::DOMException
                    -object => $_[0],
                    -type => 'NAMESPACE_ERR',
                    -subtype => 'MALFORMED_QNAME_ERR';
              }
            }
            if ($lname =~ /\A\p{InXML_NCNameStartChar10}\p{InXMLNCNameChar10}*\z/) {
              #
            } else {
              report Message::DOM::DOMException
                  -object => $_[0],
                  -type => 'NAMESPACE_ERR',
                  -subtype => 'MALFORMED_QNAME_ERR';
            }
          } else {
            report Message::DOM::DOMException
                -object => $_[0],
                -type => 'INVALID_CHARACTER_ERR',
                -subtype => 'MALFORMED_NAME_ERR';
          }
        } elsif ($xv eq '1.1') {
          if (ref $_[2] eq 'ARRAY' or
              $_[2] =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
            if (defined $prefix) {
              if ($prefix =~ /\A\p{InXMLNCNameStartChar11}\p{InXMLNCNameChar11}*\z/) {
                #
              } else {
                report Message::DOM::DOMException
                    -object => $_[0],
                    -type => 'NAMESPACE_ERR',
                    -subtype => 'MALFORMED_QNAME_ERR';
              }
            }
            if ($lname =~ /\A\p{InXMLNCNameStartChar11}\p{InXMLNCNameChar11}*\z/) {
              #
            } else {
              report Message::DOM::DOMException
                  -object => $_[0],
                  -type => 'NAMESPACE_ERR',
                  -subtype => 'MALFORMED_QNAME_ERR';
            }
          } else {
            report Message::DOM::DOMException
                -object => $_[0],
                -type => 'INVALID_CHARACTER_ERR',
                -subtype => 'MALFORMED_NAME_ERR';
          }
        } else {
          die "create_attribute_ns: XML version |$xv| is not supported";
        }
      }
  
      if (defined $prefix) {
        if (not defined $nsuri) {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'NAMESPACE_ERR',
              -subtype => 'PREFIXED_NULLNS_ERR';
        } elsif ($prefix eq 'xml' and 
                 $nsuri ne q<http://www.w3.org/XML/1998/namespace>) {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'NAMESPACE_ERR',
              -subtype => 'XMLPREFIX_NONXMLNS_ERR';
        } elsif ($prefix eq 'xmlns' and
                 $nsuri ne q<http://www.w3.org/2000/xmlns/>) {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'NAMESPACE_ERR',
              -subtype => 'XMLNSPREFIX_NONXMLNSNS_ERR';
        } elsif ($nsuri eq q<http://www.w3.org/2000/xmlns/> and
                 $prefix ne 'xmlns') {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'NAMESPACE_ERR',
              -subtype => 'NONXMLNSPREFIX_XMLNSNS_ERR';
        }
      } else { # no prefix
        if ($lname eq 'xmlns' and
            (not defined $nsuri or $nsuri ne q<http://www.w3.org/2000/xmlns/>)) {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'NAMESPACE_ERR',
              -subtype => 'XMLNS_NONXMLNSNS_ERR';
        } elsif (not defined $nsuri) {
          #
        } elsif ($nsuri eq q<http://www.w3.org/2000/xmlns/> and
                 $lname ne 'xmlns') {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'NAMESPACE_ERR',
              -subtype => 'NONXMLNSPREFIX_XMLNSNS_ERR';
        }
      }
    }
  
    ## TODO: Older version of manakai set |attribute_type|
    ## attribute for |xml:id| attribute.  Should we support this?
  
    return Message::DOM::Attr->____new ($_[0], undef, $nsuri, $prefix, $lname);
  } # create_attribute_ns
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2007/07/29 03:48:59 $
MESSAGE_DOM_ATTR

$fatpacked{"Message/DOM/CharacterData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_CHARACTERDATA';
  ## NOTE: This module will be renamed as CharacterData.pm
  
  package Message::DOM::CharacterData;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.18 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::DOM::Node', 'Message::IF::CharacterData';
  require Message::DOM::Node;
  use Message::Util::Error;
  
  sub ____new ($$$) {
    my $self = shift->SUPER::____new (shift);
    $$self->{data} = ''.(ref $_[0] eq 'SCALAR' ? ${$_[0]} : $_[0]);
    return $self;
  } # ____new
               
  ## |Node| attributes
  
  sub base_uri ($) {
    ## NOTE: Same as |EntityReference|'s.
  
    my $self = $_[0];
    local $Error::Depth = $Error::Depth + 1;
    my $pe = $$self->{parent_node};
    while (defined $pe) {
      my $nt = $pe->node_type;
      if ($nt == 1 or $nt == 2 or $nt == 6 or $nt == 9 or $nt == 11) {
        ## Element, Attr, Entity, Document, or DocumentFragment
        return $pe->base_uri;
      } elsif ($nt == 5) {
        ## EntityReference
        return $pe->manakai_entity_base_uri if $pe->manakai_external;
      }
      $pe = $$pe->{parent_node};
    }
    return $pe->base_uri if $pe;
    return $$self->{owner_document}->base_uri;
  } # base_uri
  
  sub child_nodes ($) {
    require Message::DOM::NodeList;
    return bless \\($_[0]), 'Message::DOM::NodeList::EmptyNodeList';
  } # child_nodes
  
  ## |CDATASection|:
  ## The content of the CDATA section [DOM1, DOM2, DOM3].
  ## Same as |CharacterData.data| [DOM3].
  
  ## |Comment|:
  ## The content of the comment [DOM1, DOM2, DOM3].
  ## Same as |CharacterData.data| [DOM3].
  
  ## |Text|:
  ## The content of the text node [DOM1, DOM2, DOM3].
  ## Same as |CharacterData.data| [DOM3].
  
  *node_value = \&data; # For |CDATASection|, |Comment|, and |Text|.
  
  ## ISSUE: DOM3 Core does not explicitly say setting |null|
  ## on read-only node is ignored.  Strictly speaking, it does not even
  ## say what the setter does for |CharacterData| and PI nodes.
  ## What if setting |null| to non read-only |CharacterData| or PI?
  
  *text_content = \&node_value; # For |CDATASection|, |Comment|, and |Text|.
  
  ## |Node| methods
  
  sub append_child ($$) {
    report Message::DOM::DOMException
        -object => $_[0],
        -type => 'HIERARCHY_REQUEST_ERR',
        -subtype => 'CHILD_NODE_TYPE_ERR';
  } # append_child
  
  sub manakai_append_text ($$) {
    ## NOTE: Same as |ProcessingInstruction|'s.
    if (${${$_[0]}->{owner_document}}->{strict_error_checking} and
        ${$_[0]}->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
    ${$_[0]}->{data} .= ref $_[1] eq 'SCALAR' ? ${$_[1]} : $_[1];
  } # manakai_append_text
  
  sub insert_before ($;$) {
    report Message::DOM::DOMException
        -object => $_[0],
        -type => 'HIERARCHY_REQUEST_ERR',
        -subtype => 'CHILD_NODE_TYPE_ERR';
  } # insert_before
  
  sub replace_child ($$) {
    report Message::DOM::DOMException
        -object => $_[0],
        -type => 'HIERARCHY_REQUEST_ERR',
        -subtype => 'CHILD_NODE_TYPE_ERR';
  } # replace_child
  
  ## |CharacterData| attributes
  
  sub data ($;$) {
    if (@_ > 1) {
      if (${${$_[0]}->{owner_document}}->{strict_error_checking} and
          ${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      if (defined $_[1]) {
        ${$_[0]}->{data} = ''.$_[1];
      } else {
        ${$_[0]}->{data} = ''; # for |text_content|.
      }
    }
  
    return ${$_[0]}->{data};
  } # data
  
  sub length ($) {
    my $self = $_[0];
    my $r = CORE::length $$self->{data};
    $r++ while $$self->{data} =~ /[\x{10000}-\x{10FFFF}]/g;
    return $r;
  } # length
  
  ## |CharacterData| methods
  
  *append_data = \&manakai_append_text;
  
  sub delete_data ($;$) {
    my $self = $_[0];
    my $offset = 0+$_[1];
    my $count = 0+$_[2];
    
    if ($offset < 0 or $count < 0) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'INDEX_SIZE_ERR',
          -subtype => 'INDEX_OUT_OF_BOUND_ERR';
    }
  
    require Message::DOM::StringExtended;
  
    my $offset32;
    try {
      $offset32 = Message::DOM::StringExtended::find_offset32
          ($$self->{data}, $offset);
    } catch Error::Simple with {
      my $err = shift;
      if ($err->text eq "String index out of bounds\n") {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'INDEX_SIZE_ERR',
            -subtype => 'INDEX_OUT_OF_BOUND_ERR';
      } else {
        $err->throw;
      }
    };
  
    my $eoffset32;
    try {
      $eoffset32 = Message::DOM::StringExtended::find_offset32
          ($$self->{data}, $offset + $count);
    } catch Error::Simple with {
      my $err = shift;
      if ($err->text eq "String index out of bounds\n") {
        $eoffset32 = ($offset + $count) * 2;
      } else {
        $err->throw;
      }
    };
  
    substr ($$self->{data}, $offset32, $eoffset32 - $offset32) = '';
    return undef;
  } # delete_data
  
  sub insert_data ($$$) {
    my $self = $_[0];
    my $offset = 0+$_[1];
  
    if (${$$self->{owner_document}}->{strict_error_checking} and
        $$self->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    if ($offset < 0) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'INDEX_SIZE_ERR',
          -subtype => 'INDEX_OUT_OF_BOUND_ERR';
    }
  
    require Message::DOM::StringExtended;
    my $offset32;
    try {
      $offset32 = Message::DOM::StringExtended::find_offset32
          ($$self->{data}, $offset);
    } catch Error::Simple with {
      my $err = shift;
      if ($err->text eq "String index out of bounds\n") {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'INDEX_SIZE_ERR',
            -subtype => 'INDEX_OUT_OF_BOUND_ERR';
      } else {
        $err->throw;
      }
    };
    substr ($$self->{data}, $offset32, 0) = $_[2];
  } # insert_data
  
  sub replace_data ($;$$) {
    my $self = $_[0];
    my $offset = 0+$_[1];
    my $count = 0+$_[2];
    
    if ($offset < 0 or $count < 0) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'INDEX_SIZE_ERR',
          -subtype => 'INDEX_OUT_OF_BOUND_ERR';
    }
  
    require Message::DOM::StringExtended;
  
    my $offset32;
    try {
      $offset32 = Message::DOM::StringExtended::find_offset32
          ($$self->{data}, $offset);
    } catch Error::Simple with {
      my $err = shift;
      if ($err->text eq "String index out of bounds\n") {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'INDEX_SIZE_ERR',
            -subtype => 'INDEX_OUT_OF_BOUND_ERR';
      } else {
        $err->throw;
      }
    };
  
    my $eoffset32;
    try {
      $eoffset32 = Message::DOM::StringExtended::find_offset32
          ($$self->{data}, $offset + $count);
    } catch Error::Simple with {
      my $err = shift;
      if ($err->text eq "String index out of bounds\n") {
        $eoffset32 = ($offset + $count) * 2;
      } else {
        $err->throw;
      }
    };
  
    substr ($$self->{data}, $offset32, $eoffset32 - $offset32) = $_[3];
    return undef;
  } # replace_data
  
  sub substring_data ($;$$) {
    my $self = $_[0];
    my $offset = 0+$_[1];
    my $count = 0+$_[2];
    
    if ($offset < 0 or $count < 0) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'INDEX_SIZE_ERR',
          -subtype => 'INDEX_OUT_OF_BOUND_ERR';
    }
  
    require Message::DOM::StringExtended;
  
    my $eoffset32;
    try {
      $eoffset32 = Message::DOM::StringExtended::find_offset32
          ($$self->{data}, $offset + $count);
    } catch Error::Simple with {
      my $err = shift;
      if ($err->text eq "String index out of bounds\n") {
        $eoffset32 = ($offset + $count) * 2;
      } else {
        $err->throw;
      }
    };
     
    local $Error::Depth = $Error::Depth + 1;
    my $offset32 = Message::DOM::StringExtended::find_offset32
        ($$self->{data}, $offset);
    return substr $$self->{data}, $offset32, $eoffset32 - $offset32;
  } # substring_data
  
  package Message::DOM::CharacterData::Comment;
  push our @ISA, 'Message::DOM::CharacterData', 'Message::IF::Comment';
  
  ## |Node| attributes
  
  sub node_name () { '#comment' }
  
  sub node_type () { 8 } # COMMENT_NODE
  
  package Message::IF::CharacterData;
  package Message::IF::Comment;
  
  package Message::DOM::Document;
  
  sub create_comment ($$) {
    return Message::DOM::CharacterData::Comment->____new ($_[0], $_[1]);
  } # create_comment
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2007/07/29 08:31:14 $
MESSAGE_DOM_CHARACTERDATA

$fatpacked{"Message/DOM/DOMConfiguration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_DOMCONFIGURATION';
  package Message::DOM::DOMConfiguration;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.7 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::IF::DOMConfiguration';
  require Message::DOM::DOMException;
  
  use overload
      '%{}' => sub {
        tie my %list, ref $_[0], $_[0];
        return \%list;
      },
      eq => sub {
        return 0 unless UNIVERSAL::isa ($_[1], 'Message::DOM::DOMConfiguration');
        return $${$_[0]} eq $${$_[1]};
      },
      ne => sub {
        return not ($_[0] eq $_[1]);
      },
      fallback => 1;
  
  sub ___report_error ($$) {
    $_[1]->throw;
  } # ___report_error
  
  sub TIEHASH ($$) { $_[1] }
  
  ## TODO: Define Perl binding
  
  ## |DOMConfiguration| attribute
  
  my %names = (
               'error-handler' => 1,
               'schema-type' => 1,
               q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1,
               q<http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type> => 1,
               q<http://suika.fam.cx/www/2006/dom-config/create-child-element> => 1,
               q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute> => 1,
               q<http://suika.fam.cx/www/2006/dom-config/strict-document-children> => 1,
               q<http://suika.fam.cx/www/2006/dom-config/xml-id> => 1,
  );
  
  sub parameter_names ($) {
    require Message::DOM::DOMStringList;
    return bless [sort {$a cmp $b} keys %names],
        'Message::DOM::DOMStringList::StaticList';
  } # parameter_names
  
  ## |DOMConfiguration| methods
  
  sub can_set_parameter ($$;$) {
    my $name = ''.$_[1];
    if ({
         q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/create-child-element> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/strict-document-children> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/xml-id> => 1,
        }->{$name}) {
      return 1;
    } elsif ($name eq 'error-handler') {
      return 1 unless defined $_[2];
      return ref $_[2] eq 'CODE';
    } elsif ($name eq 'schema-type') {
      return 1 unless defined $_[2];
      return 1 if ''.$_[2] eq q<http://www.w3.org/TR/REC-xml>;
      return 0;
    } else {
      return 0;
    }
  } # can_set_parameter
  
  sub get_parameter ($$) {
    my $name = ''.$_[1];
    if ({
         'schema-type' => 1,
         q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/create-child-element> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/strict-document-children> => 1,
         q<http://suika.fam.cx/www/2006/dom-config/xml-id> => 1,
         'error-handler' => 1,
        }->{$name}) {
      return ${$${$_[0]}}->{$name};    
    } else {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NOT_FOUND_ERR',
          -subtype => 'UNRECOGNIZED_CONFIGURATION_PARAMETER_ERR';
    }
  } # get_parameter
  *FETCH = \&get_parameter;
  
  ## TODO: Should we allow $cfg->{error_handler}?
  
  sub set_parameter ($$;$) {
    my $name = ''.$_[1];
    if (defined $_[2]) {
      if ({
           q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/create-child-element> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/strict-document-children> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/xml-id> => 1,
          }->{$name}) {
        if ($_[2]) {
          ${$${$_[0]}}->{$name} = 1;
        } else {
          delete ${$${$_[0]}}->{$name};
        }
      } elsif ($name eq 'error-handler') {
        if (ref $_[2] eq 'CODE') {
          ${$${$_[0]}}->{$name} = $_[2];
        } else {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'TYPE_MISMATCH_ERR',
              -subtype => 'CONFIGURATION_PARAMETER_TYPE_ERR';
        }
      } elsif ($name eq 'schema-type') {
        my $value = ''.$_[2];
        if ($value eq q<http://www.w3.org/TR/REC-xml>) {
          ${$${$_[0]}}->{$name} = ''.$_[2];
        } else {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'NOT_SUPPORTED_ERR',
              -subtype => 'CONFIGURATION_PARAMETER_VALUE_ERR';
        }
      } else {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NOT_FOUND_ERR',
            -subtype => 'UNRECOGNIZED_CONFIGURATION_PARAMETER_ERR';
      }
    } else { # reset
      if ({
           q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/strict-document-children> => 1,
           q<http://suika.fam.cx/www/2006/dom-config/xml-id> => 1,
          }->{$name}) {
        ${$${$_[0]}}->{$name} = 1;
      } elsif ({
                'schema-type' => 1,
                q<http://suika.fam.cx/www/2006/dom-config/create-child-element> => 1,
          }->{$name}) {
        delete ${$${$_[0]}}->{$name};
      } elsif ($_[1] eq 'error-handler') {
        ${$${$_[0]}}->{$name} = sub ($) {
          ## NOTE: Same as one set by |Document| constructor.
          warn $_[0];
          return $_[0]->severity != 3; # SEVERITY_FATAL_ERROR
        };
      } else {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NOT_FOUND_ERR',
            -subtype => 'UNRECOGNIZED_CONFIGURATION_PARAMETER_ERR';
      }
    }
    return undef;
  } # set_parameter
  *STORE = \&set_parameter;
  
  sub DELETE ($$) {
    local $Error::Depth = $Error::Depth + 1;
    $_[0]->set_parameter ($_[1] => undef);
  } # DELETE
  
  sub EXISTS ($$) { exists $names{$_[1]} }
  
  sub FIRSTKEY ($) {
    my $a = keys %names;
    return each %names;
  } # FIRSTKEY
                
  sub NEXTKEY ($) {
    return each %names;
  } # NEXTKEY
  
  package Message::IF::DOMConfiguration;
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2007/07/15 05:18:46 $
MESSAGE_DOM_DOMCONFIGURATION

$fatpacked{"Message/DOM/DOMException.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_DOMEXCEPTION';
  package Message::DOM::DOMException;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.16 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::Util::Error', 'Message::IF::DOMException';
  require Message::Util::Error;
  
  sub ___error_def () {+{
    INDEX_SIZE_ERR => {
      -code => 1,
      -subtype => {
        INDEX_OUT_OF_BOUND_ERR => {
          -description => q(Specified index is outside of the bounds),
        },
      },
    },
    # DOMSTRING_SIZE_ERR == 2
    HIERARCHY_REQUEST_ERR => {
      -code => 3,
      -subtype => {
        ANCESTOR_NODE_ERR => {
          -description => q(Specified node is an ancestor of the node or the node itself),
        },
        CHILD_NODE_TYPE_ERR => {
          -description => q(This type of node cannot be inserted to this point),
        },
        INUSE_DEFINITION_ERR => {
          -description => q(The node is already in use),
        },
      },
    },
    WRONG_DOCUMENT_ERR => {
      -code => 4,
      -subtype => {
        EXTERNAL_OBJECT_ERR => {
          -description => q(Can't insert into different document),
        },
        INUSE_DOCTYPE_ERR => {
          -description => q(Document type is already in use),
        },
      },
    },
    INVALID_CHARACTER_ERR => {
      -code => 5,
      -subtype => {
        MALFORMED_EVENT_TYPE_ERR => {
          -description => q(Event type is not an XML Namespaces 1.1 |NCName|),
        },
        MALFORMED_NAME_ERR => {
          -description => q(Not a legal XML |Name|),
        },
      },
    },
    # NO_DATA_ALLOWED_ERR == 6
    NO_MODIFICATION_ALLOWED_ERR => {
      -code => 7,
      -subtype => {
        READ_ONLY_NODE_ERR => {
          -description => q(Can't modify read-only node),
        },
        READ_ONLY_NODE_LIST_ERR => {
          -description => q(Can't modify read-only node list),
        },
      },
    },
    NOT_FOUND_ERR => {
      -code => 8,
      -subtype => {
        NOT_CHILD_ERR => {
          -description => q(Not a child of this node),
        },
        UNRECOGNIZED_CONFIGURATION_PARAMETER_ERR => {
          -description => q(Unrecognized configuration parameter is specified),
        },
      },
    },
    NOT_SUPPORTED_ERR => {
      -code => 9,
      -subtype => {
        ADOPT_NODE_TYPE_NOT_SUPPORTED_ERR => {
          -description => q(Can't adopt specified type of node),
        },
        CLONE_NODE_TYPE_NOT_SUPPORTED_ERR => {
          -description => q(Can't clone specified type of node),
        },
        CONFIGURATION_PARAMETER_VALUE_ERR => {
          -description => q(Can't set the value to the configuration parameter),
        },
        EVENT_INTERFACE_NOT_SUPPORTED_ERR => {
          -description => q(Can't instantiate specified event interface),
        },
        EXTERNAL_EVENT_ERR => {
          -description => q(The event has not been created using create_event
              method of this DOM implementation),
        },
        NON_HTML_OPERATION_ERR => {
          -description => q(Can't apply to HTML document),
        },
        NULLPO_ERR => {
          -description => q(NULLPO),
        },
        UNKNOWN_XML_VERSION_ERR => {
          -description => q(Specified version of XML is not supported),
        },
      },
    },
    INUSE_ATTRIBUTE_ERR => {
      -code => 10,
      -description => q(Attribute is already in use),
    },
    INVALID_STATE_ERR => {
      -code => 11,
    },
    SYNTAX_ERR => {
      -code => 12,
      -subtype => {
        INVALID_SELECTORS_ERR => {
          -description => q(Invalid group of selectors),
        },
      },
    },
    # INVALID_MODIFICATION_ERR == 13
    NAMESPACE_ERR => {
      -code => 14,
      -subtype => {
        MALFORMED_QNAME_ERR => {
          -description => q(Malformed XML qualified name),
        },
        NONXMLNSPREFIX_XMLNSNS_ERR => {
          -description => q(Namespace prefix "xmlns" must be used for namespace URI <http://www.w3.org/2000/xmlns/>),
        },
        PREFIXED_NULLNS_ERR => {
          -description => q(A namespace prefix is specified while namespace URI is null),
        },
        QNAME_NULLNS_ERR => {
          -description => q(Qualified name is not specified),
        },
        UNDECLARED_PREFIX_ERR => {
          -description => q(Undeclared prefix
              "%p (name => {namespace_prefix});"),
        },
        XMLNS_NONXMLNSNS_ERR => {
          -description => q(Qualified name "xmlns" can only be used with namespace URI <http://www.w3.org/2000/xmlns/>),
        },
        XMLNSPREFIX_NONXMLNSNS_ERR => {
          -description => q(Namespace prefix "xmlns" cannot be used for namespace URI other than <http://www.w3.org/2000/xmlns/>),
        },
        XMLPREFIX_NONXMLNS_ERR => {
          -description => q(Namespace prefix "xml" cannot be used for namespace URI other than <http://www.w3.org/XML/1998/namespace>),
        },
      },
    },
    # INVALID_ACCESS_ERR == 15
    # VALIDATION_ERR == 16
    TYPE_MISMATCH_ERR => {
      -code => 17,
      -subtype => {
        CONFIGURATION_PARAMETER_TYPE_ERR => {
          -description => q(The value type for this configuration parameter is incompatible with the specified value),
        },
      },
    },
  }} # ___error_def
  
  package Message::IF::DOMException;
  push our @ISA, 'Message::Util::Error';
  
  ## DOM1
  sub INDEX_SIZE_ERR () { 1 }
  sub DOMSTRING_SIZE_ERR () { 2 }
  sub HIERARCHY_REQUEST_ERR () { 3 }
  sub WRONG_DOCUMENT_ERR () { 4 }
  sub INVALID_CHARACTER_ERR () { 5 }
  sub NO_DATA_ALLOWED_ERR () { 6 }
  sub NO_MODIFICATION_ALLOWED_ERR () { 7 }
  sub NOT_FOUND_ERR () { 8 }
  sub NOT_SUPPORTED_ERR () { 9 }
  sub INUSE_ATTRIBUTE_ERR () { 10 }
  ## DOM2
  sub INVALID_STATE_ERR () { 11 }
  sub SYNTAX_ERR () { 12 }
  sub INVALID_MODIFICATION_ERR () { 13 }
  sub NAMESPACE_ERR () { 14 }
  sub INVALID_ACCESS_ERR () { 15 }
  ## DOM3
  sub VALIDATION_ERR () { 16 }
  sub TYPE_MISMATCH_ERR () { 17 }
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2007/10/08 07:17:18 $
MESSAGE_DOM_DOMEXCEPTION

$fatpacked{"Message/DOM/DOMImplementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_DOMIMPLEMENTATION';
  package Message::DOM::DOMImplementation;
  use strict;
  use warnings;
  our $VERSION = '1.14';
  push our @ISA, 'Message::IF::DOMImplementation',
      'Message::IF::AtomDOMImplementation',
      'Message::IF::URIImplementation',
      'Message::IF::IMTImplementation';
  
  sub ____new ($) {
    my $self = bless {}, shift;
    return $self;
  } # ____new
  *new = \&____new;
  
  my $MethodToModule = {
    create_atom_entry_document => 'Message::DOM::Atom::AtomElement',
    create_atom_feed_document => 'Message::DOM::Atom::AtomElement',
    create_document => 'Message::DOM::Document',
    create_document_type => 'Message::DOM::DocumentType',
    create_uri_reference => 'Message::URI::URIReference',
    create_internet_media_type => 'Message::IMT::InternetMediaType',
  };
  
  sub AUTOLOAD {
    my $method_name = our $AUTOLOAD;
    $method_name =~ s/.*:://;
    return if $method_name eq 'DESTROY';
  
    my $module_name = $MethodToModule->{$method_name};
    if ($module_name) {
      eval qq{ require $module_name } or die $@;
      no strict 'refs';
      goto &{ $AUTOLOAD };
    } else {
      require Carp;
      Carp::croak (qq<Can't locate method "$AUTOLOAD">);
    }
  } # AUTOLOAD
  
  our $HasFeature;
  $HasFeature->{core}->{''} = 1;
  $HasFeature->{core}->{'1.0'} = 1;
  $HasFeature->{core}->{'2.0'} = 1;
  $HasFeature->{core}->{'3.0'} = 1;
  $HasFeature->{events}->{''} = 1;
  $HasFeature->{events}->{'3.0'} = 1; ## TODO: 2.0?
  $HasFeature->{html}->{''} = 1;
  $HasFeature->{html}->{'5.0'} = 1; ## TODO: 1.0, 2.0
  $HasFeature->{xhtml}->{''} = 1;
  $HasFeature->{xhtml}->{'5.0'} = 1; ## TODO: 2.0
  $HasFeature->{traversal}->{''} = 1;
  $HasFeature->{traversal}->{'2.0'} = 1;
  $HasFeature->{xml}->{''} = 1;
  $HasFeature->{xml}->{'1.0'} = 1;
  $HasFeature->{xml}->{'2.0'} = 1;
  $HasFeature->{xml}->{'3.0'} = 1;
  $HasFeature->{xmlversion}->{''} = 1;
  $HasFeature->{xmlversion}->{'1.0'} = 1;
  $HasFeature->{xmlversion}->{'1.1'} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/atom>}->{''} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/atom>}->{'1.0'} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/atomthreading>}->{''} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/atomthreading>}->{'1.0'} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/min>}->{''} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/min>}->{'3.0'} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/uri>}->{''} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/uri>}->{'4.0'} = 1;
  $HasFeature->{q<http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#minimum>}->{''} = 1;
  $HasFeature->{q<http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#minimum>}->{'3.0'} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/xdoctype>}->{''} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/xdoctype>}->{'3.0'} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/xdoctypedeclaration>}->{''} = 1;
  $HasFeature->{q<http://suika.fam.cx/www/2006/feature/xdoctypedeclaration>}->{'3.0'} = 1;
  
  sub ___report_error { $_[1]->throw }
  
  ## |DOMImplementation| methods
  
  sub create_document ($;$$$);
  
  sub create_document_type ($$$$);
  
  sub get_feature ($$;$) {
    my $feature = lc $_[1]; ## TODO: What |lc|?
    $feature =~ s/^\+//;
    
    if ($HasFeature->{$feature}->{defined $_[2] ? $_[2] : ''}) {
      return $_[0];
    } else {
      return undef;
    }
  } # get_feature
  
  sub has_feature ($$;$) {
    my $feature = lc $_[1];
    my $plus = $feature =~ s/^\+// ? 1 : 0;
    return $HasFeature->{$feature}->{defined $_[2] ? $_[2] : ''};
  } # has_feature
  
  ## |AtomDOMImplementation| methods
  
  sub create_atom_entry_document ($$;$$);
  
  sub create_atom_feed_document ($$;$$);
  
  ## |URIImplementation| method
  
  sub create_uri_reference ($$);
  
  ## |InternetMediaType| method
  
  sub create_internet_media_type ($$$);
  
  package Message::IF::DOMImplementation;
  package Message::IF::AtomDOMImplementation;
  package Message::IF::URIImplementation;
  package Message::IF::IMTImplementation;
  
  =head1 LICENSE
  
  Copyright 2007-2010 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
MESSAGE_DOM_DOMIMPLEMENTATION

$fatpacked{"Message/DOM/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_DOCUMENT';
  package Message::DOM::Document;
  use strict;
  use warnings;
  our $VERSION = '1.32';
  push our @ISA, 'Message::DOM::Node', 'Message::IF::Document',
      'Message::IF::DocumentTraversal', 'Message::IF::DocumentXDoctype',
      'Message::IF::DocumentSelector', # MUST in Selectors API spec
      'Message::IF::HTMLDocument';
  require Message::DOM::Node;
  use Char::Class::XML
      qw/
        InXML_NameStartChar10 InXMLNameStartChar11
        InXMLNameChar10 InXMLNameChar11
        InXML_NCNameStartChar10 InXMLNCNameStartChar11
        InXMLNCNameChar10 InXMLNCNameChar11
      /;
  
  sub ____new ($$) {
    my $self = shift->SUPER::____new (undef);
    $$self->{implementation} = $_[0];
    $$self->{strict_error_checking} = 1;
    $$self->{child_nodes} = [];
    $$self->{'http://suika.fam.cx/www/2006/dom-config/strict-document-children'} = 1;
    $$self->{'http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute'} = 1;
    $$self->{'http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree'} = 1;
    $$self->{'error-handler'} = sub ($) {
      ## NOTE: Same as one set by |setParameter| with |undef| value.
      warn $_[0];
      return $_[0]->severity != 3; # SEVERITY_FATAL_ERROR
    };
    return $self;
  } # ____new
               
  sub AUTOLOAD {
    my $method_name = our $AUTOLOAD;
    $method_name =~ s/.*:://;
    return if $method_name eq 'DESTROY';
  
    if ({
      ## Read-only attributes (trivial accessors)
      default_view => 1,
      implementation => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$) {
          return \${\$_[0]}->{$method_name}; 
        }
      };
      goto &{ $AUTOLOAD };
    } elsif ({
      ## Read-write attributes (DOMString, trivial accessors)
      manakai_charset => 1,
      document_uri => 1,
      input_encoding => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$;\$) {
          if (\@_ > 1) {
            if (\${\$_[0]}->{strict_error_checking} and
                \${\$_[0]}->{manakai_read_only}) {
              report Message::DOM::DOMException
                  -object => \$_[0],
                  -type => 'NO_MODIFICATION_ALLOWED_ERR',
                  -subtype => 'READ_ONLY_NODE_ERR';
            }
            if (defined \$_[1]) {
              \${\$_[0]}->{$method_name} = ''.\$_[1];
            } else {
              delete \${\$_[0]}->{$method_name};
            }
          }
          return \${\$_[0]}->{$method_name};
        }
      };
      goto &{ $AUTOLOAD };
    } elsif ({
      ## Read-write attributes (boolean, trivial accessors)
      all_declarations_processed => 1,
      manakai_has_bom => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$;\$) {
          if (\@_ > 1) {
            if (\${\$_[0]}->{manakai_strict_error_checking} and
                \${\$_[0]}->{manakai_read_only}) {
              report Message::DOM::DOMException
                  -object => \$_[0],
                  -type => 'NO_MODIFICATION_ALLOWED_ERR',
                  -subtype => 'READ_ONLY_NODE_ERR';
            }
            if (\$_[1]) {
              \${\$_[0]}->{$method_name} = 1;
            } else {
              delete \${\$_[0]}->{$method_name};
            }
          }
          return \${\$_[0]}->{$method_name};
        }
      };
      goto &{ $AUTOLOAD };
    } elsif (my $module_name = {
      can_dispatch => 'Message::DOM::EventTargetNode',
      create_attribute => 'Message::DOM::Attr',
      create_attribute_ns => 'Message::DOM::Attr',
      create_attribute_definition => 'Message::DOM::AttributeDefinition',
      create_cdata_section => 'Message::DOM::Text',
      create_comment => 'Message::DOM::CharacterData',
      create_document_fragment => 'Message::DOM::DocumentFragment',
      create_document_type_definition => 'Message::DOM::DocumentType',
      create_element => 'Message::DOM::Element',
      create_element_ns => 'Message::DOM::Element',
      create_element_type_definition => 'Message::DOM::ElementTypeDefinition',
      create_entity_reference => 'Message::DOM::EntityReference',
      create_event => 'Message::DOM::EventTargetNode',
      create_general_entity => 'Message::DOM::Entity',
      create_notation => 'Message::DOM::Notation',
      create_processing_instruction => 'Message::DOM::ProcessingInstruction',
      manakai_create_serial_walker => 'Message::DOM::SerialWalker',
      create_text_node => 'Message::DOM::Text',
      create_tree_walker => 'Message::DOM::TreeWalker',
      query_selector => 'Message::DOM::SelectorsAPI',
      query_selector_all => 'Message::DOM::SelectorsAPI',
      ___query_selector_all => 'Message::DOM::SelectorsAPI',
    }->{$method_name}) {
      eval qq{ require $module_name } or die $@;
      goto &{ $AUTOLOAD };
    } else {
      require Carp;
      Carp::croak (qq<Can't locate method "$AUTOLOAD">);
    }
  } # AUTOLOAD
  sub implementation ($);
  sub create_attribute ($$);
  sub create_attribute_ns ($$$);
  sub create_attribute_definition ($$);
  sub create_cdata_section ($$);
  sub create_comment ($$);
  sub create_document_fragment ($);
  sub create_document_type_definition ($$);
  sub create_element ($$);
  sub create_element_ns ($$$);
  sub create_element_type_definition ($$);
  sub create_entity_reference ($$);
  sub create_general_entity ($$);
  sub create_notation ($$);
  sub create_processing_instruction ($$$);
  sub create_text_node ($$);
  
  ## |Node| attributes
  
  sub base_uri ($) {
    my $v = ${$_[0]}->{manakai_entity_base_uri};
    if (defined $v) {
      return $v;
    } else {
      return ${$_[0]}->{document_uri};
    }
    ## TODO: HTML5 <base>
  } # base_uri
  
  sub node_name () { '#document' }
  
  sub node_type () { 9 } # DOCUMENT_NODE
  
  sub text_content ($;$) {
    my $self = shift;
    if ($$self->{'http://suika.fam.cx/www/2006/dom-config/strict-document-children'}) {
      return undef;
    } else {
      local $Error::Depth = $Error::Depth + 1;
      return $self->SUPER::text_content (@_);
    }
  } # text_content
  
  ## |Node| methods
  
  sub adopt_node ($$) {
    my ($self, $source) = @_;
    ## TODO: Should we apply |copy-asis| configuration parameter to this method?
  
    return undef unless UNIVERSAL::isa ($source, 'Message::DOM::Node');
  
    my $strict = $self->strict_error_checking;
    if ($strict and $$self->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    my $parent = $source->parent_node;
    if ($strict and defined $parent and $$parent->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    my $nt = $source->node_type;
    my $oe;
    if ($nt == 2) { # ATTRIBUTE_NODE
      $oe = $source->owner_element;
      if ($strict and defined $oe and $$oe->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
    } elsif ($nt == 9 or $nt == 6 or $nt == 12 or
             $nt == 81001 or $nt == 81002) {
      # DOCUMENT_NODE, ENTITY_NODE, NOTATION_NODE,
      # ELEMENT_TYPE_DEFINITION_NODE, ATTRIBUTE_DEFINITION_NODE
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NOT_SUPPORTED_ERR',
          -subtype => 'ADOPT_NODE_TYPE_NOT_SUPPORTED_ERR';
    }
  
    my @change_od;
    my @nodes = ($source);
    while (@nodes) {
      my $node = shift @nodes;
      my $nt = $node->node_type;
      if ($strict and $$node->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      push @change_od, $node;
      push @nodes, $node->child_nodes->to_list, @{$node->attributes or []};
    } # @nodes
  
    local $Error::Depth = $Error::Depth + 1;
  
    if (defined $parent) {
      $parent->remove_child ($source);
    } elsif (defined $oe) {
      $oe->remove_attribute_node ($source);
    }
  
    return $source if $self eq $change_od[0]->owner_document;
                           ## NOTE: The array must have more than zero
                           ##       nodes by definition.  In addition,
                           ##       it cannot contain document or document
                           ##       type nodes in current implementation.
  
    my @ud_node;
    for my $n (@change_od) {
      $$n->{owner_document} = $self;
      Scalar::Util::weaken ($$n->{owner_document});
      if ($$n->{user_data}) {
        push @ud_node, $n;
      }
    }
  
    for my $src (@ud_node) {
      my $src_ud = $$src->{user_data};
      for my $key (keys %{$src_ud}) {
        my $dh = $src_ud->{$key}->[1];
        if ($dh) {
          $dh->(5, $key, $src_ud->{$key}->[0], $src, undef); # NODE_ADOPTED
        }
      }
    }
  
    return $source;
  } # adopt_node
  
  sub append_child ($$) {
    ## NOTE: Overrides |Node|'s implementation.
    my $self = $_[0];
    
    ## NOTE: |$self_od| code here in some $self->node_type.
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, $_[1]->child_nodes->to_list;
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self ne $child_od and $child_od->node_type != 10) {
        report Message::DOM::DOMException # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: Only in |Document|:
      my $strict_children = $self->dom_config->get_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/strict-document-children>);
      if ($strict_children) {
        my $has_el;
        my $has_dt;
        my $child_nt = $_[1]->node_type;
        if ($child_nt == 1) { # ELEMENT_NODE
          $has_el = 1;
        } elsif ($child_nt == 10) { # DOCUMENT_TYPE_NODE
          $has_dt = 1;
        } elsif ($child_nt == 11) { # DOCUMENT_FRAGMENT_NODE
          for my $cn ($_[1]->child_nodes->to_list) {
            my $cnt = $cn->node_type;
            if ($cnt == 1) { # ELEMENT_NODE
              if ($has_el) {
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'HIERARCHY_REQUEST_ERR',
                    -subtype => 'CHILD_NODE_TYPE_ERR';
              }
              $has_el = 1;
            } elsif ($cnt == 10) { # DOCUMENT_TYPE_NODE
              ## NOTE: |DocumentType| node cannot be contained in
              ## |DocumentFragment| in strict mode.
              if ($has_dt) {
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'HIERARCHY_REQUEST_ERR',
                    -subtype => 'CHILD_NODE_TYPE_ERR';
              }
              $has_dt = 1;
            }
          }
        }
    
        if ($has_el) {
          my $anode = $self->last_child;
          while (defined $anode) {
            if ($anode->node_type == 1) { # ELEMENT_NODE
              report Message::DOM::DOMException
                  -object => $self,
                  -type => 'HIERARCHY_REQUEST_ERR',
                  -subtype => 'CHILD_NODE_TYPE_ERR';
            }
            $anode = $anode->previous_sibling;
          }
        } # has_el
        if ($has_dt) {
          my $anode = $self->last_child;
          while (defined $anode) {
            my $ant = $anode->node_type;
            if ($ant == 1 or $ant == 10) { # ELEMENT_NODE or DOCUMENT_TYPE_NODE
              report Message::DOM::DOMException
                  -object => $self,
                  -type => 'HIERARCHY_REQUEST_ERR',
                  -subtype => 'CHILD_NODE_TYPE_ERR';
            }
            $anode = $anode->previous_sibling;
          }
        } # has_dt
      }
  
      for my $cn (@new_child) {
        unless ({
                 3, (not $strict_children), # TEXT_NODE
                 5, (not $strict_children), # ENTITY_REFERENCE_NODE
                 1, 1, # ELEMENT_NODE
                 4, (not $strict_children), # CDATA_SECTION_NODE
                 7, 1, # PROCESSING_INSTRUCTION_NODE
                 8, 1, # COMMENT_NODE
                 10, 1, # DOCUMENT_TYPE_NODE
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      ## NOTE: Ancestor check here in |Node|.
    }
  
    ## NOTE: "Insert at" code only in insert_before and replace_child
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    push @{$$self->{child_nodes}}, @new_child;
  
    ## NOTE: Only in |Document|.
    for (@new_child) {
      delete $$_->{implementation};
      $$_->{owner_document} = $self;
      Scalar::Util::weaken ($$_->{owner_document});
    }
  
    return $_[1];
  } # apepnd_child
  
  sub manakai_append_text ($$) {
    my $self = shift;
    if ($$self->{'http://suika.fam.cx/www/2006/dom-config/strict-document-children'}) {
      #
    } else {
      local $Error::Depth = $Error::Depth + 1;
      return $self->SUPER::manakai_append_text (@_);
    }
  } # manakai_append_text
  
  sub insert_before ($$) {
    ## NOTE: Overrides |Node|'s implementation.
    my $self = $_[0];
  
    ## NOTE: |$self_od| code here depending on $self->node_type.
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, $_[1]->child_nodes->to_list;
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self ne $child_od and $child_od->node_type != 10) {
        report Message::DOM::DOMException # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: Only in |Document|:
      my $strict_children = $self->dom_config->get_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/strict-document-children>);
      if ($strict_children) {
        my $has_el;
        my $has_dt;
        my $child_nt = $_[1]->node_type;
        if ($child_nt == 1) { # ELEMENT_NODE
          $has_el = 1;
        } elsif ($child_nt == 10) { # DOCUMENT_TYPE_NODE
          $has_dt = 1;
        } elsif ($child_nt == 11) { # DOCUMENT_FRAGMENT_NODE
          for my $cn ($_[1]->child_nodes->to_list) {
            my $cnt = $cn->node_type;
            if ($cnt == 1) { # ELEMENT_NODE
              if ($has_el) {
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'HIERARCHY_REQUEST_ERR',
                    -subtype => 'CHILD_NODE_TYPE_ERR';
              }
              $has_el = 1;
            } elsif ($cnt == 10) { # DOCUMENT_TYPE_NODE
              ## NOTE: |DocumentType| node cannot be contained in
              ## |DocumentFragment| in strict mode.
              if ($has_dt) {
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'HIERARCHY_REQUEST_ERR',
                    -subtype => 'CHILD_NODE_TYPE_ERR';
              }
              $has_dt = 1;
            }
          }
        }
  
        ## ISSUE: This code is wrong.  Old manakai's implementation
        ## is better, but it is also wrong in some edge cases.
        ## Maybe we should remove these code entirely.  DOM3Core
        ## conformance is not important for this bit.  It only makes
        ## things too complex.  Same for replace_child's code.
        if ($has_el) {
          my $anode = $self->last_child;
          while (defined $anode) {
            if ($anode->node_type == 1) { # ELEMENT_NODE
              report Message::DOM::DOMException
                  -object => $self,
                  -type => 'HIERARCHY_REQUEST_ERR',
                  -subtype => 'CHILD_NODE_TYPE_ERR';
            }
            $anode = $anode->previous_sibling;
          }
        } # has_el
        if ($has_dt) {
          my $anode = $self->last_child;
          while (defined $anode) {
            my $ant = $anode->node_type;
            if ($ant == 1 or $ant == 10) { # ELEMENT_NODE or DOCUMENT_TYPE_NODE
              report Message::DOM::DOMException
                  -object => $self,
                  -type => 'HIERARCHY_REQUEST_ERR',
                  -subtype => 'CHILD_NODE_TYPE_ERR';
            }
            $anode = $anode->previous_sibling;
          }
        } # has_dt
      }
  
      for my $cn (@new_child) {
        unless ({
                 3, (not $strict_children), # TEXT_NODE
                 5, (not $strict_children), # ENTITY_REFERENCE_NODE
                 1, 1, # ELEMENT_NODE
                 4, (not $strict_children), # CDATA_SECTION_NODE
                 7, 1, # PROCESSING_INSTRUCTION_NODE
                 8, 1, # COMMENT_NODE
                 10, 1, # DOCUMENT_TYPE_NODE
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      ## NOTE: Ancestor check here in |Node|.
    }
    
    ## -- Insert at... ## NOTE: Only in insert_before and replace_child
    my $index = -1; # last
    if (defined $_[2]) {
      ## error if $_[1] eq $_[2];
      
      my @cns = $self->child_nodes->to_list;
      C: {
        $index = 0;
        for my $i (0..$#cns) {
          my $cn = $cns[$i];
          if ($cn eq $_[2]) {
            $index += $i;
            last C;
          } elsif ($cn eq $_[1]) {
            $index = -1; # offset
          }
        }
        
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_FOUND_ERR',
            -subtype => 'NOT_CHILD_ERR';
      } # C
    }
    ## NOTE: "else" only in replace_child
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    if ($index == -1) {
      push @{$$self->{child_nodes}}, @new_child;
    } else {
      splice @{$$self->{child_nodes}}, $index, 0, @new_child;
    }
  
    ## NOTE: Only in |Document|.
    for (@new_child) {
      delete $$_->{implementation};
      $$_->{owner_document} = $self;
      Scalar::Util::weaken ($$_->{owner_document});
    }
  
    return $_[1];
  } # insert_before
  
  sub replace_child ($$) {
    ## NOTE: Overrides |Node|'s implementation.
    my $self = $_[0];
  
    ## NOTE: |$self_od| code here depending on $self->node_type.
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, $_[1]->child_nodes->to_list;
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self ne $child_od and $child_od->node_type != 10) {
        report Message::DOM::DOMException # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: Only in |Document|:
      my $strict_children = $self->dom_config->get_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/strict-document-children>);
      if ($strict_children) {
        my $has_el;
        my $has_dt;
        my $child_nt = $_[1]->node_type;
        if ($child_nt == 1) { # ELEMENT_NODE
          $has_el = 1;
        } elsif ($child_nt == 10) { # DOCUMENT_TYPE_NODE
          $has_dt = 1;
        } elsif ($child_nt == 11) { # DOCUMENT_FRAGMENT_NODE
          for my $cn ($_[1]->child_nodes->to_list) {
            my $cnt = $cn->node_type;
            if ($cnt == 1) { # ELEMENT_NODE
              if ($has_el) {
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'HIERARCHY_REQUEST_ERR',
                    -subtype => 'CHILD_NODE_TYPE_ERR';
              }
              $has_el = 1;
            } elsif ($cnt == 10) { # DOCUMENT_TYPE_NODE
              ## NOTE: |DocumentType| node cannot be contained in
              ## |DocumentFragment| in strict mode.
              if ($has_dt) {
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'HIERARCHY_REQUEST_ERR',
                    -subtype => 'CHILD_NODE_TYPE_ERR';
              }
              $has_dt = 1;
            }
          }
        }
    
        if ($has_el) {
          my $anode = $self->last_child;
          while (defined $anode) {
            if ($anode->node_type == 1) { # ELEMENT_NODE
              report Message::DOM::DOMException
                  -object => $self,
                  -type => 'HIERARCHY_REQUEST_ERR',
                  -subtype => 'CHILD_NODE_TYPE_ERR';
            }
            $anode = $anode->previous_sibling;
          }
        } # has_el
        if ($has_dt) {
          my $anode = $self->last_child;
          while (defined $anode) {
            my $ant = $anode->node_type;
            if ($ant == 1 or $ant == 10) { # ELEMENT_NODE or DOCUMENT_TYPE_NODE
              report Message::DOM::DOMException
                  -object => $self,
                  -type => 'HIERARCHY_REQUEST_ERR',
                  -subtype => 'CHILD_NODE_TYPE_ERR';
            }
            $anode = $anode->previous_sibling;
          }
        } # has_dt
      }
  
      for my $cn (@new_child) {
        unless ({
                 3, (not $strict_children), # TEXT_NODE
                 5, (not $strict_children), # ENTITY_REFERENCE_NODE
                 1, 1, # ELEMENT_NODE
                 4, (not $strict_children), # CDATA_SECTION_NODE
                 7, 1, # PROCESSING_INSTRUCTION_NODE
                 8, 1, # COMMENT_NODE
                 10, 1, # DOCUMENT_TYPE_NODE
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      ## NOTE: Ancestor check here in |Node|.
    }
    
    ## -- Insert at... ## NOTE: Only in insertBefore and replaceChild
    my $index = -1; # last
    if (defined $_[2]) {
      ## error if $_[1] eq $_[2];
      
      my @cns = $self->child_nodes->to_list;
      C: {
        $index = 0;
        for my $i (0..$#cns) {
          my $cn = $cns[$i];
          if ($cn eq $_[2]) {
            $index += $i;
            last C;
          } elsif ($cn eq $_[1]) {
            $index = -1; # offset
          }
        }
        
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_FOUND_ERR',
            -subtype => 'NOT_CHILD_ERR';
      } # C
    } else {
      ## NOTE: Only in replaceChild
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    }
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    splice @{$$self->{child_nodes}}, $index, 1, @new_child;
    delete ${$_[2]}->{parent_node};
  
    ## NOTE: Only in |Document|.
    for (@new_child) {
      delete $$_->{implementation};
      $$_->{owner_document} = $self;
      Scalar::Util::weaken ($$_->{owner_document});
    }
  
    return $_[2];
  } # replace_child
  
  ## |Document| attributes
  
  ## NOTE: A manakai extension.
  sub all_declarations_processed ($;$);
  
  ## TODO: documentation
  sub manakai_charset ($;$);
  
  sub doctype ($) {
    my $self = $_[0];
    for ($self->child_nodes->to_list) {
      if ($_->node_type == 10) { # DOCUMENT_TYPE_NODE
        return $_;
      }
    }
    return undef;
  } # doctype
  
  sub document_element ($) {
    my $self = shift;
    for ($self->child_nodes->to_list) {
      if ($_->node_type == 1) { # ELEMENT_NODE
        return $_;
      }
    }
    return undef;
  } # document_element
  
  sub document_uri ($;$);
  
  sub dom_config ($) {
    require Message::DOM::DOMConfiguration;
    return bless \\($_[0]), 'Message::DOM::DOMConfiguration';
  } # dom_config
  
  sub manakai_entity_base_uri ($;$) {
    my $self = $_[0];
    if (@_ > 1) {
      if ($$self->{strict_error_checking}) {
        if ($$self->{manakai_read_only}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NO_MODIFICATION_ALLOWED_ERR',
              -subtype => 'READ_ONLY_NODE_ERR';
        }
      }
      if (defined $_[1]) {
        $$self->{manakai_entity_base_uri} = ''.$_[1];
      } else {
        delete $$self->{manakai_entity_base_uri};
      }
    }
    
    if (defined $$self->{manakai_entity_base_uri}) {
      return $$self->{manakai_entity_base_uri};
    } else {
      return $$self->{document_uri};
    }
  } # manakai_entity_base_uri
  
  ## TODO: documentation
  sub manakai_has_bom ($;$);
  
  sub input_encoding ($;$);
  
  sub strict_error_checking ($;$) {
    ## NOTE: Same as trivial boolean accessor, except no read-only checking.
    if (@_ > 1) {
      if ($_[1]) {
        ${$_[0]}->{strict_error_checking} = 1;
      } else {
        delete ${$_[0]}->{strict_error_checking};
      }
    }                   
    return ${$_[0]}->{strict_error_checking};
  } # strict_error_checking
  
  ## ISSUE: Setting manakai_is_html true shadows 
  ## xml_* properties.  Is this desired?
  
  sub xml_encoding ($;$) {
    my $self = $_[0];
    if (@_ > 1) {
      ## NOTE: A manakai extension.
      if ($$self->{strict_error_checking}) {
        if ($$self->{manakai_is_html}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NOT_SUPPORTED_ERR',
              -subtype => 'NON_HTML_OPERATION_ERR';
        }
        if ($$self->{manakai_read_only}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NO_MODIFICATION_ALLOWED_ERR',
              -subtype => 'READ_ONLY_NODE_ERR';
        }
      }
      if (defined $_[1]) {
        $$self->{xml_encoding} = ''.$_[1];
      } else {
        delete $$self->{xml_encoding};
      }
    }
    
    if ($$self->{manakai_is_html}) {
      return undef;
    } else {
      return $$self->{xml_encoding};
    }
  } # xml_encoding
  
  sub xml_standalone ($;$) {
    my $self = $_[0];
    if (@_ > 1) {
      if ($$self->{strict_error_checking}) {
        if ($$self->{manakai_is_html}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NOT_SUPPORTED_ERR',
              -subtype => 'NON_HTML_OPERATION_ERR';
        }
        ## NOTE: Not in DOM3.
        if ($$self->{manakai_read_only}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NO_MODIFICATION_ALLOWED_ERR',
              -subtype => 'READ_ONLY_NODE_ERR';
        }
      }
      if ($_[1]) {
        $$self->{xml_standalone} = 1;
      } else {
        delete $$self->{xml_standalone};
      }
    }
    
    if ($$self->{manakai_is_html}) {
      return 0;
    } else {
      return $$self->{xml_standalone};
    }
  } # xml_standalone
  
  sub xml_version ($;$) {
    my $self = $_[0];
    if (@_ > 1) {
      my $v = ''.$_[1];
      if ($$self->{strict_error_checking}) {
        if ($$self->{manakai_is_html}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NOT_SUPPORTED_ERR',
              -subtype => 'NON_HTML_OPERATION_ERR';
        }
        if ($v ne '1.0' and $v ne '1.1') {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NOT_SUPPORTED_ERR',
              -subtype => 'UNKNOWN_XML_VERSION_ERR';
        }
        if ($$self->{manakai_read_only}) {
          ## ISSUE: Not in DOM3.
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NO_MODIFICATION_ALLOWED_ERR',
              -subtype => 'READ_ONLY_NODE_ERR';
        }
      }
      $$self->{xml_version} = $v;
    }
    
    if (defined wantarray) {
      if ($$self->{manakai_is_html}) {
        return undef;
      } elsif (defined $$self->{xml_version}) {
        return $$self->{xml_version};
      } else {
        return '1.0';
      }
    }
  } # xml_version
  
  ## |Document| methods
  
  sub get_element_by_id ($$) {
    local $Error::Depth = $Error::Depth + 1;
    my @nodes = $_[0]->child_nodes->to_list;
    N: while (@nodes) {
      my $node = shift @nodes;
      next N unless $node->node_type == 1; # ELEMENT_NODE
      for my $attr (@{$node->attributes}) {
        if ($attr->is_id and $attr->value eq $_[1]) {
          return $node;
        }
      }
      unshift @nodes, $node->child_nodes->to_list;
    } # N
    return undef;
  } # get_element_by_id
  
  ## TODO: HTML5 case normalization
  sub get_elements_by_tag_name ($$) {
    my $name = ''.$_[1];
    my $chk;
    if ($name eq '*') {
      $chk = sub () { 1 };
    } else {
      $chk = sub ($) {
        return $_[0]->manakai_tag_name eq $name;
      };
    }
  
    require Message::DOM::NodeList;
    return bless \[$_[0], $chk], 'Message::DOM::NodeList::GetElementsList';
  } # get_elements_by_tag_name
  
  sub get_elements_by_tag_name_ns ($$$) {
    my $nsuri = defined $_[1] ? ''.$_[1] : '';
    my $lname = ''.$_[2];
    my $chk;
    if ($nsuri eq '*') {
      if ($lname eq '*') {
        $chk = sub () { 1 };
      } else {
        $chk = sub ($) {
          return $_[0]->manakai_local_name eq $lname;
        };
      }
    } elsif ($nsuri eq '') {
      if ($lname eq '*') {
        $chk = sub ($) {
          return not defined $_[0]->namespace_uri;
        };
      } else {
        $chk = sub ($) {
          return (not defined $_[0]->namespace_uri and
                  $_[0]->manakai_local_name eq $lname);
        };
      }
    } else {
      if ($lname eq '*') {
        $chk = sub ($) {
          my $ns = $_[0]->namespace_uri;
          return (defined $ns and $ns eq $nsuri);
        };
      } else {
        $chk = sub ($) {
          my $ns = $_[0]->namespace_uri;
          return (defined $ns and $ns eq $nsuri and
                  $_[0]->manakai_local_name eq $lname);
        };
      }
    }
  
    require Message::DOM::NodeList;
    return bless \[$_[0], $chk], 'Message::DOM::NodeList::GetElementsList';
  } # get_elements_by_tag_name
  
  ## TODO: import_node
  
  ## TODO: normalize_document
  
  ## TODO: rename_node
  
  ## |DocumentTraversal| methods
  
  ## TODO: create_node_iterator
  
  sub manakai_create_serial_walker ($$;$$$);
  
  sub create_tree_walker ($$;$$$);
  
  ## |DocumentView| attribute
  
  sub default_view ($);
  
  ## |HTMLDocument| attributes
  
  sub compat_mode ($) {
    if (${$_[0]}->{manakai_is_html}) {
      if (defined ${$_[0]}->{manakai_compat_mode} and
          ${$_[0]}->{manakai_compat_mode} eq 'quirks') {
        return 'BackCompat';
      }
    }
    return 'CSS1Compat';
  } # compat_mode
  
  sub manakai_compat_mode ($;$) {
    if (${$_[0]}->{manakai_is_html}) {
      if (@_ > 1 and defined $_[1] and
          {'no quirks' => 1, 'limited quirks' => 1, 'quirks' => 1}->{$_[1]}) {
        ${$_[0]}->{manakai_compat_mode} = $_[1];
      }
      return ${$_[0]}->{manakai_compat_mode} || 'no quirks';
    } else {
      return 'no quirks';
    }
  } # manakai_compat_mode
  
  ## TODO: documentation
  sub manakai_head ($) {
    local $Error::Depth = $Error::Depth + 1;
    my $html = $_[0]->manakai_html;
    return undef unless defined $html;
    for my $el ($html->child_nodes->to_list) {
      next unless $el->node_type == 1; # ELEMENT_NODE
      my $nsuri = $el->namespace_uri;
      next unless defined $nsuri;
      next unless $nsuri eq q<http://www.w3.org/1999/xhtml>;
      next unless $el->manakai_local_name eq 'head';
      return $el;
    }
    return undef;
  } # manakai_head
  
  ## XXX test
  sub body ($) {
    local $Error::Depth = $Error::Depth + 1;
    my $html = $_[0]->manakai_html;
    return undef unless defined $html;
    for my $el ($html->child_nodes->to_list) {
      next unless $el->node_type == 1; # ELEMENT_NODE
      my $nsuri = $el->namespace_uri;
      next unless defined $nsuri;
      next unless $nsuri eq q<http://www.w3.org/1999/xhtml>;
      next unless $el->manakai_local_name eq 'body';
      return $el;
    }
    return undef;
  } # body
  
  ## TODO: documentation
  sub manakai_html ($) {
    local $Error::Depth = $Error::Depth + 1;
    my $de = $_[0]->document_element;
    my $nsuri = $de->namespace_uri;
    if (defined $nsuri and $nsuri eq q<http://www.w3.org/1999/xhtml> and
        $de->manakai_local_name eq 'html') {
      return $de;
    } else {
      return undef;
    }
  } # manakai_html
  
  sub inner_html ($;$) {
    my $self = $_[0];
    local $Error::Depth = $Error::Depth + 1;
  
    if ($$self->{manakai_is_html}) {
      require Whatpm::HTML;
      if (@_ > 1) {
        ## Step 1
        ## TODO: Stop parsing and ...
        
        ## Step 2
        for ($self->child_nodes->to_list) {
          ## NOTE: Might throw a |NO_MODIFICATION_ALLOWED_ERR|.
          $self->remove_child ($_); #
        }
  
        ## Step 3, 4, 5
        Whatpm::HTML->parse_string ($_[1] => $self);
  
        ## TODO:
        ## <script>var input = function_to_do_xmlhttprequest (location.href);
        ## document.innerHTML = input</script>
  
        return unless defined wantarray;
      }
  
      require Whatpm::HTML::Serializer;
      return ${ Whatpm::HTML::Serializer->get_inner_html ($self) };
    } else {
      if (@_ > 1) {
        ## Step 1
        require Whatpm::XML::Parser; # MUST
        my $doc = $self->implementation->create_document;
        
        ## Step 2
        #
  
        ## Step 3
        $doc = Whatpm::XML::Parser->parse_char_string ($_[1] => $doc); # MUST
  
        ## Step 4
        #
  
        ## Step 5
        ## TODO: ill-formed -> SYNTAX_ERR # MUST
  
        ## Step 6 # MUST
        ## TODO: If read-only
        for ($self->child_nodes->to_list) {
          $self->remove_child ($_);
        }
        ## TODO: strict-document-children option?
  
        ## Step 7, 8, 9, 10
        for my $node (map { $_ } $doc->child_nodes->to_list) {
          $self->append_child ($self->adopt_node ($node));
        }
  
        return unless defined wantarray;
      }
  
      ## TODO: This serializer is currently not conformant to HTML5 spec.
      require Whatpm::XMLSerializer;
      my $r = '';
      for my $node ($self->child_nodes->to_list) {
        $r .= ${ Whatpm::XMLSerializer->get_outer_xml ($node, sub {
          ## TODO: INVALID_STATE_ERR
        }) };
      }
      return $r;
    }
  } # inner_html
  
  sub manakai_is_html ($;$) {
    if (@_ > 1) {
      if ($_[1]) {
        ${$_[0]}->{manakai_is_html} = 1;
      } else {
        delete ${$_[0]}->{manakai_is_html};
        delete ${$_[0]}->{manakai_compat_mode};
      }
    }
    return ${$_[0]}->{manakai_is_html};
  } # manakai_is_html
  
  sub manakai_is_srcdoc ($;$) {
    if (@_ > 1) {
      ${$_[0]}->{manakai_is_srcdoc} = !!$_[1];
    }
  
    return ${$_[0]}->{manakai_is_srcdoc};
  } # manakai_is_srcdoc
  
  sub ready_state ($) {
    return ${$_[0]}->{ready_state} || 'complete';
  } # ready_state
  
  sub _set_ready_state ($$) {
    if ($_[1] eq 'complete') {
      delete ${$_[0]}->{ready_state};
    } else {
      ${$_[0]}->{ready_state} = $_[1];
    }
    # XXX fire a simple event named |readystatechange|
  } # _set_ready_state
  
  ## ------ The |AtomDocument| interface ------
  
  sub atom_feed_element ($) {
    my $de = $_[0]->document_element or return undef;
    return undef unless $de->manakai_local_name eq 'feed';
    return undef unless ($de->namespace_uri || '') eq q<http://www.w3.org/2005/Atom>;
  
    # XXX Atom 0.3 support
  
    return $de;
  } # atom_feed_element
  
  package Message::IF::Document;
  package Message::IF::DocumentTraversal;
  package Message::IF::DocumentXDoctype;
  package Message::IF::DocumentSelector;
  package Message::IF::HTMLDocument;
  
  package Message::DOM::DOMImplementation;
  
  sub create_document ($;$$$) {
    my $r = Message::DOM::Document->____new ($_[0]);
  
    if (defined $_[2]) {
      local $Error::Depth = $Error::Depth + 1;
      $r->append_child ($r->create_element_ns ($_[1], $_[2])); # NAMESPACE_ERR
      ## NOTE: manakai might raise DOMExceptions in cases not defined
      ## in DOM3Core spec: XMLNSPREFIX_NONXMLNSNS_ERR,
      ## XMLNS_NONXMLNSNS_ERR, and NONXMLNSPREFIX_XMLNSNS_ERR.
    } elsif (defined $_[1]) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NAMESPACE_ERR',
          -subtype => 'QNAME_NULLNS_ERR';
    }
  
    if (defined $_[3]) {
      if ($_[3]->parent_node) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'INUSE_DOCTYPE_ERR';
      }
      local $Error::Depth = $Error::Depth + 1;
      $r->insert_before ($_[3], $r->first_child); # EXTERNAL_OBJECT_ERR
    }
  
    return $r;
  } # create_document
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
MESSAGE_DOM_DOCUMENT

$fatpacked{"Message/DOM/DocumentType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_DOCUMENTTYPE';
  package Message::DOM::DocumentType;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.17 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::DOM::Node', 'Message::IF::DocumentType',
      'Message::IF::DocumentTypeDefinition',
      'Message::IF::DocumentTypeDeclaration';
  require Message::DOM::Node;
  
  sub ____new ($$$$) {
    my $self = shift->SUPER::____new (shift);
    $$self->{implementation} = $_[0] if defined $_[0];
    $$self->{name} = $_[1];
    $$self->{child_nodes} = [];
    $$self->{public_id} = '';
    $$self->{system_id} = '';
    $$self->{internal_subset} = '';
    return $self;
  } # ____new
               
  sub AUTOLOAD {
    my $method_name = our $AUTOLOAD;
    $method_name =~ s/.*:://;
    return if $method_name eq 'DESTROY';
  
    if ({
      ## Read-only attributes (trivial accessors)
      name => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$) {
          return \${\$_[0]}->{$method_name}; 
        }
      };
      goto &{ $AUTOLOAD };
    } elsif ({
      ## Read-write attributes (DOMString, trivial accessors)
      internal_subset => 1,
      public_id => 1,
      system_id => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$;\$) {
          if (\@_ > 1) {
            if (\${\$_[0]}->{strict_error_checking} and
                \${\$_[0]}->{manakai_read_only}) {
              report Message::DOM::DOMException
                  -object => \$_[0],
                  -type => 'NO_MODIFICATION_ALLOWED_ERR',
                  -subtype => 'READ_ONLY_NODE_ERR';
            }
            if (defined \$_[1]) {
              \${\$_[0]}->{$method_name} = ''.\$_[1];
            } else {
              delete \${\$_[0]}->{$method_name};
            }
          }
          return \${\$_[0]}->{$method_name};
        }
      };
      goto &{ $AUTOLOAD };
    } else {
      require Carp;
      Carp::croak (qq<Can't locate method "$AUTOLOAD">);
    }
  } # AUTOLOAD
  sub name ($);
  
  ## |Node| attributes
  
  *base_uri = \&declaration_base_uri;
  
  ## NOTE: A manakai extension
  sub implementation ($) {
    my $self = shift;
    if (defined $$self->{implementation}) {
      return $$self->{implementation};
    } elsif (defined $$self->{owner_document}) {
      local $Error::Depth = $Error::Depth + 1;
      return $$self->{owner_document}->implementation;
    } else {
      die "DocumentType with no implementation, no owner_document";
    }
  } # implementation
  
  *node_name = \&name;
  
  sub node_type () { 10 } # DOCUMENT_TYPE_NODE
  
  sub text_content ($;$) { undef }
  
  ## |Node| methods
  
  sub append_child ($$) {
    my $self = $_[0];
    
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, @{$_[1]->child_nodes};
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if (not defined $self_od or $$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if (not defined $self_od or
          ($self_od ne $child_od and $child_od->node_type != 10)) {
        report Message::DOM::DOMException # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ($cn->node_type == 7) { # PROCESSING_INSTRUCTION_NODE
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
      
      ## NOTE: Ancestor check in |Node|.
    }
  
    ## NOTE: "Insert at" code only in insert_before and replace_child
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    push @{$$self->{child_nodes}}, @new_child;
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[1];
  } # apepnd_child
  
  sub manakai_append_text () { }
  
  sub insert_before ($$) {
    my $self = $_[0];
  
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, @{$_[1]->child_nodes};
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if (not defined $self_od or $$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if (not defined $self_od or
          ($self_od ne $child_od and $child_od->node_type != 10)) {
        report Message::DOM::DOMException # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ($cn->node_type == 7) { # PROCESSING_INSTRUCTION_NODE
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      ## NOTE: Ancestor check in |Node|.
    }
    
    ## -- Insert at... ## NOTE: Only in insert_before and replace_child
    my $index = -1; # last
    if (defined $_[2]) {
      ## error if $_[1] eq $_[2];
      
      my $cns = $self->child_nodes;
      my $cnsl = @$cns;
      C: {
        $index = 0;
        for my $i (0..($cnsl-1)) {
          my $cn = $cns->[$i];
          if ($cn eq $_[2]) {
            $index += $i;
            last C;
          } elsif ($cn eq $_[1]) {
            $index = -1; # offset
          }
        }
        
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_FOUND_ERR',
            -subtype => 'NOT_CHILD_ERR';
      } # C
    }
    ## NOTE: "else" only in replace_child
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    if ($index == -1) {
      push @{$$self->{child_nodes}}, @new_child;
    } else {
      splice @{$$self->{child_nodes}}, $index, 0, @new_child;
    }
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[1];
  } # insert_before
  
  sub replace_child ($$) {
    ## NOTE: |Element|, |Entity|, |DocumentFragment|, |EntityReference|.
    ## NOTE: |Document|, |Attr|, |CharacterData|, |AttributeDefinition|,
    ## |Notation|, |ProcessingInstruction|, |ElementTypeDefinition|,
    ## and |DocumentType| define their own implementations.
    my $self = $_[0];
  
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == 11) { # DOCUMENT_FRAGMENT_NODE
      push @new_child, @{$_[1]->child_nodes};
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if (not defined $self_od or $$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if (not defined $self_od or
          ($self_od ne $child_od and $child_od->node_type != 10)) {
        report Message::DOM::DOMException  # DOCUMENT_TYPE_NODE
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ($cn->node_type == 7) { # PROCESSING_INSTRUCTION_NODE
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      ## NOTE: Ancestor check in |Node|.
    }
    
    ## -- Insert at... ## NOTE: Only in insertBefore and replaceChild
    my $index = -1; # last
    if (defined $_[2]) {
      ## error if $_[1] eq $_[2];
      
      my $cns = $self->child_nodes;
      my $cnsl = @$cns;
      C: {
        $index = 0;
        for my $i (0..($cnsl-1)) {
          my $cn = $cns->[$i];
          if ($cn eq $_[2]) {
            $index += $i;
            last C;
          } elsif ($cn eq $_[1]) {
            $index = -1; # offset
          }
        }
        
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_FOUND_ERR',
            -subtype => 'NOT_CHILD_ERR';
      } # C
    } else {
      ## NOTE: Only in replaceChild
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    }
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    splice @{$$self->{child_nodes}}, $index, 1, @new_child;
    delete ${$_[2]}->{parent_node};
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[2];
  } # replace_child
  
  ## |DocumentType| attributes
  
  ## NOTE: A manakai extension.
  sub declaration_base_uri ($;$) {
    if (${$_[0]}->{owner_document}) {
      local $Error::Depth = $Error::Depth + 1;
      return ${$_[0]}->{owner_document}->base_uri;
    }
    return undef;
  } # declaration_base_uri
  
  *manakai_declaration_base_uri = \&declaration_base_uri;
  
  sub entities ($) {
    require Message::DOM::NamedNodeMap;
    return bless \[$_[0], 'entities'], 'Message::DOM::NamedNodeMap';
  } # entities
  
  ## NOTE: Setter is a manakai extension.
  sub internal_subset ($;$);
  
  sub notations ($) {
    require Message::DOM::NamedNodeMap;
    return bless \[$_[0], 'notations'], 'Message::DOM::NamedNodeMap';
  } # notations
  
  ## NOTE: Setter is a manakai extension.
  sub public_id ($;$);
  
  ## NOTE: Setter is a manakai extension.
  sub system_id ($;$);
  
  ## |DocumentTypeDefinition| attributes
  
  sub element_types ($) {
    require Message::DOM::NamedNodeMap;
    return bless \[$_[0], 'element_types'], 'Message::DOM::NamedNodeMap';
  } # element_types
  
  *general_entities = \&entities;
  
  # *notations = \&notations;
  
  ## |DocumentTypeDefinition| methods
  
  sub get_element_type_definition_node ($$) {
    return ${$_[0]}->{element_types}->{$_[1]};
  } # get_element_type_definition_node
  
  sub get_general_entity_node ($$) {
    return ${$_[0]}->{entities}->{$_[1]};
  } # get_general_entity_node
  
  sub get_notation_node ($$) {
    return ${$_[0]}->{notations}->{$_[1]};
  } # get_notation_node
  
  sub set_element_type_definition_node ($$) {
    my $self = $_[0];
    my $node = $_[1];
  
    my $name = $node->node_name;
    my $list = $$self->{element_types} ||= {}; # ***
    my $r = $list->{$name};
  
    if (defined $r and $r eq $node) {
      return undef; # no effect
    }
  
    my $od = $$self->{owner_document};
    if ($$od->{strict_error_checking}) {
      if ($$self->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      if ($od ne $node->owner_document) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      my $owner = $$node->{owner_document_type_definition}; # ***
      if ($owner) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'HIERARCHY_REQUEST_ERR',
            -subtype => 'INUSE_DEFINITION_ERR';
      }
    }
  
    if (defined $r) {
      delete $$r->{owner_document_type_definition}; # ***
    }
  
    $list->{$name} = $node;
    $$node->{owner_document_type_definition} = $self; # ***
    Scalar::Util::weaken ($$node->{owner_document_type_definition}); # ***
  } # set_element_type_definition_node
  
  sub set_general_entity_node ($$) {
    my $self = $_[0];
    my $node = $_[1];
  
    my $name = $node->node_name;
    my $list = $$self->{entities} ||= {}; # ***
    my $r = $list->{$name};
  
    if (defined $r and $r eq $node) {
      return undef; # no effect
    }
  
    my $od = $$self->{owner_document};
    if ($$od->{strict_error_checking}) {
      if ($$self->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      if ($od ne $node->owner_document) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      my $owner = $$node->{owner_document_type_definition}; # ***
      if ($owner) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'HIERARCHY_REQUEST_ERR',
            -subtype => 'INUSE_DEFINITION_ERR';
      }
    }
  
    if (defined $r) {
      delete $$r->{owner_document_type_definition}; # ***
    }
  
    $list->{$name} = $node;
    $$node->{owner_document_type_definition} = $self; # ***
    Scalar::Util::weaken ($$node->{owner_document_type_definition}); # ***
  } # set_general_entity_node
  
  sub set_notation_node ($$) {
    my $self = $_[0];
    my $node = $_[1];
  
    my $name = $node->node_name;
    my $list = $$self->{notations} ||= {}; # ***
    my $r = $list->{$name};
  
    if (defined $r and $r eq $node) {
      return undef; # no effect
    }
  
    my $od = $$self->{owner_document};
    if ($$od->{strict_error_checking}) {
      if ($$self->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      if ($od ne $node->owner_document) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      my $owner = $$node->{owner_document_type_definition}; # ***
      if ($owner) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'HIERARCHY_REQUEST_ERR',
            -subtype => 'INUSE_DEFINITION_ERR';
      }
    }
  
    if (defined $r) {
      delete $$r->{owner_document_type_definition}; # ***
    }
  
    $list->{$name} = $node;
    $$node->{owner_document_type_definition} = $self; # ***
    Scalar::Util::weaken ($$node->{owner_document_type_definition}); # ***
  } # set_notation_node
  
  package Message::IF::DocumentType;
  package Message::IF::DocumentTypeDefinition;
  package Message::IF::DocumentTypeDeclaration;
  
  package Message::DOM::DOMImplementation;
  use Char::Class::XML
      qw/
        InXML_NameStartChar10
        InXMLNameChar10
        InXML_NCNameStartChar10
        InXMLNCNameChar10
      /;
  
  sub create_document_type ($$$$) {
    ## ISSUE: Old manakai has allowed publicId and systemId to be null.
    ## Should we continue to do so?
  
    if ($_[1] =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
      if ($_[1] =~ /\A\p{InXML_NCNameStartChar10}\p{InXMLNCNameChar10}*(?>:\p{InXML_NCNameStartChar10}\p{InXMLNCNameChar10}*)?\z/) {
        #
      } else {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NAMESPACE_ERR',
            -subtype => 'MALFORMED_QNAME_ERR';
      }
    } else {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'INVALID_CHARACTER_ERR',
          -subtype => 'MALFORMED_NAME_ERR';
    }
  
    local $Error::Depth = $Error::Depth + 1;
    my $r = Message::DOM::DocumentType->____new (undef, @_[0, 1]);
    $r->public_id ($_[2]);
    $r->system_id ($_[3]);
    $r->manakai_set_read_only (1, 1);
    return $r;
  } # create_document_type
  
  package Message::DOM::Document;
  
  sub create_document_type_definition ($$) {
    if (${$_[0]}->{strict_error_checking}) {
      my $xv = $_[0]->xml_version;
      if (defined $xv) {
        if ($xv eq '1.0' and
            $_[1] =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
          #
        } elsif ($xv eq '1.1' and
                 $_[1] =~ /\A\p{InXMLNameStartChar11}\p{InXMLNameChar11}*\z/) {
          #
        } else {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'INVALID_CHARACTER_ERR',
              -subtype => 'MALFORMED_NAME_ERR';
        }
      }
    }
  
    my $r = Message::DOM::DocumentType->____new ($_[0], undef, $_[1]);
    $$r->{manakai_has_predefined_entity_declaration} = 1;
    return $r;
  } # create_document_type_definition
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2007/12/22 06:29:32 $
MESSAGE_DOM_DOCUMENTTYPE

$fatpacked{"Message/DOM/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_ELEMENT';
  package Message::DOM::Element;
  use strict;
  use warnings;
  our $VERSION = '1.32';
  push our @ISA, 'Message::DOM::Node', 'Message::IF::Element',
      'Message::IF::ElementSelector', # MUST in Selectors API spec.
      'Message::IF::ElementCSSInlineStyle';
  require Message::DOM::Document;
  
  sub ____new ($$$$$) {
    my $self = shift->SUPER::____new (shift);
    ($$self->{namespace_uri},
     $$self->{prefix},
     $$self->{local_name}) = @_;
    $$self->{attributes} = {};
    $$self->{child_nodes} = [];
    return $self;
  } # ____new
               
  sub AUTOLOAD {
    my $method_name = our $AUTOLOAD;
    $method_name =~ s/.*:://;
    return if $method_name eq 'DESTROY';
  
    if ({
      ## Read-only attributes (trivial accessors)
      namespace_uri => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$) {
          return \${\$_[0]}->{$method_name}; 
        }
      };
      goto &{ $AUTOLOAD };
    } elsif ({
      ## Read-write attributes (DOMString, trivial accessors)
      manakai_base_uri => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$;\$) {
          if (\@_ > 1) {
            if (\${\${\$_[0]}->{owner_document}}->{strict_error_checking} and
                \${\$_[0]}->{manakai_read_only}) {
              report Message::DOM::DOMException
                  -object => \$_[0],
                  -type => 'NO_MODIFICATION_ALLOWED_ERR',
                  -subtype => 'READ_ONLY_NODE_ERR';
            }
            if (defined \$_[1]) {
              \${\$_[0]}->{$method_name} = ''.\$_[1];
            } else {
              delete \${\$_[0]}->{$method_name};
            }
          }
          return \${\$_[0]}->{$method_name};
        }
      };
      goto &{ $AUTOLOAD };
    } elsif (my $module_name = {
      query_selector => 'Message::DOM::SelectorsAPI',
      query_selector_all => 'Message::DOM::SelectorsAPI',
    }->{$method_name}) {
      eval qq{ require $module_name } or die $@;
      goto &{ $AUTOLOAD };
    } else {
      require Carp;
      Carp::croak (qq<Can't locate method "$AUTOLOAD">);
    }
  } # AUTOLOAD
  
  ## TODO: Test for create_element_ns ('', ...)
  
  ## |Node| attributes
  
  sub attributes ($) {
    require Message::DOM::NamedNodeMap;
    return bless \\($_[0]), 'Message::DOM::NamedNodeMap::AttrMap';
  } # attributes
  
  sub base_uri ($) {
    my $self = $_[0];
    return $$self->{manakai_base_uri} if defined $$self->{manakai_base_uri};
  
    local $Error::Depth = $Error::Depth + 1;
    my $xb = $self->get_attribute_node_ns
      ('http://www.w3.org/XML/1998/namespace', 'base');
    unless (defined $xb) {
      $xb = $self->get_attribute_node_ns (undef, 'xml:base');
    }
  
    if ($xb) {
      my $v = $self->owner_document->implementation->create_uri_reference
        ($xb->value);
      if (not defined $v->uri_scheme) { # Relative reference
        my $xbbase = $xb->base_uri;
        if (defined $xbbase) {
          return $v->get_absolute_reference ($xbbase)->uri_reference;
        }
      }
      return $v->uri_reference;
    }
  
    my $pe = $$self->{parent_node};
    while (defined $pe) {
      my $nt = $pe->node_type;
      if ($nt == 1 or $nt == 6 or $nt == 9 or $nt == 11) {
        ## Element, Entity, Document, or DocumentFragment
        return $pe->base_uri;
      } elsif ($nt == 5) {
        ## EntityReference
        if ($pe->manakai_external) {
          return $pe->manakai_entity_base_uri;
        }
      }
      $pe = $$pe->{parent_node};
    }
    return $pe->base_uri if $pe;
    return $$self->{owner_document}->base_uri;
  } # base_uri
  
  sub local_name ($) { # TODO: HTML5 case
    return ${$_[0]}->{local_name};
  } # local_name
  
  sub manakai_local_name ($) {
    return ${$_[0]}->{local_name};
  } # manakai_local_name
  
  sub namespace_uri ($);
  
  ## The tag name of the element [DOM1, DOM2].
  ## Same as |Element.tagName| [DOM3].
  
  *node_name = \&tag_name;
  
  sub node_type () { 1 } # ELEMENT_NODE
  
  sub prefix ($;$) {
    ## NOTE: No check for new value as Firefox doesn't do.
    ## See <http://suika.fam.cx/gate/2005/sw/prefix>.
  
    ## NOTE: Same as trivial setter except "" -> undef
  
    ## NOTE: Same as |Attr|'s |prefix|.
    
    if (@_ > 1) {
      if (${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
      if (defined $_[1] and $_[1] ne '') {
        ${$_[0]}->{prefix} = ''.$_[1];
      } else {
        delete ${$_[0]}->{prefix};
      }
    }
    return ${$_[0]}->{prefix}; 
  } # prefix
  
  ## |Element| attributes
  
  sub manakai_base_uri ($;$);
  
  ## Defined in |HTMLElement| interface of HTML5
  sub inner_html ($;$) {
    my $self = $_[0];
  
    if (@_ > 1) {
      require Whatpm::HTML;
      ## TODO: Setter ...
      Whatpm::HTML->set_inner_html ($self, $_[1]);
      return unless defined wantarray;
    }
    
    if (${$$self->{owner_document}}->{manakai_is_html}) {
      require Whatpm::HTML::Serializer;
      return ${ Whatpm::HTML::Serializer->get_inner_html ($self) };
    } else {
      ## TODO: This serializer is not currenly conformant to HTML5.
      require Whatpm::XMLSerializer;
      my $r = '';
      for (@{$self->child_nodes}) {
        $r .= ${ Whatpm::XMLSerializer->get_outer_xml ($_) };
      }
      return $r;
    }
  } # inner_html
  
  sub schema_type_info ($) {
    require Message::DOM::TypeInfo;
    my $v = 0;
    return bless \$v, 'Message::DOM::TypeInfo';
  ## NOTE: Currently manakai does not support XML Schema, so it is 
  ## always a no-type |TypeInfo|.  It is expected that
  ## a future version of the implementation will return an
  ## element type definition node that also implement the
  ## |TypeInfo| interface when the schema language is XML DTD.
  } # schema_type_info
  
  ## TODO: HTML5 capitalization
  sub tag_name ($) {
    my $self = shift;
    if (defined $$self->{prefix}) {
      return $$self->{prefix} . ':' . $$self->{local_name};
    } else {
      return $$self->{local_name};
    }
  } # tag_name
  
  ## TODO: Documentation
  sub manakai_tag_name ($) {
    my $self = shift;
    if (defined $$self->{prefix}) {
      return $$self->{prefix} . ':' . $$self->{local_name};
    } else {
      return $$self->{local_name};
    }
  } # manakai_tag_name
  
  ## The |Element| interface - methods
  
  sub manakai_element_type_match ($$$) {
    my ($self, $nsuri, $ln) = @_;
    if (defined $nsuri) {
      if (defined $$self->{namespace_uri} and $nsuri eq $$self->{namespace_uri}) {
        return ($ln eq $$self->{local_name});
      } else {
        return 0;
      }
    } else {
      if (not defined $$self->{namespace_uri}) {
        return ($ln eq $$self->{local_name});
      } else {
        return 0;
      }
    }
  } # manakai_element_type_match
  
  sub get_attribute ($$) {
    my $attr = ${$_[0]}->{attributes};
    my $name = ''.$_[1];
  
    ## NOTE: |sort|ing is required so that every |getAttribute|, |setAttribute|,
    ## |hasAttribute|, |removeAttribute|, or any other namespace unaware
    ## methods operates on the same node even if there is 
    ## multiple nodes with the same qualified name.
  
    ## NOTE: Same as |get_attribute_node|, except what is returned.
  
    for my $ns (sort {$a cmp $b} keys %$attr) {
      for my $ln (sort {$a cmp $b} keys %{$attr->{$ns}}) {
        my $node = $attr->{$ns}->{$ln};
        if ($node->manakai_name eq $name) {
          return $node->value;
        }
      }
    }
  
    return undef;
  } # get_attribute
  
  sub get_attribute_node ($$) {
    my $attr = ${$_[0]}->{attributes};
    my $name = ''.$_[1];
  
    ## NOTE: Same as |get_attribute|, except what is returned.
  
    for my $ns (sort {$a cmp $b} keys %$attr) {
      for my $ln (sort {$a cmp $b} keys %{$attr->{$ns}}) {
        my $node = $attr->{$ns}->{$ln};
        if ($node->manakai_name eq $name) {
          return $node;
        }
      }
    }
  
    return undef;
  } # get_attribute_node
  
  sub get_attribute_ns ($$$) {
    my $nsuri = defined $_[1] ? ''.$_[1] : '';
    my $ln = ''.$_[2];
    if (my $attr = ${$_[0]}->{attributes}->{$nsuri}->{$ln}) {
      return $attr->value;
    } else {
      return undef;
    }
  } # get_attribute_ns
  
  sub get_attribute_node_ns ($$$) {
    return ${$_[0]}->{attributes}->{defined $_[1] ? ''.$_[1] : ''}->{''.$_[2]};
  } # get_attribute_node_ns
  
  *get_elements_by_tag_name = \&Message::DOM::Document::get_elements_by_tag_name;
  
  *get_elements_by_tag_name_ns
      = \&Message::DOM::Document::get_elements_by_tag_name_ns;
  
  sub has_attribute ($$) {
    my $attr = ${$_[0]}->{attributes};
    my $name = ''.$_[1];
  
    for my $ns (keys %$attr) {
      for my $ln (keys %{$attr->{$ns}}) {
        my $node = $attr->{$ns}->{$ln};
        if ($node->manakai_name eq $name) {
          return 1;
        }
      }
    }
  
    return 0;
  } # has_attribute
  
  sub has_attribute_ns ($$$) {
    return ${$_[0]}->{attributes}->{defined $_[1] ? ''.$_[1] : ''}->{''.$_[2]}?1:0;
  } # has_attribute_ns
  
  sub remove_attribute ($$) {
    my $attr = ${$_[0]}->{attributes};
    my $name = ''.$_[1];
  
    my $list;
    my $key;
    my $attr_node;
    ATTR: {
      for my $ns (keys %$attr) {
        $list = $attr->{$ns};
        for my $ln (keys %$list) {
          $attr_node = $list->{$ln};
          if ($attr_node->manakai_name eq $name) {
            $key = $ln;
            last ATTR;
          }
        }
      }
      
      return undef; # not found
    } # ATTR
  
    my $od = ${$_[0]}->{owner_document};
    if ($$od->{strict_error_checking} and ${$_[0]}->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    delete $list->{$key};
    delete $$attr_node->{owner_element};
    $$attr_node->{specified} = 1;
    delete ${$_[0]}->{manakai_content_attribute_list};
  
    ## Default attribute
    local $Error::Depth = $Error::Depth + 1;
    my $cfg = $od->dom_config;
    if ($cfg->get_parameter 
        (q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute>)) {
      my $doctype = $od->doctype;
      if ($doctype) {
        my $et = $doctype->get_element_type_definition_node
            ($_[0]->manakai_tag_name);
        if ($et) {
          my $at = $et->get_attribute_definition_node ($name);
          if ($at) {
            local $$od->{strict_error_checking} = 0;
            my $copy_asis = $cfg->get_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree>);
            $cfg->set_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1);
            ADD: {
              my $def_attr_node;
              my $def_prefix = $attr_node->prefix;
              my $def_nsuri = '';
              my $def_ln;
              if (defined $def_prefix) {
                $def_nsuri =
                    $def_prefix eq 'xml' ? q<http://www.w3.org/XML/1998/namespace>:
                    $def_prefix eq 'xmlns' ? q<http://www.w3.org/2000/xmlns/>:
                    $_[0]->lookup_namespace_uri ($def_prefix);
                unless (defined $def_nsuri) {
                  ## TODO: Namespace well-formedness error...
                }
                $def_ln = $attr_node->manakai_local_name;
              } else {
                $def_nsuri = $name eq 'xmlns'
                    ? q<http://www.w3.org/2000/xmlns/> : undef;
                $def_ln = $name;
              }
              if ($attr->{defined $def_nsuri ? $def_nsuri : ''}->{$def_ln}) {
                ## TODO: Namespace well-formedness warning?
                last ADD;
              }
              $def_attr_node = $od->create_attribute_ns
                  ($def_nsuri, [$def_prefix, $def_ln]);
            
              for my $child (@{$at->child_nodes}) {
                $def_attr_node->append_child ($child->clone_node (1));
              }
              $def_attr_node->manakai_attribute_type ($at->declared_type);
              $attr->{defined $def_nsuri ? $def_nsuri : ''}->{$def_ln}
                  = $def_attr_node;
              $$def_attr_node->{owner_element} = $_[0];
              Scalar::Util::weaken ($$def_attr_node->{owner_element});
              delete $$def_attr_node->{specified};
            } # ADD
            $cfg->set_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => $copy_asis);
          }
        }
      }
    }
  
    return undef;
  } # remove_attribute
  
  sub remove_attribute_node ($$) {
    my $od = ${$_[0]}->{owner_document};
    if ($$od->{strict_error_checking} and ${$_[0]}->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    my $attr_node = $_[1];
    my $ln = $attr_node->manakai_local_name;
    my $attr = ${$_[0]}->{attributes};
    FIND: {
      my $nsuri = $attr_node->namespace_uri;
      my $list = $attr->{defined $nsuri ? $nsuri : ''};
      my $list_node = $list->{$ln};
      if (defined $list_node and $list_node eq $attr_node) {
        delete $list->{$ln};
        last FIND;
      }
  
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    } # FIND
  
    delete ${$_[0]}->{manakai_content_attribute_list};
    delete $$attr_node->{owner_element};
    $$attr_node->{specified} = 1;
        
    ## Default attribute
    ## Same as |remove_attribute|'s, except where marked as "***".
    local $Error::Depth = $Error::Depth + 1;
    my $cfg = $od->dom_config;
    if ($cfg->get_parameter 
        (q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute>)) {
      my $doctype = $od->doctype;
      if ($doctype) {
        my $et = $doctype->get_element_type_definition_node
            ($_[0]->manakai_tag_name);
        if ($et) {
          my $at = $et->get_attribute_definition_node ($_[1]->manakai_name); # ***
          if ($at) {
            local $$od->{strict_error_checking} = 0;
            my $copy_asis = $cfg->get_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree>);
            $cfg->set_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1);
            ADD: {
              my $def_attr_node;
              my $def_prefix = $attr_node->prefix;
              my $def_nsuri = '';
              my $def_ln;
              if (defined $def_prefix) {
                $def_nsuri =
                    $def_prefix eq 'xml' ? q<http://www.w3.org/XML/1998/namespace>:
                    $def_prefix eq 'xmlns' ? q<http://www.w3.org/2000/xmlns/>:
                    $_[0]->lookup_namespace_uri ($def_prefix);
                unless (defined $def_nsuri) {
                  ## TODO: Namespace well-formedness error...
                }
                $def_ln = $attr_node->manakai_local_name;
              } else {
                $def_nsuri = $attr_node->manakai_name eq 'xmlns'
                    ? q<http://www.w3.org/2000/xmlns/> : undef;
                $def_ln = $attr_node->manakai_local_name; ## ***
              }
              if ($attr->{defined $def_nsuri ? $def_nsuri : ''}->{$def_ln}) {
                ## TODO: Namespace well-formedness warning?
                last ADD;
              }
              $def_attr_node = $od->create_attribute_ns
                  ($def_nsuri, [$def_prefix, $def_ln]);
            
              for my $child (@{$at->child_nodes}) {
                $def_attr_node->append_child ($child->clone_node (1));
              }
              $def_attr_node->manakai_attribute_type ($at->declared_type);
              $attr->{defined $def_nsuri ? $def_nsuri : ''}->{$def_ln}
                  = $def_attr_node;
              $$def_attr_node->{owner_element} = $_[0];
              Scalar::Util::weaken ($$def_attr_node->{owner_element});
              delete $$def_attr_node->{specified};
            } # ADD
            $cfg->set_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => $copy_asis);
          }
        }
      }
    }
  
    return $_[1];
  } # remove_attribute_node
  
  sub remove_attribute_ns ($$$) {
    my $attr = ${$_[0]}->{attributes};
  
    my $list = $attr->{defined $_[1] ? $_[1] : ''};
    my $key = ''.$_[2];
    my $attr_node = $list->{$key};
    return undef unless defined $attr_node;
  
    ## NOTE: Anything below is same as |remove_attribute|'s except "***"
  
    my $od = ${$_[0]}->{owner_document};
    if ($$od->{strict_error_checking} and ${$_[0]}->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    delete $list->{$key};
    delete $$attr_node->{owner_element};
    $$attr_node->{specified} = 1;
    delete ${$_[0]}->{manakai_content_attribute_list};
  
    ## Default attribute
    local $Error::Depth = $Error::Depth + 1;
    my $cfg = $od->dom_config;
    if ($cfg->get_parameter 
        (q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute>)) {
      my $doctype = $od->doctype;
      if ($doctype) {
        my $et = $doctype->get_element_type_definition_node
            ($_[0]->manakai_tag_name);
        if ($et) {
          my $at = $et->get_attribute_definition_node
              ($attr_node->manakai_name); # ***
          if ($at) {
            local $$od->{strict_error_checking} = 0;
            my $copy_asis = $cfg->get_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree>);
            $cfg->set_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1);
            ADD: {
              my $def_attr_node;
              my $def_prefix = $attr_node->prefix;
              my $def_nsuri = '';
              my $def_ln;
              if (defined $def_prefix) {
                $def_nsuri =
                    $def_prefix eq 'xml' ? q<http://www.w3.org/XML/1998/namespace>:
                    $def_prefix eq 'xmlns' ? q<http://www.w3.org/2000/xmlns/>:
                    $_[0]->lookup_namespace_uri ($def_prefix);
                unless (defined $def_nsuri) {
                  ## TODO: Namespace well-formedness error...
                }
              } else {
                $def_nsuri = $attr_node->manakai_name eq 'xmlns'
                    ? q<http://www.w3.org/2000/xmlns/> : undef;
              }
              $def_ln = $attr_node->manakai_local_name; # ***
              if ($attr->{defined $def_nsuri ? $def_nsuri : ''}->{$def_ln}) {
                ## TODO: Namespace well-formedness warning?
                last ADD;
              }
              $def_attr_node = $od->create_attribute_ns
                  ($def_nsuri, [$def_prefix, $def_ln]);
            
              for my $child (@{$at->child_nodes}) {
                $def_attr_node->append_child ($child->clone_node (1));
              }
              $def_attr_node->manakai_attribute_type ($at->declared_type);
              $attr->{defined $def_nsuri ? $def_nsuri : ''}->{$def_ln}
                  = $def_attr_node;
              $$def_attr_node->{owner_element} = $_[0];
              Scalar::Util::weaken ($$def_attr_node->{owner_element});
              delete $$def_attr_node->{specified};
            } # ADD
            $cfg->set_parameter
                (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => $copy_asis);
          }
        }
      }
    }
  
    return undef;
  } # remove_attribute_ns
  
  sub set_attribute ($$$) {
    my $od = ${$_[0]}->{owner_document};
    if ($$od->{strict_error_checking}) {
      if (${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
    }
  
    my $name = ''.$_[1];
    my $attr = ${$_[0]}->{attributes};  
    my $attr_node;
    NS: for my $ns (keys %$attr) {
      for my $ln (keys %{$attr->{$ns}}) {
        my $node = $attr->{$ns}->{$ln};
        if ($node->manakai_name eq $name) {
          $attr_node = $node;
          last NS;
        }
      }
    }
    
    local $Error::Depth = $Error::Depth + 1;
    if (defined $attr_node) {
      if ($$od->{strict_error_checking}) {
        $od->create_attribute ($name); # or exception
      }
    } else {
      $attr_node = $od->create_attribute ($name); # return or exception
      delete ${$_[0]}->{manakai_content_attribute_list};
      $attr->{''}->{$name} = $attr_node;
      $$attr_node->{owner_element} = $_[0];
      Scalar::Util::weaken ($$attr_node->{owner_element});
  
      if ($od->dom_config->get_parameter
            (q<http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type>)) {
        my $doctype = $od->doctype;
        if (defined $doctype) {
          my $et = $doctype->get_element_type_definition_node
              ($_[0]->manakai_tag_name);
          if (defined $et) {
            my $at = $et->get_attribute_definition_node ($attr_node->manakai_name);
            if (defined $at) {
              $attr_node->manakai_attribute_type ($at->declared_type);
            }
          }
        }
      }
    }
  
    $attr_node->value ($_[2]); # set or exception
    $attr_node->specified (1);
    return undef;
  } # set_attribute
  
  sub set_attribute_node ($$) {
    my ($self, $new_attr) = @_;
    local $Error::Depth = $Error::Depth + 1;
    my $check = ${$$self->{owner_document}}->{strict_error_checking};
    if ($check and $$self->{owner_document} ne $new_attr->owner_document) {
      local $Error::Depth = $Error::Depth - 1;
      report Message::DOM::DOMException
          -object => $self,
          -type => 'WRONG_DOCUMENT_ERR';
    }
  
    my $nsuri = $$new_attr->{namespace_uri};
    $nsuri = '' unless defined $nsuri;
    my $ln = $$new_attr->{local_name};
  
    delete $$self->{manakai_content_attribute_list};
    my $attrs = $$self->{attributes};
    my $current = $attrs->{$nsuri}->{$ln};
  
    if (defined $$new_attr->{owner_element}) {
      if (defined $current and $current eq $new_attr) {
        ## No effect
        return undef; # no return value
      } else {
        local $Error::Depth = $Error::Depth - 1;
        report Message::DOM::DOMException
            -object => $self,
            -type => 'INUSE_ATTRIBUTE_ERR';
      }
    } elsif ($check and $$self->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    $attrs->{$nsuri}->{$ln} = $new_attr;
    $$new_attr->{owner_element} = $self;
    Scalar::Util::weaken ($$new_attr->{owner_element});
    $$new_attr->{specified} = 1;
  
    if (defined $current) {
      delete $$current->{owner_element};
      $$current->{specified} = 1;
    }
    return $current;
  } # set_attribute_node
  
  *set_attribute_node_ns = \&set_attribute_node;
  
  ## The second parameter only supports manakai extended way
  ## to specify qualified name - "[$prefix, $local_name]" ## TODO: Document
  sub set_attribute_ns ($$$$) {
    my $prefix;
    my $lname;
    if (ref $_[2] eq 'ARRAY') {
      ($prefix, $lname) = @{$_[2]};
    } else {
      ($prefix, $lname) = split /:/, $_[2], 2;
      ($prefix, $lname) = (undef, $prefix) unless defined $lname;
    }
  
    my $od = ${$_[0]}->{owner_document};
    if ($$od->{strict_error_checking}) {
      if (${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
    }
  
    my $attr = ${$_[0]}->{attributes};  
    my $attr_node = $attr->{defined $_[1] ? ''.$_[1] : ''}->{$lname};
    
    local $Error::Depth = $Error::Depth + 1;
    if (defined $attr_node) {
      if ($$od->{strict_error_checking}) {
        $od->create_attribute_ns ($_[1], [$prefix, $lname]); # name exception
      }
    } else {
      $attr_node = $od->create_attribute_ns
          ($_[1], [$prefix, $lname]); # or exception
      delete ${$_[0]}->{manakai_content_attribute_list};
      $attr->{defined $_[1] ? ''.$_[1] : ''}->{$lname} = $attr_node;
      $$attr_node->{owner_element} = $_[0];
      Scalar::Util::weaken ($$attr_node->{owner_element});
  
      if ($od->dom_config->get_parameter
            (q<http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type>)) {
        my $doctype = $od->doctype;
        if (defined $doctype) {
          my $et = $doctype->get_element_type_definition_node
              ($_[0]->manakai_tag_name);
          if (defined $et) {
            my $at = $et->get_attribute_definition_node ($attr_node->manakai_name);
            if (defined $at) {
              $attr_node->manakai_attribute_type ($at->declared_type);
            }
          }
        }
      }
    }
  
    $attr_node->value ($_[3]); # set or exception
    $attr_node->prefix ($prefix);
    $attr_node->specified (1);
    return undef;
  } # set_attribute_ns
  
  sub set_id_attribute ($$$) {
    if (${${$_[0]}->{owner_document}}->{strict_error_checking} and
        ${$_[0]}->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
    
    my $attr = $_[0]->get_attribute_node ($_[1]);
    if (not defined $attr) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    } else {
      local $Error::Depth = $Error::Depth + 1;
      $attr->is_id ($_[2]); # or exception
    }
    return;
  } # set_id_attribute
  
  sub set_id_attribute_ns ($$$$) {
    if (${${$_[0]}->{owner_document}}->{strict_error_checking} and
        ${$_[0]}->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
    
    my $attr = $_[0]->get_attribute_node_ns ($_[1], $_[2]);
    if (not defined $attr) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    } else {
      local $Error::Depth = $Error::Depth + 1;
      $attr->is_id ($_[2]);
    }
    return;
  } # set_id_attribute_ns
  
  sub set_id_attribute_node ($$$$) {
    if (${${$_[0]}->{owner_document}}->{strict_error_checking} and
        ${$_[0]}->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    my $oe = $_[1]->owner_element;  
    if ($oe ne $_[0]) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    } else {
      local $Error::Depth = $Error::Depth + 1;
      $_[1]->is_id ($_[2]);
    }
    return;
  } # set_id_attribute_node
  
  sub manakai_ids ($) {
    my $self = shift;
    my $ids = {};
    for my $attr (@{$self->attributes}) {
      $ids->{$attr->value} = 1 if $attr->is_id;
    }
    require Message::DOM::DOMStringList;
    return bless [keys %$ids], 'Message::DOM::DOMStringList::StaticList';
  } # ids
  
  ## |ElementSelector| methods
  
  sub query_selector ($$;$);
  
  sub query_selector_all ($$;$);
  
  ## |ElementCSSInlineStyle| attributes
  
  ## TODO: documentation
  sub manakai_computed_style ($) {
    ## TODO: If not part of document tree
  
    ## ISSUE: Neither |getComputedStyle| nor |currentStyle| represent
    ## the set of computed values in the real world (in fact what is
    ## represented by them disagree in browsers and even |getComputedStyle|
    ## and |currentStyle| are different in the same Opera browser).
    
    local $Error::Depth = $Error::Depth + 1;
    my $self = shift;
    my $view = $self->owner_document->default_view;
    return undef unless defined $view;  ## ISSUE: Not defined in the spec yet.
    
    return $view->manakai_get_computed_style ($self);
  } # manakai_computed_style
  
  ## TODO: |current_style|, |style|, |runtime_style|
  
  package Message::IF::Element;
  package Message::IF::ElementSelector;
  package Message::IF::ElementCSSInlineStyle;
  
  package Message::DOM::Document;
  
  sub create_element ($$) {
    my $self = $_[0];
    my $eln = ''.$_[1]; ## TODO: Need testing against DOM Perl binding.
    if ($$self->{strict_error_checking}) {
      my $xv = $self->xml_version;
      ## TODO: HTML Document ??
      if (defined $xv) {
        if ($xv eq '1.0' and
            $eln =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
          #
        } elsif ($xv eq '1.1' and
                 $eln =~ /\A\p{InXMLNameStartChar11}\p{InXMLNameChar11}*\z/) {
          # 
        } else {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'INVALID_CHARACTER_ERR',
              -subtype => 'MALFORMED_NAME_ERR';
        }
      }
    }
    ## TODO: HTML5
  
    my $r = Message::DOM::Element->____new ($self, undef, undef, $eln);
  
    ## -- Default attributes
    {
      local $Error::Depth = $Error::Depth + 1;
      my $cfg = $self->dom_config;
      return $r
          unless $cfg->get_parameter
              (q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute>);
  
      my $doctype = $self->doctype;
      return $r unless defined $doctype;
  
      my $et = $doctype->get_element_type_definition_node ($eln);
      return $r unless defined $et;
  
      my $orig_strict = $self->strict_error_checking;
      $self->strict_error_checking (0);
  
      my %gattr;
      my %has_attr;
      my %pfx_to_uri;
      my $copy_asis = $cfg->get_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree>);
      $cfg->set_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1);
      
      for my $at (@{$et->attribute_definitions}) {
        my $at_default = $at->default_type;
        if ($at_default == 4 or $at_default == 1) {
          # EXPLICIT_DEFAULT, FIXED_DEFAULT
          my ($nn1, $nn2) = split /:/, $at->node_name;
          if (defined $nn2) { # prefixed
            if ($nn1 eq 'xmlns') {
              ## TODO: NCName check, prefix check and NSURI check
              my $attr = $self->create_attribute_ns
                  (q<http://www.w3.org/2000/xmlns/>, [$nn1, $nn2]);
              for my $at_child (@{$at->child_nodes}) {
                $attr->append_child ($at_child->clone_node (1));
              }
              $attr->manakai_attribute_type ($at->declared_type);
              my $nsuri = $attr->value;
              ## TODO: Namespace well-formedness check (NSURI), v1.1 chk
              $pfx_to_uri{$nn2} = $nsuri;
              $r->set_attribute_node_ns ($attr);
                  ## NOTE: This method changes |specified| flag
              $attr->specified (0);
              $has_attr{q<http://www.w3.org/2000/xmlns/>}->{$nn2} = 1;
            } else {
              ## TODO: NCName check
              $gattr{$nn1}->{$nn2} = $at;
            }
          } else {            # no prefixed
            my $attr;
            if ($nn1 eq 'xmlns') {
              $attr = $self->create_attribute_ns
                  (q<http://www.w3.org/2000/xmlns/>, 'xmlns');
              $has_attr{q<http://www.w3.org/2000/xmlns/>}->{xmlns} = 1;
            } else {
              $attr = $self->create_attribute_ns (undef, $nn1);
              ## TODO: NCName check
            }
            for my $at_child (@{$at->child_nodes}) {
              $attr->append_child ($at_child->clone_node (1));
            }
            $attr->manakai_attribute_type ($at->declared_type);
            ## TODO: Namespace well-formedness check (NSURI)
            $r->set_attribute_node_ns ($attr);
                ## NOTE: This method changes |specified| flag
            $attr->specified (0);
          }
        }
      } # attrdefs
      for my $pfx (keys %gattr) {
        my $nsuri = $pfx_to_uri{$pfx};
        unless (defined $nsuri) {
          ## TODO: Namespace well-formedness error
        }
        LN: for my $ln (keys %{$gattr{$pfx}}) {
          if ($has_attr{defined $nsuri ? $nsuri : ''}->{$ln}) {
            ## TODO: Namespace well-formedness error
            next LN;
          }
          ## TODO: NCName check, prefix check and NSURI check
          my $at = $gattr{$pfx}->{$ln};
          my $attr = $self->create_attribute_ns ($nsuri, [$pfx, $ln]);
          for my $at_child (@{$at->child_nodes}) {
            $attr->append_child ($at_child->clone_node (1));
          }
          $attr->manakai_attribute_type ($at->declared_type);
          $r->set_attribute_node_ns ($attr);
              ## NOTE: This method changes |specified| flag
          $attr->specified (0);
          $has_attr{defined $nsuri ? $nsuri : ''}->{$ln} = 1;
        } # LN
      } # pfx
      $cfg->set_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => $copy_asis);
      $self->strict_error_checking ($orig_strict);
    }
  
    return $r;
  } # create_element
  
  sub create_element_ns ($$$) {
    my $self = $_[0];
    my ($prefix, $lname);
    if (ref $_[2] eq 'ARRAY') {
      ($prefix, $lname) = @{$_[2]};
    } else {
      ($prefix, $lname) = split /:/, $_[2], 2;
      ($prefix, $lname) = (undef, $prefix) unless defined $lname;
    }
    my $nsuri = defined $_[1] ? $_[1] eq '' ? undef : ''.$_[1] : undef;
    ## TODO: Need tests against DOM Perl binding.
  
    if ($$self->{strict_error_checking}) {
      my $xv = $self->xml_version;
      ## TODO: HTML Document ?? (NOT_SUPPORTED_ERR is different from what Web browsers do)
      if (defined $xv) {
        if ($xv eq '1.0') {
          if (ref $_[2] eq 'ARRAY' or
              $_[2] =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
            if (defined $prefix) {
              if ($prefix =~ /\A\p{InXML_NCNameStartChar10}\p{InXMLNCNameChar10}*\z/) {
                #
              } else {
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'NAMESPACE_ERR',
                    -subtype => 'MALFORMED_QNAME_ERR';
              }
            }
            if ($lname =~ /\A\p{InXML_NCNameStartChar10}\p{InXMLNCNameChar10}*\z/) {
              #
            } else {
              report Message::DOM::DOMException
                  -object => $self,
                  -type => 'NAMESPACE_ERR',
                  -subtype => 'MALFORMED_QNAME_ERR';
            }
          } else {
            report Message::DOM::DOMException
                -object => $self,
                -type => 'INVALID_CHARACTER_ERR',
                -subtype => 'MALFORMED_NAME_ERR';
          }
        } elsif ($xv eq '1.1') {
          if (ref $_[2] eq 'ARRAY' or
              $_[2] =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
            if (defined $prefix) {
              if ($prefix =~ /\A\p{InXMLNCNameStartChar11}\p{InXMLNCNameChar11}*\z/) {
                #
              } else {
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'NAMESPACE_ERR',
                    -subtype => 'MALFORMED_QNAME_ERR';
              }
            }
            if ($lname =~ /\A\p{InXMLNCNameStartChar11}\p{InXMLNCNameChar11}*\z/) {
              #
            } else {
              report Message::DOM::DOMException
                  -object => $self,
                  -type => 'NAMESPACE_ERR',
                  -subtype => 'MALFORMED_QNAME_ERR';
            }
          } else {
            report Message::DOM::DOMException
                -object => $self,
                -type => 'INVALID_CHARACTER_ERR',
                -subtype => 'MALFORMED_NAME_ERR';
          }
        } else {
          die "create_attribute_ns: XML version |$xv| is not supported";
        }
      }
  
      if (defined $prefix) {
        if (not defined $nsuri) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NAMESPACE_ERR',
              -subtype => 'PREFIXED_NULLNS_ERR';
        } elsif ($prefix eq 'xml' and 
                 $nsuri ne q<http://www.w3.org/XML/1998/namespace>) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NAMESPACE_ERR',
              -subtype => 'XMLPREFIX_NONXMLNS_ERR';
        } elsif ($prefix eq 'xmlns' and
                 $nsuri ne q<http://www.w3.org/2000/xmlns/>) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NAMESPACE_ERR',
              -subtype => 'XMLNSPREFIX_NONXMLNSNS_ERR';
        } elsif ($nsuri eq q<http://www.w3.org/2000/xmlns/> and
                 $prefix ne 'xmlns') {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NAMESPACE_ERR',
              -subtype => 'NONXMLNSPREFIX_XMLNSNS_ERR';
        }
      } else { # no prefix
        if ($lname eq 'xmlns' and
            (not defined $nsuri or $nsuri ne q<http://www.w3.org/2000/xmlns/>)) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NAMESPACE_ERR',
              -subtype => 'XMLNS_NONXMLNSNS_ERR';
        } elsif (not defined $nsuri) {
          #
        } elsif ($nsuri eq q<http://www.w3.org/2000/xmlns/> and
                 $lname ne 'xmlns') {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'NAMESPACE_ERR',
              -subtype => 'NONXMLNSPREFIX_XMLNSNS_ERR';
        }
      }
    }
  
    ## -- Choose the most apppropriate class for the element
    my $class = 'Message::DOM::Element';
    if (defined $nsuri) {
      if ($nsuri eq q<http://www.w3.org/1999/xhtml>) {
        require Message::DOM::HTML::HTMLElement;
        $class = {
          a => 'Message::DOM::HTML::HTMLAnchorElement',
          area => 'Message::DOM::HTML::HTMLAreaElement',
          audio => 'Message::DOM::HTML::HTMLAudioElement',
          base => 'Message::DOM::HTML::HTMLBaseElement',
          body => 'Message::DOM::HTML::HTMLBodyElement',
          canvas => 'Message::DOM::HTML::HTMLCanvasElement',
          command => 'Message::DOM::HTML::HTMLCommandElement',
          datagrid => 'Message::DOM::HTML::HTMLDataGridElement',
          details => 'Message::DOM::HTML::HTMLDetailsElement',
          embed => 'Message::DOM::HTML::HTMLEmbedElement',
          'event-source' => 'Message::DOM::HTML::HTMLEventSourceElement',
          font => 'Message::DOM::HTML::HTMLFontElement',
          head => 'Message::DOM::HTML::HTMLHeadElement',
          html => 'Message::DOM::HTML::HTMLHtmlElement',
          iframe => 'Message::DOM::HTML::HTMLIFrameElement',
          img => 'Message::DOM::HTML::HTMLImageElement',
          li => 'Message::DOM::HTML::HTMLLIElement',
          link => 'Message::DOM::HTML::HTMLLinkElement',
          map => 'Message::DOM::HTML::HTMLMapElement',
          menu => 'Message::DOM::HTML::HTMLMenuElement',
          meta => 'Message::DOM::HTML::HTMLMetaElement',
          meter => 'Message::DOM::HTML::HTMLMeterElement',
          del => 'Message::DOM::HTML::HTMLModElement',
          ins => 'Message::DOM::HTML::HTMLModElement',
          object => 'Message::DOM::HTML::HTMLObjectElement', 
          ol => 'Message::DOM::HTML::HTMLOListElement',
          param => 'Message::DOM::HTML::HTMLParamElement',
          progress => 'Message::DOM::HTML::HTMLProgressElement',
          blockquote => 'Message::DOM::HTML::HTMLQuoteElement',
          q => 'Message::DOM::HTML::HTMLQuoteElement',
          script => 'Message::DOM::HTML::HTMLScriptElement',
          source => 'Message::DOM::HTML::HTMLSourceElement',
          style => 'Message::DOM::HTML::HTMLStyleElement',
          table => 'Message::DOM::HTML::HTMLTableElement',
          td => 'Message::DOM::HTML::HTMLTableCellElement',
          col => 'Message::DOM::HTML::HTMLTableColElement',
          colgroup => 'Message::DOM::HTML::HTMLTableColElement',
          th => 'Message::DOM::HTML::HTMLTableHeaderCellElement',
          tr => 'Message::DOM::HTML::HTMLTableRowElement',
          tbody => 'Message::DOM::HTML::HTMLTableSectionElement',
          tfoot => 'Message::DOM::HTML::HTMLTableSectionElement',
          thead => 'Message::DOM::HTML::HTMLTableSectionElement',
          time => 'Message::DOM::HTML::HTMLTimeElement',
          video => 'Message::DOM::HTML::HTMLVideoElement',
        }->{$lname} || 'Message::DOM::HTML::HTMLElement';
      } elsif ($nsuri eq q<http://www.w3.org/2005/Atom>) {
        require Message::DOM::Atom::AtomElement;
        $class = {
                  author => 'Message::DOM::Atom::AtomElement::AtomPersonConstruct',
                  category => 'Message::DOM::Atom::AtomElement::AtomCategoryElement',
                  content => 'Message::DOM::Atom::AtomElement::AtomContentElement',
                  contributor => 'Message::DOM::Atom::AtomElement::AtomPersonConstruct',
                  entry => 'Message::DOM::Atom::AtomElement::AtomEntryElement',
                  feed => 'Message::DOM::Atom::AtomElement::AtomFeedElement',
                  generator => 'Message::DOM::Atom::AtomElement::AtomGeneratorElement',
                  link => 'Message::DOM::Atom::AtomElement::AtomLinkElement',
                  published => 'Message::DOM::Atom::AtomElement::AtomDateConstruct',
                  rights => 'Message::DOM::Atom::AtomElement::AtomTextConstruct',
                  source => 'Message::DOM::Atom::AtomElement::AtomSourceElement',
                  subtitle => 'Message::DOM::Atom::AtomElement::AtomTextConstruct',
                  summary => 'Message::DOM::Atom::AtomElement::AtomTextConstruct',
                  title => 'Message::DOM::Atom::AtomElement::AtomTextConstruct',
                  updated => 'Message::DOM::Atom::AtomElement::AtomDateConstruct',
                 }->{$lname} || 'Message::DOM::Atom::AtomElement';
      }
    }
  
    my $r = $class->____new ($self, $nsuri, $prefix, $lname);
  
    ## -- Default attributes
    {
      local $Error::Depth = $Error::Depth + 1;
      my $cfg = $self->dom_config;
      return $r
          unless $cfg->get_parameter
              (q<http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute>);
  
      my $doctype = $self->doctype;
      return $r unless defined $doctype;
  
      my $et = $doctype->get_element_type_definition_node
          (defined $prefix ? $prefix . ':' . $lname : $lname);
      return $r unless defined $et;
  
      my $orig_strict = $self->strict_error_checking;
      $self->strict_error_checking (0);
  
      my %gattr;
      my %has_attr;
      my %pfx_to_uri;
      my $copy_asis = $cfg->get_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree>);
      $cfg->set_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => 1);
      
      for my $at (@{$et->attribute_definitions}) {
        my $at_default = $at->default_type;
        if ($at_default == 4 or $at_default == 1) {
          # EXPLICIT_DEFAULT, FIXED_DEFAULT
          my ($nn1, $nn2) = split /:/, $at->node_name;
          if (defined $nn2) { # prefixed
            if ($nn1 eq 'xmlns') {
              ## TODO: NCName check, prefix check and NSURI check
              my $attr = $self->create_attribute_ns
                  (q<http://www.w3.org/2000/xmlns/>, [$nn1, $nn2]);
              for my $at_child (@{$at->child_nodes}) {
                $attr->append_child ($at_child->clone_node (1));
              }
              $attr->manakai_attribute_type ($at->declared_type);
              my $nsuri = $attr->value;
              ## TODO: Namespace well-formedness check (NSURI), v1.1 chk
              $pfx_to_uri{$nn2} = $nsuri;
              $r->set_attribute_node_ns ($attr);
                  ## NOTE: This method changes |specified| flag
              $attr->specified (0);
              $has_attr{q<http://www.w3.org/2000/xmlns/>}->{$nn2} = 1;
            } else {
              ## TODO: NCName check
              $gattr{$nn1}->{$nn2} = $at;
            }
          } else {            # no prefixed
            my $attr;
            if ($nn1 eq 'xmlns') {
              $attr = $self->create_attribute_ns
                  (q<http://www.w3.org/2000/xmlns/>, 'xmlns');
              $has_attr{q<http://www.w3.org/2000/xmlns/>}->{xmlns} = 1;
            } else {
              $attr = $self->create_attribute_ns (undef, $nn1);
              ## TODO: NCName check
            }
            for my $at_child (@{$at->child_nodes}) {
              $attr->append_child ($at_child->clone_node (1));
            }
            $attr->manakai_attribute_type ($at->declared_type);
            ## TODO: Namespace well-formedness check (NSURI)
            $r->set_attribute_node_ns ($attr);
                ## NOTE: This method changes |specified| flag
            $attr->specified (0);
          }
        }
      } # attrdefs
      for my $pfx (keys %gattr) {
        my $nsuri = $pfx_to_uri{$pfx};
        unless (defined $nsuri) {
          ## TODO: Namespace well-formedness error
        }
        LN: for my $ln (keys %{$gattr{$pfx}}) {
          if ($has_attr{defined $nsuri ? $nsuri : ''}->{$ln}) {
            ## TODO: Namespace well-formedness error
            next LN;
          }
          ## TODO: NCName check, prefix check and NSURI check
          my $at = $gattr{$pfx}->{$ln};
          my $attr = $self->create_attribute_ns ($nsuri, [$pfx, $ln]);
          for my $at_child (@{$at->child_nodes}) {
            $attr->append_child ($at_child->clone_node (1));
          }
          $attr->manakai_attribute_type ($at->declared_type);
          $r->set_attribute_node_ns ($attr);
              ## NOTE: This method changes |specified| flag
          $attr->specified (0);
          $has_attr{defined $nsuri ? $nsuri : ''}->{$ln} = 1;
        } # LN
      } # pfx
      $cfg->set_parameter
          (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree> => $copy_asis);
      $self->strict_error_checking ($orig_strict);
    }
  
    return $r;
  } # create_element_ns
  
  =head1 AUTHOR
  
  Wakaba <w@suika.fam.cx>.
  
  =head1 LICENSE
  
  Copyright 2007-2010 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
MESSAGE_DOM_ELEMENT

$fatpacked{"Message/DOM/HTML/HTMLElement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_HTML_HTMLELEMENT';
  package Message::DOM::HTML::HTMLElement;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.5 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::DOM::Element';
  require Message::DOM::Element;
  
  ## TODO: interface
  
  ## TODO: "reflect" definition need to be updated (both implementation and Perl binding specification) - see HTML5 for latest definition
  
  sub AUTOLOAD {
    my $method_name = our $AUTOLOAD;
    return if $method_name =~ /::DESTROY$/;
  
    my $ln;
    if ($ln = {  ## Reflecting |DOMString| attribute
      'Message::DOM::HTML::HTMLAreaElement::alt' => 'alt',
      'Message::DOM::HTML::HTMLImageElement::alt' => 'alt',
      'Message::DOM::HTML::HTMLElement::class_name' => 'class',
      'Message::DOM::HTML::HTMLMetaElement::content' => 'content',
      'Message::DOM::HTML::HTMLAreaElement::coords' => 'coords',
      'Message::DOM::HTML::HTMLTimeElement::datetime' => 'datetime',
      'Message::DOM::HTML::HTMLModElement::datetime' => 'datetime',
      'Message::DOM::HTML::HTMLAnchorElement::hreflang' => 'hreflang',
      'Message::DOM::HTML::HTMLAreaElement::hreflang' => 'hreflang',
      'Message::DOM::HTML::HTMLLinkElement::hreflang' => 'hreflang',
      'Message::DOM::HTML::HTMLElement::id' => 'id',
      'Message::DOM::HTML::HTMLCommandElement::label' => 'label',
      'Message::DOM::HTML::HTMLMenuElement::label' => 'label',
      'Message::DOM::HTML::HTMLElement::lang' => 'lang',
      'Message::DOM::HTML::HTMLAnchorElement::media' => 'media',
      'Message::DOM::HTML::HTMLAreaElement::media' => 'media',
      'Message::DOM::HTML::HTMLLinkElement::media' => 'media',
      'Message::DOM::HTML::HTMLSourceElement::media' => 'media',
      'Message::DOM::HTML::HTMLStyleElement::media' => 'media',
      'Message::DOM::HTML::HTMLParamElement::name' => 'name',
      'Message::DOM::HTML::HTMLAnchorElement::ping' => 'ping',
      'Message::DOM::HTML::HTMLAreaElement::ping' => 'ping',
      'Message::DOM::HTML::HTMLCommandElement::radiogroup' => 'radiogroup',
      'Message::DOM::HTML::HTMLAnchorElement::rel' => 'rel',
      'Message::DOM::HTML::HTMLAreaElement::rel' => 'rel',
      'Message::DOM::HTML::HTMLLinkElement::rel' => 'rel',
      'Message::DOM::HTML::HTMLAnchorElement::target' => 'target',
      'Message::DOM::HTML::HTMLAreaElement::target' => 'target',
      'Message::DOM::HTML::HTMLBaseElement::target' => 'target',
      'Message::DOM::HTML::HTMLElement::title' => 'title',
      'Message::DOM::HTML::HTMLAnchorElement::type' => 'type',
      'Message::DOM::HTML::HTMLAreaElement::type' => 'type',
      'Message::DOM::HTML::HTMLCommandElement::type' => 'type',
      'Message::DOM::HTML::HTMLEmbedElement::type' => 'type',
      'Message::DOM::HTML::HTMLLinkElement::type' => 'type',
      'Message::DOM::HTML::HTMLObjectElement::type' => 'type',
      'Message::DOM::HTML::HTMLScriptElement::type' => 'type',
      'Message::DOM::HTML::HTMLSourceElement::type' => 'type',
      'Message::DOM::HTML::HTMLStyleElement::type' => 'type',
      'Message::DOM::HTML::HTMLImageElement::usemap' => 'usemap',
      'Message::DOM::HTML::HTMLObjectElement::usemap' => 'usemap',
      'Message::DOM::HTML::HTMLParamElement::value' => 'value',
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$;\$) {
          local \$Error::Depth = \$Error::Depth + 1;
  
          if (\@_ > 1) {
            if (defined \$_[1]) {
              \$_[0]->set_attribute_ns (undef, '$ln', ''.\$_[1]);
            } else {
              ## ISSUE: Not in spec
              \$_[0]->set_attribute_ns (undef, '$ln', '');
            }
            return unless defined wantarray;
          }
  
          ## ISSUE: If missing?
          return \$_[0]->get_attribute_ns (undef, '$ln');
        }
      };
      goto &{ $AUTOLOAD };
    } elsif ($ln = {  ## Reflecting URI attribute
      'Message::DOM::HTML::HTMLAnchorElement::href' => 'href',
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$;\$) {
          local \$Error::Depth = \$Error::Depth + 1;
  
          ## TODO: Implement the spec...
  
          if (\@_ > 1) {
            if (defined \$_[1]) {
              \$_[0]->set_attribute_ns (undef, '$ln', ''.\$_[1]);
            } else {
              \$_[0]->set_attribute_ns (undef, '$ln', '');
            }
            return unless defined wantarray;
          }
  
          if (defined wantarray) {
            my \$uri = \$_[0]->get_attribute_ns (undef, '$ln');
            if (defined \$uri) {
              return \$_[0]->owner_document->implementation->create_uri_reference
                  (\$uri)->get_absolute_reference (\$_[0]->base_uri)
                  ->uri_reference;
              ## TODO: If base_uri is undef...
            } else {
              return undef;
            }
          }
        }
      };
      goto &{ $AUTOLOAD };
    } elsif ($ln = {  ## Reflecting boolean attribute
      'Message::DOM::HTML::HTMLScriptElement::async' => 'async',
      'Message::DOM::HTML::HTMLMenuElement::autosubmit' => 'autosubmit',
      'Message::DOM::HTML::HTMLCommandElement::checked' => 'checked',
      'Message::DOM::HTML::HTMLMediaElement::controls' => 'controls',
      'Message::DOM::HTML::HTMLCommandElement::default' => 'default',
      'Message::DOM::HTML::HTMLScriptElement::defer' => 'defer',
      'Message::DOM::HTML::HTMLCommandElement::disabled' => 'disabled',
      'Message::DOM::HTML::HTMLDataGridElement::disabled' => 'disabled',
      'Message::DOM::HTML::HTMLCommandElement::hidden' => 'hidden',
      'Message::DOM::HTML::HTMLElement::irrelevant' => 'irrelevant',
      'Message::DOM::HTML::HTMLImageElement::ismap' => 'ismap',
      'Message::DOM::HTML::HTMLDataGridElement::multiple' => 'multiple',
      'Message::DOM::HTML::HTMLDetailsElement::open' => 'open',
      'Message::DOM::HTML::HTMLStyleElement::scoped' => 'scoped',
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$;\$) {
          local \$Error::Depth = \$Error::Depth + 1;
  
          if (\@_ > 1) {
            if (\$_[1]) {
              \$_[0]->set_attribute_ns (undef, '$ln', '$ln');
            } else {
              \$_[0]->remove_attribute_ns (undef, '$ln');
            }
            return unless defined wantarray;
          }
  
          return \$_[0]->has_attribute_ns (undef, '$ln');
        }
      };
      goto &{ $AUTOLOAD };
    } else {
      require Carp;
      Carp::croak (qq<Can't locate method "$AUTOLOAD">);
    }
  } # AUTOLOAD
  
  ## TODO: class_list
  
  sub class_name ($;$);
  
  ## TODO: dir
  
  sub id ($;$);
  
  ## NOTE: inner_html is part of |Message::DOM::Element|.
  
  sub lang ($;$);
  
  ## TODO: tab_index
  
  sub title ($;$);
  
  ## TODO: Other DOM5 HTML members
  
  package Message::DOM::HTML::HTMLAnchorElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: href
  
  sub hreflang ($;$);
  
  sub media ($;$);
  
  sub ping ($;$);
  
  sub rel ($;$);
  
  ## TODO: rel_list
  
  sub target ($;$);
  
  sub type ($;$);
  
  ## TODO: Command
  
  package Message::DOM::HTML::HTMLAreaElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub alt ($;$);
  
  sub coords ($;$);
  
  ## TODO: href
  
  sub hreflang ($;$);
  
  sub media ($;$);
  
  sub ping ($;$);
  
  sub rel ($;$);
  
  ## TODO: rel_list, shape
  
  sub target ($;$);
  
  sub type ($;$);
  
  package Message::DOM::HTML::HTMLAudioElement;
  push our @ISA, 'Message::DOM::HTML::HTMLMediaElement';
  
  package Message::DOM::HTML::HTMLBaseElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub target ($;$);
  
  ## TODO: href
  
  package Message::DOM::HTML::HTMLBodyElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: DOM2
  
  package Message::DOM::HTML::HTMLCanvasElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO
  
  package Message::DOM::HTML::HTMLCommandElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub checked ($;$);
  
  sub default ($;$);
  
  sub disabled ($;$);
  
  sub hidden ($;$);
  
  ## TODO: icon
  
  sub label ($;$);
  
  sub radiogroup ($;$);
  
  sub type ($;$); ## NOTE: This is not an enumerated attribute.
  
  ## TODO: Command
  
  package Message::DOM::HTML::HTMLDataGridElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO
  
  sub disabled ($;$);
  
  sub multiple ($;$);
  
  package Message::DOM::HTML::HTMLDetailsElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub open ($;$);
  
  package Message::DOM::HTML::HTMLEmbedElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: height, src
  
  sub type ($;$);
  
  ## TODO: width
  
  package Message::DOM::HTML::HTMLEventSourceElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: src
  
  package Message::DOM::HTML::HTMLFontElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO
  
  package Message::DOM::HTML::HTMLHeadElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: DOM2
  
  package Message::DOM::HTML::HTMLHtmlElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: DOM2
  
  package Message::DOM::HTML::HTMLIFrameElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: src, EmbeddingElement
  
  package Message::DOM::HTML::HTMLImageElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub alt ($;$);
  
  ## TODO: complete
  
  sub ismap ($;$);
  
  ## TODO: height, src
  
  sub usemap ($;$);
  
  ## TODO: width
  
  package Message::DOM::HTML::HTMLLIElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: value
  
  package Message::DOM::HTML::HTMLLinkElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: disabled, href
  
  sub hreflang ($;$);
  
  sub media ($;$);
  
  sub rel ($;$);
  
  ## TODO: rel_list
  
  sub type ($;$);
  
  ## TODO: LinkStyle
  
  package Message::DOM::HTML::HTMLMapElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO
  
  package Message::DOM::HTML::HTMLMediaElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO...
  
  sub controls ($;$);
  
  package Message::DOM::HTML::HTMLMenuElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub autosubmit ($;$);
  
  sub label ($;$);
  
  ## TODO: type
  
  package Message::DOM::HTML::HTMLMetaElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub content ($;$);
  
  ## TODO: name, http_equiv
  
  package Message::DOM::HTML::HTMLMeterElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: value, min, max, low, high, optimum
  
  package Message::DOM::HTML::HTMLModElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: cite
  
  sub datetime ($;$);
  
  package Message::DOM::HTML::HTMLObjectElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: data, height
  
  sub type ($;$);
  
  sub usemap ($;$);
  
  ## TODO: width, EmbeddingElement
  
  package Message::DOM::HTML::HTMLOListElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: start
  
  package Message::DOM::HTML::HTMLParamElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub name ($;$);
  
  sub value ($;$);
  
  package Message::DOM::HTML::HTMLProgressElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: value, max, position
  
  package Message::DOM::HTML::HTMLQuoteElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: cite
  
  package Message::DOM::HTML::HTMLScriptElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub async ($;$);
  
  sub defer ($;$);
  
  ## TODO: src, text
  
  sub type ($;$);
  
  package Message::DOM::HTML::HTMLSourceElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  sub media ($;$);
  
  ## TODO: src
  
  sub type ($;$);
  
  package Message::DOM::HTML::HTMLStyleElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: disabled
  
  sub media ($;$);
  
  sub scoped ($;$);
  
  sub type ($;$);
  
  package Message::DOM::HTML::HTMLTableElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO
  
  package Message::DOM::HTML::HTMLTableCellElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO
  
  package Message::DOM::HTML::HTMLTableColElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: span
  
  package Message::DOM::HTML::HTMLTableHeaderCellElement;
  push our @ISA, 'Message::DOM::HTML::HTMLTableCellElement';
  
  ## TODO
  
  package Message::DOM::HTML::HTMLTableRowElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO
  
  package Message::DOM::HTML::HTMLTableSectionElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO
  
  package Message::DOM::HTML::HTMLTimeElement;
  push our @ISA, 'Message::DOM::HTML::HTMLElement';
  
  ## TODO: date
  
  sub datetime ($;$);
  
  ## TODO: time, timezone
  
  package Message::DOM::HTML::HTMLVideoElement;
  push our @ISA, 'Message::DOM::HTML::HTMLMediaElement';
  
  ## TODO: video_width, video_height
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2008/05/25 08:54:15 $
  
MESSAGE_DOM_HTML_HTMLELEMENT

$fatpacked{"Message/DOM/NamedNodeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_NAMEDNODEMAP';
  package Message::DOM::NamedNodeMap;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.2 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::IF::NamedNodeMap';
  require Message::DOM::DOMException;
  require Tie::Array;
  
  use overload
      '@{}' => sub {
        tie my @list, (ref $_[0]) . '::Array', $_[0];
        return \@list;
      },
      '%{}' => sub {
        tie my %list, ref $_[0], $_[0];
        return \%list;
      },
      eq => sub {
        return 0 unless UNIVERSAL::isa ($_[1], 'Message::DOM::NamedNodeMap');
        return 0 if $_[1]->isa ('Message::DOM::NamedNodeMap::ArrayMap');
        return (${$_[0]}->[0] eq ${$_[1]}->[0] and ${$_[0]}->[1] eq ${$_[1]}->[1]);
      },
      ne => sub {
        return not ($_[0] eq $_[1]);
      },
      '==' => sub {
        return 0 unless UNIVERSAL::isa ($_[1], 'Message::IF::NamedNodeMap');
        
        local $Error::Depth = $Error::Depth + 1;
        my $length1 = @{$_[0]};
        my $length2 = @{$_[1]};
        return 0 if $length1 != $length2;
  
        for my $i (0..($length1 - 1)) {
          my $node1 = $_[0]->[$i];
          my $node2 = $_[1]->[$i];
          return 0 if $node1 != $node2;
        }
        ## TODO: This ordering is only assumed in manakai...
  
        return 1;
      },
      '!=' => sub {
        return not ($_[0] == $_[1]);
      },
      fallback => 1;
  
  sub ___report_error ($$) {
    $_[1]->throw;
  } # ___report_error
  
  sub TIEHASH ($$) { $_[1] }
  
  ## |NamedNodeMap| attributes
  
  sub length ($) {
    return scalar @{[map {$_} values %{${${$_[0]}->[0]}->{${$_[0]}->[1]}}]};
  } # length
  
  sub manakai_read_only ($) {
    return ${${$_[0]}->[0]}->{manakai_read_only};
  } # manakai_read_only
  
  ## |NamedNodeMap| methods
  
  sub get_named_item ($$) {
    return ${${$_[0]}->[0]}->{${$_[0]}->[1]}->{$_[1]};
  } # get_named_item
  *FETCH = \&get_named_item;
  
  sub get_named_item_ns ($$$) { }
  
  sub item ($$) {
    my $index = 0+$_[1];
    my $list = ${${$_[0]}->[0]}->{${$_[0]}->[1]};
  
    my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index] : undef;
    if (defined $key and defined $list->{$key}) {
      return $list->{$key};
    } else {
      return undef;
    }
  } # item
  
  sub remove_named_item ($$) {
    my $name = ''.$_[1];
    my $list = ${${$_[0]}->[0]}->{${$_[0]}->[1]};
  
    my $od = ${${$_[0]}->[0]}->{owner_document}; # might be undef, but no problem
  
    my $key = ${$_[0]}->[1] eq 'attribute_definitions'
        ? 'owner_element_type_definition' : 'owner_document_type_definition';
  
    if ($$od->{strict_error_checking}) {
      if (${${$_[0]}->[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
    }
  
    if (defined $list->{$name}) {
      my $r = $list->{$name};
      delete $$r->{$key};
      delete $list->{$name};
      return $r;
    } else {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    }
  } # remove_named_item
  
  sub remove_named_item_ns ($$) {
    report Message::DOM::DOMException
        -object => $_[0],
        -type => 'NOT_FOUND_ERR',
        -subtype => 'NOT_CHILD_ERR';
  } # remove_named_item_ns
  
  sub DELETE ($$) {
    my $r;
    try {
      $r = $_[0]->remove_named_item ($_[1]);
    } catch Message::DOM::DOMException with {
      my $err = shift;
      unless ($err->subtype eq 'NOT_CHILD_ERR') {
        $err->throw;
      }
    };
    return $r; ## TODO: This return value is ok?
  } # DELETE
  
  sub set_named_item ($$) {
    my $od = ${${$_[0]}->[0]}->{owner_document};
    if (not defined $od or
        $od ne ($_[1]->owner_document || $_[1])) {
      ## TODO: $od not defined case is manakai extension.  Document it!
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'WRONG_DOCUMENT_ERR',
          -subtype => 'EXTERNAL_OBJECT_ERR';
    }
  
    my $key = ${$_[0]}->[1] eq 'attribute_definitions'
        ? 'owner_element_type_definition' : 'owner_document_type_definition';
  
    if ($$od->{strict_error_checking}) {
      if ($_[1]->node_type !=
          {
           element_types => 81001, # ELEMENT_TYPE_DEFINITION_NODE
           attribute_definitions => 81002, # ATTRIBUTE_DEFINITION_NODE
           entities => 6, # ENTITY_NODE
           notations => 12, # NOTATION_NODE
          }->{${$_[0]}->[1]}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'HIERARCHY_REQUEST_ERR',
            -subtype => 'CHILD_NODE_TYPE_ERR';
      }
  
      if (${${$_[0]}->[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      if (${$_[1]}->{$key} and not ${$_[1]}->{$key} eq ${$_[0]}->[0]) {
        ## TODO: This is manakai extension.  Document it!
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'HIERARCHY_REQUEST_ERR',
            -subtype => 'INUSE_DEFINITION_ERR';
      }
    }
  
    my $name = $_[1]->node_name;
    my $list = ${${$_[0]}->[0]}->{${$_[0]}->[1]};
    if (defined $list->{$name}) {
      my $r = $list->{$name};
      if ($r eq $_[1]) {
        ## NOTE: Replace by itself (implementation dependent).
        return undef;
      } else {
        $list->{$name} = $_[1];
        ${$_[1]}->{$key} = ${$_[0]}->[0];
        Scalar::Util::weaken (${$_[1]}->{$key});
        delete $$r->{$key};
        return $r;
      }
    } else {
      $list->{$name} = $_[1];
      ${$_[1]}->{$key} = ${$_[0]}->[0];
      Scalar::Util::weaken (${$_[1]}->{$key});
      return undef;
    }
  } # set_named_item
  
  sub set_named_item_ns ($$) {
    report Message::DOM::DOMException
        -object => $_[0],
        -type => 'HIERARCHY_REQUEST_ERR',
        -subtype => 'CHILD_NODE_TYPE_ERR';
  } # set_named_item_ns
  
  sub EXISTS ($$) {
    return exists ${${$_[0]}->[0]}->{${$_[0]}->[1]}->{$_[1]};
  } # EXISTS
  
  sub FIRSTKEY ($) {
    my $list = ${${$_[0]}->[0]}->{${$_[0]}->[1]};
    my $a = keys %$list; # reset
    return each %$list;
  } # FIRSTKEY
  
  sub NEXTKEY ($) {
    return each %{${${$_[0]}->[0]}->{${$_[0]}->[1]}};
  } # NEXTKEY
  
  sub SCALAR ($) {
    return scalar %{${${$_[0]}->[0]}->{${$_[0]}->[1]}};
  } # SCALAR
  
  package Message::DOM::NamedNodeMap::Array;
  push our @ISA, 'Tie::Array';
  
  sub DELETE ($$) {
    my $item = $_[0]->item ($_[1]);
    if ($item) {
      local $Error::Depth = $Error::Depth + 1;
      return $_[0]->remove_named_item ($item->node_name);
    } else {
      return undef;
    }
  } # DELETE
  
  sub EXISTS ($$) {
    return ($_[1] < $_[0]->length);
  } # EXISTS
  
  *FETCH = \&Message::DOM::NamedNodeMap::item;
  
  *FETCHSIZE = \&Message::DOM::NamedNodeMap::length;
  
  ## TODO: |STORE|
  
  sub STORESIZE ($) {
    local $Error::Depth = $Error::Depth + 1;
    my $length = $_[0]->length;
    if ($length > $_[1]) {
      for (my $i = $length - 1; $i >= $_[1]; $i--) {
        my $item = $_[0]->item ($i);
        $_[0]->remove_named_item ($item->node_name);
      }
    }
  } # STORESIZE
  
  sub TIEARRAY ($$) { bless \[${$_[1]}->[0], ${$_[1]}->[1]], __PACKAGE__ }
  
  package Message::DOM::NamedNodeMap::AttrMap;
  push our @ISA, 'Message::DOM::NamedNodeMap';
  
  use overload
      eq => sub {
        return 0 unless UNIVERSAL::isa ($_[1], 'Message::DOM::NamedNodeMap');
        return $${$_[0]} eq $${$_[1]};
      },
      fallback => 1;
  
  sub TIEHASH ($$) { $_[1] }
  
  ## |NamedNodeMap| attributes
  
  sub length ($) {
    my $list = ${$${$_[0]}}->{manakai_content_attribute_list};
    if (defined $list) {
      return scalar @$list;
    } else {
      $list = ${$${$_[0]}}->{attributes};
      my $r = 0;
      for my $l (values %$list) {
        $r += grep {$l->{$_}} keys %$l;
      }
      return $r;
    }
  } # length
  
  sub manakai_read_only ($) {
    return ${$${$_[0]}}->{manakai_read_only};
  } # manakai_read_only
  
  ## |NamedNodeMap| methods
  
  sub get_named_item ($$) {
    local $Error::Depth = $Error::Depth + 1;
    return $${$_[0]}->get_attribute_node ($_[1]);
  } # get_named_item
  *FETCH = \&get_named_item;
  
  sub get_named_item_ns ($$$) {
    local $Error::Depth = $Error::Depth + 1;
    return $${$_[0]}->get_attribute_node_ns ($_[1], $_[2]);
  } # get_named_item_ns
  
  sub item ($$) {
    ## Update the sorted content attribute name list
    my $list = ${$${$_[0]}}->{manakai_content_attribute_list};
    my $attrs = ${$${$_[0]}}->{attributes};
    unless (defined $list) {
      $list = [];
      for my $ns (sort {$a cmp $b} keys %{$attrs}) {
        push @$list, map {[$ns => $_]} sort {$a cmp $b} keys %{$attrs->{$ns}};
      }
      ${$${$_[0]}}->{manakai_content_attribute_list} = $list;
    }
  
    my $index = 0+$_[1];
    return $attrs->{$list->[$index]->[0]}->{$list->[$index]->[1]};
  } # item
  
  sub remove_named_item ($$) {
    my $el = $${$_[0]};
    local $Error::Depth = $Error::Depth + 1;
    my $node = $el->get_attribute_node ($_[1]);
    unless ($node) {
      local $Error::Depth = $Error::Depth - 1;
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    }
    return $el->remove_attribute_node ($node);
  } # remove_named_item
  
  sub remove_named_item_ns ($$) {
    my $el = $${$_[0]};
    local $Error::Depth = $Error::Depth + 1;
    my $node = $el->get_attribute_node_ns ($_[1], $_[2]);
    unless ($node) {
      local $Error::Depth = $Error::Depth - 1;
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    }
    return $el->remove_attribute_node ($node);
  } # remove_named_item_ns
  
  sub set_named_item ($$) {
    if ($_[1]->node_type != 2) { # ATTRIBUTE_NODE
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'HIERARCHY_REQUEST_ERR',
          -subtype => 'CHILD_NODE_TYPE_ERR';
    }
  
    local $Error::Depth = $Error::Depth + 1;
    return $${$_[0]}->set_attribute_node ($_[1]);
  } # set_named_item
  
  sub set_named_item_ns ($$) {
    if ($_[1]->node_type != 2) { # ATTRIBUTE_NODE
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'HIERARCHY_REQUEST_ERR',
          -subtype => 'CHILD_NODE_TYPE_ERR';
    }
  
    local $Error::Depth = $Error::Depth + 1;
    return $${$_[0]}->set_attribute_node_ns ($_[1]);
  } # set_named_item_ns
  
  sub EXISTS ($$) {
    local $Error::Depth = $Error::Depth + 1;
    return defined ($_[0]->get_named_item ($_[1]));
  } # EXISTS
  
  sub FIRSTKEY ($) {
    local $Error::Depth = $Error::Depth + 1;
    my $node = $_[0]->item (0);
    ${$${$_[0]}}->{manakai_hash_position} = 1;
    return $node ? $node->node_name : undef;
  } # FIRSTKEY
  
  sub NEXTKEY ($) {
    my $i = ${$${$_[0]}}->{manakai_hash_position}++;
    my $node = $_[0]->item ($i);
    return $node ? $node->node_name : undef;
  } # NEXTKEY
  
  sub SCALAR ($) {
    local $Error::Depth = $Error::Depth + 1;
    return $${$_[0]}->has_attributes;
  } # SCALAR
  
  package Message::DOM::NamedNodeMap::AttrMap::Array;
  push our @ISA, 'Tie::Array';
  
  sub DELETE ($$) {
    my $item = $_[0]->item ($_[1]);
    if ($item) {
      local $Error::Depth = $Error::Depth + 1;
      return $_[0]->remove_named_item_ns
          ($item->namespace_uri, $item->manakai_local_name);
    } else {
      return undef;
    }
  } # DELETE
  
  sub EXISTS ($$) {
    return ($_[1] < $_[0]->length);
  } # EXISTS
  
  *FETCH = \&Message::DOM::NamedNodeMap::AttrMap::item;
  
  *FETCHSIZE = \&Message::DOM::NamedNodeMap::AttrMap::length;
  
  sub STORESIZE ($) {
    local $Error::Depth = $Error::Depth + 1;
    my $length = $_[0]->length;
    if ($length > $_[1]) {
      for (my $i = $length - 1; $i >= $_[1]; $i--) {
        my $item = $_[0]->item ($i);
        $_[0]->remove_named_item_ns
            ($item->namespace_uri, $item->manakai_local_name);
      }
    }
  } # STORESIZE
  
  sub TIEARRAY ($$) { bless \\$${$_[1]}, __PACKAGE__ }
  
  package Message::IF::NamedNodeMap;
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2007/07/14 10:00:32 $
MESSAGE_DOM_NAMEDNODEMAP

$fatpacked{"Message/DOM/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_NODE';
  package Message::DOM::Node;
  use strict;
  use warnings;
  our $VERSION = '1.20';
  push our @ISA, 'Message::IF::Node',
      'Message::IF::NSResolver';
  require Scalar::Util;
  require Message::DOM::DOMException;
  use Exporter::Lite;
  
  our @EXPORT;
  
  ## NOTE:
  ##   Node
  ##   + Attr (2)
  ##   + AttributeDefinition (81002)
  ##   + CharacterData
  ##     + Comment (8)
  ##     + Text (3)
  ##       + CDATASection (4)
  ##   + Document (9)
  ##   + DocumentFragment (11)
  ##   + DocumentType (10)
  ##   + Element (1)
  ##   + ElementTypeDefinition (81001)
  ##   + Entity (6)
  ##   + EntityReference (5)
  ##   + Notation (12)
  ##   + ProcessingInstruction (7)
  
  use overload
      '==' => 'is_equal_node',
      '!=' => sub {
        return not ($_[0] == $_[1]);
      },
      #eq => sub { $_[0] eq $_[1] }, ## is_same_node
      #ne => sub { $_[0] ne $_[1] }, ## not is_same_node
      fallback => 1;
  
  ## The |Node| interface - constants
  
  ## Definition group NodeType
  
  ## NOTE: Numeric codes up to 200 are reserved by W3C [DOM1SE, DOM2, DOM3].
  
  sub ELEMENT_NODE () { 1 }
  sub ATTRIBUTE_NODE () { 2 }
  sub TEXT_NODE () { 3 }
  sub CDATA_SECTION_NODE () { 4 }
  sub ENTITY_REFERENCE_NODE () { 5 }
  sub ENTITY_NODE () { 6 }
  sub PROCESSING_INSTRUCTION_NODE () { 7 }
  sub COMMENT_NODE () { 8 }
  sub DOCUMENT_NODE () { 9 }
  sub DOCUMENT_TYPE_NODE () { 10 }
  sub DOCUMENT_FRAGMENT_NODE () { 11 }
  sub NOTATION_NODE () { 12 }
  sub ELEMENT_TYPE_DEFINITION_NODE () { 81001 }
  sub ATTRIBUTE_DEFINITION_NODE () { 81002 }
  
  push @EXPORT, qw(
    ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE
    ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE
    COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE
    NOTATION_NODE ELEMENT_TYPE_DEFINITION_NODE ATTRIBUTE_DEFINITION_NODE
  );
  
  ## Definition group DocumentPosition
  
  sub DOCUMENT_POSITION_DISCONNECTED () { 0x01 }
  sub DOCUMENT_POSITION_PRECEDING () { 0x02 }
  sub DOCUMENT_POSITION_FOLLOWING () { 0x04 }
  sub DOCUMENT_POSITION_CONTAINS () { 0x08 }
  sub DOCUMENT_POSITION_CONTAINED_BY () { 0x10 }
  sub DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC () { 0x20 }
  
  ## |OperationType| from the |UserDataHandler| interface.
  sub NODE_CLONED () { 1 }
  sub NODE_IMPORTED () { 2 }
  sub NODE_DELETED () { 3 }
  sub NODE_RENAMED () { 4 }
  sub NODE_ADOPTED () { 5 }
  
  sub ____new ($$) {
    my $self = bless \({}), shift;
    $$self->{owner_document} = shift;
    Scalar::Util::weaken ($$self->{owner_document});
    return $self;
  } # ____new
  
  sub ___report_error ($$) {
    $_[1]->throw;
  } # ___report_error
  
  sub AUTOLOAD {
    my $method_name = our $AUTOLOAD;
    $method_name =~ s/.*:://;
    return if $method_name eq 'DESTROY';
  
    if ({
      ## Read-only attributes (trivial accessors)
      owner_document => 1,
      parent_node => 1,
      manakai_read_only => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$) {
          return \${\$_[0]}->{$method_name}; 
        }
      };
      goto &{ $AUTOLOAD };
    } elsif (my $module_name = {
      add_event_listener => 'Message::DOM::EventTargetNode',
      add_event_listener_ns => 'Message::DOM::EventTargetNode',
      dispatch_event => 'Message::DOM::EventTargetNode',
      remove_event_listener => 'Message::DOM::EventTargetNode',
      remove_event_listener_ns => 'Message::DOM::EventTargetNode',
    }->{$method_name}) {
      eval qq{ require $module_name } or die $@;
      goto &{ $AUTOLOAD };
    } else {
      require Carp;
      Carp::croak (qq<Can't locate method "$AUTOLOAD">);
    }
  } # AUTOLOAD
  
  ## |Node| attributes
  
  ## NOTE: Overridden by |Element|.
  sub attributes () { undef }
  
  sub base_uri ($) {
    ## NOTE: Overridden by |Attr|, |CharacterData|, |Document|, |DocumentType|,
    ## |Element|, |EntityReference|, and |ProcessingInstruction|.
  
    local $Error::Depth = $Error::Depth + 1;
    return $_[0]->owner_document->base_uri;
  } # base_uri
  
  sub child_nodes ($) {
    ## NOTE: Overridden by |CharacterData|, |ElementTypeDefinition|,
    ## |Notation|, and |ProcessingInstruction|.
    require Message::DOM::NodeList;
    return bless \\($_[0]), 'Message::DOM::NodeList::ChildNodeList';
  } # child_nodes
  
  sub manakai_expanded_uri ($) {
    my $self = shift;
    local $Error::Depth = $Error::Depth + 1;
    my $ln = $self->local_name;
    if (defined $ln) {
      my $nsuri = $self->namespace_uri;
      if (defined $nsuri) {
        return $nsuri . $ln;
      } else {
        return $ln;
      }
    } else {
      return undef;
    } 
  } # manakai_expanded_uri
  
  sub first_child ($) {
    my $self = shift;
    return $$self->{child_nodes} ? $$self->{child_nodes}->[0] : undef;
  } # first_child
  
  sub manakai_language ($;$) {
    my $self = $_[0];
    local $Error::Depth = $Error::Depth + 1;
  
    if (@_ > 1) {
      if ($self->node_type == 1) { # ELEMENT_NODE
        if (defined $_[1]) {
          if ($self->has_attribute_ns (undef, 'xml:lang')) {
            $self->set_attribute_ns (undef, [undef, 'xml:lang'] => $_[1]);
                # or exception
          } else {
            $self->set_attribute_ns
                (q<http://www.w3.org/XML/1998/namespace>, 'xml:lang', $_[1]);
          }
        } else {
          $self->remove_attribute_ns
              (q<http://www.w3.org/XML/1998/namespace>, 'lang');
          $self->remove_attribute_ns (undef, 'xml:lang');
        }
      }
      
      return undef unless defined wantarray;
    }
  
    my $target = $self;
    while (defined $target) {
      if ($target->node_type == 1) { # ELEMENT_NODE
        ## Step 1
  
        ## Step 1.1
        my $r = $target->get_attribute_ns
            (q<http://www.w3.org/XML/1998/namespace>, 'lang');
        return $r if defined $r;
  
        ## Step 1.2
        $r = $target->get_attribute_ns (undef, 'xml:lang');
        return $r if defined $r;
      }
  
      ## Step 2
      $target = $target->parent_node;
    }
  
    ## Step 3
    my $od = $self->owner_document;
    if (defined $od) {
      return $od->manakai_language;
    }
  
    ## Step 4
    ## TODO: from upper-level protocol, if $self isa Document
  
    ## Step 5
    return '';
  } # manakai_language
  
  ## TODO: document
  sub manakai_html_language ($;$) {
    my $self = $_[0];
    local $Error::Depth = $Error::Depth + 1;
  
    if (@_ > 1) {
      if ($self->node_type == 1) { # ELEMENT_NODE
        if (defined $_[1]) {
  ## TODO: non HTML
          if ($self->has_attribute_ns (undef, 'xml:lang')) {
            $self->set_attribute_ns (undef, [undef, 'xml:lang'] => $_[1]);
                # or exception
          } else {
            $self->set_attribute (lang => $_[1]);
          }
        } else {
  ## TODO: html lang
          $self->remove_attribute_ns
              (q<http://www.w3.org/XML/1998/namespace>, 'lang');
          $self->remove_attribute_ns (undef, 'xml:lang');
        }
      }
      
      return undef unless defined wantarray;
    }
  
    my $target = $self;
    while (defined $target) {
      if ($target->node_type == 1) { # ELEMENT_NODE
  
  ## TODO: non-html
        my $r = $target->get_attribute ('lang');
        return $r if defined $r;
  
        ## Step 1
  
        ## Step 1.1
        $r = $target->get_attribute_ns
            (q<http://www.w3.org/XML/1998/namespace>, 'lang');
        return $r if defined $r;
  
        ## Step 1.2
        $r = $target->get_attribute_ns (undef, 'xml:lang');
        return $r if defined $r;
      }
  
      ## Step 2
      $target = $target->parent_node;
    }
  
    ## Step 3
    my $od = $self->owner_document;
    if (defined $od) {
      return $od->manakai_language;
    }
  
    ## Step 4
    ## TODO: from upper-level protocol, if $self isa Document
  
    ## Step 5
    return '';
  } # manakai_html_language
  
  sub last_child ($) {
    my $self = shift;
    return $$self->{child_nodes} && $$self->{child_nodes}->[0]
      ? $$self->{child_nodes}->[-1] : undef;
  } # last_child
  
  sub local_name { undef }
  
  sub manakai_local_name { undef }
  
  sub namespace_uri { undef }
  
  sub next_sibling ($) {
    my $self = shift;
    my $parent = $$self->{parent_node};
    return undef unless defined $parent;
    my $has_self;
    for ($parent->child_nodes->to_list) {
      if ($_ eq $self) {
        $has_self = 1;
      } elsif ($has_self) {
        return $_;
      }
    }
    return undef;
  } # next_sibling
  
  ## NOTE: Overridden by subclasses.
  sub node_name () { undef }
  
  ## NOTE: Overridden by subclasses.
  sub node_type () { }
  
  ## NOTE: Overridden by |Attr|, |AttributeDefinition|,
  ## |CharacterData|, and |ProcessingInstruction|.
  sub node_value () { undef }
  
  sub owner_document ($);
  
  sub manakai_parent_element ($) {
    my $self = shift;
    my $parent = $$self->{parent_node};
    while (defined $parent) {
      if ($parent->node_type == ELEMENT_NODE) {
        return $parent;
      } else {
        $parent = $$parent->{parent_node};
      }
    }
    return undef;
  } # manakai_parent_element
  
  sub parent_node ($);
  
  ## NOTE: Overridden by |Element| and |Attr|.
  sub prefix ($;$) { undef }
  
  sub previous_sibling ($) {
    my $self = shift;
    my $parent = $$self->{parent_node};
    return undef unless defined $parent;
    my $prev;
    for ($parent->child_nodes->to_list) {
      if ($_ eq $self) {
        return $prev;
      } else {
        $prev = $_;
      }
    }
    return undef;
  } # previous_sibling
  
  sub manakai_read_only ($);
  
  sub text_content ($;$) {
    ## NOTE: For |Element|, |Attr|, |Entity|, |EntityReference|,
    ## |DocumentFragment|, and |AttributeDefinition|.  In addition,
    ## |Document|'s |text_content| might call this attribute.
    
    ## NOTE: Overridden by |Document|, |DocumentType|, |Notation|,
    ## |CharacterData|, |ProcessingInstruction|, and |ElementTypeDefinition|.
  
    my $self = $_[0];
  
    if (@_ > 1) {
      if (${$$self->{owner_document} or $self}->{strict_error_checking} and
          $$self->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
      
      local $Error::Depth = $Error::Depth + 1;
      @{$self->child_nodes} = ();
      if (defined $_[1] and length $_[1]) {
        ## NOTE: |DocumentType| don't use this code.
        my $text = ($$self->{owner_document} || $self)->create_text_node ($_[1]);
        $self->append_child ($text);
      }    
    }
  
    if (defined wantarray) {
      local $Error::Depth = $Error::Depth + 1;
      my $r = '';
      my @node = $self->child_nodes->to_list;
      while (@node) {
        my $child = shift @node;
        my $child_nt = $child->node_type;
        if ($child_nt == TEXT_NODE or $child_nt == CDATA_SECTION_NODE) {
          $r .= $child->node_value unless $child->is_element_content_whitespace;
        } elsif ($child_nt == COMMENT_NODE or
                 $child_nt == PROCESSING_INSTRUCTION_NODE or
                 $child_nt == DOCUMENT_TYPE_NODE) {
          #
        } else {
          unshift @node, $child->child_nodes->to_list;
        }
      }
      return $r;
    }
  } # text_content
  
  ## |Node| methods
  
  sub append_child ($$) {
    ## NOTE: |Element|, |Entity|, |DocumentFragment|, |EntityReference|.
    ## NOTE: |Document|, |Attr|, |CharacterData|, |AttributeDefinition|,
    ## |Notation|, |ProcessingInstruction| |ElementTypeDefinition|,
    ## and |DocumentType| define their own implementations.
    my $self = $_[0];
    
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == DOCUMENT_FRAGMENT_NODE) {
      push @new_child, $_[1]->child_nodes->to_list;
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self_od ne $child_od and $child_od->node_type != DOCUMENT_TYPE_NODE) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ({
                 TEXT_NODE, 1, ENTITY_REFERENCE_NODE, 1,
                 ELEMENT_NODE, 1, CDATA_SECTION_NODE, 1,
                 PROCESSING_INSTRUCTION_NODE, 1, COMMENT_NODE, 1,
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      my $anode = $self;
      while (defined $anode) {
        if ($anode eq $_[1]) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'ANCESTOR_NODE_ERR';
        }
        $anode = $$anode->{parent_node};
      }
    }
  
    ## NOTE: "Insert at" code only in insert_before and replace_child
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    push @{$$self->{child_nodes}}, @new_child;
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[1];
  } # apepnd_child
  
  sub clone_node ($;$) {
    my ($self, $deep) = @_;
  
    ## TODO: Cloning operation
    ## for ElementTypeDefinition, and AttributeDefinition nodes,
    ## as well as new attributes introduced in DOM XML Document Type Definition
    ## module.
    ## TODO: if default attributes and attributedefinition are inconsistent
  
    local $Error::Depth = $Error::Depth + 1;
    my $od = $self->owner_document;
    my $strict_check = $od->strict_error_checking;
    $od->strict_error_checking (0);
    my $cfg = $od->dom_config;
    my $er_copy_asis
        = $cfg->get_parameter
            (q<http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree>);
  
    my $r;
    my @udh;
    my @node = ([$self]);
    while (@node) {
      my ($node, $parent) = @{shift @node};
      my $nt = $node->node_type;
      my $clone;
      if ($nt == ELEMENT_NODE) {
        $clone = $od->create_element_ns
          ($node->namespace_uri, [$node->prefix, $node->local_name]);
        if ($parent) {
          $parent->append_child ($clone);
        } else {
          $r = $clone;
        }
        my $attrs = $node->attributes;
        my $attrsMax = @$attrs - 1;
        for my $i (0..$attrsMax) {
          my $attr = $attrs->[$i];
          push @node, [$attr, $clone] if $attr->specified;
        }
        if ($deep) {
          push @node, map {[$_, $clone]} $node->child_nodes->to_list;
        }
      } elsif ($nt == TEXT_NODE) {
        $clone = $od->create_text_node ($node->data);
        if ($parent) {
          $parent->append_child ($clone);
        } else {
          $r = $clone;
        }
        $clone->is_element_content_whitespace (1)
          if $node->is_element_content_whitespace;
      } elsif ($nt == ATTRIBUTE_NODE) {
        $clone = $od->create_attribute_ns
          ($node->namespace_uri, [$node->prefix, $node->local_name]);
        if ($parent) {
          $parent->set_attribute_node_ns ($clone);
        } else {
          $r = $clone;
        }
        $clone->specified (1);
        push @node, map {[$_, $clone]} $node->child_nodes->to_list;
      } elsif ($nt == COMMENT_NODE) {
        $clone = $od->create_comment ($node->data);
        if ($parent) {
          $parent->append_child ($clone);
        } else {
          $r = $clone;
        }
      } elsif ($nt == CDATA_SECTION_NODE) {
        $clone = $od->create_cdata_section ($node->data);
        if ($parent) {
          $parent->append_child ($clone);
        } else {
          $r = $clone;
        }
      } elsif ($nt == PROCESSING_INSTRUCTION_NODE) {
        $clone = $od->create_processing_instruction
          ($node->target, $node->data);
        if ($parent) {
          $parent->append_child ($clone);
        } else {
          $r = $clone;
        }
      } elsif ($nt == ENTITY_REFERENCE_NODE) {
        $clone = $od->create_entity_reference ($node->node_name);
        if ($er_copy_asis) {
          $clone->manakai_set_read_only (0);
          $clone->text_content (0);
          for ($node->child_nodes->to_list) {
            $clone->append_child ($_->clone_node (1));
          }
          $clone->manakai_expanded ($node->manakai_expanded);
          $clone->manakai_set_read_only (1, 1);
        } # copy asis
        if ($parent) {
          $parent->append_child ($clone);
        } else {
          $r = $clone;
        }
      } elsif ($nt == DOCUMENT_FRAGMENT_NODE) {
        $clone = $od->create_document_fragment;
        $r = $clone;
        push @node, map {[$_, $clone]} $node->child_nodes->to_list;
      } elsif ($nt == DOCUMENT_NODE) {
        $od->strict_error_checking ($strict_check);
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_SUPPORTED_ERR',
            -subtype => 'CLONE_NODE_NOT_SUPPORTED_ERR';
      } elsif ($nt == DOCUMENT_TYPE_NODE) {
        $od->strict_error_checking ($strict_check);
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_SUPPORTED_ERR',
            -subtype => 'CLONE_NODE_NOT_SUPPORTED_ERR';
      } elsif ($nt == ENTITY_NODE) {
        $od->strict_error_checking ($strict_check);
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_SUPPORTED_ERR',
            -subtype => 'CLONE_NODE_NOT_SUPPORTED_ERR';
      } elsif ($nt == NOTATION_NODE) {
        $od->strict_error_checking ($strict_check);
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_SUPPORTED_ERR',
            -subtype => 'CLONE_NODE_NOT_SUPPORTED_ERR';
      } else {
        $od->strict_error_checking ($strict_check);
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_SUPPORTED_ERR',
            -subtype => 'CLONE_NODE_NOT_SUPPORTED_ERR';
      }
  
      my $udhs = $$self->{user_data};
      push @udh, [$node => $clone, $udhs] if $udhs and %$udhs;
    } # @node
    $od->strict_error_checking (1) if $strict_check;
    
    ## Calling user data handlers if any
    for my $sd (@udh) {
      my $src = $sd->[0];
      my $src_ud = $sd->[2];
      for my $key (keys %{$src_ud}) {
        my $dh = $src_ud->{$key}->[1];
        if ($dh) {     ## NODE_CLONED
          $dh->handle (1, $key, $src_ud->{$key}->[0], $src, $sd->[1]);
          ## ISSUE: |handler| method? CODE?
        }
      }
    }
  
    return $r;
  } # clone_node
  
  sub compare_document_position ($$) {
    ## ISSUE: There are implementation specifics
    ## (see what Gecko does if it implement this method...)
  
    ## ISSUE: Maybe we should overload <=> or cmp
  
    ## TODO: Too long method name!  Too long constant names!
    ## Too many thing to be done by a method!
    ## Maybe we should import simpler method implemented by IE.
  
    ## TODO: ElementTypeDefinition and AttributeDefinition
  
    my @acontainer = ($_[0]);
    my @bcontainer = ($_[1]);
    F: {
      A: while (1) {
        if ($acontainer[-1] eq $bcontainer[-1]) {
          last F;
        } else {
          my $ap;
          my $atype = $acontainer[-1]->node_type;
          if ($atype == ATTRIBUTE_NODE) {
            $ap = $acontainer[-1]->owner_element;
          } elsif ($atype == ENTITY_NODE or $atype == NOTATION_NODE or
                   $atype == ELEMENT_TYPE_DEFINITION_NODE) {
            $ap = $acontainer[-1]->owner_document_type_definition;
          } elsif ($atype == ATTRIBUTE_DEFINITION_NODE) {
            $ap = $acontainer[-1]->owner_element_type_definition;
          } else {
            $ap = $acontainer[-1]->parent_node;
          }
          if (defined $ap) {
            push @acontainer, $ap;
          } else {
            last A;
          }
        }
      } # A
  
      B: while (1) {
        if ($acontainer[-1] eq $bcontainer[-1]) {
          last F;
        } else {
          my $bp;
          my $btype = $bcontainer[-1]->node_type;
          if ($btype == ATTRIBUTE_NODE) {
            $bp = $bcontainer[-1]->owner_element;
          } elsif ($btype == ENTITY_NODE or $btype == NOTATION_NODE or
                   $btype == ELEMENT_TYPE_DEFINITION_NODE) {
            $bp = $bcontainer[-1]->owner_document_type_definition;
          } elsif ($btype == ATTRIBUTE_DEFINITION_NODE) {
            $bp = $bcontainer[-1]->owner_element_type_definition;
          } else {
            $bp = $bcontainer[-1]->parent_node;
          }
          if (defined $bp) {
            push @bcontainer, $bp;
          } else {
            last B;
          }
        }
      } # B
        
      ## Disconnected
      if ($bcontainer[-1]->isa ('Message::IF::Node')) {
        ## ISSUE: Document this in manakai's DOM Perl Binding?
        return DOCUMENT_POSITION_DISCONNECTED
          | DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
          | ((${$acontainer[-1]} cmp ${$bcontainer[-1]}) > 0
               ? DOCUMENT_POSITION_FOLLOWING
               : DOCUMENT_POSITION_PRECEDING);
      } else {
        ## TODO: Is there test cases for this?
        return DOCUMENT_POSITION_DISCONNECTED
          | DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
          | DOCUMENT_POSITION_FOLLOWING;
      }
    } # F
  
    ## Common container found
    if (@acontainer >= 2) {
      if (@bcontainer >= 2) {
        my $acnt = $acontainer[-2]->node_type;
        my $bcnt = $bcontainer[-2]->node_type;
        if ($acnt == ATTRIBUTE_NODE or
            $acnt == NOTATION_NODE or 
            $acnt == ELEMENT_TYPE_DEFINITION_NODE or
            $acnt == ATTRIBUTE_DEFINITION_NODE) {
          if ($acnt == $bcnt) {
            return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
              | (($acontainer[-2]->node_name cmp
                  $bcontainer[-2]->node_name) > 0
                 ? DOCUMENT_POSITION_FOLLOWING
                 : DOCUMENT_POSITION_PRECEDING);
          } elsif ($bcnt == ATTRIBUTE_NODE or
                   $bcnt == NOTATION_NODE or
                   $bcnt == ELEMENT_TYPE_DEFINITION_NODE or
                   $bcnt == ATTRIBUTE_DEFINITION_NODE) {
            return (($acnt < $bcnt)
                    ? DOCUMENT_POSITION_FOLLOWING
                    : DOCUMENT_POSITION_PRECEDING);
          } else {
            ## A: Non-child and B: child
            return DOCUMENT_POSITION_FOLLOWING;
          }
        } elsif ($bcnt == ATTRIBUTE_NODE or
                 $bcnt == NOTATION_NODE or
                 $bcnt == ELEMENT_TYPE_DEFINITION_NODE or
                 $bcnt == ATTRIBUTE_DEFINITION_NODE) {
          ## A: Child and B: non-child
          return DOCUMENT_POSITION_PRECEDING;
        } else {
          ## A and B are both children
          for my $cn ($acontainer[-1]->child_nodes->to_list) {
            if ($cn eq $acontainer[-2]) {
              return DOCUMENT_POSITION_FOLLOWING;
            } elsif ($cn eq $bcontainer[-2]) {
              return DOCUMENT_POSITION_PRECEDING;
            }
          }
          die "compare_document_position: Something wrong (1)";
        }
      } else {
        ## B contains A
        return DOCUMENT_POSITION_CONTAINS
          | DOCUMENT_POSITION_PRECEDING;
      }
    } else {
      if (@bcontainer >= 2) {
        ## A contains B
        return DOCUMENT_POSITION_CONTAINED_BY
          | DOCUMENT_POSITION_FOLLOWING;
      } else {
        ## A eq B
        return 0;
      }
    }
    die "compare_document_position: Something wrong (2)";
  } # compare_document_position
  
  sub get_feature ($$;$) {
    my $feature = lc $_[1]; ## TODO: |lc|?
    $feature =~ s/^\+//;
    my $version = defined $_[2] ? $_[2] : '';
    if ($Message::DOM::DOMImplementation::HasFeature->{$feature}->{$version}) {
      return $_[0];
    } else {
      return undef;
    }
  } # get_feature
  
  sub get_user_data ($$) {
    if (${$_[0]}->{user_data}->{$_[1]}) {
      return ${$_[0]}->{user_data}->{$_[1]}->[0];
    } else {
      return undef;
    }
  } # get_user_data
  
  sub has_attributes ($) {
    for (values %{${$_[0]}->{attributes} or {}}) {
      return 1 if keys %$_;
    }
    return 0;
  } # has_attributes
  
  sub has_child_nodes ($) {
    return (@{${$_[0]}->{child_nodes} or []} > 0);
  } # has_child_nodes
  
  sub insert_before ($$) {
    ## NOTE: |Element|, |Entity|, |DocumentFragment|, |EntityReference|.
    ## NOTE: |Document|, |Attr|, |CharacterData|, |AttributeDefinition|,
    ## |Notation|, |ProcessingInstruction|, |ElementTypeDefinition|,
    ## and |DocumentType| define their own implementations.
    my $self = $_[0];
  
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == DOCUMENT_FRAGMENT_NODE) {
      push @new_child, $_[1]->child_nodes->to_list;
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self_od ne $child_od and $child_od->node_type != DOCUMENT_TYPE_NODE) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ({
                 TEXT_NODE, 1, ENTITY_REFERENCE_NODE, 1,
                 ELEMENT_NODE, 1, CDATA_SECTION_NODE, 1,
                 PROCESSING_INSTRUCTION_NODE, 1, COMMENT_NODE, 1,
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      my $anode = $self;
      while (defined $anode) {
        if ($anode eq $_[1]) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'ANCESTOR_NODE_ERR';
        }
        $anode = $$anode->{parent_node};
      }
    }
    
    ## -- Insert at... ## NOTE: Only in insert_before and replace_child
    my $index = -1; # last
    if (defined $_[2]) {
      ## error if $_[1] eq $_[2];
      
      my @cns = $self->child_nodes->to_list;
      C: {
        $index = 0;
        for my $i (0..$#cns) {
          my $cn = $cns[$i];
          if ($cn eq $_[2]) {
            $index += $i;
            last C;
          } elsif ($cn eq $_[1]) {
            $index = -1; # offset
          }
        }
        
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_FOUND_ERR',
            -subtype => 'NOT_CHILD_ERR';
      } # C
    }
    ## NOTE: "else" only in replace_child
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    if ($index == -1) {
      push @{$$self->{child_nodes}}, @new_child;
    } else {
      splice @{$$self->{child_nodes}}, $index, 0, @new_child;
    }
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[1];
  } # insert_before
  
  sub is_equal_node ($$) {
    local $Error::Depth = $Error::Depth + 1;
  
    return 0 unless UNIVERSAL::isa ($_[1], 'Message::IF::Node');
  
    my $nt = $_[0]->node_type;
    return 0 unless $nt == $_[1]->node_type;
  
    my @str_attr = qw/node_name local_name namespace_uri
        prefix node_value/;
    push @str_attr, qw/public_id system_id internal_subset/
        if $nt == DOCUMENT_TYPE_NODE;
    for my $attr_name (@str_attr) {
      my $v1 = $_[0]->can ($attr_name) ? $_[0]->$attr_name : undef;
      my $v2 = $_[1]->can ($attr_name) ? $_[1]->$attr_name : undef;
      if (defined $v1 and defined $v2) {
        return 0 unless ''.$v1 eq ''.$v2;
      } elsif (defined $v1 or defined $v2) {
        return 0;
      }
    }
  
    my @num_eq_attr = qw/child_nodes attributes/;
    push @num_eq_attr, qw/entities notations element_types/
        if $nt == DOCUMENT_TYPE_NODE;
    push @num_eq_attr, qw/attribute_definitions/
        if $nt == ELEMENT_TYPE_DEFINITION_NODE;
    push @num_eq_attr, qw/declared_type default_type allowed_tokens/
        if $nt == ATTRIBUTE_DEFINITION_NODE;
    for my $attr_name (@num_eq_attr) {
      my $v1 = $_[0]->can ($attr_name) ? $_[0]->$attr_name : undef;
      my $v2 = $_[1]->can ($attr_name) ? $_[1]->$attr_name : undef;
      if (defined $v1 and defined $v2) {
        return 0 unless $v1 == $v2;
      } elsif (defined $v1 or defined $v2) {
        return 0;
      }
    }
  
    return 1;
  } # is_equal_node
  
  sub is_same_node ($$) { $_[0] eq $_[1] }
  
  sub is_supported ($$;$) {
    my $feature = lc $_[1]; ## TODO: |lc|?
    my $plus = ($feature =~ s/^\+//);
    my $version = defined $_[2] ? $_[2] : '';
    return $Message::DOM::DOMImplementation::HasFeature->{$feature}->{$version};
  } # is_supported;
  
  sub manakai_append_text ($$) {
    ## NOTE: For |Element|, |Attr|, |Entity|, |EntityReference|,
    ## |DocumentFragment|, and |AttributeDefinition|.  In addition,
    ## |Document|'s |text_content| might call this attribute.
    
    ## NOTE: Overridden by |Document|, |DocumentType|, |CharacterData|, 
    ## |ElementTypeDefinition|, |Notation|, and |ProcessingInstruction|.
  
    my $self = $_[0];
    local $Error::Depth = $Error::Depth + 1;
    if (@{$$self->{child_nodes}} and
        $$self->{child_nodes}->[-1]->node_type == TEXT_NODE) {
      $$self->{child_nodes}->[-1]->manakai_append_text ($_[1]);
    } else {
      my $text = ($$self->{owner_document} or $self)->create_text_node ($_[1]);
      $self->append_child ($text);
    }
  } # manakai_append_text
  
  sub is_default_namespace ($$) {
    local $Error::Depth = $Error::Depth + 1;
    my $namespace_uri = defined $_[1] ? $_[1] : '';
    my $nt = $_[0]->node_type;
    if ($nt == ELEMENT_NODE) {
      my $el = $_[0];
      EL: {
        unless (defined $el->prefix) {
          my $elns = $el->namespace_uri;
          if ($namespace_uri ne '' and defined $elns) {
            return $namespace_uri eq $elns;
          } else {
            return not ($namespace_uri eq '' or defined $elns);
          }
        }
        my $xmlns = $el->get_attribute_ns
          ('http://www.w3.org/2000/xmlns/', 'xmlns');
        if (defined $xmlns) {
          if ($namespace_uri ne '') {
            return ($namespace_uri eq $xmlns);
          } else {
            return ($xmlns eq '');
          }
        }
        $el = $el->manakai_parent_element;
        redo EL if defined $el;
        return 0;
      } # EL;
    } else {
      my $el = $nt == DOCUMENT_NODE
        ? $_[0]->document_element
        : $nt == ATTRIBUTE_NODE
          ? $_[0]->owner_element
          : $_[0]->manakai_parent_element;
      if (defined $el) {
        return $el->is_default_namespace ($_[1]);
      } else {
        return 0;
      }
    }
  } # is_default_namespace
  
  sub lookup_namespace_uri ($$) {
    my ($self, $prefix) = @_;
    $prefix = undef if defined $prefix and $prefix eq '';
        ## NOTE: Implementation dependent.
        ## TODO: Check what Gecko does.
    local $Error::Depth = $Error::Depth + 1;
    my $nt = $self->node_type;
    if ($nt == ELEMENT_NODE) {
      my $el = $self;
      EL: {
        my $elns = $el->namespace_uri;
        if (defined $elns) {
          my $elpfx = $el->prefix;
          if ((not defined $prefix and not defined $elpfx) or
              (defined $prefix and defined $elpfx and $prefix eq $elpfx)) {
            return $elns;
          }
        }
        AT: for my $attr (@{$el->attributes}) {
          my $attrns = $attr->namespace_uri;
          next AT if not defined $attrns or
            $attrns ne 'http://www.w3.org/2000/xmlns/';
          my $attrpfx = $attr->prefix;
          if (not defined $prefix) {
            my $attrln = $attr->local_name;
            if ($attrln eq 'xmlns') {
              my $attrval = $attr->value;
              return length $attrval ? $attrval : undef;
            }
          } elsif (defined $prefix and
                   defined $attrpfx and $attrpfx eq 'xmlns') {
            my $attrln = $attr->local_name;
            if ($attrln eq $prefix) {
              my $attrval = $attr->value;
              return length $attrval ? $attrval : undef;
            }
          }
        } # AT
        $el = $el->manakai_parent_element;
        redo EL if defined $el;
        return undef;
      } # EL;
    } else {
      my $el = $nt == DOCUMENT_NODE
        ? $self->document_element
        : $nt == ATTRIBUTE_NODE
          ? $self->owner_element
          : $self->manakai_parent_element;
      if (defined $el) {
        return $el->lookup_namespace_uri ($prefix);
      } else {
        return undef;
      }
    }
  } # lookup_namespace_uri
  
  sub manakai_get_child_namespace_uri ($) {
    my $self = $_[0];
    my $doc = $$self->{owner_document} || $self;
    if ($doc->manakai_is_html) {
      my $tag_name = defined $_[1] ? $_[1] : '';
      $tag_name =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
  
      require Whatpm::HTML::ParserData;
      my $ns = $self->namespace_uri;
      my $ln = $self->manakai_local_name;
      if (not defined $ln or not defined $ns) {
        #
      } elsif ($ns eq Whatpm::HTML::ParserData::SVG_NS ()) {
        if ($Whatpm::HTML::ParserData::SVGHTMLIntegrationPoints->{$ln}) {
          #
        } else {
          return $ns;
        }
      } elsif ($ns eq Whatpm::HTML::ParserData::MML_NS ()) {
        if ($Whatpm::HTML::ParserData::MathMLTextIntegrationPoints->{$ln}) {
          if ($tag_name eq 'mglyph' or $tag_name eq 'malignmark') {
            return Whatpm::HTML::ParserData::MML_NS ();
          }
        } elsif ($ln eq 'annotation-xml') {
          if ($tag_name eq 'svg') {
            return Whatpm::HTML::ParserData::SVG_NS ();
          }
          my $encoding = $self->get_attribute ('encoding') || '';
          $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          if ($encoding eq 'text/html' or $encoding eq 'application/xhtml+xml') {
            #
          } else {
            return $ns;
          }
        } elsif ($Whatpm::HTML::ParserData::MathMLHTMLIntegrationPoints->{$ln}) {
          #
        } else {
          return $ns;
        }
      } # $ns
  
      if ($tag_name eq 'svg') {
        return Whatpm::HTML::ParserData::SVG_NS ();
      } elsif ($tag_name eq 'math') {
        return Whatpm::HTML::ParserData::MML_NS ();
      } else {
        return Whatpm::HTML::ParserData::HTML_NS ();
      }
    } else {
      if (defined $_[1] and $_[1] =~ /:/) {
        my $prefix = $_[1];
        $prefix =~ s/:.*//gs;
        if ($prefix eq '') {
          return undef;
        } else {
          return $self->lookup_namespace_uri ($prefix);
        }
      } else {
        return $self->lookup_namespace_uri (undef);
      }
    }
  } # manakai_get_child_namespace_uri
  
  sub lookup_prefix ($$) {
    my $namespace_uri = defined $_[1] ? $_[1] : '';
    if ($namespace_uri eq '') {
      return undef;
    }
  
    local $Error::Depth = $Error::Depth + 1;
    my $nt = $_[0]->node_type;
    if ($nt == ELEMENT_NODE) {
      my $el = $_[0];
      EL: {
        my $elns = $el->namespace_uri;
        if (defined $elns and $elns eq $namespace_uri) {
          my $elpfx = $el->prefix;
          if (defined $elpfx) {
            my $oeluri = $_[0]->lookup_namespace_uri ($elpfx);
            if (defined $oeluri and $oeluri eq $namespace_uri) {
              return $elpfx;
            }
          }
        }
        AT: for my $attr (@{$el->attributes}) {
          my $attrpfx = $attr->prefix;
          next AT if not defined $attrpfx or $attrpfx ne 'xmlns';
          my $attrns = $attr->namespace_uri;
          next AT if not defined $attrns or
            $attrns ne 'http://www.w3.org/2000/xmlns/';
          next AT unless $attr->value eq $namespace_uri;
          my $attrln = $attr->local_name;
          my $oeluri = $el->lookup_namespace_uri ($attrln);
          next AT unless defined $oeluri;
          if ($oeluri eq $namespace_uri) {
            return $attrln;
          }
        }
        $el = $el->manakai_parent_element;
        redo EL if defined $el;
        return undef;
      } # EL
    } else {
      my $el = $nt == DOCUMENT_NODE
        ? $_[0]->document_element
        : $nt == ATTRIBUTE_NODE
          ? $_[0]->owner_element
          : $_[0]->manakai_parent_element;
      if (defined $el) {
        return $el->lookup_prefix ($_[1]);
      } else { 
        return undef;
      }
    }
  } # lookup_prefix
  
  sub normalize ($) {
    my $self = shift;
    my $ptext;
    local $Error::Depth = $Error::Depth + 1;
    
    ## Children
    my @remove;
    for my $cn ($self->child_nodes->to_list) {
      if ($cn->node_type == TEXT_NODE) {
        my $nv = $cn->node_value;
        if (length $nv) {
          if (defined $ptext) {
            $ptext->manakai_append_text ($nv);
            $ptext->is_element_content_whitespace (1)
              if $cn->is_element_content_whitespace and
                $ptext->is_element_content_whitespace;
            push @remove, $cn;
          } else {
            $ptext = $cn;
          }
        } else {
          push @remove, $cn;
        }
      } else {
        $cn->normalize;
        undef $ptext;
      }
    }
    $self->remove_child ($_) for @remove;
  
    my $nt = $self->node_type;
    if ($nt == ELEMENT_NODE) {
      ## Attributes
      $_->normalize for @{$self->attributes};
    } elsif ($nt == DOCUMENT_TYPE_NODE) {
      ## Element type definitions
      $_->normalize for @{$self->element_types};
      ## General entities
      $_->normalize for @{$self->general_entities};
    } elsif ($nt == ELEMENT_TYPE_DEFINITION_NODE) {
      ## Attribute definitions
      $_->normalize for @{$self->attribute_definitions};
    }
    ## TODO: normalize-characters
  
    ## TODO: In this implementation, if a modification raises a 
    ## |NO_MODIFICATION_ALLOWED_ERR|, then any modification before it
    ## is not reverted.
  } # normalize
  
  sub remove_child ($$) {
    my ($self, $old_child) = @_;
  
    if ($$self->{manakai_read_only} and
        ${$$self->{owner_document} or $self}->{strict_error_checking}) {
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
  
    my $parent_list = $$self->{child_nodes} || [];
    for (0..$#$parent_list) {
      if ($parent_list->[$_] eq $old_child) {
        splice @$parent_list, $_, 1, ();
        delete $$old_child->{parent_node};
        return $old_child;
      }
    }
  
    report Message::DOM::DOMException
        -object => $self,
        -type => 'NOT_FOUND_ERR',
        -subtype => 'NOT_CHILD_ERR';
  } # remove_child
  
  sub replace_child ($$) {
    ## NOTE: |Element|, |Entity|, |DocumentFragment|, |EntityReference|.
    ## NOTE: |Document|, |Attr|, |CharacterData|, |AttributeDefinition|,
    ## |Notation|, |ProcessingInstruction|, |ElementTypeDefinition|,
    ## and |DocumentType| define their own implementations.
    my $self = $_[0];
  
    ## NOTE: Depends on $self->node_type:
    my $self_od = $$self->{owner_document};
  
    ## -- Node Type check
    my @new_child;
    my $new_child_parent;
    if ($_[1]->node_type == DOCUMENT_FRAGMENT_NODE) {
      push @new_child, $_[1]->child_nodes->to_list;
      $new_child_parent = $_[1];
    } else {
      @new_child = ($_[1]);
      $new_child_parent = $_[1]->parent_node;
    }
  
    ## NOTE: Depends on $self->node_type:
    if ($$self_od->{strict_error_checking}) {
      my $child_od = $_[1]->owner_document || $_[1]; # might be DocumentType
      if ($self_od ne $child_od and $child_od->node_type != DOCUMENT_TYPE_NODE) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'WRONG_DOCUMENT_ERR',
            -subtype => 'EXTERNAL_OBJECT_ERR';
      }
  
      if ($$self->{manakai_read_only} or
          (@new_child and defined $new_child_parent and
           $$new_child_parent->{manakai_read_only})) {
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      ## NOTE: |Document| has children order check here.
  
      for my $cn (@new_child) {
        unless ({
                 TEXT_NODE, 1, ENTITY_REFERENCE_NODE, 1,
                 ELEMENT_NODE, 1, CDATA_SECTION_NODE, 1,
                 PROCESSING_INSTRUCTION_NODE, 1, COMMENT_NODE, 1,
                }->{$cn->node_type}) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'CHILD_NODE_TYPE_ERR';
        }
      }
  
      my $anode = $self;
      while (defined $anode) {
        if ($anode eq $_[1]) {
          report Message::DOM::DOMException
              -object => $self,
              -type => 'HIERARCHY_REQUEST_ERR',
              -subtype => 'ANCESTOR_NODE_ERR';
        }
        $anode = $$anode->{parent_node};
      }
    }
    
    ## -- Insert at... ## NOTE: Only in insertBefore and replaceChild
    my $index = -1; # last
    if (defined $_[2]) {
      ## error if $_[1] eq $_[2];
      
      my @cns = $self->child_nodes->to_list;
      C: {
        $index = 0;
        for my $i (0..$#cns) {
          my $cn = $cns[$i];
          if ($cn eq $_[2]) {
            $index += $i;
            last C;
          } elsif ($cn eq $_[1]) {
            $index = -1; # offset
          }
        }
        
        report Message::DOM::DOMException
            -object => $self,
            -type => 'NOT_FOUND_ERR',
            -subtype => 'NOT_CHILD_ERR';
      } # C
    } else {
      ## NOTE: Only in replaceChild
      report Message::DOM::DOMException
          -object => $self,
          -type => 'NOT_FOUND_ERR',
          -subtype => 'NOT_CHILD_ERR';
    }
  
    ## -- Removes from parent
    if ($new_child_parent) {
      if (@new_child == 1) {
        my $v = $$new_child_parent->{child_nodes};
        RP: for my $i (0..$#$v) {
          if ($v->[$i] eq $new_child[0]) {
            splice @$v, $i, 1, ();
            last RP;
          }
        } # RP
      } else {
        @{$$new_child_parent->{child_nodes}} = ();
      }
    }
  
    ## -- Rewrite the |parentNode| properties
    for my $nc (@new_child) {
      $$nc->{parent_node} = $self;
      Scalar::Util::weaken ($$nc->{parent_node});
    }
  
    ## NOTE: Depends on method:
    splice @{$$self->{child_nodes}}, $index, 1, @new_child;
    delete ${$_[2]}->{parent_node};
  
    ## NOTE: Setting |owner_document| in |Document|.
  
    return $_[2];
  } # replace_child
  
  sub manakai_set_read_only ($;$$) {
    my $value = 1 if $_[1];
    if ($_[2]) {
      my @target = ($_[0]);
      while (@target) {
        my $target = shift @target;
        if ($value) {
          $$target->{manakai_read_only} = 1;
        } else {
          delete $$target->{manakai_read_only};
        }
        push @target, $target->child_nodes->to_list;
        
        my $nt = $target->node_type;
        if ($nt == ELEMENT_NODE) {
          push @target, @{$target->attributes};
        } elsif ($nt == ELEMENT_TYPE_DEFINITION_NODE) {
          push @target, @{$target->attribute_definitions};
        } elsif ($nt == DOCUMENT_TYPE_NODE) {
          push @target, @{$target->element_types};
          push @target, @{$target->general_entities};
          push @target, @{$target->notations};
        }
      }
    } else { # not deep
      if ($value) {
        ${$_[0]}->{manakai_read_only} = 1;
      } else {
        delete ${$_[0]}->{manakai_read_only};
      }
    }
  } # manakai_set_read_only
  
  #        {NOTE:: Perl application developers are advised to be careful
  #                to include direct or indirect references to the node
  #                itself as user data or in user data handlers.
  #                They would result in memory leak problems unless
  #                the circular references are removed later.
  #                
  #                It would be a good practive to eusure that every user data
  #                registered to a node is later unregistered by setting
  #                <DOM::null> as a data for the same key.
  #
  sub set_user_data ($$;$$) {
    my ($self, $key, $data, $handler) = @_;
  
    my $v = ($$self->{user_data} ||= {});
    my $r = $v->{$key}->[0];
  
    if (defined $data) {
      $v->{$key} = [$data, $handler];
  
      if (defined $handler) {
        eval q{
          no warnings;
          sub DESTROY {
            my $uds = ${$_[0]}->{user_data};
            for my $key (keys %$uds) {
              if (defined $uds->{$key}->[1]) {
                local $Error::Depth = $Error::Depth + 1;
                $uds->{$key}->[1]->(3, $key, $uds->{$key}->[0]); # NODE_DELETED
              }
            }
          }
        };
      }
    } else {
      delete $v->{$key};
    }
    return $r;
  } # set_user_data
  
  package Message::IF::Node;
  package Message::IF::NSResolver;
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2008/10/21 07:51:59 $
MESSAGE_DOM_NODE

$fatpacked{"Message/DOM/NodeList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_NODELIST';
  package Message::DOM::NodeList;
  use strict;
  use warnings;
  our $VERSION = '2.0';
  push our @ISA, 'Tie::Array', 'Message::IF::NodeList';
  require Message::DOM::DOMException;
  require Tie::Array;
  use Carp;
  
  use overload
      '@{}' => sub {
        tie my @list, ref $_[0], $_[0];
        return \@list;
      },
      eq => sub {
        return 0 unless UNIVERSAL::isa ($_[1], 'Message::DOM::NodeList');
        return $${$_[0]} eq $${$_[1]};
      },
      ne => sub {
        return not ($_[0] eq $_[1]);
      },
      fallback => 1;
  
  sub TIEARRAY ($$) { $_[1] }
  
  sub STORE {
    croak "Modification of a read-only value attempted";
  } # STORE
  
  sub STORESIZE {
    croak "Modification of a read-only value attempted";
  } # STORESIZE
  
  sub to_list ($) {
    return (@{$_[0]});
  } # to_list
  
  sub to_a ($) {
    return [@{$_[0]}];
  } # to_a
  
  ## For compatibility with Template::Iterator in Template Toolkit.
  ## Don't use for any ohter purpose.
  sub as_list ($) {
    return $_[0]->to_a;
  } # as_list
  
  package Message::DOM::NodeList::ChildNodeList;
  push our @ISA, 'Message::DOM::NodeList';
  
  ## NOTE: |Message::DOM::CSSRuleList| has similar codes to this package.
  
  sub ___report_error ($$) {
    $_[1]->throw;
  } # ___report_error
  
  ## |NodeList| attributes
  
  sub EXISTS ($$) {
    return exists ${$${$_[0]}}->{child_nodes}->[$_[1]];
  } # EXISTS
  
  sub length ($) {
    return scalar @{${$${$_[0]}}->{child_nodes}};
  } # length
  
  *FETCHSIZE = \&length;
  
  sub manakai_read_only ($) {
    local $Error::Depth = $Error::Depth + 1;
    return $${$_[0]}->manakai_read_only;
  } # manakai_read_only
  
  ## |NodeList| methods
  
  sub item ($$) {
    my $index = 0+$_[1];
    return undef if $index < 0;
    return ${$${$_[0]}}->{child_nodes}->[$index];
  } # item
  
  sub FETCH ($$) {
    return ${$${$_[0]}}->{child_nodes}->[$_[1]];
  } # FETCH
  
  sub to_list ($) {
    return @{${$${$_[0]}}->{child_nodes}};
  } # to_list
  
  sub to_a ($) {
    return [@{${$${$_[0]}}->{child_nodes}}];
  } # to_a
  
  sub CLEAR ($) {
    my $self = $_[0];
    my $list = ${$$$self}->{child_nodes};
  
    local $Error::Depth = $Error::Depth + 1;
    for (my @a = @$list) {
      $$$self->remove_child ($_);
    }
  } # CLEAR
  
  package Message::DOM::NodeList::EmptyNodeList;
  push our @ISA, 'Message::DOM::NodeList';
  
  sub ___report_error ($$) {
    $_[1]->throw;
  } # ___report_error
  
  ## |NodeList| attributes
  
  sub EXISTS ($$) { 0 }
  
  sub length ($) { 0 }
  
  *FETCHSIZE = \&length;
  
  sub manakai_read_only ($) { 1 }
  
  ## |NodeList| methods
  
  sub item ($$) { undef }
  
  *FETCH = \&item;
  
  sub to_list ($) {
    return ();
  } # to_list
  
  sub to_a ($) {
    return [];
  } # to_a
  
  package Message::DOM::NodeList::GetElementsList;
  push our @ISA, 'Message::DOM::NodeList::EmptyNodeList';
  
  sub ___report_error ($$) {
    $_[1]->throw;
  } # ___report_error
  
  sub length ($) {
    my $self = $_[0];
    my $r = 0;
  
    ## TODO: Improve!
    local $Error::Depth = $Error::Depth + 1;
    my @target = $$self->[0]->child_nodes->to_list;
    while (@target) {
      my $target = shift @target;
      if ($target->node_type == 1) { # ELEMENT_NODE
        if ($$self->[1]->($target)) {
          $r++;
        }
      }
      unshift @target, @{$target->child_nodes};
    }
  
    return $r;
  } # length
  *FETCHSIZE = \&length;
  
  sub to_list ($) {
    return (@{$_[0]});
  } # to_list
  
  sub to_a ($) {
    return [@{$_[0]}];
  } # to_a
  
  sub item ($;$) {
    my $self = $_[0];
    my $index = 0+($_[1] or 0);
  
    ## TODO: Improve!
    local $Error::Depth = $Error::Depth + 1;
    my @target = @{$$self->[0]->child_nodes};
    my $i = -1;
    while (@target) {
      my $target = shift @target;
      if ($target->node_type == 1) { # ELEMENT_NODE
        if ($$self->[1]->($target)) {
          if (++$i == $index) {
            return $target;
          }
        }
      }
      unshift @target, @{$target->child_nodes};
    }
  
    return undef;
  } # item
  *FETCH = \&item;
  
  sub EXISTS ($$) {
    return defined $_[0]->item ($_[1]);
  } # EXISTS
  
  package Message::DOM::NodeList::StaticNodeList;
  push our @ISA, 'Message::IF::StaticNodeList';
  
  sub ____new_from_arrayref {
    my $list = bless $_[1], $_[0];
    Internals::SvREADONLY (@$list, 1);
    Internals::SvREADONLY ($_, 1) for @$list;
    return $list;
  } # ____new_from_arrayref
  
  ## |NodeList| attributes
  
  sub length ($) {
    return scalar @{$_[0]};
  } # length
  
  sub manakai_read_only () { 0 }
  
  ## |NodeList| methods
  
  sub item ($;$) {
    my $index = int ($_[1] or 0);
    return $_[0]->[$index] if $index >= 0;
  } # item
  
  sub to_a ($) {
    return [@{$_[0]}];
  } # to_a
  
  sub to_list ($) {
    return @{$_[0]};
  } # to_list
  
  sub as_list ($) {
    return [@{$_[0]}];
  } # as_list
  
  package Message::IF::NodeList;
  
  package Message::IF::StaticNodeList;
  push our @ISA, 'Message::IF::NodeList';
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
MESSAGE_DOM_NODELIST

$fatpacked{"Message/DOM/ProcessingInstruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_PROCESSINGINSTRUCTION';
  package Message::DOM::ProcessingInstruction;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.11 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::DOM::Node', 'Message::IF::ProcessingInstruction';
  require Message::DOM::Node;
  
  sub ____new ($$$$) {
    my $self = shift->SUPER::____new (shift);
    ($$self->{target}, $$self->{data}) = @_;
    return $self;
  } # ____new
               
  sub AUTOLOAD {
    my $method_name = our $AUTOLOAD;
    $method_name =~ s/.*:://;
    return if $method_name eq 'DESTROY';
  
    if ({
      ## Read-only attributes (trivial accessors)
      target => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$) {
          return \${\$_[0]}->{$method_name}; 
        }
      };
      goto &{ $AUTOLOAD };
    } elsif ({
      ## Read-write attributes (DOMString, trivial accessors)
      manakai_base_uri => 1,
    }->{$method_name}) {
      no strict 'refs';
      eval qq{
        sub $method_name (\$;\$) {
          if (\@_ > 1) {
            if (\${\${\$_[0]}->{owner_document}}->{strict_error_checking} and
                \${\$_[0]}->{manakai_read_only}) {
              report Message::DOM::DOMException
                  -object => \$_[0],
                  -type => 'NO_MODIFICATION_ALLOWED_ERR',
                  -subtype => 'READ_ONLY_NODE_ERR';
            }
            if (defined \$_[1]) {
              \${\$_[0]}->{$method_name} = ''.\$_[1];
            } else {
              delete \${\$_[0]}->{$method_name};
            }
          }
          return \${\$_[0]}->{$method_name};
        }
      };
      goto &{ $AUTOLOAD };
    } else {
      require Carp;
      Carp::croak (qq<Can't locate method "$AUTOLOAD">);
    }
  } # AUTOLOAD
  
  ## |Node| attributes
  
  sub base_uri ($) {
    my $self = $_[0];
    return $$self->{manakai_base_uri} if defined $$self->{manakai_base_uri};
    
    local $Error::Depth = $Error::Depth + 1;
    my $node = $$self->{parent_node};
    while (defined $node) {
      my $nt = $node->node_type;
      if ($nt == 1 or $nt == 6 or $nt == 9 or $nt == 10 or $nt == 11) {
        ## Element, Entity, Document, DocumentType, or DocumentFragment
        return $node->base_uri;
      } elsif ($nt == 5) {
        ## EntityReference
        return $node->manakai_entity_base_uri if $node->manakai_external;
      }
      $node = $$node->{parent_node};
    }
    return $node->base_uri if $node;
    return $self->owner_document->base_uri;
  } # base_uri
  
  sub child_nodes ($) {
    require Message::DOM::NodeList;
    return bless \\($_[0]), 'Message::DOM::NodeList::EmptyNodeList';
  } # child_nodes
  
  *node_name = \&target;
  
  sub node_type () { 7 } # PROCESSING_INSTRUCTION_NODE
  
  *node_value = \&data;
  
  *text_content = \&node_value;
  
  ## |Node| methods
  
  sub append_child ($$) {
    report Message::DOM::DOMException
        -object => $_[0],
        -type => 'HIERARCHY_REQUEST_ERR',
        -subtype => 'CHILD_NODE_TYPE_ERR';
  } # append_child
  
  sub manakai_append_text ($$) {
    ## NOTE: Same as |CharacterData|'s.
    if (${${$_[0]}->{owner_document}}->{strict_error_checking} and
        ${$_[0]}->{manakai_read_only}) {
      report Message::DOM::DOMException
          -object => $_[0],
          -type => 'NO_MODIFICATION_ALLOWED_ERR',
          -subtype => 'READ_ONLY_NODE_ERR';
    }
    ${$_[0]}->{data} .= ref $_[1] eq 'SCALAR' ? ${$_[1]} : $_[1];
  } # manakai_append_text
  
  sub insert_before ($;$) {
    report Message::DOM::DOMException
        -object => $_[0],
        -type => 'HIERARCHY_REQUEST_ERR',
        -subtype => 'CHILD_NODE_TYPE_ERR';
  } # insert_before
  
  sub replace_child ($$) {
    report Message::DOM::DOMException
        -object => $_[0],
        -type => 'HIERARCHY_REQUEST_ERR',
        -subtype => 'CHILD_NODE_TYPE_ERR';
  } # replace_child
  
  ## |ProcessingInstruction| attributes
  
  sub manakai_base_uri ($;$);
  
  sub data ($;$) {
    if (@_ > 1) {
      if (${${$_[0]}->{owner_document}}->{strict_error_checking} and
          ${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
      
      if (defined $_[1]) {
        ${$_[0]}->{data} = ''.$_[1];
      } else {
        ${$_[0]}->{data} = '';
      }
    }
  
    return ${$_[0]}->{data};
  } # data
  
  sub target ($);
  
  package Message::IF::ProcessingInstruction;
  
  package Message::DOM::Document;
  
  sub create_processing_instruction ($$$) {
    if (${$_[0]}->{strict_error_checking}) {
      my $xv = $_[0]->xml_version;
      if (defined $xv) {
        if ($xv eq '1.0' and
            $_[1] =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/) {
          #
        } elsif ($xv eq '1.1' and
                 $_[1] =~ /\A\p{InXMLNameStartChar11}\p{InXMLNameChar11}*\z/) {
          #
        } else {
          report Message::DOM::DOMException
              -object => $_[0],
              -type => 'INVALID_CHARACTER_ERR',
              -subtype => 'MALFORMED_NAME_ERR';
        }
      }
    }
  
    return Message::DOM::ProcessingInstruction->____new (@_[0, 1, 2]);
  } # create_processing_instruction
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2007/07/29 03:49:00 $
MESSAGE_DOM_PROCESSINGINSTRUCTION

$fatpacked{"Message/DOM/SelectorsAPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_SELECTORSAPI';
  package Message::DOM::SelectorsAPI;
  use strict;
  use warnings;
  our $VERSION = '1.12';
  
  require Message::DOM::DOMException;
  
  ## NOTE: This implementation does no optimization at all.  Future
  ## revisions are expected to do it, but the current focus is
  ## implementing the features rather than tuning some of them.
  
  package Message::DOM::Document;
  
  use Whatpm::CSS::SelectorsParser qw(:match :combinator :selector);
  
  my $sss_match;
  $sss_match = sub ($$$$) {
    my ($self, $sss, $node, $current_node, $is_html) = @_;
  
    my $sss_matched = 1;
    for my $simple_selector (@{$sss}) {
      if ($simple_selector->[0] == LOCAL_NAME_SELECTOR) {
              if ($simple_selector->[1] eq
                  $node->manakai_local_name) {
                #
              } elsif ($is_html) {
                my $nsuri = $node->namespace_uri;
                if (defined $nsuri and
                    $nsuri eq q<http://www.w3.org/1999/xhtml>) {
                  if (lc $simple_selector->[1] eq
                      $node->manakai_local_name) {
                    ## TODO: What kind of case-insensitivility?
                    ## TODO: Is this checking method OK?
                    #
                  } else {
                    $sss_matched = 0;
                  }
                } else {
                  $sss_matched = 0;
                }
              } else {
                $sss_matched = 0;
              }
            } elsif ($simple_selector->[0] == NAMESPACE_SELECTOR) {
              my $nsuri = $node->namespace_uri;
              if (defined $simple_selector->[1]) {
                if (defined $nsuri and $nsuri eq $simple_selector->[1]) {
                  #
                } else {
                  $sss_matched = 0;
                }
              } else {
                if (defined $nsuri) {
                  $sss_matched = 0;
                }
              }
      } elsif ($simple_selector->[0] == CLASS_SELECTOR) {
        M: {
          my $class_name = $node->can('class_name') ? $node->class_name : '';
          $class_name = '' unless defined $class_name;
          for (grep length, split /[\x09\x0A\x0C\x0D\x20]/, $class_name, -1) {
            if ($simple_selector->[1] eq $_) {
              last M;
            }
          }
          $sss_matched = 0;
        } # M
      } elsif ($simple_selector->[0] == ID_SELECTOR) {
        my $el = $node->owner_document->get_element_by_id ($simple_selector->[1]);
        $sss_matched = $el eq $node;
      } elsif ($simple_selector->[0] == ATTRIBUTE_SELECTOR) {
              my @attr_node;
              ## Namespace URI
              if (not defined $simple_selector->[1]) {
                my $ln = $simple_selector->[2];
                if ($is_html) {
                  my $nsuri = $node->namespace_uri;
                  if (defined $nsuri and
                      $nsuri eq q<http://www.w3.org/1999/xhtml>) {
                    $ln =~ tr/A-Z/a-z/; ## ISSUE: Case-insensitivity
                  }
                }
  
                ## Any Namespace, Local Name
                M: {
                  for my $attr_node (@{$node->attributes}) {
                    my $node_ln = $attr_node->manakai_local_name;
                    if ($node_ln eq $simple_selector->[2]) {
                      push @attr_node, $attr_node;
                      last M if $simple_selector->[3] == EXISTS_MATCH;
                    } elsif (not defined $attr_node->namespace_uri and
                             $node_ln eq $ln) {
                      push @attr_node, $attr_node;
                      last M if $simple_selector->[3] == EXISTS_MATCH;
                    }
                  }
                  last M if @attr_node;
                  $sss_matched = 0;
                } # M
              } elsif ($simple_selector->[1] eq '') {
                my $ln = $simple_selector->[2];
                if ($is_html) {
                  my $nsuri = $node->namespace_uri;
                  if (defined $nsuri and
                      $nsuri eq q<http://www.w3.org/1999/xhtml>) {
                    $ln =~ tr/A-Z/a-z/; ## ISSUE: Case-insensitivity
                  }
                }
  
                ## ISSUE: Does <p>.setAttributeNS (undef, 'Align')'ed <p>
                ## match with [align]?
  
                ## Null Namespace, Local Name
                my $attr_node = $node->get_attribute_node_ns
                    (undef, $ln);
                if ($attr_node) {
                  push @attr_node, $attr_node;
                } else {
                  $sss_matched = 0;
                }
              } else {
                ## Non-null Namespace, Local Name
                my $attr_node = $node->get_attribute_node_ns
                        ($simple_selector->[1], $simple_selector->[2]);
                if ($attr_node) {
                  push @attr_node, $attr_node;
                } else {
                  $sss_matched = 0;
                }
              }
  
        if ($sss_matched) {
          if ($simple_selector->[3] == EXISTS_MATCH) {
            #
          } else {
            for my $attr_node (@attr_node) {
              ## TODO: Attribute value case-insensitivility
              my $value = $attr_node->value;
              if ($simple_selector->[3] == EQUALS_MATCH) {
                if ($value eq $simple_selector->[4]) {
                  #
                } else {
                  $sss_matched = 0;
                }
              } elsif ($simple_selector->[3] == DASH_MATCH) {
                ## ISSUE: [a|=""] a="a--b" a="-" ?
                if ($value eq $simple_selector->[4]) {
                  #
                } elsif (substr ($value, 0,
                                 1 + length $simple_selector->[4]) eq
                         $simple_selector->[4] . '-') {
                  #
                } else {
                  $sss_matched = 0;
                }
              } elsif ($simple_selector->[3] == INCLUDES_MATCH) { # ~=
                M: {
                  for (split /[\x09\x0A\x0C\x0D\x20]+/, $value, -1) {
                    next unless length;
                    if ($_ eq $simple_selector->[4]) {
                      last M;
                    }
                  }
                  $sss_matched = 0;
                } # M
              } elsif ($simple_selector->[3] == PREFIX_MATCH) {
                if (length $simple_selector->[4] and
                    $simple_selector->[4] eq
                        substr ($value, 0, length $simple_selector->[4])) {
                  #
                } else {
                  $sss_matched = 0;
                }
              } elsif ($simple_selector->[3] == SUFFIX_MATCH) {
                if (length $simple_selector->[4] and
                    $simple_selector->[4] eq
                        substr ($value, -length $simple_selector->[4])) {
                  #
                } else {
                  $sss_matched = 0;
                }
              } elsif ($simple_selector->[3] == SUBSTRING_MATCH) {
                if (length $simple_selector->[4] and
                    index ($value, $simple_selector->[4]) > -1) {
                  #
                } else {
                  $sss_matched = 0;
                }
              } else {
                ## NOTE: New match type.
                report Message::DOM::DOMException
                    -object => $self,
                    -type => 'SYNTAX_ERR',
                    -subtype => 'INVALID_SELECTORS_ERR';
              }
            }
          }
        }
      } elsif ($simple_selector->[0] == PSEUDO_CLASS_SELECTOR) {
        my $class_name = $simple_selector->[1];
        if ($class_name eq 'not') {
          if ($sss_match->($self, [@$simple_selector[2..$#$simple_selector]],
                           $node, $current_node, $is_html)) {
            $sss_matched = 0;
          }
        } elsif ({
          'nth-child' => 1, 'nth-last-child' => 1,
          'nth-of-type' => 1, 'nth-last-of-type' => 1,
          'first-child' => 1, 'last-child' => 1,
          'first-of-type' => 1, 'last-of-type' => 1,
        }->{$class_name}) {
          my $aa = $class_name =~ /^first/ ? 0
                 : $class_name =~ /^last/ ? 0
                 : $simple_selector->[2];
          my $ab = $class_name =~ /^first/ ? 1
                 : $class_name =~ /^last/ ? 1
                 : $simple_selector->[3];
          my $parent = $node->parent_node;
          if ($parent) {
  
            ## O(n^2) (or O(nm) where /m/ is the average number of
            ## children, more strictly speaking) as a whole, which seems
            ## bad...
            my $i = 0;
            my @child = @{$parent->child_nodes};
            @child = reverse @child if $class_name =~ /last/;
            for (@child) {
              next unless $_->node_type == 1; # ELEMENT_NODE
              next if $class_name =~ /of-type/ and
                  not $_->manakai_element_type_match
                          ($node->namespace_uri, $node->manakai_local_name);
              $i++;
              last if $_ eq $node;
            }
  
            if ($aa == 0) {
              $sss_matched = 0 if $i != $ab;
            } else {
              my $j = $i - $ab;
              if ($aa > 0) {
                $sss_matched = 0 if $j % $aa or $j / $aa < 0;
              } else { # $aa < 0
                $sss_matched = 0 if -$j % -$aa or -$j / -$aa < 0;
              }
            }
          } else {
            $sss_matched = 0;
          }
        } elsif ($class_name eq 'only-child' or $class_name eq 'only-of-type') {
          my $parent = $node->parent_node;
          if ($parent) {
            my $i = 0;
            for (@{$parent->child_nodes}) {
              if ($_->node_type == 1) { # ELEMENT_NODE
                if ($class_name eq 'only-of-type') {
                  $i++ if $_->manakai_element_type_match
                      ($node->namespace_uri, $node->manakai_local_name);
                } else {
                  $i++;
                }
                if ($i == 2) {
                  $sss_matched = 0;
                  last;
                }
              }
            }
          } else {
            $sss_matched = 0;
          }
        } elsif ($class_name eq 'empty') {
          for (@{$node->child_nodes}) {
            my $nt = $_->node_type;
            if ($nt == 1) { # ELEMENT_NODE
              $sss_matched = 0;
              last;
            } elsif ($nt == 3 or $nt == 4) { # TEXT_NODE, CDATA_SECTION_NODE
              my $length = length $_->data;
              if ($length) {
                $sss_matched = 0;
                last;
              }
            }
          }
        } elsif ($class_name eq 'root') {
          my $parent = $node->parent_node;
          $sss_matched = 0
              unless $parent->node_type == 9; # DOCUMENT_NODE
        } elsif ($class_name eq '-manakai-current') {
          $sss_matched = 0 if $current_node ne $node;
        } elsif ($class_name eq '-manakai-contains') {
          $sss_matched = 0
              if index ($node->text_content,
                        $simple_selector->[2]) == -1;
        } else {
          ## This statement should never be executed.
          die "$class_name: Bad pseudo-class";
        }
      } elsif ($simple_selector->[0] == PSEUDO_ELEMENT_SELECTOR) {
        $sss_matched = 0;
      } else {
        ## NOTE: New simple selector type.
        report Message::DOM::DOMException
            -object => $self,
            -type => 'SYNTAX_ERR',
            -subtype => 'INVALID_SELECTORS_ERR';
      }
    }
    return $sss_matched;
  }; # $sss_match
  
  my $get_elements_by_selectors = sub {
    # $node, $selectors, $resolver, $node_conds, $is_html, $all, $current
  
    my $p = Whatpm::CSS::SelectorsParser->new;
  
    my $selectors;
    if (ref $_[1] eq 'ARRAY') {
      $selectors = $_[1];
    } else {
      my $ns_error;
      my $resolver = $_[2] || sub { return undef };
    if (UNIVERSAL::can ($_[2], 'lookup_namespace_uri')) {
      my $re = $resolver;
      $resolver = sub {
        local $Error::Depth = $Error::Depth + 1;
        return $re->lookup_namespace_uri ($_[0]);
      };
    }
    $p->{lookup_namespace_uri} = sub {
      local $Error::Depth = $Error::Depth + 2;
      ## NOTE: MAY assume that $resolver returns consistent results.
      ## NOTE: MUST be case-sensitive.
      if (defined $_[0] and $_[0] ne '') {
        my $uri = $resolver->($_[0]);
        if (defined $uri) {
          $uri = ''.$uri;
          if ($uri eq '') {
            return '';
          } else {
            return $uri;
          }
        } else {
          $ns_error = $_[0];
          return undef;
        }
      } else {
        my $uri = $resolver->(undef);
        if (defined $uri) {
          $uri = ''.$uri;
          if ($uri eq '') {
            return '';
          } else {
            return $uri;
          }
        } else {
          return undef;
        }
      }
    }; # lookup_namespace_uri
  
    ## NOTE: SHOULD ensure to remain stable when facing a hostile $_[2].
  
    $p->{pseudo_class}->{$_} = 1 for qw/
      root nth-child nth-last-child nth-of-type nth-last-of-type
      first-child first-of-type last-child last-of-type
      only-child only-of-type empty
      not
      -manakai-contains -manakai-current
    /;
  #    active checked disabled enabled focus hover indeterminate link
  #    target visited lang
  
    ## NOTE: MAY treat all links as :link rather than :visited
  
    $p->{pseudo_element}->{$_} = 1 for qw/
      after before first-letter first-line
    /;
  
    $selectors = $p->parse_string (''.$_[1]);
    unless (defined $selectors) {
      local $Error::Depth = $Error::Depth - 1;
      # MUST
      if (defined $ns_error) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NAMESPACE_ERR',
            -subtype => 'UNDECLARED_PREFIX_ERR',
            namespace_prefix => $ns_error;
      } else { 
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'SYNTAX_ERR',
            -subtype => 'INVALID_SELECTORS_ERR';
      }
    }
    }
  
    my $is_html = $_[4];
    my $r;
    $r = [] if $_[5];
    
    my @node_cond = map {$_->[1] = [@$selectors]; $_} @{$_[3]};
    while (@node_cond) {
      $Message::DOM::SelectorsAPI::NodeCount++;
      my $node_cond = shift @node_cond;
      if ($node_cond->[0]->node_type == 1) { # ELEMENT_NODE
        my @new_cond;
        my $matched;
        for my $selector (@{$node_cond->[1]}) {
          if ($sss_match->($_[0], $selector->[1], $node_cond->[0], $_[6],
                           $is_html)) {
            if (@$selector == 2) {
              unless ($node_cond->[3]) {
                return $node_cond->[0] unless defined $r;
                push @$r, $node_cond->[0] unless $matched;
                $matched = 1;
              }
            } else {
              my $new_selector = [@$selector[2..$#$selector]];
              if ($new_selector->[0] == DESCENDANT_COMBINATOR or
                  $new_selector->[0] == CHILD_COMBINATOR) {
                push @new_cond, $new_selector;
              } else { # ADJACENT_SIBLING_COMBINATOR | GENERAL_SIBLING_COMBINATOR
                push @{$node_cond->[2]->[1] || []}, $new_selector;
              }
            }
          }
          if ($selector->[0] == DESCENDANT_COMBINATOR) {
            push @new_cond, $selector;
          } elsif ($selector->[0] == GENERAL_SIBLING_COMBINATOR) {
            push @{$node_cond->[2]->[1] || []}, $selector;
          } elsif ($selector->[0] == CHILD_COMBINATOR or
                   $selector->[0] == ADJACENT_SIBLING_COMBINATOR) {
            #
          } else {
            ## NOTE: New combinator.
            report Message::DOM::DOMException
                -object => $_[0],
                -type => 'SYNTAX_ERR',
                -subtype => 'INVALID_SELECTORS_ERR';
          }
        }
  
        if (@new_cond) {
          unless ($node_cond->[3]) {
            my @children = grep { # ELEMENT_NODE or ENTITY_REFERENCE_NODE
              $_->node_type == 1 or $_->node_type == 5
            } @{$node_cond->[0]->child_nodes};
            my $next_sibling_cond;
            for (reverse @children) {
              my $new_node_cond = [$_, [@new_cond], $next_sibling_cond];
              unshift @node_cond, $new_node_cond;
              $next_sibling_cond = $new_node_cond;
            }
          } else {
            for (@{$node_cond->[4]}) {
              $_->[1] = [@new_cond];
            }
            $node_cond->[4]->[0]->[1] = \@new_cond if @{$node_cond->[4]};
          }
        }
      } elsif ($node_cond->[0]->node_type == 5) { # ENTITY_REFERENCE_NODE
        my @new_cond = @{$node_cond->[1]};
        my @new_cond2 = grep {
          $_->[0] != ADJACENT_SIBLING_COMBINATOR and
          $_->[0] != GENERAL_SIBLING_COMBINATOR
        } @new_cond;
        unless ($node_cond->[3]) {
          my @children = grep { # ELEMENT_NODE or ENTITY_REFERENCE_NODE
            $_->node_type == 1 or $_->node_type == 5
          } @{$node_cond->[0]->child_nodes};
          my $next_sibling_cond;
          for (reverse @children) {
            my $new_node_cond = [$_, [@new_cond2], $next_sibling_cond];
            unshift @node_cond, $new_node_cond;
            $next_sibling_cond = $new_node_cond;
          }
          $next_sibling_cond->[1] = \@new_cond;
        } else {
          for (@{$node_cond->[4]}) {
            $_->[1] = [@new_cond2];
          }
          $node_cond->[4]->[0]->[1] = \@new_cond if @{$node_cond->[4]};
        }
      }
    }
  
    if ($r) {
      require Message::DOM::NodeList;
      $r = Message::DOM::NodeList::StaticNodeList->____new_from_arrayref ($r);
    }
  
    return $r;
  }; # $get_elements_by_selectors
  
  sub query_selector ($$;$) {
    local $Error::Depth = $Error::Depth + 1;
  
    ## Children of the Element.
    my @node_cond;
    my @children = grep { # ELEMENT_NODE or ENTITY_REFERENCE_NODE
      $_->node_type == 1 or $_->node_type == 5
    } @{$_[0]->child_nodes};
    my $next_sibling_cond;
    for (reverse @children) {
      my $new_node_cond = [$_, undef, $next_sibling_cond];
      unshift @node_cond, $new_node_cond;
      $next_sibling_cond = $new_node_cond;
    }
  
    return $get_elements_by_selectors
        ->($_[0], ''.$_[1], $_[2], \@node_cond,
           $_[0]->manakai_is_html, 0, 0);
  } # query_selector
  
  sub query_selector_all ($$;$) {
    local $Error::Depth = $Error::Depth + 1;
  
    ## Children of the Element.
    my @node_cond;
    my @children = grep { # ELEMENT_NODE or ENTITY_REFERENCE_NODE
      $_->node_type == 1 or $_->node_type == 5
    } @{$_[0]->child_nodes};
    my $next_sibling_cond;
    for (reverse @children) {
      my $new_node_cond = [$_, undef, $next_sibling_cond];
      unshift @node_cond, $new_node_cond;
      $next_sibling_cond = $new_node_cond;
    }
  
    return $get_elements_by_selectors
        ->($_[0], ''.$_[1], $_[2], \@node_cond,
           $_[0]->manakai_is_html, 1, 0);
  } # query_selector_all
  
  ## NOTE: For internal use - $_[1] is a selectors object.
  sub ___query_selector_all ($$) {
    local $Error::Depth = $Error::Depth + 1;
  
    ## Children of the Element.
    my @node_cond;
    my @children = grep { # ELEMENT_NODE or ENTITY_REFERENCE_NODE
      $_->node_type == 1 or $_->node_type == 5
    } @{$_[0]->child_nodes};
    my $next_sibling_cond;
    for (reverse @children) {
      my $new_node_cond = [$_, undef, $next_sibling_cond];
      unshift @node_cond, $new_node_cond;
      $next_sibling_cond = $new_node_cond;
    }
  
    return $get_elements_by_selectors
        ->($_[0], $_[1], undef, \@node_cond,
           $_[0]->manakai_is_html, 1, 0);
  } # ___query_selector_all
  
  package Message::DOM::Element;
  
  my $get_node_cond = sub {
    my @node_cond;
    my $child_conds = [];
  
    ## Children of the Element.
    my @children = grep { # ELEMENT_NODE or ENTITY_REFERENCE_NODE
      $_->node_type == 1 or $_->node_type == 5
    } @{$_[0]->child_nodes};
    my $next_sibling_cond;
    for (reverse @children) {
      my $new_node_cond = [$_, undef, $next_sibling_cond];
      unshift @node_cond, $new_node_cond;
      $next_sibling_cond = $new_node_cond;
    }
    @$child_conds = @node_cond;
  
    ## Ancestors and previous siblings of ancestors
    my $node = $_[0];
    my $parent = $node->parent_node;
    while (defined $parent) {
      my $conds = [];
      for (grep { # ELEMENT_NODE or ENTITY_REFERENCE_NODE
        $_->node_type == 1 or $_->node_type == 5
      } @{$parent->child_nodes}) {
        push @$conds, my $cond = [$_, undef, undef, 1, $child_conds];
        if ($_ eq $node) {
          $child_conds = $conds;
          ($node, $parent) = ($parent, $parent->parent_node);
          last;
        }
      }
      my $nsib_cond;
      for (reverse @$child_conds) {
        $_->[2] = $nsib_cond;
        $nsib_cond = $_;
      }
      unshift @node_cond, @$conds;
    }
    if ($node->node_type == 1) { # ELEMENT_NODE
      unshift @node_cond, [$node, undef, undef, 1, $child_conds];
    }
  
    return \@node_cond;
  }; # $get_node_cond
  
  sub query_selector ($$;$) {
    local $Error::Depth = $Error::Depth + 1;
  
    return $get_elements_by_selectors
        ->($_[0], ''.$_[1], $_[2], $get_node_cond->($_[0]),
           $_[0]->owner_document->manakai_is_html, 0, $_[0]);
  } # query_selector
  
  sub query_selector_all ($$;$) {
    local $Error::Depth = $Error::Depth + 1;
  
    return $get_elements_by_selectors
        ->($_[0], ''.$_[1], $_[2], $get_node_cond->($_[0]),
           $_[0]->owner_document->manakai_is_html, 1, $_[0]);
  } # query_selector_all
  
  =head1 SEE ALSO
  
  Selectors <http://www.w3.org/TR/selectors/>.
  
  Selectors API Editor's Draft 29 August 2007
  <http://dev.w3.org/cvsweb/~checkout~/2006/webapi/selectors-api/Overview.html?rev=1.28&content-type=text/html;%20charset=utf-8>
  
  manakai Selectors Extensions
  <http://suika.fam.cx/gate/2005/sw/manakai/Selectors%20Extensions>
  
  =head1 LICENSE
  
  Copyright 2007-2011 Wakaba <w@suika.fam.cx>.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
MESSAGE_DOM_SELECTORSAPI

$fatpacked{"Message/DOM/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_DOM_TEXT';
  package Message::DOM::Text;
  use strict;
  our $VERSION=do{my @r=(q$Revision: 1.12 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  push our @ISA, 'Message::DOM::CharacterData', 'Message::IF::Text';
  require Message::DOM::CharacterData;
  
  ## |Node| attributes
  
  sub node_name () { '#text' }
  
  sub node_type () { 3 } # TEXT_NODE
  
  ## |Text| attributes
  
  sub is_element_content_whitespace ($;$) {
    if (@_ > 1) {
      ## TODO: Document how setter work
      if (${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      if ($_[1]) {
        ${$_[0]}->{is_element_content_whitespace} = 1;
      } else {
        delete ${$_[0]}->{is_element_content_whitespace};
      }
    }
    return ${$_[0]}->{is_element_content_whitespace};
  } # is_element_content_whitespace
  
  sub whole_text ($) {
    local $Error::Depth = $Error::Depth + 1;
    my $doc = $_[0]->owner_document;
    my $tw1 = $doc->create_tree_walker
        ($doc, 0xFFFFFFFF, sub { # SHOW_ALL ENTITY_REFERENCE_NODE
          ($_[0]->node_type == 5) ? 3 : 1; # FILTER_SKIP FILTER_ACCEPT
        }, 1);
    $tw1->current_node ($_[0]);
    
    my $tw2 = $tw1->clone;
    my $r = $_[0]->node_value;
  
    S: while (defined (my $node = $tw1->previous_sibling)) {
      my $nt = $node->node_type;
      if ($nt == 3 or $nt == 4) { # TEXT_NODE CDATA_SECTION_NODE
        $r = $node->node_value . $r;
      } else {
        last S;
      }
    } # S
  
    S: while (defined (my $node = $tw2->next_sibling)) {
      my $nt = $node->node_type;
      if ($nt == 3 or $nt == 4) { # TEXT_NODE CDATA_SECTION_NODE
        $r .= $node->node_value;
      } else {
        last S;
      }
    } # S
  
    return $r;
  
    ## TODO: Skipping |DocumentType| is manakai-extension.  Document it!
  } # whole_text
  
  ## |Text| methods
  
  ## TODO: replace_whole_text
  
  sub split_text ($;$) {
    my $parent = $_[0]->parent_node;
    if (${${$_[0]}->{owner_document}}->{strict_error_checking}) {
      if (${$_[0]}->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
  
      if (defined $parent and $$parent->{manakai_read_only}) {
        report Message::DOM::DOMException
            -object => $_[0],
            -type => 'NO_MODIFICATION_ALLOWED_ERR',
            -subtype => 'READ_ONLY_NODE_ERR';
      }
    }
  
    require Message::DOM::StringExtended;
    local $Error::Depth = $Error::Depth + 1;
    my $offset32 = Message::DOM::StringExtended::find_offset32
        (${$_[0]}->{data}, $_[1]);
    my $data2 = substr ${$_[0]}->{data}, $offset32;
  
    my $r = $_[0]->node_type == 3 # TEXT_NODE
        ? ${$_[0]}->{owner_document}->create_text_node ($data2)
        : ${$_[0]}->{owner_document}->create_cdata_section ($data2);
    $r->is_element_content_whitespace ($_[0]->is_element_content_whitespace);
    substr (${$_[0]}->{data}, $offset32) = '';
  
    if (defined $parent) {
      $parent->insert_before ($r, $_[0]->next_sibling);
    }
  
    return $r;
  } # split_text
  
  package Message::DOM::Text::CDATASection;
  push our @ISA, 'Message::DOM::Text', 'Message::IF::CDATASection';
  
  ## |Node| attributes
  
  sub node_name () { '#cdata-section' }
  
  sub node_type () { 4 } # CDATA_SECTION_NODE
  
  ## |Text| attribute
  
  sub is_element_content_whitespace () { 0 }
  
  package Message::IF::Text;
  package Message::IF::CDATASection;
  
  package Message::DOM::Document;
  
  sub create_cdata_section ($$) {
    return Message::DOM::Text::CDATASection->____new (@_[0, 1]);
  } # create_cdata_section
  
  sub create_text_node ($$) {
    return Message::DOM::Text->____new ($_[0], $_[1]);
  } # create_text_node
  
  =head1 LICENSE
  
  Copyright 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  ## $Date: 2007/07/29 08:31:14 $
MESSAGE_DOM_TEXT

$fatpacked{"Message/Util/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_UTIL_ERROR';
  package Message::Util::Error;
  use strict;
  our $VERSION = do{my @r=(q$Revision: 1.13 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  use Error;
  push our @ISA, 'Error';
  our $DEBUG;
  our $VERBOSE;
  
  sub import {
    shift;
    local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
    if (@_) {
      Error::subs->import(@_);
    } else {
      Error::subs->import (':try');
    }
  }
  
  sub ___error_def () {+{
   UNKNOWN => {
               -code => 0,
               -description => '"%name;": Unknown error',
              },
  }}
  
  sub ___get_error_def ($$) {
    my ($self, $name) = @_;
    my $err;
    warn ((ref $self or $self)."->___get_error_def ('$name')\n") if $DEBUG;
    $err = $self->___error_def->{$name} if $self->can ('___error_def');
    return $err if $err;
    no strict 'refs';
    for my $SUPER (@{(ref ($self) || $self).'::ISA'}) {
      if ($SUPER->can ('___get_error_def')) {
        $err = $SUPER->___get_error_def ($name);
        return $err if $err;
      }
    }
    return undef;
  }
  
  sub new ($;%) {
    my $class = shift;
    my %opt = @_;
    die qq(Error type is not specified) unless defined $opt{-type};
    $opt{-def} = $class->___get_error_def ($opt{-type})
              || $class->___get_error_def ('UNKNOWN')
              or die qq(Error definition for "$opt{-type}" not found);
  #  local $Error::Depth = $Error::Depth + 1;
    my $err = $class->SUPER::new (%opt);
    if ($Error::Debug or $DEBUG) {
      require Carp;
      #local $Carp::CarpLevel = $Error::Depth;
      local $Carp::CarpLevel = 1;
      $err->{-stacktrace_} = Carp::longmess ();
    } elsif ($VERBOSE) {
      require Carp;
      local $Carp::CarpLevel = $Error::Depth - 1;
      $err->{-stacktrace_} = Carp::longmess ();
    }
    return $err;
  }
  
  sub text {
    my $self = shift;
    my $template;
    if (defined $self->{-subtype}) {
      my $subtype_def = $self->{-def}->{-subtype}->{$self->{-subtype}};
      if (defined $subtype_def) {
        $template = $subtype_def->{-description};
      }
    }
    unless (defined $template) {
      $template = $self->{-def}->{-description};
    }
    unless (defined $template) {
      return $self->SUPER::text;
    }
    return $self->_FORMATTER_PACKAGE_->new->replace ($template, param => $self);
  } # text
  
  sub value ($) {
    my $self = shift;
    if (defined $self->{-def}->{-code}) {
      return $self->{-def}->{-code};
    } else {
      return $self->SUPER::value;
    }
  } # value
  
  sub code ($) {
    return shift->{-def}->{-code} || 0;
  } # code
  
  sub type ($) {
    return shift->{-type};
  } # type
  
  sub subtype ($) {
    return shift->{-subtype};
  } # subtype
  
  sub type_def ($) {
    return shift->{-def};
  } # type_def
  
  sub stringify {
    my $self = shift;
    my $text = $self->text;
    unless ($text =~ /\n$/s) {
      if ($Error::Debug or $DEBUG or $VERBOSE) {
        $text = defined $self->{-stacktrace_} ? $text . $self->{-stacktrace_}
                                              : Carp::longmess ($text);
      } else {
        $text .= sprintf " at %s line %d.\n", $self->file, $self->line;
      }
    }
    $text;
  }
  
  sub report ($;%) {
    my ($self, %opt) = @_;
    if (ref $opt{-object}) {
      local $Error::Depth = $Error::Depth + 3;
        # => obj->{method}
        # => mue->report
        # => err->new
      my $err;
      {
        local $@;
        $err = $self->new (%opt);
      }
      $opt{-object}->___report_error ($err);
    } else {
      local $Error::Depth = $Error::Depth + 2;
        # => {-object}->{method}
        # (=> ->report)
      throw $self %opt;
    }
  }
  
  sub throw ($@) {
    my $self = shift;
    local $Error::Depth = $Error::Depth + 2;
    $self->SUPER::throw (@_);
  }
  
  ## Disables since Error::associate makes looping reference
  sub associate {}
  
  sub _FORMATTER_PACKAGE_ () { 'Message::Util::Error::formatter' }
  
  package Message::Util::Error::formatter;
  use Message::Util::Formatter::Text;
  push our @ISA, q(Message::Util::Formatter::Text);
  sub ___rule_def () {+{
    name => {
      after => sub {
        my ($f, $name, $p, $o) = @_;
        $p->{-result} = $o->{-type};
      },
    },
    ## "t" is obsolete; use "p"
    t => {
      after => sub {
        my ($f, $name, $p, $o) = @_;
        $p->{name} =~ tr/-/_/;
        my $val = $o->{$p->{name}};
        if (defined $val) {
          if (length $val) {
            $p->{-result} = $val;
          } else {
            $p->{-result} = defined $p->{empty} ? $p->{empty} : '<empty>';
          }
        } else {
          $p->{-result} = defined $p->{undef} ? $p->{undef} : '<undef>';
        }
      },
    },
    p => {
      after => sub {
        my ($f, $name, $p, $o) = @_;
        my $val = $o->{$p->{name}};
        if (defined $val) {
          if (length $val) {
            $p->{-result} = $val;
          } else {
            $p->{-result} = defined $p->{empty} ? $p->{empty} : '<empty>';
          }
        } elsif (exists $o->{$p->{name}}) {
          $p->{-result} = defined $p->{undef} ? $p->{undef} : '<undef>';
        }
      },
    },
  }}
  
  =head1 LICENSE
  
  Copyright 2003-2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1; # $Date: 2007/06/16 05:30:37 $
MESSAGE_UTIL_ERROR

$fatpacked{"Message/Util/Formatter/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_UTIL_FORMATTER_BASE';
  
  =head1 NAME
  
  Message::Util::Formatter::Base - Formatting Template Text Replacement Engine
  
  =head1 DESCRIPTION
  
  C<Message::Util::Formatter::Base> is a base class to implement specific
  application of "formatting."
  
  This module is part of manakai.
  
  =cut
  
  package Message::Util::Formatter::Base;
  use strict;
  our $VERSION = do{my @r=(q$Revision: 1.8 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  
  sub ___rule_def () {+{
    -bare_text => {
                   
    },
    -undef     => {
               
    },
    -default   => {
      pre => sub { },
      post => sub { },
      attr => sub { },                 
    },
    -entire    => {
      
    },
  }}
  
  sub ___get_rule_def ($$) {
    my ($self, $name) = @_;
    my $def;
    $def = $self->___rule_def->{$name} if $self->can ('___rule_def');
    return $def if $def;
    no strict 'refs';
    for my $SUPER (@{(ref ($self) || $self).'::ISA'}) {
      if ($SUPER->can ('___get_rule_def')) {
        $def = $SUPER->___get_rule_def ($name);
        return $def if $def;
      }
    }  
    return undef;
  }
  
  sub new ($;%) {
    my ($class, %opt) = @_;
    my $self = bless \%opt, $class;
    if (ref $self->{rule}) {
      if (ref $self->{rule} eq 'HASH') {
        my $rules = $self->{rule};
        $self->{rule} = sub { $rules->{$_[1]} };
      }
    } else {
      $self->{rule} = sub { $_[0]->___get_rule_def ($_[1]) };
    }
    $self;
  }
  
  {
  our $__QuoteBlockContent;
  $__QuoteBlockContent = qr/(?>[^{}]*)(?>(?>[^{}]+|{(??{$__QuoteBlockContent})})*)/;
  our $Token ||= qr/[\w_.+-]+/;
  my $WordM = qr(
                            ($Token)                    ## Bare
                         | {($__QuoteBlockContent)}     ## {Quoted}
                         | "([^"\\]*(?>[^"\\]+|\\.)*)"  ## "Quoted"
  )x;
  
  sub replace_option () {+{}}
  
  sub replace ($$;%) {
    my ($self, $format) = (shift, shift);
    my (%opt) = (%{$self->replace_option}, @_);
    my $defrule = $self->{rule}->($self, '-default');
    my $textrule = $self->{rule}->($self, '-bare_text');
    my $entirerule = $self->{rule}->($self, '-entire');
    local $opt{param}->{-formatter};
    local $opt{param}->{-result};
    ($entirerule->{pre}||=$defrule->{pre})->($self, '-entire',
                                            $opt{param}, $opt{param},
                                            option => \%opt);
    pos ($format) = 0;
    while (pos ($format) < length ($format)) {
      if ($format =~ /\G%([\w-]+)\s*/gc) { # ":" is reserved for QName
        my $name = $1;
        $name =~ tr/-/_/;
        my $rule = $self->{rule}->($self, $name)
                || $self->{rule}->($self, '-undef');
        my %attr;
        ($rule->{pre}||=$defrule->{pre})->($self, $name, \%attr, $opt{param},
                                           option => \%opt);
        $format =~ /\G\s+/gc;
        
        if ($format =~ /\G\(\s*/gc) {
          while (1) {
            if ($format =~ /\G$WordM\s*/gco) {
              my $attr_name = $+;
              $attr_name =~ s/\\(.)/$1/gs if defined $3; # "quoted"
              $attr_name =~ tr/-/_/;
              my $nflag;
              $nflag = $1 if $format =~ /\G($Token)\s*/goc;
              if ($format =~ /\G=>\s*$WordM\s*/gco) {
                my $attr_val = $+;
                $attr_val =~ s/\\(.)/$1/gs if defined $3; # "quoted"
                my $vflag;
                $vflag = $1 if $format =~ /\G(\w+)\s*/gc;
                ($rule->{attr}||=$defrule->{attr})->($self, $name,
                                                    \%attr, $opt{param},
                                                    $attr_name => $attr_val,
                                                    -name_flag => $nflag,
                                                    -value_flag => $vflag,
                                                    option => \%opt);
              } else {
                ($rule->{attr}||=$defrule->{attr})->($self, $name,
                                                    \%attr, $opt{param},
                                                    -boolean => $attr_name,
                                                    -name_flag => $nflag,
                                                    option => \%opt);
              }
            } # An attribute specification
            if ($format =~ /\G,\s*/gc) {
              next;
            } elsif ($format =~ /\G\)\s*/gc) {
              last;
            } else {
              throw Message::Util::Formatter::Base::error
                -type => 'ATTR_SEPARATOR_NOT_FOUND',
                context_before => (pos ($format) > 20 ?
                                   substr ($format, pos ($format) - 20, 20):
                                   substr ($format, 0, pos ($format))),
                context_after => substr ($format, pos ($format), 20),
                -object => $self, method => 'replace',
                option => \%opt;
            }
          } # Attributes
        } # Attribute specification list
        if ($format =~ /\G;/gc) {
          ($rule->{post}||=$defrule->{post})->($self, $name,
                                              \%attr,
                                              $opt{param},
                                              option => \%opt);
        } else {
          throw Message::Util::Formatter::Base::error
            -type => 'SEMICOLON_NOT_FOUND',
            context_before => (pos ($format) > 20 ?
                               substr ($format, pos ($format) - 20, 20):
                               substr ($format, 0, pos ($format))),
            context_after => substr ($format, pos ($format), 20),
            -object => $self, method => 'replace',
            option => \%opt;
        }
        ($entirerule->{attr}||=$defrule->{attr})->($self, '-entire',
                                                  $opt{param}, $opt{param},
                                                  $name => \%attr,
                                                  option => \%opt);
      } elsif ($format =~ /\G(?>[^%]+|%(?![\w-]))+/gc) {
        my %attr;
        ($textrule->{pre}||=$defrule->{pre})->($self, '-bare_text',
                                              \%attr, $opt{param},
                                              option => \%opt);
        ($textrule->{attr}||=$defrule->{attr})->($self, '-bare_text',
                                                \%attr, $opt{param},
                         -bare_text => substr ($format, $-[0], $+[0]-$-[0]),
                                                option => \%opt);
        ($textrule->{post}||=$defrule->{post})->($self, '-bare_text',
                                                \%attr, $opt{param},
                                                option => \%opt);
        ($entirerule->{attr}||=$defrule->{attr})->($self, '-entire',
                                                  $opt{param}, $opt{param},
                                                  -bare_text => \%attr,
                                                  option => \%opt);
      }
    }
    ($entirerule->{post}||=$defrule->{post})->($self, '-entire',
                                              $opt{param}, $opt{param},
                                              option => \%opt);
    return $opt{param}->{-result} if defined wantarray;
  }
  }
  
  sub call ($$;@) {
    my ($self, $name, $function) = (@_[0,1,2]);
    ( ($self->{rule}->($self, $name) or $self->{rule}->($self, '-undef') )
      ->{$function}
    or $self->{rule}->($self, '-default')->{$function})
    ->($self, $name, @_[3..$#_]);
  }
  
  package Message::Util::Formatter::error;
  require Message::Util::Error;
  push our @ISA, 'Message::Util::Error';
  
  package Message::Util::Formatter::Base::error;
  push our @ISA, 'Message::Util::Formatter::error';
  sub ___error_def () {+{
    ATTR_SEPARATOR_NOT_FOUND => {
      -description => q[Separator ("," or ")") expected at "%t(name=>context-before);"**here**"%t(name=>context-after);"],  
    },
    SEMICOLON_NOT_FOUND => {
      -description => q(Semicolon (";") expected at "%t(name=>context-before);"**here**"%t(name=>context-after);"),
    },
  }}
  
  =head1 LICENSE
  
  Copyright 2003, 2007 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1; # $Date: 2007/09/21 08:11:37 $
MESSAGE_UTIL_FORMATTER_BASE

$fatpacked{"Message/Util/Formatter/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MESSAGE_UTIL_FORMATTER_TEXT';
  
  =head1 NAME
  
  Message::Util::Formatter::Text --- Manakai : Plain-text formatter
  
  =head1 DESCRIPTION
  
  This module is an application of Message::Util::Formatter mechanism,
  used to generate formatted plain text (fragment) with given formatting
  rule text and formatting functions.
  
  This module is part of manakai.
  
  =cut
  
  package Message::Util::Formatter::Text;
  use strict;
  our $VERSION = do{my @r=(q$Revision: 1.5 $=~/\d+/g);sprintf "%d."."%02d" x $#r,@r};
  require Message::Util::Formatter::Base;
  our @ISA = 'Message::Util::Formatter::Base';
  
  sub ___rule_def () {+{
      -bare_text => {
        after => sub {
          my ($self, $name, $p, $o, $key => $val) = @_;
          $p->{-result} .= $p->{-bare_text};
        },
      },
      -undef     => {
        post => sub {
          my ($self, $name, $p, $o) = @_;
          $p->{-result} = qq([undef: $name]);
        },             
      },
      -default   => {
        pre => sub { 
          my ($self, $name, $p, $o, %opt) = @_;
          $p->{-result} = '';
          $self->call ($name, 'before', $p, $o, %opt);
        },
        post => sub { 
          my ($self, $name, $p, $o, %opt) = @_;
          $self->call ($name, 'after', $p, $o, %opt);
          if (length $p->{-result}) {
            $p->{-result} = $p->{prefix} . $p->{-result} if defined $p->{prefix};
            $p->{-result} .= $p->{suffix} if defined $p->{suffix};
          }
        },
        attr => sub {
          my ($self, $name, $p, $o, $key, $val, %opt) = @_;
          if ($key eq '-boolean') {
            $p->{$val} = 1;
          } else {
            if ($opt{-value_flag} and index ($opt{-value_flag}, 'p') > -1) {
              $val = $self->replace ($val, param => $o);
            }
            $p->{$key} = $val;
          }
        },                 
        before => sub {
        },
        after => sub {
        },
      },
      -entire    => {
        pre => sub {
          my ($self, $name, $p, $o) = @_;
          $p->{-result} = '';
        },
        attr => sub {
          my ($self, $name, $p, $o, $key => $val) = @_;
          $p->{-result} .= $val->{-result};
        },
      },
      percent => {
        after => sub {
          my ($self, $name, $p, $o) = @_;
          $p->{-result} = '%';
        },
      },
  }}
  
  =head1 LICENSE
  
  Copyright 2003 Wakaba <w@suika.fam.cx>
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1; # $Date: 2004/10/10 06:12:11 $
MESSAGE_UTIL_FORMATTER_TEXT

$fatpacked{"Path/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_CLASS';
  use strict;
  
  package Path::Class;
  {
    $Path::Class::VERSION = '0.37';
  }
  
  {
    ## no critic
    no strict 'vars';
    @ISA = qw(Exporter);
    @EXPORT    = qw(file dir);
    @EXPORT_OK = qw(file dir foreign_file foreign_dir tempdir);
  }
  
  use Exporter;
  use Path::Class::File;
  use Path::Class::Dir;
  use File::Temp ();
  
  sub file { Path::Class::File->new(@_) }
  sub dir  { Path::Class::Dir ->new(@_) }
  sub foreign_file { Path::Class::File->new_foreign(@_) }
  sub foreign_dir  { Path::Class::Dir ->new_foreign(@_) }
  sub tempdir { Path::Class::Dir->new(File::Temp::tempdir(@_)) }
  
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class - Cross-platform path specification manipulation
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    use Path::Class;
    
    my $dir  = dir('foo', 'bar');       # Path::Class::Dir object
    my $file = file('bob', 'file.txt'); # Path::Class::File object
    
    # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
    print "dir: $dir\n";
    
    # Stringifies to 'bob/file.txt' on Unix, 'bob\file.txt' on Windows
    print "file: $file\n";
    
    my $subdir  = $dir->subdir('baz');  # foo/bar/baz
    my $parent  = $subdir->parent;      # foo/bar
    my $parent2 = $parent->parent;      # foo
    
    my $dir2 = $file->dir;              # bob
  
    # Work with foreign paths
    use Path::Class qw(foreign_file foreign_dir);
    my $file = foreign_file('Mac', ':foo:file.txt');
    print $file->dir;                   # :foo:
    print $file->as_foreign('Win32');   # foo\file.txt
    
    # Interact with the underlying filesystem:
    
    # $dir_handle is an IO::Dir object
    my $dir_handle = $dir->open or die "Can't read $dir: $!";
    
    # $file_handle is an IO::File object
    my $file_handle = $file->open($mode) or die "Can't read $file: $!";
  
  =head1 DESCRIPTION
  
  C<Path::Class> is a module for manipulation of file and directory
  specifications (strings describing their locations, like
  C<'/home/ken/foo.txt'> or C<'C:\Windows\Foo.txt'>) in a cross-platform
  manner.  It supports pretty much every platform Perl runs on,
  including Unix, Windows, Mac, VMS, Epoc, Cygwin, OS/2, and NetWare.
  
  The well-known module L<File::Spec> also provides this service, but
  it's sort of awkward to use well, so people sometimes avoid it, or use
  it in a way that won't actually work properly on platforms
  significantly different than the ones they've tested their code on.
  
  In fact, C<Path::Class> uses C<File::Spec> internally, wrapping all
  the unsightly details so you can concentrate on your application code.
  Whereas C<File::Spec> provides functions for some common path
  manipulations, C<Path::Class> provides an object-oriented model of the
  world of path specifications and their underlying semantics.
  C<File::Spec> doesn't create any objects, and its classes represent
  the different ways in which paths must be manipulated on various
  platforms (not a very intuitive concept).  C<Path::Class> creates
  objects representing files and directories, and provides methods that
  relate them to each other.  For instance, the following C<File::Spec>
  code:
  
   my $absolute = File::Spec->file_name_is_absolute(
                    File::Spec->catfile( @dirs, $file )
                  );
  
  can be written using C<Path::Class> as
  
   my $absolute = Path::Class::File->new( @dirs, $file )->is_absolute;
  
  or even as 
  
   my $absolute = file( @dirs, $file )->is_absolute;
  
  Similar readability improvements should happen all over the place when
  using C<Path::Class>.
  
  Using C<Path::Class> can help solve real problems in your code too -
  for instance, how many people actually take the "volume" (like C<C:>
  on Windows) into account when writing C<File::Spec>-using code?  I
  thought not.  But if you use C<Path::Class>, your file and directory objects
  will know what volumes they refer to and do the right thing.
  
  The guts of the C<Path::Class> code live in the L<Path::Class::File>
  and L<Path::Class::Dir> modules, so please see those
  modules' documentation for more details about how to use them.
  
  =head2 EXPORT
  
  The following functions are exported by default.
  
  =over 4
  
  =item file
  
  A synonym for C<< Path::Class::File->new >>.
  
  =item dir
  
  A synonym for C<< Path::Class::Dir->new >>.
  
  =back
  
  If you would like to prevent their export, you may explicitly pass an
  empty list to perl's C<use>, i.e. C<use Path::Class ()>.
  
  The following are exported only on demand.
  
  =over 4
  
  =item foreign_file
  
  A synonym for C<< Path::Class::File->new_foreign >>.
  
  =item foreign_dir
  
  A synonym for C<< Path::Class::Dir->new_foreign >>.
  
  =item tempdir
  
  Create a new Path::Class::Dir instance pointed to temporary directory.
  
    my $temp = Path::Class::tempdir(CLEANUP => 1);
  
  A synonym for C<< Path::Class::Dir->new(File::Temp::tempdir(@_)) >>.
  
  =back
  
  =head1 Notes on Cross-Platform Compatibility
  
  Although it is much easier to write cross-platform-friendly code with
  this module than with C<File::Spec>, there are still some issues to be
  aware of.
  
  =over 4
  
  =item *
  
  On some platforms, notably VMS and some older versions of DOS (I think),
  all filenames must have an extension.  Thus if you create a file
  called F<foo/bar> and then ask for a list of files in the directory
  F<foo>, you may find a file called F<bar.> instead of the F<bar> you
  were expecting.  Thus it might be a good idea to use an extension in
  the first place.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, KWILLIAMS@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  L<Path::Class::Dir>, L<Path::Class::File>, L<File::Spec>
  
  =cut
PATH_CLASS

$fatpacked{"Path/Class/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_CLASS_DIR';
  use strict;
  
  package Path::Class::Dir;
  {
    $Path::Class::Dir::VERSION = '0.37';
  }
  
  use Path::Class::File;
  use Carp();
  use parent qw(Path::Class::Entity);
  
  use IO::Dir ();
  use File::Path ();
  use File::Temp ();
  use Scalar::Util ();
  
  # updir & curdir on the local machine, for screening them out in
  # children().  Note that they don't respect 'foreign' semantics.
  my $Updir  = __PACKAGE__->_spec->updir;
  my $Curdir = __PACKAGE__->_spec->curdir;
  
  sub new {
    my $self = shift->SUPER::new();
  
    # If the only arg is undef, it's probably a mistake.  Without this
    # special case here, we'd return the root directory, which is a
    # lousy thing to do to someone when they made a mistake.  Return
    # undef instead.
    return if @_==1 && !defined($_[0]);
  
    my $s = $self->_spec;
    
    my $first = (@_ == 0     ? $s->curdir :
  	       !ref($_[0]) && $_[0] eq '' ? (shift, $s->rootdir) :
  	       shift()
  	      );
    
    $self->{dirs} = [];
    if ( Scalar::Util::blessed($first) && $first->isa("Path::Class::Dir") ) {
      $self->{volume} = $first->{volume};
      push @{$self->{dirs}}, @{$first->{dirs}};
    }
    else {
      ($self->{volume}, my $dirs) = $s->splitpath( $s->canonpath("$first") , 1);
      push @{$self->{dirs}}, $dirs eq $s->rootdir ? "" : $s->splitdir($dirs);
    }
  
    push @{$self->{dirs}}, map {
      Scalar::Util::blessed($_) && $_->isa("Path::Class::Dir")
        ? @{$_->{dirs}}
        : $s->splitdir( $s->canonpath($_) )
    } @_;
  
  
    return $self;
  }
  
  sub file_class { "Path::Class::File" }
  
  sub is_dir { 1 }
  
  sub as_foreign {
    my ($self, $type) = @_;
  
    my $foreign = do {
      local $self->{file_spec_class} = $self->_spec_class($type);
      $self->SUPER::new;
    };
    
    # Clone internal structure
    $foreign->{volume} = $self->{volume};
    my ($u, $fu) = ($self->_spec->updir, $foreign->_spec->updir);
    $foreign->{dirs} = [ map {$_ eq $u ? $fu : $_} @{$self->{dirs}}];
    return $foreign;
  }
  
  sub stringify {
    my $self = shift;
    my $s = $self->_spec;
    return $s->catpath($self->{volume},
  		     $s->catdir(@{$self->{dirs}}),
  		     '');
  }
  
  sub volume { shift()->{volume} }
  
  sub file {
    local $Path::Class::Foreign = $_[0]->{file_spec_class} if $_[0]->{file_spec_class};
    return $_[0]->file_class->new(@_);
  }
  
  sub basename { shift()->{dirs}[-1] }
  
  sub dir_list {
    my $self = shift;
    my $d = $self->{dirs};
    return @$d unless @_;
    
    my $offset = shift;
    if ($offset < 0) { $offset = $#$d + $offset + 1 }
    
    return wantarray ? @$d[$offset .. $#$d] : $d->[$offset] unless @_;
    
    my $length = shift;
    if ($length < 0) { $length = $#$d + $length + 1 - $offset }
    return @$d[$offset .. $length + $offset - 1];
  }
  
  sub components {
    my $self = shift;
    return $self->dir_list(@_);
  }
  
  sub subdir {
    my $self = shift;
    return $self->new($self, @_);
  }
  
  sub parent {
    my $self = shift;
    my $dirs = $self->{dirs};
    my ($curdir, $updir) = ($self->_spec->curdir, $self->_spec->updir);
  
    if ($self->is_absolute) {
      my $parent = $self->new($self);
      pop @{$parent->{dirs}} if @$dirs > 1;
      return $parent;
  
    } elsif ($self eq $curdir) {
      return $self->new($updir);
  
    } elsif (!grep {$_ ne $updir} @$dirs) {  # All updirs
      return $self->new($self, $updir); # Add one more
  
    } elsif (@$dirs == 1) {
      return $self->new($curdir);
  
    } else {
      my $parent = $self->new($self);
      pop @{$parent->{dirs}};
      return $parent;
    }
  }
  
  sub relative {
    # File::Spec->abs2rel before version 3.13 returned the empty string
    # when the two paths were equal - work around it here.
    my $self = shift;
    my $rel = $self->_spec->abs2rel($self->stringify, @_);
    return $self->new( length $rel ? $rel : $self->_spec->curdir );
  }
  
  sub open  { IO::Dir->new(@_) }
  sub mkpath { File::Path::mkpath(shift()->stringify, @_) }
  sub rmtree { File::Path::rmtree(shift()->stringify, @_) }
  
  sub remove {
    rmdir( shift() );
  }
  
  sub traverse {
    my $self = shift;
    my ($callback, @args) = @_;
    my @children = $self->children;
    return $self->$callback(
      sub {
        my @inner_args = @_;
        return map { $_->traverse($callback, @inner_args) } @children;
      },
      @args
    );
  }
  
  sub traverse_if {
    my $self = shift;
    my ($callback, $condition, @args) = @_;
    my @children = grep { $condition->($_) } $self->children;
    return $self->$callback(
      sub {
        my @inner_args = @_;
        return map { $_->traverse_if($callback, $condition, @inner_args) } @children;
      },
      @args
    );
  }
  
  sub recurse {
    my $self = shift;
    my %opts = (preorder => 1, depthfirst => 0, @_);
    
    my $callback = $opts{callback}
      or Carp::croak( "Must provide a 'callback' parameter to recurse()" );
    
    my @queue = ($self);
    
    my $visit_entry;
    my $visit_dir = 
      $opts{depthfirst} && $opts{preorder}
      ? sub {
        my $dir = shift;
        my $ret = $callback->($dir);
        unless( ($ret||'') eq $self->PRUNE ) {
            unshift @queue, $dir->children;
        }
      }
      : $opts{preorder}
      ? sub {
        my $dir = shift;
        my $ret = $callback->($dir);
        unless( ($ret||'') eq $self->PRUNE ) {
            push @queue, $dir->children;
        }
      }
      : sub {
        my $dir = shift;
        $visit_entry->($_) foreach $dir->children;
        $callback->($dir);
      };
    
    $visit_entry = sub {
      my $entry = shift;
      if ($entry->is_dir) { $visit_dir->($entry) } # Will call $callback
      else { $callback->($entry) }
    };
    
    while (@queue) {
      $visit_entry->( shift @queue );
    }
  }
  
  sub children {
    my ($self, %opts) = @_;
    
    my $dh = $self->open or Carp::croak( "Can't open directory $self: $!" );
    
    my @out;
    while (defined(my $entry = $dh->read)) {
      next if !$opts{all} && $self->_is_local_dot_dir($entry);
      next if ($opts{no_hidden} && $entry =~ /^\./);
      push @out, $self->file($entry);
      $out[-1] = $self->subdir($entry) if -d $out[-1];
    }
    return @out;
  }
  
  sub _is_local_dot_dir {
    my $self = shift;
    my $dir  = shift;
  
    return ($dir eq $Updir or $dir eq $Curdir);
  }
  
  sub next {
    my $self = shift;
    unless ($self->{dh}) {
      $self->{dh} = $self->open or Carp::croak( "Can't open directory $self: $!" );
    }
    
    my $next = $self->{dh}->read;
    unless (defined $next) {
      delete $self->{dh};
      ## no critic
      return undef;
    }
    
    # Figure out whether it's a file or directory
    my $file = $self->file($next);
    $file = $self->subdir($next) if -d $file;
    return $file;
  }
  
  sub subsumes {
    Carp::croak "Too many arguments given to subsumes()" if $#_ > 2;
    my ($self, $other) = @_;
    Carp::croak( "No second entity given to subsumes()" ) unless defined $other;
  
    $other = $self->new($other) unless eval{$other->isa( "Path::Class::Entity")};
    $other = $other->dir unless $other->is_dir;
  
    if ($self->is_absolute) {
      $other = $other->absolute;
    } elsif ($other->is_absolute) {
      $self = $self->absolute;
    }
  
    $self = $self->cleanup;
    $other = $other->cleanup;
  
    if ($self->volume || $other->volume) {
      return 0 unless $other->volume eq $self->volume;
    }
  
    # The root dir subsumes everything (but ignore the volume because
    # we've already checked that)
    return 1 if "@{$self->{dirs}}" eq "@{$self->new('')->{dirs}}";
  
    # The current dir subsumes every relative path (unless starting with updir)
    if ($self eq $self->_spec->curdir) {
      return $other->{dirs}[0] ne $self->_spec->updir;
    }
  
    my $i = 0;
    while ($i <= $#{ $self->{dirs} }) {
      return 0 if $i > $#{ $other->{dirs} };
      return 0 if $self->{dirs}[$i] ne $other->{dirs}[$i];
      $i++;
    }
    return 1;
  }
  
  sub contains {
    Carp::croak "Too many arguments given to contains()" if $#_ > 2;
    my ($self, $other) = @_;
    Carp::croak "No second entity given to contains()" unless defined $other;
    return unless -d $self and (-e $other or -l $other);
  
    # We're going to resolve the path, and don't want side effects on the objects
    # so clone them.  This also handles strings passed as $other.
    $self= $self->new($self)->resolve;
    $other= $self->new($other)->resolve;
    
    return $self->subsumes($other);
  }
  
  sub tempfile {
    my $self = shift;
    return File::Temp::tempfile(@_, DIR => $self->stringify);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::Dir - Objects representing directories
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    use Path::Class;  # Exports dir() by default
    
    my $dir = dir('foo', 'bar');       # Path::Class::Dir object
    my $dir = Path::Class::Dir->new('foo', 'bar');  # Same thing
    
    # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
    print "dir: $dir\n";
    
    if ($dir->is_absolute) { ... }
    if ($dir->is_relative) { ... }
    
    my $v = $dir->volume; # Could be 'C:' on Windows, empty string
                          # on Unix, 'Macintosh HD:' on Mac OS
    
    $dir->cleanup; # Perform logical cleanup of pathname
    $dir->resolve; # Perform physical cleanup of pathname
    
    my $file = $dir->file('file.txt'); # A file in this directory
    my $subdir = $dir->subdir('george'); # A subdirectory
    my $parent = $dir->parent; # The parent directory, 'foo'
    
    my $abs = $dir->absolute; # Transform to absolute path
    my $rel = $abs->relative; # Transform to relative path
    my $rel = $abs->relative('/foo'); # Relative to /foo
    
    print $dir->as_foreign('Mac');   # :foo:bar:
    print $dir->as_foreign('Win32'); #  foo\bar
  
    # Iterate with IO::Dir methods:
    my $handle = $dir->open;
    while (my $file = $handle->read) {
      $file = $dir->file($file);  # Turn into Path::Class::File object
      ...
    }
    
    # Iterate with Path::Class methods:
    while (my $file = $dir->next) {
      # $file is a Path::Class::File or Path::Class::Dir object
      ...
    }
  
  
  =head1 DESCRIPTION
  
  The C<Path::Class::Dir> class contains functionality for manipulating
  directory names in a cross-platform way.
  
  =head1 METHODS
  
  =over 4
  
  =item $dir = Path::Class::Dir->new( <dir1>, <dir2>, ... )
  
  =item $dir = dir( <dir1>, <dir2>, ... )
  
  Creates a new C<Path::Class::Dir> object and returns it.  The
  arguments specify names of directories which will be joined to create
  a single directory object.  A volume may also be specified as the
  first argument, or as part of the first argument.  You can use
  platform-neutral syntax:
  
    my $dir = dir( 'foo', 'bar', 'baz' );
  
  or platform-native syntax:
  
    my $dir = dir( 'foo/bar/baz' );
  
  or a mixture of the two:
  
    my $dir = dir( 'foo/bar', 'baz' );
  
  All three of the above examples create relative paths.  To create an
  absolute path, either use the platform native syntax for doing so:
  
    my $dir = dir( '/var/tmp' );
  
  or use an empty string as the first argument:
  
    my $dir = dir( '', 'var', 'tmp' );
  
  If the second form seems awkward, that's somewhat intentional - paths
  like C</var/tmp> or C<\Windows> aren't cross-platform concepts in the
  first place (many non-Unix platforms don't have a notion of a "root
  directory"), so they probably shouldn't appear in your code if you're
  trying to be cross-platform.  The first form is perfectly natural,
  because paths like this may come from config files, user input, or
  whatever.
  
  As a special case, since it doesn't otherwise mean anything useful and
  it's convenient to define this way, C<< Path::Class::Dir->new() >> (or
  C<dir()>) refers to the current directory (C<< File::Spec->curdir >>).
  To get the current directory as an absolute path, do C<<
  dir()->absolute >>.
  
  Finally, as another special case C<dir(undef)> will return undef,
  since that's usually an accident on the part of the caller, and
  returning the root directory would be a nasty surprise just asking for
  trouble a few lines later.
  
  =item $dir->stringify
  
  This method is called internally when a C<Path::Class::Dir> object is
  used in a string context, so the following are equivalent:
  
    $string = $dir->stringify;
    $string = "$dir";
  
  =item $dir->volume
  
  Returns the volume (e.g. C<C:> on Windows, C<Macintosh HD:> on Mac OS,
  etc.) of the directory object, if any.  Otherwise, returns the empty
  string.
  
  =item $dir->basename
  
  Returns the last directory name of the path as a string.
  
  =item $dir->is_dir
  
  Returns a boolean value indicating whether this object represents a
  directory.  Not surprisingly, L<Path::Class::File> objects always
  return false, and C<Path::Class::Dir> objects always return true.
  
  =item $dir->is_absolute
  
  Returns true or false depending on whether the directory refers to an
  absolute path specifier (like C</usr/local> or C<\Windows>).
  
  =item $dir->is_relative
  
  Returns true or false depending on whether the directory refers to a
  relative path specifier (like C<lib/foo> or C<./dir>).
  
  =item $dir->cleanup
  
  Performs a logical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo//baz/./foo')->cleanup;
    # $dir now represents '/foo/baz/foo';
  
  =item $dir->resolve
  
  Performs a physical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo//baz/../foo')->resolve;
    # $dir now represents '/foo/foo', assuming no symlinks
  
  This actually consults the filesystem to verify the validity of the
  path.
  
  =item $file = $dir->file( <dir1>, <dir2>, ..., <file> )
  
  Returns a L<Path::Class::File> object representing an entry in C<$dir>
  or one of its subdirectories.  Internally, this just calls C<<
  Path::Class::File->new( @_ ) >>.
  
  =item $subdir = $dir->subdir( <dir1>, <dir2>, ... )
  
  Returns a new C<Path::Class::Dir> object representing a subdirectory
  of C<$dir>.
  
  =item $parent = $dir->parent
  
  Returns the parent directory of C<$dir>.  Note that this is the
  I<logical> parent, not necessarily the physical parent.  It really
  means we just chop off entries from the end of the directory list
  until we cain't chop no more.  If the directory is relative, we start
  using the relative forms of parent directories.
  
  The following code demonstrates the behavior on absolute and relative
  directories:
  
    $dir = dir('/foo/bar');
    for (1..6) {
      print "Absolute: $dir\n";
      $dir = $dir->parent;
    }
    
    $dir = dir('foo/bar');
    for (1..6) {
      print "Relative: $dir\n";
      $dir = $dir->parent;
    }
    
    ########### Output on Unix ################
    Absolute: /foo/bar
    Absolute: /foo
    Absolute: /
    Absolute: /
    Absolute: /
    Absolute: /
    Relative: foo/bar
    Relative: foo
    Relative: .
    Relative: ..
    Relative: ../..
    Relative: ../../..
  
  =item @list = $dir->children
  
  Returns a list of L<Path::Class::File> and/or C<Path::Class::Dir>
  objects listed in this directory, or in scalar context the number of
  such objects.  Obviously, it is necessary for C<$dir> to
  exist and be readable in order to find its children.
  
  Note that the children are returned as subdirectories of C<$dir>,
  i.e. the children of F<foo> will be F<foo/bar> and F<foo/baz>, not
  F<bar> and F<baz>.
  
  Ordinarily C<children()> will not include the I<self> and I<parent>
  entries C<.> and C<..> (or their equivalents on non-Unix systems),
  because that's like I'm-my-own-grandpa business.  If you do want all
  directory entries including these special ones, pass a true value for
  the C<all> parameter:
  
    @c = $dir->children(); # Just the children
    @c = $dir->children(all => 1); # All entries
  
  In addition, there's a C<no_hidden> parameter that will exclude all
  normally "hidden" entries - on Unix this means excluding all entries
  that begin with a dot (C<.>):
  
    @c = $dir->children(no_hidden => 1); # Just normally-visible entries
  
  
  =item $abs = $dir->absolute
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as an
  absolute path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $rel = $dir->relative
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as a
  relative path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $boolean = $dir->subsumes($other)
  
  Returns true if this directory spec subsumes the other spec, and false
  otherwise.  Think of "subsumes" as "contains", but we only look at the
  I<specs>, not whether C<$dir> actually contains C<$other> on the
  filesystem.
  
  The C<$other> argument may be a C<Path::Class::Dir> object, a
  L<Path::Class::File> object, or a string.  In the latter case, we
  assume it's a directory.
  
    # Examples:
    dir('foo/bar' )->subsumes(dir('foo/bar/baz'))  # True
    dir('/foo/bar')->subsumes(dir('/foo/bar/baz')) # True
    dir('foo/..')->subsumes(dir('foo/../bar))      # True
    dir('foo/bar' )->subsumes(dir('bar/baz'))      # False
    dir('/foo/bar')->subsumes(dir('foo/bar'))      # False
    dir('foo/..')->subsumes(dir('bar'))            # False! Use C<contains> to resolve ".."
  
  
  =item $boolean = $dir->contains($other)
  
  Returns true if this directory actually contains C<$other> on the
  filesystem.  C<$other> doesn't have to be a direct child of C<$dir>,
  it just has to be subsumed after both paths have been resolved.
  
  =item $foreign = $dir->as_foreign($type)
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  Any generated objects (subdirectories, files, parents, etc.) will also
  retain this type.
  
  =item $foreign = Path::Class::Dir->new_foreign($type, @args)
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  The arguments in C<@args> are the same as they would be specified in
  C<new()>.
  
  =item @list = $dir->dir_list([OFFSET, [LENGTH]])
  
  Returns the list of strings internally representing this directory
  structure.  Each successive member of the list is understood to be an
  entry in its predecessor's directory list.  By contract, C<<
  Path::Class->new( $dir->dir_list ) >> should be equivalent to C<$dir>.
  
  The semantics of this method are similar to Perl's C<splice> or
  C<substr> functions; they return C<LENGTH> elements starting at
  C<OFFSET>.  If C<LENGTH> is omitted, returns all the elements starting
  at C<OFFSET> up to the end of the list.  If C<LENGTH> is negative,
  returns the elements from C<OFFSET> onward except for C<-LENGTH>
  elements at the end.  If C<OFFSET> is negative, it counts backward
  C<OFFSET> elements from the end of the list.  If C<OFFSET> and
  C<LENGTH> are both omitted, the entire list is returned.
  
  In a scalar context, C<dir_list()> with no arguments returns the
  number of entries in the directory list; C<dir_list(OFFSET)> returns
  the single element at that offset; C<dir_list(OFFSET, LENGTH)> returns
  the final element that would have been returned in a list context.
  
  =item $dir->components
  
  Identical to C<dir_list()>.  It exists because there's an analogous
  method C<dir_list()> in the C<Path::Class::File> class that also
  returns the basename string, so this method lets someone call
  C<components()> without caring whether the object is a file or a
  directory.
  
  =item $fh = $dir->open()
  
  Passes C<$dir> to C<< IO::Dir->open >> and returns the result as an
  L<IO::Dir> object.  If the opening fails, C<undef> is returned and
  C<$!> is set.
  
  =item $dir->mkpath($verbose, $mode)
  
  Passes all arguments, including C<$dir>, to C<< File::Path::mkpath()
  >> and returns the result (a list of all directories created).
  
  =item $dir->rmtree($verbose, $cautious)
  
  Passes all arguments, including C<$dir>, to C<< File::Path::rmtree()
  >> and returns the result (the number of files successfully deleted).
  
  =item $dir->remove()
  
  Removes the directory, which must be empty.  Returns a boolean value
  indicating whether or not the directory was successfully removed.
  This method is mainly provided for consistency with
  C<Path::Class::File>'s C<remove()> method.
  
  =item $dir->tempfile(...)
  
  An interface to L<File::Temp>'s C<tempfile()> function.  Just like
  that function, if you call this in a scalar context, the return value
  is the filehandle and the file is C<unlink>ed as soon as possible
  (which is immediately on Unix-like platforms).  If called in a list
  context, the return values are the filehandle and the filename.
  
  The given directory is passed as the C<DIR> parameter.
  
  Here's an example of pretty good usage which doesn't allow race
  conditions, won't leave yucky tempfiles around on your filesystem,
  etc.:
  
    my $fh = $dir->tempfile;
    print $fh "Here's some data...\n";
    seek($fh, 0, 0);
    while (<$fh>) { do something... }
  
  Or in combination with a C<fork>:
  
    my $fh = $dir->tempfile;
    print $fh "Here's some more data...\n";
    seek($fh, 0, 0);
    if ($pid=fork()) {
      wait;
    } else {
      something($_) while <$fh>;
    }
  
  
  =item $dir_or_file = $dir->next()
  
  A convenient way to iterate through directory contents.  The first
  time C<next()> is called, it will C<open()> the directory and read the
  first item from it, returning the result as a C<Path::Class::Dir> or
  L<Path::Class::File> object (depending, of course, on its actual
  type).  Each subsequent call to C<next()> will simply iterate over the
  directory's contents, until there are no more items in the directory,
  and then the undefined value is returned.  For example, to iterate
  over all the regular files in a directory:
  
    while (my $file = $dir->next) {
      next unless -f $file;
      my $fh = $file->open('r') or die "Can't read $file: $!";
      ...
    }
  
  If an error occurs when opening the directory (for instance, it
  doesn't exist or isn't readable), C<next()> will throw an exception
  with the value of C<$!>.
  
  =item $dir->traverse( sub { ... }, @args )
  
  Calls the given callback for the root, passing it a continuation
  function which, when called, will call this recursively on each of its
  children. The callback function should be of the form:
  
    sub {
      my ($child, $cont, @args) = @_;
      # ...
    }
  
  For instance, to calculate the number of files in a directory, you
  can do this:
  
    my $nfiles = $dir->traverse(sub {
      my ($child, $cont) = @_;
      return sum($cont->(), ($child->is_dir ? 0 : 1));
    });
  
  or to calculate the maximum depth of a directory:
  
    my $depth = $dir->traverse(sub {
      my ($child, $cont, $depth) = @_;
      return max($cont->($depth + 1), $depth);
    }, 0);
  
  You can also choose not to call the callback in certain situations:
  
    $dir->traverse(sub {
      my ($child, $cont) = @_;
      return if -l $child; # don't follow symlinks
      # do something with $child
      return $cont->();
    });
  
  =item $dir->traverse_if( sub { ... }, sub { ... }, @args )
  
  traverse with additional "should I visit this child" callback.
  Particularly useful in case examined tree contains inaccessible
  directories.
  
  Canonical example:
  
    $dir->traverse_if(
      sub {
         my ($child, $cont) = @_;
         # do something with $child
         return $cont->();
      }, 
      sub {
         my ($child) = @_;
         # Process only readable items
         return -r $child;
      });
  
  Second callback gets single parameter: child. Only children for
  which it returns true will be processed by the first callback.
  
  Remaining parameters are interpreted as in traverse, in particular
  C<traverse_if(callback, sub { 1 }, @args> is equivalent to
  C<traverse(callback, @args)>.
  
  =item $dir->recurse( callback => sub {...} )
  
  Iterates through this directory and all of its children, and all of
  its children's children, etc., calling the C<callback> subroutine for
  each entry.  This is a lot like what the L<File::Find> module does,
  and of course C<File::Find> will work fine on L<Path::Class> objects,
  but the advantage of the C<recurse()> method is that it will also feed
  your callback routine C<Path::Class> objects rather than just pathname
  strings.
  
  The C<recurse()> method requires a C<callback> parameter specifying
  the subroutine to invoke for each entry.  It will be passed the
  C<Path::Class> object as its first argument.
  
  C<recurse()> also accepts two boolean parameters, C<depthfirst> and
  C<preorder> that control the order of recursion.  The default is a
  preorder, breadth-first search, i.e. C<< depthfirst => 0, preorder => 1 >>.
  At the time of this writing, all combinations of these two parameters
  are supported I<except> C<< depthfirst => 0, preorder => 0 >>.
  
  C<callback> is normally not required to return any value. If it
  returns special constant C<Path::Class::Entity::PRUNE()> (more easily
  available as C<< $item->PRUNE >>),  no children of analyzed
  item will be analyzed (mostly as if you set C<$File::Find::prune=1>). Of course
  pruning is available only in C<preorder>, in postorder return value
  has no effect.
  
  =item $st = $file->stat()
  
  Invokes C<< File::stat::stat() >> on this directory and returns a
  C<File::stat> object representing the result.
  
  =item $st = $file->lstat()
  
  Same as C<stat()>, but if C<$file> is a symbolic link, C<lstat()>
  stats the link instead of the directory the link points to.
  
  =item $class = $file->file_class()
  
  Returns the class which should be used to create file objects.
  
  Generally overridden whenever this class is subclassed.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  L<Path::Class>, L<Path::Class::File>, L<File::Spec>
  
  =cut
PATH_CLASS_DIR

$fatpacked{"Path/Class/Entity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_CLASS_ENTITY';
  use strict;
  
  package Path::Class::Entity;
  {
    $Path::Class::Entity::VERSION = '0.37';
  }
  
  use File::Spec 3.26;
  use File::stat ();
  use Cwd;
  use Carp();
  
  use overload
    (
     q[""] => 'stringify',
     'bool' => 'boolify',
     fallback => 1,
    );
  
  sub new {
    my $from = shift;
    my ($class, $fs_class) = (ref($from)
  			    ? (ref $from, $from->{file_spec_class})
  			    : ($from, $Path::Class::Foreign));
    return bless {file_spec_class => $fs_class}, $class;
  }
  
  sub is_dir { 0 }
  
  sub _spec_class {
    my ($class, $type) = @_;
  
    die "Invalid system type '$type'" unless ($type) = $type =~ /^(\w+)$/;  # Untaint
    my $spec = "File::Spec::$type";
    ## no critic
    eval "require $spec; 1" or die $@;
    return $spec;
  }
  
  sub new_foreign {
    my ($class, $type) = (shift, shift);
    local $Path::Class::Foreign = $class->_spec_class($type);
    return $class->new(@_);
  }
  
  sub _spec { (ref($_[0]) && $_[0]->{file_spec_class}) || 'File::Spec' }
  
  sub boolify { 1 }
    
  sub is_absolute { 
    # 5.6.0 has a bug with regexes and stringification that's ticked by
    # file_name_is_absolute().  Help it along with an explicit stringify().
    $_[0]->_spec->file_name_is_absolute($_[0]->stringify) 
  }
  
  sub is_relative { ! $_[0]->is_absolute }
  
  sub cleanup {
    my $self = shift;
    my $cleaned = $self->new( $self->_spec->canonpath("$self") );
    %$self = %$cleaned;
    return $self;
  }
  
  sub resolve {
    my $self = shift;
    Carp::croak($! . " $self") unless -e $self;  # No such file or directory
    my $cleaned = $self->new( scalar Cwd::realpath($self->stringify) );
  
    # realpath() always returns absolute path, kind of annoying
    $cleaned = $cleaned->relative if $self->is_relative;
  
    %$self = %$cleaned;
    return $self;
  }
  
  sub absolute {
    my $self = shift;
    return $self if $self->is_absolute;
    return $self->new($self->_spec->rel2abs($self->stringify, @_));
  }
  
  sub relative {
    my $self = shift;
    return $self->new($self->_spec->abs2rel($self->stringify, @_));
  }
  
  sub stat  { File::stat::stat("$_[0]") }
  sub lstat { File::stat::lstat("$_[0]") }
  
  sub PRUNE { return \&PRUNE; }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::Entity - Base class for files and directories
  
  =head1 VERSION
  
  version 0.37
  
  =head1 DESCRIPTION
  
  This class is the base class for C<Path::Class::File> and
  C<Path::Class::Dir>, it is not used directly by callers.
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  Path::Class
  
  =cut
PATH_CLASS_ENTITY

$fatpacked{"Path/Class/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_CLASS_FILE';
  use strict;
  
  package Path::Class::File;
  {
    $Path::Class::File::VERSION = '0.37';
  }
  
  use Path::Class::Dir;
  use parent qw(Path::Class::Entity);
  use Carp;
  
  use IO::File ();
  
  sub new {
    my $self = shift->SUPER::new;
    my $file = pop();
    my @dirs = @_;
  
    my ($volume, $dirs, $base) = $self->_spec->splitpath($file);
  
    if (length $dirs) {
      push @dirs, $self->_spec->catpath($volume, $dirs, '');
    }
  
    $self->{dir}  = @dirs ? $self->dir_class->new(@dirs) : undef;
    $self->{file} = $base;
  
    return $self;
  }
  
  sub dir_class { "Path::Class::Dir" }
  
  sub as_foreign {
    my ($self, $type) = @_;
    local $Path::Class::Foreign = $self->_spec_class($type);
    my $foreign = ref($self)->SUPER::new;
    $foreign->{dir} = $self->{dir}->as_foreign($type) if defined $self->{dir};
    $foreign->{file} = $self->{file};
    return $foreign;
  }
  
  sub stringify {
    my $self = shift;
    return $self->{file} unless defined $self->{dir};
    return $self->_spec->catfile($self->{dir}->stringify, $self->{file});
  }
  
  sub dir {
    my $self = shift;
    return $self->{dir} if defined $self->{dir};
    return $self->dir_class->new($self->_spec->curdir);
  }
  BEGIN { *parent = \&dir; }
  
  sub volume {
    my $self = shift;
    return '' unless defined $self->{dir};
    return $self->{dir}->volume;
  }
  
  sub components {
    my $self = shift;
    croak "Arguments are not currently supported by File->components()" if @_;
    return ($self->dir->components, $self->basename);
  }
  
  sub basename { shift->{file} }
  sub open  { IO::File->new(@_) }
  
  sub openr { $_[0]->open('r') or croak "Can't read $_[0]: $!"  }
  sub openw { $_[0]->open('w') or croak "Can't write to $_[0]: $!" }
  sub opena { $_[0]->open('a') or croak "Can't append to $_[0]: $!" }
  
  sub touch {
    my $self = shift;
    if (-e $self) {
      utime undef, undef, $self;
    } else {
      $self->openw;
    }
  }
  
  sub slurp {
    my ($self, %args) = @_;
    my $iomode = $args{iomode} || 'r';
    my $fh = $self->open($iomode) or croak "Can't read $self: $!";
  
    if (wantarray) {
      my @data = <$fh>;
      chomp @data if $args{chomped} or $args{chomp};
  
      if ( my $splitter = $args{split} ) {
        @data = map { [ split $splitter, $_ ] } @data;
      }
  
      return @data;
    }
  
  
    croak "'split' argument can only be used in list context"
      if $args{split};
  
  
    if ($args{chomped} or $args{chomp}) {
      chomp( my @data = <$fh> );
      return join '', @data;
    }
  
  
    local $/;
    return <$fh>;
  }
  
  sub spew {
      my $self = shift;
      my %args = splice( @_, 0, @_-1 );
  
      my $iomode = $args{iomode} || 'w';
      my $fh = $self->open( $iomode ) or croak "Can't write to $self: $!";
  
      if (ref($_[0]) eq 'ARRAY') {
          # Use old-school for loop to avoid copying.
          for (my $i = 0; $i < @{ $_[0] }; $i++) {
              print $fh $_[0]->[$i]
                  or croak "Can't write to $self: $!";
          }
      }
      else {
          print $fh $_[0]
              or croak "Can't write to $self: $!";
      }
  
      close $fh
          or croak "Can't write to $self: $!";
  
      return;
  }
  
  sub spew_lines {
      my $self = shift;
      my %args = splice( @_, 0, @_-1 );
  
      my $content = $_[0];
  
      # If content is an array ref, appends $/ to each element of the array.
      # Otherwise, if it is a simple scalar, just appends $/ to that scalar.
  
      $content
          = ref( $content ) eq 'ARRAY'
          ? [ map { $_, $/ } @$content ]
          : "$content$/";
  
      return $self->spew( %args, $content );
  }
  
  sub remove {
    my $file = shift->stringify;
    return unlink $file unless -e $file; # Sets $! correctly
    1 while unlink $file;
    return not -e $file;
  }
  
  sub copy_to {
    my ($self, $dest) = @_;
    if ( eval{ $dest->isa("Path::Class::File")} ) { 
      $dest = $dest->stringify;
      croak "Can't copy to file $dest: it is a directory" if -d $dest;
    } elsif ( eval{ $dest->isa("Path::Class::Dir") } ) {
      $dest = $dest->stringify;
      croak "Can't copy to directory $dest: it is a file" if -f $dest;
      croak "Can't copy to directory $dest: no such directory" unless -d $dest;
    } elsif ( ref $dest ) {
      croak "Don't know how to copy files to objects of type '".ref($self)."'";
    }
  
    require Perl::OSType;
    if ( !Perl::OSType::is_os_type('Unix') ) {
  
        require File::Copy;
        return unless File::Copy::cp($self->stringify, "${dest}");
  
    } else {
  
        return unless (system('cp', $self->stringify, "${dest}") == 0);
  
    }
  
    return $self->new($dest);
  }
  
  sub move_to {
    my ($self, $dest) = @_;
    require File::Copy;
    if (File::Copy::move($self->stringify, "${dest}")) {
  
        my $new = $self->new($dest);
  
        $self->{$_} = $new->{$_} foreach (qw/ dir file /);
  
        return $self;
  
    } else {
  
        return;
  
    }
  }
  
  sub traverse {
    my $self = shift;
    my ($callback, @args) = @_;
    return $self->$callback(sub { () }, @args);
  }
  
  sub traverse_if {
    my $self = shift;
    my ($callback, $condition, @args) = @_;
    return $self->$callback(sub { () }, @args);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::File - Objects representing files
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    use Path::Class;  # Exports file() by default
  
    my $file = file('foo', 'bar.txt');  # Path::Class::File object
    my $file = Path::Class::File->new('foo', 'bar.txt'); # Same thing
  
    # Stringifies to 'foo/bar.txt' on Unix, 'foo\bar.txt' on Windows, etc.
    print "file: $file\n";
  
    if ($file->is_absolute) { ... }
    if ($file->is_relative) { ... }
  
    my $v = $file->volume; # Could be 'C:' on Windows, empty string
                           # on Unix, 'Macintosh HD:' on Mac OS
  
    $file->cleanup; # Perform logical cleanup of pathname
    $file->resolve; # Perform physical cleanup of pathname
  
    my $dir = $file->dir;  # A Path::Class::Dir object
  
    my $abs = $file->absolute; # Transform to absolute path
    my $rel = $file->relative; # Transform to relative path
  
  =head1 DESCRIPTION
  
  The C<Path::Class::File> class contains functionality for manipulating
  file names in a cross-platform way.
  
  =head1 METHODS
  
  =over 4
  
  =item $file = Path::Class::File->new( <dir1>, <dir2>, ..., <file> )
  
  =item $file = file( <dir1>, <dir2>, ..., <file> )
  
  Creates a new C<Path::Class::File> object and returns it.  The
  arguments specify the path to the file.  Any volume may also be
  specified as the first argument, or as part of the first argument.
  You can use platform-neutral syntax:
  
    my $file = file( 'foo', 'bar', 'baz.txt' );
  
  or platform-native syntax:
  
    my $file = file( 'foo/bar/baz.txt' );
  
  or a mixture of the two:
  
    my $file = file( 'foo/bar', 'baz.txt' );
  
  All three of the above examples create relative paths.  To create an
  absolute path, either use the platform native syntax for doing so:
  
    my $file = file( '/var/tmp/foo.txt' );
  
  or use an empty string as the first argument:
  
    my $file = file( '', 'var', 'tmp', 'foo.txt' );
  
  If the second form seems awkward, that's somewhat intentional - paths
  like C</var/tmp> or C<\Windows> aren't cross-platform concepts in the
  first place, so they probably shouldn't appear in your code if you're
  trying to be cross-platform.  The first form is perfectly fine,
  because paths like this may come from config files, user input, or
  whatever.
  
  =item $file->stringify
  
  This method is called internally when a C<Path::Class::File> object is
  used in a string context, so the following are equivalent:
  
    $string = $file->stringify;
    $string = "$file";
  
  =item $file->volume
  
  Returns the volume (e.g. C<C:> on Windows, C<Macintosh HD:> on Mac OS,
  etc.) of the object, if any.  Otherwise, returns the empty string.
  
  =item $file->basename
  
  Returns the name of the file as a string, without the directory
  portion (if any).
  
  =item $file->components
  
  Returns a list of the directory components of this file, followed by
  the basename.
  
  Note: unlike C<< $dir->components >>, this method currently does not
  accept any arguments to select which elements of the list will be
  returned.  It may do so in the future.  Currently it throws an
  exception if such arguments are present.
  
  
  =item $file->is_dir
  
  Returns a boolean value indicating whether this object represents a
  directory.  Not surprisingly, C<Path::Class::File> objects always
  return false, and L<Path::Class::Dir> objects always return true.
  
  =item $file->is_absolute
  
  Returns true or false depending on whether the file refers to an
  absolute path specifier (like C</usr/local/foo.txt> or C<\Windows\Foo.txt>).
  
  =item $file->is_relative
  
  Returns true or false depending on whether the file refers to a
  relative path specifier (like C<lib/foo.txt> or C<.\Foo.txt>).
  
  =item $file->cleanup
  
  Performs a logical cleanup of the file path.  For instance:
  
    my $file = file('/foo//baz/./foo.txt')->cleanup;
    # $file now represents '/foo/baz/foo.txt';
  
  =item $dir->resolve
  
  Performs a physical cleanup of the file path.  For instance:
  
    my $file = file('/foo/baz/../foo.txt')->resolve;
    # $file now represents '/foo/foo.txt', assuming no symlinks
  
  This actually consults the filesystem to verify the validity of the
  path.
  
  =item $dir = $file->dir
  
  Returns a C<Path::Class::Dir> object representing the directory
  containing this file.
  
  =item $dir = $file->parent
  
  A synonym for the C<dir()> method.
  
  =item $abs = $file->absolute
  
  Returns a C<Path::Class::File> object representing C<$file> as an
  absolute path.  An optional argument, given as either a string or a
  L<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $rel = $file->relative
  
  Returns a C<Path::Class::File> object representing C<$file> as a
  relative path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $foreign = $file->as_foreign($type)
  
  Returns a C<Path::Class::File> object representing C<$file> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  Any generated objects (subdirectories, files, parents, etc.) will also
  retain this type.
  
  =item $foreign = Path::Class::File->new_foreign($type, @args)
  
  Returns a C<Path::Class::File> object representing a file as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  The arguments in C<@args> are the same as they would be specified in
  C<new()>.
  
  =item $fh = $file->open($mode, $permissions)
  
  Passes the given arguments, including C<$file>, to C<< IO::File->new >>
  (which in turn calls C<< IO::File->open >> and returns the result
  as an L<IO::File> object.  If the opening
  fails, C<undef> is returned and C<$!> is set.
  
  =item $fh = $file->openr()
  
  A shortcut for
  
   $fh = $file->open('r') or croak "Can't read $file: $!";
  
  =item $fh = $file->openw()
  
  A shortcut for
  
   $fh = $file->open('w') or croak "Can't write to $file: $!";
  
  =item $fh = $file->opena()
  
  A shortcut for
  
   $fh = $file->open('a') or croak "Can't append to $file: $!";
  
  =item $file->touch
  
  Sets the modification and access time of the given file to right now,
  if the file exists.  If it doesn't exist, C<touch()> will I<make> it
  exist, and - YES! - set its modification and access time to now.
  
  =item $file->slurp()
  
  In a scalar context, returns the contents of C<$file> in a string.  In
  a list context, returns the lines of C<$file> (according to how C<$/>
  is set) as a list.  If the file can't be read, this method will throw
  an exception.
  
  If you want C<chomp()> run on each line of the file, pass a true value
  for the C<chomp> or C<chomped> parameters:
  
    my @lines = $file->slurp(chomp => 1);
  
  You may also use the C<iomode> parameter to pass in an IO mode to use
  when opening the file, usually IO layers (though anything accepted by
  the MODE argument of C<open()> is accepted here).  Just make sure it's
  a I<reading> mode.
  
    my @lines = $file->slurp(iomode => ':crlf');
    my $lines = $file->slurp(iomode => '<:encoding(UTF-8)');
  
  The default C<iomode> is C<r>.
  
  Lines can also be automatically split, mimicking the perl command-line
  option C<-a> by using the C<split> parameter. If this parameter is used,
  each line will be returned as an array ref.
  
      my @lines = $file->slurp( chomp => 1, split => qr/\s*,\s*/ );
  
  The C<split> parameter can only be used in a list context.
  
  =item $file->spew( $content );
  
  The opposite of L</slurp>, this takes a list of strings and prints them
  to the file in write mode.  If the file can't be written to, this method
  will throw an exception.
  
  The content to be written can be either an array ref or a plain scalar.
  If the content is an array ref then each entry in the array will be
  written to the file.
  
  You may use the C<iomode> parameter to pass in an IO mode to use when
  opening the file, just like L</slurp> supports.
  
    $file->spew(iomode => '>:raw', $content);
  
  The default C<iomode> is C<w>.
  
  =item $file->spew_lines( $content );
  
  Just like C<spew>, but, if $content is a plain scalar, appends $/
  to it, or, if $content is an array ref, appends $/ to each element
  of the array.
  
  Can also take an C<iomode> parameter like C<spew>. Again, the
  default C<iomode> is C<w>.
  
  =item $file->traverse(sub { ... }, @args)
  
  Calls the given callback on $file. This doesn't do much on its own,
  but see the associated documentation in L<Path::Class::Dir>.
  
  =item $file->remove()
  
  This method will remove the file in a way that works well on all
  platforms, and returns a boolean value indicating whether or not the
  file was successfully removed.
  
  C<remove()> is better than simply calling Perl's C<unlink()> function,
  because on some platforms (notably VMS) you actually may need to call
  C<unlink()> several times before all versions of the file are gone -
  the C<remove()> method handles this process for you.
  
  =item $st = $file->stat()
  
  Invokes C<< File::stat::stat() >> on this file and returns a
  L<File::stat> object representing the result.
  
  =item $st = $file->lstat()
  
  Same as C<stat()>, but if C<$file> is a symbolic link, C<lstat()>
  stats the link instead of the file the link points to.
  
  =item $class = $file->dir_class()
  
  Returns the class which should be used to create directory objects.
  
  Generally overridden whenever this class is subclassed.
  
  =item $copy = $file->copy_to( $dest );
  
  Copies the C<$file> to C<$dest>. It returns a L<Path::Class::File>
  object when successful, C<undef> otherwise.
  
  =item $moved = $file->move_to( $dest );
  
  Moves the C<$file> to C<$dest>, and updates C<$file> accordingly.
  
  It returns C<$file> is successful, C<undef> otherwise.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  L<Path::Class>, L<Path::Class::Dir>, L<File::Spec>
  
  =cut
PATH_CLASS_FILE

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  
  our $VERSION = '0.124';
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 0.86 ();          # shipped with 5.8.1
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  # FREEZE/THAW per Sereal/CBOR/Types::Serialiser protocol
  sub FREEZE { return $_[0]->[PATH] }
  sub THAW   { return path( $_[2] ) }
  { no warnings 'once'; *TO_JSON = *FREEZE };
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      local $SIG{__DIE__}; # prevent outer handler from being called
      !!eval {
          require Unicode::UTF8;
          Unicode::UTF8->VERSION(0.58);
          1;
      };
  }
  
  my $HAS_PU;              # has PerlIO::utf8_strict; lazily populated
  
  sub _check_PU {
      local $SIG{__DIE__}; # prevent outer handler from being called
      !!eval {
          # MUST preload Encode or $SIG{__DIE__} localization fails
          # on some Perl 5.8.8 (maybe other 5.8.*) compiled with -O2.
          require Encode;
          require PerlIO::utf8_strict;
          PerlIO::utf8_strict->VERSION(0.003);
          1;
      };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?\z}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT\z/ ) : ( $_[0] eq '/' );
  }
  
  BEGIN {
      *_same = IS_WIN32() ? sub { lc( $_[0] ) eq lc( $_[1] ) } : sub { $_[0] eq $_[1] };
  }
  
  # mode bits encoded for chmod in symbolic mode
  my %MODEBITS = ( om => 0007, gm => 0070, um => 0700 ); ## no critic
  { my $m = 0; $MODEBITS{$_} = ( 1 << $m++ ) for qw/ox ow or gx gw gr ux uw ur/ };
  
  sub _symbolic_chmod {
      my ( $mode, $symbolic ) = @_;
      for my $clause ( split /,\s*/, $symbolic ) {
          if ( $clause =~ m{\A([augo]+)([=+-])([rwx]+)\z} ) {
              my ( $who, $action, $perms ) = ( $1, $2, $3 );
              $who =~ s/a/ugo/g;
              for my $w ( split //, $who ) {
                  my $p = 0;
                  $p |= $MODEBITS{"$w$_"} for split //, $perms;
                  if ( $action eq '=' ) {
                      $mode = ( $mode & ~$MODEBITS{"${w}m"} ) | $p;
                  }
                  else {
                      $mode = $action eq "+" ? ( $mode | $p ) : ( $mode & ~$p );
                  }
              }
          }
          else {
              Carp::croak("Invalid mode clause '$clause' for chmod()");
          }
      }
      return $mode;
  }
  
  # flock doesn't work on NFS on BSD or on some filesystems like lustre.
  # Since program authors often can't control or detect that, we warn once
  # instead of being fatal if we can detect it and people who need it strict
  # can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use warnings::register }
  #>>>
  
  my $WARNED_NO_FLOCK = 0;
  
  sub _throw {
      my ( $self, $function, $file, $msg ) = @_;
      if (   $function =~ /^flock/
          && $! =~ /operation not supported|function not implemented/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_NO_FLOCK ) {
              warnings::warn( flock => "Flock not available: '$!': continuing in unsafe mode" );
              $WARNED_NO_FLOCK++;
          }
      }
      else {
          $msg = $! unless defined $msg;
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ),
              $msg );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  #pod =construct path
  #pod
  #pod     $path = path("foo/bar");
  #pod     $path = path("/tmp", "file.txt"); # list
  #pod     $path = path(".");                # cwd
  #pod     $path = path("~user/file.txt");   # tilde processing
  #pod
  #pod Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  #pod directory path.  It's still up to you to call directory-like methods only on
  #pod directories and file-like methods only on files.  This function is exported
  #pod automatically by default.
  #pod
  #pod The first argument must be defined and have non-zero length or an exception
  #pod will be thrown.  This prevents subtle, dangerous errors with code like
  #pod C<< path( maybe_undef() )->remove_tree >>.
  #pod
  #pod If the first component of the path is a tilde ('~') then the component will be
  #pod replaced with the output of C<glob('~')>.  If the first component of the path
  #pod is a tilde followed by a user name then the component will be replaced with
  #pod output of C<glob('~username')>.  Behaviour for non-existent users depends on
  #pod the output of C<glob> on the system.
  #pod
  #pod On Windows, if the path consists of a drive identifier without a path component
  #pod (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  #pod directory on that volume using C<Cwd::getdcwd()>.
  #pod
  #pod If called with a single C<Path::Tiny> argument, the original is returned unless
  #pod the original is holding a temporary file or directory reference in which case a
  #pod stringified copy is made.
  #pod
  #pod     $path = path("foo/bar");
  #pod     $temp = Path::Tiny->tempfile;
  #pod
  #pod     $p2 = path($path); # like $p2 = $path
  #pod     $t2 = path($temp); # like $t2 = path( "$temp" )
  #pod
  #pod This optimizes copies without proliferating references unexpectedly if a copy is
  #pod made by code outside your control.
  #pod
  #pod Current API available since 0.017.
  #pod
  #pod =cut
  
  sub path {
      my $path = shift;
      Carp::croak("Path::Tiny paths require defined, positive-length parts")
        unless 1 + @_ == grep { defined && length } $path, @_;
  
      # non-temp Path::Tiny objects are effectively immutable and can be reused
      if ( !@_ && ref($path) eq __PACKAGE__ && !$path->[TEMP] ) {
          return $path;
      }
  
      # stringify objects
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|\z)};
          $path .= "/" if $path =~ m{^$UNC_VOL\z};
      }
  
      # concatenations stringifies objects, too
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize, but with unix slashes and put back trailing volume slash
      my $cpath = $path = File::Spec->canonpath($path);
      $path =~ tr[\\][/] if IS_WIN32();
      $path = "/" if $path eq '/..'; # for old File::Spec
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL\z};
  
      # root paths must always have a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?\z}{/};
      }
      else {
          $path =~ s{/\z}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          require File::Glob;
          my ($homedir) = File::Glob::bsd_glob($1);
          $homedir =~ tr[\\][/] if IS_WIN32();
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  #pod =construct new
  #pod
  #pod     $path = Path::Tiny->new("foo/bar");
  #pod
  #pod This is just like C<path>, but with method call overhead.  (Why would you
  #pod do that?)
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub new { shift; path(@_) }
  
  #pod =construct cwd
  #pod
  #pod     $path = Path::Tiny->cwd; # path( Cwd::getcwd )
  #pod     $path = cwd; # optional export
  #pod
  #pod Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  #pod This is slightly faster than C<< path(".")->absolute >>.
  #pod
  #pod C<cwd> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  #pod =construct rootdir
  #pod
  #pod     $path = Path::Tiny->rootdir; # /
  #pod     $path = rootdir;             # optional export 
  #pod
  #pod Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  #pod picky for C<path("/")>.
  #pod
  #pod C<rootdir> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  #pod =construct tempfile, tempdir
  #pod
  #pod     $temp = Path::Tiny->tempfile( @options );
  #pod     $temp = Path::Tiny->tempdir( @options );
  #pod     $temp = $dirpath->tempfile( @options );
  #pod     $temp = $dirpath->tempdir( @options );
  #pod     $temp = tempfile( @options ); # optional export
  #pod     $temp = tempdir( @options );  # optional export
  #pod
  #pod C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  #pod object with the file name.  The C<TMPDIR> option is enabled by default.
  #pod
  #pod The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  #pod destroyed, the C<File::Temp> object will be as well.
  #pod
  #pod C<File::Temp> annoyingly requires you to specify a custom template in slightly
  #pod different ways depending on which function or method you call, but
  #pod C<Path::Tiny> lets you ignore that and can take either a leading template or a
  #pod C<TEMPLATE> option and does the right thing.
  #pod
  #pod     $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
  #pod     $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  #pod
  #pod The tempfile path object will be normalized to have an absolute path, even if
  #pod created in a relative directory using C<DIR>.  If you want it to have
  #pod the C<realpath> instead, pass a leading options hash like this:
  #pod
  #pod     $real_temp = tempfile({realpath => 1}, @options);
  #pod
  #pod C<tempdir> is just like C<tempfile>, except it calls
  #pod C<< File::Temp->newdir >> instead.
  #pod
  #pod Both C<tempfile> and C<tempdir> may be exported on request and used as
  #pod functions instead of as methods.
  #pod
  #pod The methods can be called on an instances representing a
  #pod directory. In this case, the directory is used as the base to create the
  #pod temporary file/directory, setting the C<DIR> option in File::Temp.
  #pod
  #pod     my $target_dir = path('/to/destination');
  #pod     my $tempfile = $target_dir->tempfile('foobarXXXXXX');
  #pod     $tempfile->spew('A lot of data...');  # not atomic
  #pod     $tempfile->move($target_dir->child('foobar')); # hopefully atomic
  #pod
  #pod In this case, any value set for option C<DIR> is ignored.
  #pod
  #pod B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  #pod reused.  This is not as secure as using File::Temp handles directly, but is
  #pod less prone to deadlocks or access problems on some platforms.  Think of what
  #pod C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  #pod up.
  #pod
  #pod B<Note 2>: if you don't want these cleaned up automatically when the object
  #pod is destroyed, File::Temp requires different options for directories and
  #pod files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  #pod files.
  #pod
  #pod B<Note 3>: Don't lose the temporary object by chaining a method call instead
  #pod of storing it:
  #pod
  #pod     my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  #pod
  #pod B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  #pod Keeping a reference to, or modifying the cached object may break the
  #pod behavior documented above and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.119.
  #pod
  #pod =cut
  
  sub tempfile {
      my ( $opts, $maybe_template, $args )
          = _parse_file_temp_args(tempfile => @_);
  
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = $opts->{realpath} ? path($temp)->realpath : path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      my ( $opts, $maybe_template, $args )
          = _parse_file_temp_args(tempdir => @_);
  
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = $opts->{realpath} ? path($temp)->realpath : path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      # Some ActiveState Perls for Windows break Cwd in ways that lead
      # File::Temp to get confused about what path to remove; this
      # monkey-patches the object with our own view of the absolute path
      $temp->{REALNAME} = $self->[CANON] if IS_WIN32;
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $called_as = shift;
      if ( @_ && $_[0] eq 'Path::Tiny' ) { shift } # class method
      elsif ( @_ && eval{$_[0]->isa('Path::Tiny')} ) {
          my $dir = shift;
          if (! $dir->is_dir) {
              $dir->_throw( $called_as, $dir, "is not a directory object" );
          }
          push @_, DIR => $dir->stringify; # no overriding
      }
      my $opts = ( @_ && ref $_[0] eq 'HASH' ) ? shift @_ : {};
      $opts = _get_args( $opts, qw/realpath/ );
  
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
  
      return ( $opts, \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  sub _resolve_symlinks {
      my ($self) = @_;
      my $new = $self;
      my ( $count, %seen ) = 0;
      while ( -l $new->[PATH] ) {
          if ( $seen{ $new->[PATH] }++ ) {
              $self->_throw( 'readlink', $self->[PATH], "symlink loop detected" );
          }
          if ( ++$count > 100 ) {
              $self->_throw( 'readlink', $self->[PATH], "maximum symlink depth exceeded" );
          }
          my $resolved = readlink $new->[PATH] or $new->_throw( 'readlink', $new->[PATH] );
          $resolved = path($resolved);
          $new = $resolved->is_absolute ? $resolved : $new->sibling($resolved);
      }
      return $new;
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  #pod =method absolute
  #pod
  #pod     $abs = path("foo/bar")->absolute;
  #pod     $abs = path("foo/bar")->absolute("/tmp");
  #pod
  #pod Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  #pod absolute).  If no argument is given, the current directory is used as the
  #pod absolute base path.  If an argument is given, it will be converted to an
  #pod absolute path (if it is not already) and used as the absolute base path.
  #pod
  #pod This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  #pod in L<File::Spec> would normally do so on your platform.  If you need them
  #pod resolved, you must call the more expensive C<realpath> method instead.
  #pod
  #pod On Windows, an absolute path without a volume component will have it added
  #pod based on the current drive.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # no base means use current directory as base
      require Cwd;
      return path( Cwd::getcwd(), $_[0]->[PATH] ) unless defined $base;
  
      # relative base should be made absolute; we check is_absolute rather
      # than unconditionally make base absolute so that "/foo" doesn't become
      # "C:/foo" on Windows.
      $base = path($base);
      return path( ( $base->is_absolute ? $base : $base->absolute ), $_[0]->[PATH] );
  }
  
  #pod =method append, append_raw, append_utf8
  #pod
  #pod     path("foo.txt")->append(@data);
  #pod     path("foo.txt")->append(\@data);
  #pod     path("foo.txt")->append({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->append_raw(@data);
  #pod     path("foo.txt")->append_utf8(@data);
  #pod
  #pod Appends data to a file.  The file is locked with C<flock> prior to writing
  #pod and closed afterwards.  An optional hash reference may be used to pass
  #pod options.  Valid options are:
  #pod
  #pod =for :list
  #pod * C<binmode>: passed to C<binmode()> on the handle used for writing.
  #pod * C<truncate>: truncates the file after locking and before appending
  #pod
  #pod The C<truncate> option is a way to replace the contents of a file
  #pod B<in place>, unlike L</spew> which writes to a temporary file and then
  #pod replaces the original (if it exists).
  #pod
  #pod C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<append_utf8> is like C<append> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw append will be done instead on the data encoded
  #pod with C<Unicode::UTF8>.
  #pod
  #pod Current API available since 0.060.
  #pod
  #pod =cut
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $mode = $args->{truncate} ? ">" : ">>";
      my $fh = $self->filehandle( { locked => 1 }, $mode, $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      $args->{binmode} = ':unix';
      append( $self, $args, @data );
  }
  
  sub append_utf8 {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          $args->{binmode} = ":unix";
          append( $self, $args, map { Unicode::UTF8::encode_utf8($_) } @data );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          append( $self, $args, @data );
      }
      else {
          $args->{binmode} = ":unix:encoding(UTF-8)";
          append( $self, $args, @data );
      }
  }
  
  #pod =method assert
  #pod
  #pod     $path = path("foo.txt")->assert( sub { $_->exists } );
  #pod
  #pod Returns the invocant after asserting that a code reference argument returns
  #pod true.  When the assertion code reference runs, it will have the invocant
  #pod object in the C<$_> variable.  If it returns false, an exception will be
  #pod thrown.  The assertion code reference may also throw its own exception.
  #pod
  #pod If no assertion is provided, the invocant is returned without error.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut
  
  sub assert {
      my ( $self, $assertion ) = @_;
      return $self unless $assertion;
      if ( ref $assertion eq 'CODE' ) {
          local $_ = $self;
          $assertion->()
            or Path::Tiny::Error->throw( "assert", $self->[PATH], "failed assertion" );
      }
      else {
          Carp::croak("argument to assert must be a code reference argument");
      }
      return $self;
  }
  
  #pod =method basename
  #pod
  #pod     $name = path("foo/bar.txt")->basename;        # bar.txt
  #pod     $name = path("foo.txt")->basename('.txt');    # foo
  #pod     $name = path("foo.txt")->basename(qr/.txt/);  # foo
  #pod     $name = path("foo.txt")->basename(@suffixes);
  #pod
  #pod Returns the file portion or last directory portion of a path.
  #pod
  #pod Given a list of suffixes as strings or regular expressions, any that match at
  #pod the end of the file portion or last directory portion will be removed before
  #pod the result is returned.
  #pod
  #pod Current API available since 0.054.
  #pod
  #pod =cut
  
  sub basename {
      my ( $self, @suffixes ) = @_;
      $self->_splitpath unless defined $self->[FILE];
      my $file = $self->[FILE];
      for my $s (@suffixes) {
          my $re = ref($s) eq 'Regexp' ? qr/$s\z/ : qr/\Q$s\E\z/;
          last if $file =~ s/$re//;
      }
      return $file;
  }
  
  #pod =method canonpath
  #pod
  #pod     $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  #pod
  #pod Returns a string with the canonical format of the path name for
  #pod the platform.  In particular, this means directory separators
  #pod will be C<\> on Windows.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub canonpath { $_[0]->[CANON] }
  
  #pod =method cached_temp
  #pod
  #pod Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  #pod C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  #pod If there is no such object, this method throws.
  #pod
  #pod B<WARNING>: Keeping a reference to, or modifying the cached object may
  #pod break the behavior documented for temporary files and directories created
  #pod with C<Path::Tiny> and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut
  
  sub cached_temp {
      my $self = shift;
      $self->_throw( "cached_temp", $self, "has no cached File::Temp object" )
        unless defined $self->[TEMP];
      return $self->[TEMP];
  }
  
  #pod =method child
  #pod
  #pod     $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
  #pod     $file = path("/tmp")->child(@parts);
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the original.  Works
  #pod like C<catfile> or C<catdir> from File::Spec, but without caring about
  #pod file or directories.
  #pod
  #pod B<WARNING>: because the argument could contain C<..> or refer to symlinks,
  #pod there is no guarantee that the new path refers to an actual descendent of
  #pod the original.  If this is important to you, transform parent and child with
  #pod L</realpath> and check them with L</subsumes>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  #pod =method children
  #pod
  #pod     @paths = path("/tmp")->children;
  #pod     @paths = path("/tmp")->children( qr/\.txt\z/ );
  #pod
  #pod Returns a list of C<Path::Tiny> objects for all files and directories
  #pod within a directory.  Excludes "." and ".." automatically.
  #pod
  #pod If an optional C<qr//> argument is provided, it only returns objects for child
  #pod names that match the given regular expression.  Only the base name is used
  #pod for matching:
  #pod
  #pod     @paths = path("/tmp")->children( qr/^foo/ );
  #pod     # matches children like the glob foo*
  #pod
  #pod Current API available since 0.028.
  #pod
  #pod =cut
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  #pod =method chmod
  #pod
  #pod     path("foo.txt")->chmod(0777);
  #pod     path("foo.txt")->chmod("0755");
  #pod     path("foo.txt")->chmod("go-w");
  #pod     path("foo.txt")->chmod("a=r,u+wx");
  #pod
  #pod Sets file or directory permissions.  The argument can be a numeric mode, a
  #pod octal string beginning with a "0" or a limited subset of the symbolic mode use
  #pod by F</bin/chmod>.
  #pod
  #pod The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  #pod match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  #pod "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  #pod are required for each clause, multiple ops are not allowed and permissions
  #pod C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut
  
  sub chmod {
      my ( $self, $new_mode ) = @_;
  
      my $mode;
      if ( $new_mode =~ /\d/ ) {
          $mode = ( $new_mode =~ /^0/ ? oct($new_mode) : $new_mode );
      }
      elsif ( $new_mode =~ /[=+-]/ ) {
          $mode = _symbolic_chmod( $self->stat->mode & 07777, $new_mode ); ## no critic
      }
      else {
          Carp::croak("Invalid mode argument '$new_mode' for chmod()");
      }
  
      CORE::chmod( $mode, $self->[PATH] ) or $self->_throw("chmod");
  
      return 1;
  }
  
  #pod =method copy
  #pod
  #pod     path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  #pod
  #pod Copies the current path to the given destination using L<File::Copy>'s
  #pod C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  #pod newly copied file.
  #pod
  #pod Current API available since 0.070.
  #pod
  #pod =cut
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  
      return -d $dest ? path( $dest, $self->basename ) : path($dest);
  }
  
  #pod =method digest
  #pod
  #pod     $obj = path("/tmp/foo.txt")->digest;        # SHA-256
  #pod     $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  #pod     $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  #pod
  #pod Returns a hexadecimal digest for a file.  An optional hash reference of options may
  #pod be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  #pod bytes will be read at a time.  If not provided, the entire file will be slurped
  #pod into memory to compute the digest.
  #pod
  #pod Any subsequent arguments are passed to the constructor for L<Digest> to select
  #pod an algorithm.  If no arguments are given, the default is SHA-256.
  #pod
  #pod Current API available since 0.056.
  #pod
  #pod =cut
  
  sub digest {
      my ( $self, @opts ) = @_;
      my $args = ( @opts && ref $opts[0] eq 'HASH' ) ? shift @opts : {};
      $args = _get_args( $args, qw/chunk_size/ );
      unshift @opts, 'SHA-256' unless @opts;
      require Digest;
      my $digest = Digest->new(@opts);
      if ( $args->{chunk_size} ) {
          my $fh = $self->filehandle( { locked => 1 }, "<", ":unix" );
          my $buf;
          $digest->add($buf) while read $fh, $buf, $args->{chunk_size};
      }
      else {
          $digest->add( $self->slurp_raw );
      }
      return $digest->hexdigest;
  }
  
  #pod =method dirname (deprecated)
  #pod
  #pod     $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  #pod
  #pod Returns the directory portion you would get from calling
  #pod C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  #pod parent directory portion.  Because L<File::Spec> is inconsistent, the result
  #pod might or might not have a trailing slash.  Because of this, this method is
  #pod B<deprecated>.
  #pod
  #pod A better, more consistently approach is likely C<< $path->parent->stringify >>,
  #pod which will not have a trailing slash except for a root directory.
  #pod
  #pod Deprecated in 0.056.
  #pod
  #pod =cut
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  #pod =method edit, edit_raw, edit_utf8
  #pod
  #pod     path("foo.txt")->edit( \&callback, $options );
  #pod     path("foo.txt")->edit_utf8( \&callback );
  #pod     path("foo.txt")->edit_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file using a single
  #pod callback argument. They slurp the file using C<slurp>, place the contents
  #pod inside a localized C<$_> variable, call the callback function (without
  #pod arguments), and then write C<$_> (presumably mutated) back to the
  #pod file with C<spew>.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to C<slurp> and C<spew>.
  #pod
  #pod C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  #pod C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut
  
  sub edit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      local $_ =
        $self->slurp( exists( $args->{binmode} ) ? { binmode => $args->{binmode} } : () );
      $cb->();
      $self->spew( $args, $_ );
  
      return;
  }
  
  # this is done long-hand to benefit from slurp_utf8 optimizations
  sub edit_utf8 {
      my ( $self, $cb ) = @_;
      Carp::croak("Callback for edit_utf8() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      local $_ = $self->slurp_utf8;
      $cb->();
      $self->spew_utf8($_);
  
      return;
  }
  
  sub edit_raw { $_[2] = { binmode => ":unix" }; goto &edit }
  
  #pod =method edit_lines, edit_lines_utf8, edit_lines_raw
  #pod
  #pod     path("foo.txt")->edit_lines( \&callback, $options );
  #pod     path("foo.txt")->edit_lines_utf8( \&callback );
  #pod     path("foo.txt")->edit_lines_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file's lines using a
  #pod single callback argument.  They iterate over the file: for each line, the
  #pod line is put into a localized C<$_> variable, the callback function is
  #pod executed (without arguments) and then C<$_> is written to a temporary file.
  #pod When iteration is finished, the temporary file is atomically renamed over
  #pod the original.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to the method that open handles for reading and
  #pod writing.
  #pod
  #pod C<edit_lines_utf8> and C<edit_lines_raw> act like their respective
  #pod C<slurp_*> and C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut
  
  sub edit_lines {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit_lines() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
  
      # writing need to follow the link and create the tempfile in the same
      # dir for later atomic rename
      my $resolved_path = $self->_resolve_symlinks;
      my $temp          = path( $resolved_path . $$ . int( rand( 2**31 ) ) );
  
      my $temp_fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      my $in_fh = $self->filehandle( { locked => 1 }, '<', $binmode );
  
      local $_;
      while (<$in_fh>) {
          $cb->();
          $temp_fh->print($_);
      }
  
      close $temp_fh or $self->_throw( 'close', $temp );
      close $in_fh or $self->_throw('close');
  
      return $temp->move($resolved_path);
  }
  
  sub edit_lines_raw { $_[2] = { binmode => ":unix" }; goto &edit_lines }
  
  sub edit_lines_utf8 {
      $_[2] = { binmode => ":raw:encoding(UTF-8)" };
      goto &edit_lines;
  }
  
  #pod =method exists, is_file, is_dir
  #pod
  #pod     if ( path("/tmp")->exists ) { ... }     # -e
  #pod     if ( path("/tmp")->is_dir ) { ... }     # -d
  #pod     if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  #pod
  #pod Implements file test operations, this means the file or directory actually has
  #pod to exist on the filesystem.  Until then, it's just a path.
  #pod
  #pod B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  #pod C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  #pod read just like files.
  #pod
  #pod Use C<-f> instead if you really mean to check for a plain file.
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -e $_[0]->[PATH] && !-d _ }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  #pod =method filehandle
  #pod
  #pod     $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  #pod
  #pod Returns an open file handle.  The C<$mode> argument must be a Perl-style
  #pod read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  #pod is given, it is set during the C<open> call.
  #pod
  #pod An optional hash reference may be used to pass options.
  #pod
  #pod The C<locked> option governs file locking; if true, handles opened for writing,
  #pod appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  #pod locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  #pod truncation until after the lock is acquired.
  #pod
  #pod The C<exclusive> option causes the open() call to fail if the file already
  #pod exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  #pod C<exclusive> implies C<locked> and will set it for you if you forget it.
  #pod
  #pod See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  #pod
  #pod Current API available since 0.066.
  #pod
  #pod =cut
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked exclusive/ );
      $args->{locked} = 1 if $args->{exclusive};
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} && !$ENV{PERL_PATH_TINY_NO_FLOCK} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              $flags |= Fcntl::O_EXCL() if $args->{exclusive};
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX if
              # the file is writable; otherwise give up on locking.  N.B.
              # checking -w before open to determine the open mode is an
              # unavoidable race condition
              if ( -w $self->[PATH] ) {
                  $opentype = "+<";
                  $lock     = Fcntl::LOCK_EX();
              }
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  #pod =method is_absolute, is_relative
  #pod
  #pod     if ( path("/tmp")->is_absolute ) { ... }
  #pod     if ( path("/tmp")->is_relative ) { ... }
  #pod
  #pod Booleans for whether the path appears absolute or relative.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  #pod =method is_rootdir
  #pod
  #pod     while ( ! $path->is_rootdir ) {
  #pod         $path = $path->parent;
  #pod         ...
  #pod     }
  #pod
  #pod Boolean for whether the path is the root directory of the volume.  I.e. the
  #pod C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  #pod
  #pod This works even on C<MSWin32> with drives and UNC volumes:
  #pod
  #pod     path("C:/")->is_rootdir;             # true
  #pod     path("//server/share/")->is_rootdir; #true
  #pod
  #pod Current API available since 0.038.
  #pod
  #pod =cut
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  #pod =method iterator
  #pod
  #pod     $iter = path("/tmp")->iterator( \%options );
  #pod
  #pod Returns a code reference that walks a directory lazily.  Each invocation
  #pod returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  #pod
  #pod     $iter = path("/tmp")->iterator;
  #pod     while ( $path = $iter->() ) {
  #pod         ...
  #pod     }
  #pod
  #pod The current and parent directory entries ("." and "..") will not
  #pod be included.
  #pod
  #pod If the C<recurse> option is true, the iterator will walk the directory
  #pod recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  #pod directory links will be followed recursively.  There is no protection against
  #pod loops when following links. If a directory is not readable, it will not be
  #pod followed.
  #pod
  #pod The default is the same as:
  #pod
  #pod     $iter = path("/tmp")->iterator( {
  #pod         recurse         => 0,
  #pod         follow_symlinks => 0,
  #pod     } );
  #pod
  #pod For a more powerful, recursive iterator with built-in loop avoidance, see
  #pod L<Path::Iterator::Rule>.
  #pod
  #pod See also L</visit>.
  #pod
  #pod Current API available since 0.016.
  #pod
  #pod =cut
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  #pod =method lines, lines_raw, lines_utf8
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines;
  #pod     @contents = path("/tmp/foo.txt")->lines(\%options);
  #pod     @contents = path("/tmp/foo.txt")->lines_raw;
  #pod     @contents = path("/tmp/foo.txt")->lines_utf8;
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  #pod
  #pod Returns a list of lines from a file.  Optionally takes a hash-reference of
  #pod options.  Valid options are C<binmode>, C<count> and C<chomp>.
  #pod
  #pod If C<binmode> is provided, it will be set on the handle prior to reading.
  #pod
  #pod If a positive C<count> is provided, that many lines will be returned from the
  #pod start of the file.  If a negative C<count> is provided, the entire file will be
  #pod read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  #pod exceeds the number of lines in the file, all lines will be returned.
  #pod
  #pod If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  #pod C<LF>) will be removed from the lines returned.
  #pod
  #pod Because the return is a list, C<lines> in scalar context will return the number
  #pod of lines (and throw away the data).
  #pod
  #pod     $number_of_lines = path("/tmp/foo.txt")->lines;
  #pod
  #pod C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  #pod instead of C<:unix> so PerlIO buffering can manage reading by line.
  #pod
  #pod C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  #pod (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  #pod UTF-8 slurp will be done and then the lines will be split.  This is
  #pod actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  #pod intensive.  If memory use is a concern, consider C<openr_utf8> and
  #pod iterating directly on the handle.
  #pod
  #pod Current API available since 0.065.
  #pod
  #pod =cut
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( $counter, $mod, @result ) = ( 0, abs( $args->{count} ) );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})\z// if $chomp;
              $result[ $counter++ ] = $line;
              # for positive count, terminate after right number of lines
              last if $counter == $args->{count};
              # for negative count, eventually wrap around in the result array
              $counter %= $mod;
          }
          # reorder results if full and wrapped somewhere in the middle
          splice( @result, 0, 0, splice( @result, $counter ) )
            if @result == $mod && $counter % $mod;
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})\z//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  my $CRLF = qr/(?:\x{0d}?\x{0a}|\x{0d})/;
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) )
          && $args->{chomp}
          && !$args->{count} )
      {
          my $slurp = slurp_utf8($self);
          $slurp =~ s/$CRLF\z//; # like chomp, but full CR?LF|CR
          return split $CRLF, $slurp, -1; ## no critic
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          return lines( $self, $args );
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  #pod =method mkpath
  #pod
  #pod     path("foo/bar/baz")->mkpath;
  #pod     path("foo/bar/baz")->mkpath( \%options );
  #pod
  #pod Like calling C<make_path> from L<File::Path>.  An optional hash reference
  #pod is passed through to C<make_path>.  Errors will be trapped and an exception
  #pod thrown.  Returns the list of directories created or an empty list if
  #pod the directories already exist, just like C<make_path>.
  #pod
  #pod See also L</touchpath> as a chainable alternative to create a writeable file path
  #pod (though without options).
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  #pod =method move
  #pod
  #pod     path("foo.txt")->move("bar.txt");
  #pod
  #pod Move the current path to the given destination path using Perl's
  #pod built-in L<rename|perlfunc/rename> function. Returns the result
  #pod of the C<rename> function (except it throws an exception if it fails).
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst" );
  }
  
  #pod =method openr, openw, openrw, opena
  #pod
  #pod     $fh = path("foo.txt")->openr($binmode);  # read
  #pod     $fh = path("foo.txt")->openr_raw;
  #pod     $fh = path("foo.txt")->openr_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openw($binmode);  # write
  #pod     $fh = path("foo.txt")->openw_raw;
  #pod     $fh = path("foo.txt")->openw_utf8;
  #pod
  #pod     $fh = path("foo.txt")->opena($binmode);  # append
  #pod     $fh = path("foo.txt")->opena_raw;
  #pod     $fh = path("foo.txt")->opena_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openrw($binmode); # read/write
  #pod     $fh = path("foo.txt")->openrw_raw;
  #pod     $fh = path("foo.txt")->openrw_utf8;
  #pod
  #pod Returns a file handle opened in the specified mode.  The C<openr> style methods
  #pod take a single C<binmode> argument.  All of the C<open*> methods have
  #pod C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  #pod C<:raw:encoding(UTF-8)>, respectively.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<locked>.  If true, handles opened for writing, appending or read-write are
  #pod locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  #pod
  #pod     $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  #pod
  #pod See L</filehandle> for more on locking.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  #pod =method parent
  #pod
  #pod     $parent = path("foo/bar/baz")->parent; # foo/bar
  #pod     $parent = path("foo/wibble.txt")->parent; # foo
  #pod
  #pod     $parent = path("foo/bar/baz")->parent(2); # foo
  #pod
  #pod Returns a C<Path::Tiny> object corresponding to the parent directory of the
  #pod original directory or file. An optional positive integer argument is the number
  #pod of parent directories upwards to return.  C<parent> by itself is equivalent to
  #pod C<parent(1)>.
  #pod
  #pod Current API available since 0.014.
  #pod
  #pod =cut
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.\z)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/\z}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  #pod =method realpath
  #pod
  #pod     $real = path("/baz/foo/../bar")->realpath;
  #pod     $real = path("foo/../bar")->realpath;
  #pod
  #pod Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  #pod parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  #pod more expensive as it must actually consult the filesystem.
  #pod
  #pod If the parent path can't be resolved (e.g. if it includes directories that
  #pod don't exist), an exception will be thrown:
  #pod
  #pod     $real = path("doesnt_exist/foo")->realpath; # dies
  #pod
  #pod However, if the parent path exists and only the last component (e.g. filename)
  #pod doesn't exist, the realpath will be the realpath of the parent plus the
  #pod non-existent last component:
  #pod
  #pod     $real = path("./aasdlfasdlf")->realpath; # works
  #pod
  #pod The underlying L<Cwd> module usually worked this way on Unix, but died on
  #pod Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  #pod it's safe to use anywhere.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  # Win32 and some Unixes need parent path resolved separately so realpath
  # doesn't throw an error resolving non-existent basename
  sub realpath {
      my $self = shift;
      $self = $self->_resolve_symlinks;
      require Cwd;
      $self->_splitpath if !defined $self->[FILE];
      my $check_parent =
        length $self->[FILE] && $self->[FILE] ne '.' && $self->[FILE] ne '..';
      my $realpath = eval {
          # pure-perl Cwd can carp
          local $SIG{__WARN__} = sub { };
          Cwd::realpath( $check_parent ? $self->parent->[PATH] : $self->[PATH] );
      };
      # parent realpath must exist; not all Cwd::realpath will error if it doesn't
      $self->_throw("resolving realpath")
        unless defined $realpath && length $realpath && -e $realpath;
      return ( $check_parent ? path( $realpath, $self->[FILE] ) : path($realpath) );
  }
  
  #pod =method relative
  #pod
  #pod     $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  #pod
  #pod Returns a C<Path::Tiny> object with a path relative to a new base path
  #pod given as an argument.  If no argument is given, the current directory will
  #pod be used as the new base path.
  #pod
  #pod If either path is already relative, it will be made absolute based on the
  #pod current directly before determining the new relative path.
  #pod
  #pod The algorithm is roughly as follows:
  #pod
  #pod =for :list
  #pod * If the original and new base path are on different volumes, an exception
  #pod   will be thrown.
  #pod * If the original and new base are identical, the relative path is C<".">.
  #pod * If the new base subsumes the original, the relative path is the original
  #pod   path with the new base chopped off the front
  #pod * If the new base does not subsume the original, a common prefix path is
  #pod   determined (possibly the root directory) and the relative path will
  #pod   consist of updirs (C<"..">) to reach the common prefix, followed by the
  #pod   original path less the common prefix.
  #pod
  #pod Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  #pod on a common prefix takes into account symlinks that could affect the updir
  #pod process.  Given an original path "/A/B" and a new base "/A/C",
  #pod (where "A", "B" and "C" could each have multiple path components):
  #pod
  #pod =for :list
  #pod * Symlinks in "A" don't change the result unless the last component of A is
  #pod   a symlink and the first component of "C" is an updir.
  #pod * Symlinks in "B" don't change the result and will exist in the result as
  #pod   given.
  #pod * Symlinks and updirs in "C" must be resolved to actual paths, taking into
  #pod   account the possibility that not all path components might exist on the
  #pod   filesystem.
  #pod
  #pod Current API available since 0.001.  New algorithm (that accounts for
  #pod symlinks) available since 0.079.
  #pod
  #pod =cut
  
  sub relative {
      my ( $self, $base ) = @_;
      $base = path( defined $base && length $base ? $base : '.' );
  
      # relative paths must be converted to absolute first
      $self = $self->absolute if $self->is_relative;
      $base = $base->absolute if $base->is_relative;
  
      # normalize volumes if they exist
      $self = $self->absolute if !length $self->volume && length $base->volume;
      $base = $base->absolute if length $self->volume  && !length $base->volume;
  
      # can't make paths relative across volumes
      if ( !_same( $self->volume, $base->volume ) ) {
          Carp::croak("relative() can't cross volumes: '$self' vs '$base'");
      }
  
      # if same absolute path, relative is current directory
      return path(".") if _same( $self->[PATH], $base->[PATH] );
  
      # if base is a prefix of self, chop prefix off self
      if ( $base->subsumes($self) ) {
          $base = "" if $base->is_rootdir;
          my $relative = "$self";
          $relative =~ s{\A\Q$base/}{};
          return path($relative);
      }
  
      # base is not a prefix, so must find a common prefix (even if root)
      my ( @common, @self_parts, @base_parts );
      @base_parts = split /\//, $base->_just_filepath;
  
      # if self is rootdir, then common directory is root (shown as empty
      # string for later joins); otherwise, must be computed from path parts.
      if ( $self->is_rootdir ) {
          @common = ("");
          shift @base_parts;
      }
      else {
          @self_parts = split /\//, $self->_just_filepath;
  
          while ( @self_parts && @base_parts && _same( $self_parts[0], $base_parts[0] ) ) {
              push @common, shift @base_parts;
              shift @self_parts;
          }
      }
  
      # if there are any symlinks from common to base, we have a problem, as
      # you can't guarantee that updir from base reaches the common prefix;
      # we must resolve symlinks and try again; likewise, any updirs are
      # a problem as it throws off calculation of updirs needed to get from
      # self's path to the common prefix.
      if ( my $new_base = $self->_resolve_between( \@common, \@base_parts ) ) {
          return $self->relative($new_base);
      }
  
      # otherwise, symlinks in common or from common to A don't matter as
      # those don't involve updirs
      my @new_path = ( ("..") x ( 0+ @base_parts ), @self_parts );
      return path(@new_path);
  }
  
  sub _just_filepath {
      my $self     = shift;
      my $self_vol = $self->volume;
      return "$self" if !length $self_vol;
  
      ( my $self_path = "$self" ) =~ s{\A\Q$self_vol}{};
  
      return $self_path;
  }
  
  sub _resolve_between {
      my ( $self, $common, $base ) = @_;
      my $path = $self->volume . join( "/", @$common );
      my $changed = 0;
      for my $p (@$base) {
          $path .= "/$p";
          if ( $p eq '..' ) {
              $changed = 1;
              if ( -e $path ) {
                  $path = path($path)->realpath->[PATH];
              }
              else {
                  $path =~ s{/[^/]+/..\z}{/};
              }
          }
          if ( -l $path ) {
              $changed = 1;
              $path    = path($path)->realpath->[PATH];
          }
      }
      return $changed ? path($path) : undef;
  }
  
  #pod =method remove
  #pod
  #pod     path("foo.txt")->remove;
  #pod
  #pod This is just like C<unlink>, except for its error handling: if the path does
  #pod not exist, it returns false; if deleting the file fails, it throws an
  #pod exception.
  #pod
  #pod Current API available since 0.012.
  #pod
  #pod =cut
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink( $self->[PATH] ) || $self->_throw('unlink');
  }
  
  #pod =method remove_tree
  #pod
  #pod     # directory
  #pod     path("foo/bar/baz")->remove_tree;
  #pod     path("foo/bar/baz")->remove_tree( \%options );
  #pod     path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  #pod
  #pod Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  #pod An optional hash reference is passed through to C<remove_tree>.  Errors will be
  #pod trapped and an exception thrown.  Returns the number of directories deleted,
  #pod just like C<remove_tree>.
  #pod
  #pod If you want to remove a directory only if it is empty, use the built-in
  #pod C<rmdir> function instead.
  #pod
  #pod     rmdir path("foo/bar/baz/");
  #pod
  #pod Current API available since 0.013.
  #pod
  #pod =cut
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      $args->{safe}  = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  #pod =method sibling
  #pod
  #pod     $foo = path("/tmp/foo.txt");
  #pod     $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
  #pod     $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the parent of the original.
  #pod This is slightly more efficient than C<< $path->parent->child(...) >>.
  #pod
  #pod Current API available since 0.058.
  #pod
  #pod =cut
  
  sub sibling {
      my $self = shift;
      return path( $self->parent->[PATH], @_ );
  }
  
  #pod =method size, size_human
  #pod
  #pod     my $p = path("foo"); # with size 1025 bytes
  #pod
  #pod     $p->size;                            # "1025"
  #pod     $p->size_human;                      # "1.1 K"
  #pod     $p->size_human( {format => "iec"} ); # "1.1 KiB"
  #pod
  #pod Returns the size of a file.  The C<size> method is just a wrapper around C<-s>.
  #pod
  #pod The C<size_human> method provides a human-readable string similar to
  #pod C<ls -lh>.  Like C<ls>, it rounds upwards and provides one decimal place for
  #pod single-digit sizes and no decimal places for larger sizes.  The only available
  #pod option is C<format>, which has three valid values:
  #pod
  #pod =for :list
  #pod * 'ls' (the default): base-2 sizes, with C<ls> style single-letter suffixes (K, M, etc.)
  #pod * 'iec': base-2 sizes, with IEC binary suffixes (KiB, MiB, etc.)
  #pod * 'si': base-10 sizes, with SI decimal suffixes (kB, MB, etc.)
  #pod
  #pod If C<-s> would return C<undef>, C<size_human> returns the empty string.
  #pod
  #pod Current API available since 0.122.
  #pod
  #pod =cut
  
  sub size { -s $_[0]->[PATH] }
  
  my %formats = (
      'ls'  => [ 1024, log(1024), [ "", map { " $_" } qw/K M G T/ ] ],
      'iec' => [ 1024, log(1024), [ "", map { " $_" } qw/KiB MiB GiB TiB/ ] ],
      'si'  => [ 1000, log(1000), [ "", map { " $_" } qw/kB MB GB TB/ ] ],
  );
  
  sub _formats { return $formats{$_[0]} }
  
  sub size_human {
      my $self     = shift;
      my $args     = _get_args( shift, qw/format/ );
      my $format   = defined $args->{format} ? $args->{format} : "ls";
      my $fmt_opts = $formats{$format}
        or Carp::croak("Invalid format '$format' for size_human()");
      my $size = -s $self->[PATH];
      return defined $size ? _human_size( $size, @$fmt_opts ) : "";
  }
  
  sub _ceil {
      return $_[0] == int($_[0]) ? $_[0] : int($_[0]+1);
  }
  
  sub _human_size {
      my ( $size, $base, $log_base, $suffixes ) = @_;
      return "0" if $size == 0;
  
      my $mag = int( log($size) / $log_base );
      $size /= $base**$mag;
      $size =
          $mag == 0               ? $size
        : length( int($size) ) == 1 ? _ceil( $size * 10 ) / 10
        :                             _ceil($size);
      if ( $size >= $base ) {
          $size /= $base;
          $mag++;
      }
  
      my $fmt = ( $mag == 0 || length( int($size) ) > 1 ) ? "%.0f%s" : "%.1f%s";
      return sprintf( $fmt, $size, $suffixes->[$mag] );
  }
  
  #pod =method slurp, slurp_raw, slurp_utf8
  #pod
  #pod     $data = path("foo.txt")->slurp;
  #pod     $data = path("foo.txt")->slurp( {binmode => ":raw"} );
  #pod     $data = path("foo.txt")->slurp_raw;
  #pod     $data = path("foo.txt")->slurp_utf8;
  #pod
  #pod Reads file contents into a scalar.  Takes an optional hash reference which may
  #pod be used to pass options.  The only available option is C<binmode>, which is
  #pod passed to C<binmode()> on the handle used for reading.
  #pod
  #pod C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  #pod a fast, unbuffered, raw read.
  #pod
  #pod C<slurp_utf8> is like C<slurp> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw slurp will be done instead and the result decoded
  #pod with C<Unicode::UTF8>.  This is just as strict and is roughly an order of
  #pod magnitude faster than using C<:encoding(UTF-8)>.
  #pod
  #pod B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  #pod you plan to slurp from a file created with L<File::Temp>, be sure to
  #pod close other handles or open without locking to avoid a deadlock:
  #pod
  #pod     my $tempfile = File::Temp->new(EXLOCK => 0);
  #pod     my $guts = path($tempfile)->slurp;
  #pod
  #pod Current API available since 0.004.
  #pod
  #pod =cut
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $_[1] = { binmode => ":unix:utf8_strict" };
          goto &slurp;
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  #pod =method spew, spew_raw, spew_utf8
  #pod
  #pod     path("foo.txt")->spew(@data);
  #pod     path("foo.txt")->spew(\@data);
  #pod     path("foo.txt")->spew({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->spew_raw(@data);
  #pod     path("foo.txt")->spew_utf8(@data);
  #pod
  #pod Writes data to a file atomically.  The file is written to a temporary file in
  #pod the same directory, then renamed over the original.  An optional hash reference
  #pod may be used to pass options.  The only option is C<binmode>, which is passed to
  #pod C<binmode()> on the handle used for writing.
  #pod
  #pod C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  #pod (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  #pod spew will be done instead on the data encoded with C<Unicode::UTF8>.
  #pod
  #pod B<NOTE>: because the file is written to a temporary file and then renamed, the
  #pod new file will wind up with permissions based on your current umask.  This is a
  #pod feature to protect you from a race condition that would otherwise give
  #pod different permissions than you might expect.  If you really want to keep the
  #pod original mode flags, use L</append> with the C<truncate> option.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
  
      # spewing need to follow the link
      # and create the tempfile in the same dir
      my $resolved_path = $self->_resolve_symlinks;
  
      my $temp = path( $resolved_path . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          my $self = shift;
          spew(
              $self,
              { binmode => ":unix" },
              map { Unicode::UTF8::encode_utf8($_) } map { ref eq 'ARRAY' ? @$_ : $_ } @_
          );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          splice @_, 1, 0, { binmode => ":unix:utf8_strict" };
          goto &spew;
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  #pod =method stat, lstat
  #pod
  #pod     $stat = path("foo.txt")->stat;
  #pod     $stat = path("/some/symlink")->lstat;
  #pod
  #pod Like calling C<stat> or C<lstat> from L<File::stat>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  #pod =method stringify
  #pod
  #pod     $path = path("foo.txt");
  #pod     say $path->stringify; # same as "$path"
  #pod
  #pod Returns a string representation of the path.  Unlike C<canonpath>, this method
  #pod returns the path standardized with Unix-style C</> directory separators.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub stringify { $_[0]->[PATH] }
  
  #pod =method subsumes
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/baz"); # true
  #pod     path("/foo/bar")->subsumes("/foo/baz");   # false
  #pod
  #pod Returns true if the first path is a prefix of the second path at a directory
  #pod boundary.
  #pod
  #pod This B<does not> resolve parent directory entries (C<..>) or symlinks:
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/../baz"); # true
  #pod
  #pod If such things are important to you, ensure that both paths are resolved to
  #pod the filesystem with C<realpath>:
  #pod
  #pod     my $p1 = path("foo/bar")->realpath;
  #pod     my $p2 = path("foo/bar/../baz")->realpath;
  #pod     if ( $p1->subsumes($p2) ) { ... }
  #pod
  #pod Current API available since 0.048.
  #pod
  #pod =cut
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|\z)};
      }
  }
  
  #pod =method touch
  #pod
  #pod     path("foo.txt")->touch;
  #pod     path("foo.txt")->touch($epoch_secs);
  #pod
  #pod Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  #pod changes the modification and access times to the current time.  If the first
  #pod argument is the epoch seconds then it will be used.
  #pod
  #pod Returns the path object so it can be easily chained with other methods:
  #pod
  #pod     # won't die if foo.txt doesn't exist
  #pod     $content = path("foo.txt")->touch->slurp;
  #pod
  #pod Current API available since 0.015.
  #pod
  #pod =cut
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      if ( defined $epoch ) {
          utime $epoch, $epoch, $self->[PATH]
            or $self->_throw("utime ($epoch)");
      }
      else {
          # literal undef prevents warnings :-(
          utime undef, undef, $self->[PATH]
            or $self->_throw("utime ()");
      }
      return $self;
  }
  
  #pod =method touchpath
  #pod
  #pod     path("bar/baz/foo.txt")->touchpath;
  #pod
  #pod Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  #pod before touching the file.  Returns the path object like C<touch> does.
  #pod
  #pod Current API available since 0.022.
  #pod
  #pod =cut
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  #pod =method visit
  #pod
  #pod     path("/tmp")->visit( \&callback, \%options );
  #pod
  #pod Executes a callback for each child of a directory.  It returns a hash
  #pod reference with any state accumulated during iteration.
  #pod
  #pod The options are the same as for L</iterator> (which it uses internally):
  #pod C<recurse> and C<follow_symlinks>.  Both default to false.
  #pod
  #pod The callback function will receive a C<Path::Tiny> object as the first argument
  #pod and a hash reference to accumulate state as the second argument.  For example:
  #pod
  #pod     # collect files sizes
  #pod     my $sizes = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             return if $path->is_dir;
  #pod             $state->{$path} = -s $path;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod For convenience, the C<Path::Tiny> object will also be locally aliased as the
  #pod C<$_> global variable:
  #pod
  #pod     # print paths matching /foo/
  #pod     path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  #pod
  #pod If the callback returns a B<reference> to a false scalar value, iteration will
  #pod terminate.  This is not the same as "pruning" a directory search; this just
  #pod stops all iteration and returns the state hash reference.
  #pod
  #pod     # find up to 10 files larger than 100K
  #pod     my $files = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             $state->{$path}++ if -s $path > 102400
  #pod             return \0 if keys %$state == 10;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut
  
  sub visit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      Carp::croak("Callback for visit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
      my $next  = $self->iterator($args);
      my $state = {};
      while ( my $file = $next->() ) {
          local $_ = $file;
          my $r = $cb->( $file, $state );
          last if ref($r) eq 'SCALAR' && !$$r;
      }
      return $state;
  }
  
  #pod =method volume
  #pod
  #pod     $vol = path("/tmp/foo.txt")->volume;   # ""
  #pod     $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  #pod
  #pod Returns the volume portion of the path.  This is equivalent
  #pod to what L<File::Spec> would give from C<splitpath> and thus
  #pod usually is the empty string on Unix-like operating systems or the
  #pod drive letter for an absolute path on C<MSWin32>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.124
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    ($head) = $file->lines( {count => 1} );
    ($tail) = $file->lines( {count => -1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module provides a small, fast utility for working with file paths.  It is
  friendlier to use than L<File::Spec> and provides easy access to functions from
  several other core file handling modules.  It aims to be smaller and faster
  than many alternatives on CPAN, while helping people do many common things in
  consistent and less error-prone ways.
  
  Path::Tiny does not try to work for anything except Unix-like and Win32
  platforms.  Even then, it might break if you try something particularly obscure
  or tortuous.  (Quick!  What does this mean:
  C<< ///../../..//./././a//b/.././c/././ >>?  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform and/or filesystem).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode.  On Windows, that means they will not have CRLF translation from the
  C<:crlf> IO layer.  Installing L<Unicode::UTF8> 0.58 or later will speed up
  C<*_utf8> situations in many cases and is highly recommended.
  Alternatively, installing L<PerlIO::utf8_strict> 0.003 or later will be
  used in place of the default C<:encoding(UTF-8)>.
  
  This module depends heavily on PerlIO layers for correct operation and thus
  requires Perl 5.008001 or later.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  If called with a single C<Path::Tiny> argument, the original is returned unless
  the original is holding a temporary file or directory reference in which case a
  stringified copy is made.
  
      $path = path("foo/bar");
      $temp = Path::Tiny->tempfile;
  
      $p2 = path($path); # like $p2 = $path
      $t2 = path($temp); # like $t2 = path( "$temp" )
  
  This optimizes copies without proliferating references unexpectedly if a copy is
  made by code outside your control.
  
  Current API available since 0.017.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  Current API available since 0.001.
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  Current API available since 0.018.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  Current API available since 0.018.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = $dirpath->tempfile( @options );
      $temp = $dirpath->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will be normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.  If you want it to have
  the C<realpath> instead, pass a leading options hash like this:
  
      $real_temp = tempfile({realpath => 1}, @options);
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  The methods can be called on an instances representing a
  directory. In this case, the directory is used as the base to create the
  temporary file/directory, setting the C<DIR> option in File::Temp.
  
      my $target_dir = path('/to/destination');
      my $tempfile = $target_dir->tempfile('foobarXXXXXX');
      $tempfile->spew('A lot of data...');  # not atomic
      $tempfile->move($target_dir->child('foobar')); # hopefully atomic
  
  In this case, any value set for option C<DIR> is ignored.
  
  B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  reused.  This is not as secure as using File::Temp handles directly, but is
  less prone to deadlocks or access problems on some platforms.  Think of what
  C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  up.
  
  B<Note 2>: if you don't want these cleaned up automatically when the object
  is destroyed, File::Temp requires different options for directories and
  files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  files.
  
  B<Note 3>: Don't lose the temporary object by chaining a method call instead
  of storing it:
  
      my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  
  B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  Keeping a reference to, or modifying the cached object may break the
  behavior documented above and is not supported.  Use at your own risk.
  
  Current API available since 0.119.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  If no argument is given, the current directory is used as the
  absolute base path.  If an argument is given, it will be converted to an
  absolute path (if it is not already) and used as the absolute base path.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  Current API available since 0.101.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing
  and closed afterwards.  An optional hash reference may be used to pass
  options.  Valid options are:
  
  =over 4
  
  =item *
  
  C<binmode>: passed to C<binmode()> on the handle used for writing.
  
  =item *
  
  C<truncate>: truncates the file after locking and before appending
  
  =back
  
  The C<truncate> option is a way to replace the contents of a file
  B<in place>, unlike L</spew> which writes to a temporary file and then
  replaces the original (if it exists).
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw append will be done instead on the data encoded
  with C<Unicode::UTF8>.
  
  Current API available since 0.060.
  
  =head2 assert
  
      $path = path("foo.txt")->assert( sub { $_->exists } );
  
  Returns the invocant after asserting that a code reference argument returns
  true.  When the assertion code reference runs, it will have the invocant
  object in the C<$_> variable.  If it returns false, an exception will be
  thrown.  The assertion code reference may also throw its own exception.
  
  If no assertion is provided, the invocant is returned without error.
  
  Current API available since 0.062.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename;        # bar.txt
      $name = path("foo.txt")->basename('.txt');    # foo
      $name = path("foo.txt")->basename(qr/.txt/);  # foo
      $name = path("foo.txt")->basename(@suffixes);
  
  Returns the file portion or last directory portion of a path.
  
  Given a list of suffixes as strings or regular expressions, any that match at
  the end of the file portion or last directory portion will be removed before
  the result is returned.
  
  Current API available since 0.054.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  Current API available since 0.001.
  
  =head2 cached_temp
  
  Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  If there is no such object, this method throws.
  
  B<WARNING>: Keeping a reference to, or modifying the cached object may
  break the behavior documented for temporary files and directories created
  with C<Path::Tiny> and is not supported.  Use at your own risk.
  
  Current API available since 0.101.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  B<WARNING>: because the argument could contain C<..> or refer to symlinks,
  there is no guarantee that the new path refers to an actual descendent of
  the original.  If this is important to you, transform parent and child with
  L</realpath> and check them with L</subsumes>.
  
  Current API available since 0.001.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt\z/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  Current API available since 0.028.
  
  =head2 chmod
  
      path("foo.txt")->chmod(0777);
      path("foo.txt")->chmod("0755");
      path("foo.txt")->chmod("go-w");
      path("foo.txt")->chmod("a=r,u+wx");
  
  Sets file or directory permissions.  The argument can be a numeric mode, a
  octal string beginning with a "0" or a limited subset of the symbolic mode use
  by F</bin/chmod>.
  
  The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  are required for each clause, multiple ops are not allowed and permissions
  C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  
  Current API available since 0.053.
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies the current path to the given destination using L<File::Copy>'s
  C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  newly copied file.
  
  Current API available since 0.070.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
      $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  
  Returns a hexadecimal digest for a file.  An optional hash reference of options may
  be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  bytes will be read at a time.  If not provided, the entire file will be slurped
  into memory to compute the digest.
  
  Any subsequent arguments are passed to the constructor for L<Digest> to select
  an algorithm.  If no arguments are given, the default is SHA-256.
  
  Current API available since 0.056.
  
  =head2 dirname (deprecated)
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory portion you would get from calling
  C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  parent directory portion.  Because L<File::Spec> is inconsistent, the result
  might or might not have a trailing slash.  Because of this, this method is
  B<deprecated>.
  
  A better, more consistently approach is likely C<< $path->parent->stringify >>,
  which will not have a trailing slash except for a root directory.
  
  Deprecated in 0.056.
  
  =head2 edit, edit_raw, edit_utf8
  
      path("foo.txt")->edit( \&callback, $options );
      path("foo.txt")->edit_utf8( \&callback );
      path("foo.txt")->edit_raw( \&callback );
  
  These are convenience methods that allow "editing" a file using a single
  callback argument. They slurp the file using C<slurp>, place the contents
  inside a localized C<$_> variable, call the callback function (without
  arguments), and then write C<$_> (presumably mutated) back to the
  file with C<spew>.
  
  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<slurp> and C<spew>.
  
  C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  C<spew_*> methods.
  
  Current API available since 0.077.
  
  =head2 edit_lines, edit_lines_utf8, edit_lines_raw
  
      path("foo.txt")->edit_lines( \&callback, $options );
      path("foo.txt")->edit_lines_utf8( \&callback );
      path("foo.txt")->edit_lines_raw( \&callback );
  
  These are convenience methods that allow "editing" a file's lines using a
  single callback argument.  They iterate over the file: for each line, the
  line is put into a localized C<$_> variable, the callback function is
  executed (without arguments) and then C<$_> is written to a temporary file.
  When iteration is finished, the temporary file is atomically renamed over
  the original.
  
  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to the method that open handles for reading and
  writing.
  
  C<edit_lines_utf8> and C<edit_lines_raw> act like their respective
  C<slurp_*> and C<spew_*> methods.
  
  Current API available since 0.077.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }     # -e
      if ( path("/tmp")->is_dir ) { ... }     # -d
      if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  
  Implements file test operations, this means the file or directory actually has
  to exist on the filesystem.  Until then, it's just a path.
  
  B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  read just like files.
  
  Use C<-f> instead if you really mean to check for a plain file.
  
  Current API available since 0.053.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.
  
  The C<locked> option governs file locking; if true, handles opened for writing,
  appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  truncation until after the lock is acquired.
  
  The C<exclusive> option causes the open() call to fail if the file already
  exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  C<exclusive> implies C<locked> and will set it for you if you forget it.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  Current API available since 0.066.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  Current API available since 0.001.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  Current API available since 0.038.
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  See also L</visit>.
  
  Current API available since 0.016.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.
  
  If C<binmode> is provided, it will be set on the handle prior to reading.
  
  If a positive C<count> is provided, that many lines will be returned from the
  start of the file.  If a negative C<count> is provided, the entire file will be
  read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  exceeds the number of lines in the file, all lines will be returned.
  
  If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  C<LF>) will be removed from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  Current API available since 0.065.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  See also L</touchpath> as a chainable alternative to create a writeable file path
  (though without options).
  
  Current API available since 0.001.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Move the current path to the given destination path using Perl's
  built-in L<rename|perlfunc/rename> function. Returns the result
  of the C<rename> function (except it throws an exception if it fails).
  
  Current API available since 0.001.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  Current API available since 0.011.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  Current API available since 0.014.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the parent path can't be resolved (e.g. if it includes directories that
  don't exist), an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  However, if the parent path exists and only the last component (e.g. filename)
  doesn't exist, the realpath will be the realpath of the parent plus the
  non-existent last component:
  
      $real = path("./aasdlfasdlf")->realpath; # works
  
  The underlying L<Cwd> module usually worked this way on Unix, but died on
  Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  it's safe to use anywhere.
  
  Current API available since 0.001.
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a path relative to a new base path
  given as an argument.  If no argument is given, the current directory will
  be used as the new base path.
  
  If either path is already relative, it will be made absolute based on the
  current directly before determining the new relative path.
  
  The algorithm is roughly as follows:
  
  =over 4
  
  =item *
  
  If the original and new base path are on different volumes, an exception will be thrown.
  
  =item *
  
  If the original and new base are identical, the relative path is C<".">.
  
  =item *
  
  If the new base subsumes the original, the relative path is the original path with the new base chopped off the front
  
  =item *
  
  If the new base does not subsume the original, a common prefix path is determined (possibly the root directory) and the relative path will consist of updirs (C<"..">) to reach the common prefix, followed by the original path less the common prefix.
  
  =back
  
  Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  on a common prefix takes into account symlinks that could affect the updir
  process.  Given an original path "/A/B" and a new base "/A/C",
  (where "A", "B" and "C" could each have multiple path components):
  
  =over 4
  
  =item *
  
  Symlinks in "A" don't change the result unless the last component of A is a symlink and the first component of "C" is an updir.
  
  =item *
  
  Symlinks in "B" don't change the result and will exist in the result as given.
  
  =item *
  
  Symlinks and updirs in "C" must be resolved to actual paths, taking into account the possibility that not all path components might exist on the filesystem.
  
  =back
  
  Current API available since 0.001.  New algorithm (that accounts for
  symlinks) available since 0.079.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  This is just like C<unlink>, except for its error handling: if the path does
  not exist, it returns false; if deleting the file fails, it throws an
  exception.
  
  Current API available since 0.012.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  Current API available since 0.013.
  
  =head2 sibling
  
      $foo = path("/tmp/foo.txt");
      $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
      $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  
  Returns a new C<Path::Tiny> object relative to the parent of the original.
  This is slightly more efficient than C<< $path->parent->child(...) >>.
  
  Current API available since 0.058.
  
  =head2 size, size_human
  
      my $p = path("foo"); # with size 1025 bytes
  
      $p->size;                            # "1025"
      $p->size_human;                      # "1.1 K"
      $p->size_human( {format => "iec"} ); # "1.1 KiB"
  
  Returns the size of a file.  The C<size> method is just a wrapper around C<-s>.
  
  The C<size_human> method provides a human-readable string similar to
  C<ls -lh>.  Like C<ls>, it rounds upwards and provides one decimal place for
  single-digit sizes and no decimal places for larger sizes.  The only available
  option is C<format>, which has three valid values:
  
  =over 4
  
  =item *
  
  'ls' (the default): base-2 sizes, with C<ls> style single-letter suffixes (K, M, etc.)
  
  =item *
  
  'iec': base-2 sizes, with IEC binary suffixes (KiB, MiB, etc.)
  
  =item *
  
  'si': base-10 sizes, with SI decimal suffixes (kB, MB, etc.)
  
  =back
  
  If C<-s> would return C<undef>, C<size_human> returns the empty string.
  
  Current API available since 0.122.
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference which may
  be used to pass options.  The only available option is C<binmode>, which is
  passed to C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw slurp will be done instead and the result decoded
  with C<Unicode::UTF8>.  This is just as strict and is roughly an order of
  magnitude faster than using C<:encoding(UTF-8)>.
  
  B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  you plan to slurp from a file created with L<File::Temp>, be sure to
  close other handles or open without locking to avoid a deadlock:
  
      my $tempfile = File::Temp->new(EXLOCK => 0);
      my $guts = path($tempfile)->slurp;
  
  Current API available since 0.004.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  spew will be done instead on the data encoded with C<Unicode::UTF8>.
  
  B<NOTE>: because the file is written to a temporary file and then renamed, the
  new file will wind up with permissions based on your current umask.  This is a
  feature to protect you from a race condition that would otherwise give
  different permissions than you might expect.  If you really want to keep the
  original mode flags, use L</append> with the C<truncate> option.
  
  Current API available since 0.011.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  Current API available since 0.001.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  Current API available since 0.001.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  Current API available since 0.048.
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with other methods:
  
      # won't die if foo.txt doesn't exist
      $content = path("foo.txt")->touch->slurp;
  
  Current API available since 0.015.
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  Current API available since 0.022.
  
  =head2 visit
  
      path("/tmp")->visit( \&callback, \%options );
  
  Executes a callback for each child of a directory.  It returns a hash
  reference with any state accumulated during iteration.
  
  The options are the same as for L</iterator> (which it uses internally):
  C<recurse> and C<follow_symlinks>.  Both default to false.
  
  The callback function will receive a C<Path::Tiny> object as the first argument
  and a hash reference to accumulate state as the second argument.  For example:
  
      # collect files sizes
      my $sizes = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              return if $path->is_dir;
              $state->{$path} = -s $path;
          },
          { recurse => 1 }
      );
  
  For convenience, the C<Path::Tiny> object will also be locally aliased as the
  C<$_> global variable:
  
      # print paths matching /foo/
      path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  
  If the callback returns a B<reference> to a false scalar value, iteration will
  terminate.  This is not the same as "pruning" a directory search; this just
  stops all iteration and returns the state hash reference.
  
      # find up to 10 files larger than 100K
      my $files = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              $state->{$path}++ if -s $path > 102400
              return \0 if keys %$state == 10;
          },
          { recurse => 1 }
      );
  
  If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  
  Current API available since 0.062.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  Current API available since 0.001.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_WIN32 FREEZE THAW TO_JSON abs2rel
  
  =head1 EXCEPTION HANDLING
  
  Simple usage errors will generally croak.  Failures of underlying Perl
  functions will be thrown as exceptions in the class
  C<Path::Tiny::Error>.
  
  A C<Path::Tiny::Error> object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op>  a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file>  the file or directory relating to the error
  
  =item *
  
  C<err>  hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg>  a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_PATH_TINY_NO_FLOCK
  
  If the environment variable C<PERL_PATH_TINY_NO_FLOCK> is set to a true
  value then flock will NOT be used when accessing files (this is not
  recommended).
  
  =head1 CAVEATS
  
  =head2 Subclassing not supported
  
  For speed, this class is implemented as an array based object and uses many
  direct function calls internally.  You must not subclass it and expect
  things to work properly.
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  In situations where a platform normally would support locking, but the
  flock fails due to a filesystem limitation, Path::Tiny has some heuristics
  to detect this and will warn once and continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  If detected, this situation will warn once, as described
  above.
  
  =head3 Lustre
  
  The Lustre filesystem does not support flock.  If detected, this situation
  will warn once, as described above.
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.  If the user does not have write
  permission, no lock will be used.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods by default use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.  Alternatively, if you install L<PerlIO::utf8_strict>,
  that will be used instead of C<:encoding(UTF-8)> and is also very fast.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::chmod>
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alex Efros Aristotle Pagaltzis Chris Williams Dan Book Dave Rolsky David Steinbrunner Doug Bell Flavio Poletti Gabor Szabo Gabriel Andrade George Hartzell Geraud Continsouzas Goro Fuji Graham Knop Ollis Ian Sillitoe James Hunt John Karr Karen Etheridge Mark Ellis Martin H. Sluka Kjeldsen Michael G. Schwern Nigel Gregoire Philippe Bruhat (BooK) regina-verbae Roy Ivy III Shlomi Fish Smylers Tatsuhiko Miyagawa Toby Inkster Yanick Champoux  - Keedi Kim
  
  =over 4
  
  =item *
  
  Alex Efros <powerman@powerman.name>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  Dan Book <grinnz@grinnz.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Doug Bell <madcityzen@gmail.com>
  
  =item *
  
  Flavio Poletti <flavio@polettix.it>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  Ian Sillitoe <ian@sillit.com>
  
  =item *
  
  James Hunt <james@niftylogic.com>
  
  =item *
  
  John Karr <brainbuz@brainbuz.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Mark Ellis <mark.ellis@cartridgesave.co.uk>
  
  =item *
  
  Martin H. Sluka <fany@cpan.org>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Nigel Gregoire <nigelgregoire@gmail.com>
  
  =item *
  
  Philippe Bruhat (BooK) <book@cpan.org>
  
  =item *
  
  regina-verbae <regina-verbae@users.noreply.github.com>
  
  =item *
  
  Roy Ivy III <rivy@cpan.org>
  
  =item *
  
  Shlomi Fish <shlomif@shlomifish.org>
  
  =item *
  
  Smylers <Smylers@stripey.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
  Yanick Champoux <yanick@babyl.dyndns.org>
  
  =item *
  
   - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Pod/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MAN';
  # Convert POD data to formatted *roff input.
  #
  # This module translates POD documentation into *roff markup using the man
  # macro set, and is intended for converting POD documents written as Unix
  # manual pages to manual pages that can be read by the man(1) command.  It is
  # a replacement for the pod2man command distributed with versions of Perl
  # prior to 5.6.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Man;
  
  use 5.008;
  use strict;
  use warnings;
  
  use subs qw(makespace);
  use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);
  
  use Carp qw(carp croak);
  use Pod::Simple ();
  
  # Conditionally import Encode and set $HAS_ENCODE if it is available.  This is
  # required to support building as part of Perl core, since podlators is built
  # before Encode is.
  our $HAS_ENCODE;
  BEGIN {
      $HAS_ENCODE = eval { require Encode };
  }
  
  @ISA = qw(Pod::Simple);
  
  $VERSION = '4.14';
  
  # Set the debugging level.  If someone has inserted a debug function into this
  # class already, use that.  Otherwise, use any Pod::Simple debug function
  # that's defined, and failing that, define a debug level of 10.
  BEGIN {
      my $parent = defined (&Pod::Simple::DEBUG) ? \&Pod::Simple::DEBUG : undef;
      unless (defined &DEBUG) {
          *DEBUG = $parent || sub () { 10 };
      }
  }
  
  # Import the ASCII constant from Pod::Simple.  This is true iff we're in an
  # ASCII-based universe (including such things as ISO 8859-1 and UTF-8), and is
  # generally only false for EBCDIC.
  BEGIN { *ASCII = \&Pod::Simple::ASCII }
  
  # Pretty-print a data structure.  Only used for debugging.
  BEGIN { *pretty = \&Pod::Simple::pretty }
  
  # Formatting instructions for various types of blocks.  cleanup makes hyphens
  # hard, adds spaces between consecutive underscores, and escapes backslashes.
  # convert translates characters into escapes.  guesswork means to apply the
  # transformations done by the guesswork sub.  literal says to protect literal
  # quotes from being turned into UTF-8 quotes.  By default, all transformations
  # are on except literal, but some elements override.
  #
  # DEFAULT specifies the default settings.  All other elements should list only
  # those settings that they are overriding.  Data indicates =for roff blocks,
  # which should be passed along completely verbatim.
  #
  # Formatting inherits negatively, in the sense that if the parent has turned
  # off guesswork, all child elements should leave it off.
  my %FORMATTING = (
      DEFAULT  => { cleanup => 1, convert => 1, guesswork => 1, literal => 0 },
      Data     => { cleanup => 0, convert => 0, guesswork => 0, literal => 0 },
      Verbatim => {                             guesswork => 0, literal => 1 },
      C        => {                             guesswork => 0, literal => 1 },
      X        => { cleanup => 0,               guesswork => 0               },
  );
  
  ##############################################################################
  # Object initialization
  ##############################################################################
  
  # Initialize the object and set various Pod::Simple options that we need.
  # Here, we also process any additional options passed to the constructor or
  # set up defaults if none were given.  Note that all internal object keys are
  # in all-caps, reserving all lower-case object keys for Pod::Simple and user
  # arguments.
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new;
  
      # Tell Pod::Simple not to handle S<> by automatically inserting &nbsp;.
      $self->nbsp_for_S (1);
  
      # Tell Pod::Simple to keep whitespace whenever possible.
      if (my $preserve_whitespace = $self->can ('preserve_whitespace')) {
          $self->$preserve_whitespace (1);
      } else {
          $self->fullstop_space_harden (1);
      }
  
      # The =for and =begin targets that we accept.
      $self->accept_targets (qw/man MAN roff ROFF/);
  
      # Ensure that contiguous blocks of code are merged together.  Otherwise,
      # some of the guesswork heuristics don't work right.
      $self->merge_text (1);
  
      # Pod::Simple doesn't do anything useful with our arguments, but we want
      # to put them in our object as hash keys and values.  This could cause
      # problems if we ever clash with Pod::Simple's own internal class
      # variables.
      %$self = (%$self, @_);
  
      # Send errors to stderr if requested.
      if ($$self{stderr} and not $$self{errors}) {
          $$self{errors} = 'stderr';
      }
      delete $$self{stderr};
  
      # Validate the errors parameter and act on it.
      if (not defined $$self{errors}) {
          $$self{errors} = 'pod';
      }
      if ($$self{errors} eq 'stderr' || $$self{errors} eq 'die') {
          $self->no_errata_section (1);
          $self->complain_stderr (1);
          if ($$self{errors} eq 'die') {
              $$self{complain_die} = 1;
          }
      } elsif ($$self{errors} eq 'pod') {
          $self->no_errata_section (0);
          $self->complain_stderr (0);
      } elsif ($$self{errors} eq 'none') {
          $self->no_errata_section (1);
          $self->no_whining (1);
      } else {
          croak (qq(Invalid errors setting: "$$self{errors}"));
      }
      delete $$self{errors};
  
      # Degrade back to non-utf8 if Encode is not available.
      #
      # Suppress the warning message when PERL_CORE is set, indicating this is
      # running as part of the core Perl build.  Perl builds podlators (and all
      # pure Perl modules) before Encode and other XS modules, so Encode won't
      # yet be available.  Rely on the Perl core build to generate man pages
      # later, after all the modules are available, so that UTF-8 handling will
      # be correct.
      if ($$self{utf8} and !$HAS_ENCODE) {
          if (!$ENV{PERL_CORE}) {
              carp ('utf8 mode requested but Encode module not available,'
                      . ' falling back to non-utf8');
          }
          delete $$self{utf8};
      }
  
      # Initialize various other internal constants based on our arguments.
      $self->init_fonts;
      $self->init_quotes;
      $self->init_page;
  
      # For right now, default to turning on all of the magic.
      $$self{MAGIC_CPP}       = 1;
      $$self{MAGIC_EMDASH}    = 1;
      $$self{MAGIC_FUNC}      = 1;
      $$self{MAGIC_MANREF}    = 1;
      $$self{MAGIC_SMALLCAPS} = 1;
      $$self{MAGIC_VARS}      = 1;
  
      return $self;
  }
  
  # Translate a font string into an escape.
  sub toescape { (length ($_[0]) > 1 ? '\f(' : '\f') . $_[0] }
  
  # Determine which fonts the user wishes to use and store them in the object.
  # Regular, italic, bold, and bold-italic are constants, but the fixed width
  # fonts may be set by the user.  Sets the internal hash key FONTS which is
  # used to map our internal font escapes to actual *roff sequences later.
  sub init_fonts {
      my ($self) = @_;
  
      # Figure out the fixed-width font.  If user-supplied, make sure that they
      # are the right length.
      for (qw/fixed fixedbold fixeditalic fixedbolditalic/) {
          my $font = $$self{$_};
          if (defined ($font) && (length ($font) < 1 || length ($font) > 2)) {
              croak qq(roff font should be 1 or 2 chars, not "$font");
          }
      }
  
      # Set the default fonts.  We can't be sure portably across different
      # implementations what fixed bold-italic may be called (if it's even
      # available), so default to just bold.
      $$self{fixed}           ||= 'CW';
      $$self{fixedbold}       ||= 'CB';
      $$self{fixeditalic}     ||= 'CI';
      $$self{fixedbolditalic} ||= 'CB';
  
      # Set up a table of font escapes.  First number is fixed-width, second is
      # bold, third is italic.
      $$self{FONTS} = { '000' => '\fR', '001' => '\fI',
                        '010' => '\fB', '011' => '\f(BI',
                        '100' => toescape ($$self{fixed}),
                        '101' => toescape ($$self{fixeditalic}),
                        '110' => toescape ($$self{fixedbold}),
                        '111' => toescape ($$self{fixedbolditalic}) };
  }
  
  # Initialize the quotes that we'll be using for C<> text.  This requires some
  # special handling, both to parse the user parameters if given and to make
  # sure that the quotes will be safe against *roff.  Sets the internal hash
  # keys LQUOTE and RQUOTE.
  sub init_quotes {
      my ($self) = (@_);
  
      # Handle the quotes option first, which sets both quotes at once.
      $$self{quotes} ||= '"';
      if ($$self{quotes} eq 'none') {
          $$self{LQUOTE} = $$self{RQUOTE} = '';
      } elsif (length ($$self{quotes}) == 1) {
          $$self{LQUOTE} = $$self{RQUOTE} = $$self{quotes};
      } elsif (length ($$self{quotes}) % 2 == 0) {
          my $length = length ($$self{quotes}) / 2;
          $$self{LQUOTE} = substr ($$self{quotes}, 0, $length);
          $$self{RQUOTE} = substr ($$self{quotes}, $length);
      } else {
          croak(qq(Invalid quote specification "$$self{quotes}"))
      }
  
      # Now handle the lquote and rquote options.
      if (defined $$self{lquote}) {
          $$self{LQUOTE} = $$self{lquote} eq 'none' ? q{} : $$self{lquote};
      }
      if (defined $$self{rquote}) {
          $$self{RQUOTE} = $$self{rquote} eq 'none' ? q{} : $$self{rquote};
      }
  
      # Double the first quote; note that this should not be s///g as two double
      # quotes is represented in *roff as three double quotes, not four.  Weird,
      # I know.
      $$self{LQUOTE} =~ s/\"/\"\"/;
      $$self{RQUOTE} =~ s/\"/\"\"/;
  }
  
  # Initialize the page title information and indentation from our arguments.
  sub init_page {
      my ($self) = @_;
  
      # Get the version from the running Perl.
      my @version = ($] =~ /^(\d+)\.(\d{3})(\d+)$/);
      for (@version) { $_ += 0 }
      my $version = join ('.', @version);
  
      # Set the defaults for page titles and indentation if the user didn't
      # override anything.
      $$self{center} = 'User Contributed Perl Documentation'
          unless defined $$self{center};
      $$self{release} = 'perl v' . $version
          unless defined $$self{release};
      $$self{indent} = 4
          unless defined $$self{indent};
  
      # Double quotes in things that will be quoted.
      for (qw/center release/) {
          $$self{$_} =~ s/\"/\"\"/g if $$self{$_};
      }
  }
  
  ##############################################################################
  # Core parsing
  ##############################################################################
  
  # This is the glue that connects the code below with Pod::Simple itself.  The
  # goal is to convert the event stream coming from the POD parser into method
  # calls to handlers once the complete content of a tag has been seen.  Each
  # paragraph or POD command will have textual content associated with it, and
  # as soon as all of a paragraph or POD command has been seen, that content
  # will be passed in to the corresponding method for handling that type of
  # object.  The exceptions are handlers for lists, which have opening tag
  # handlers and closing tag handlers that will be called right away.
  #
  # The internal hash key PENDING is used to store the contents of a tag until
  # all of it has been seen.  It holds a stack of open tags, each one
  # represented by a tuple of the attributes hash for the tag, formatting
  # options for the tag (which are inherited), and the contents of the tag.
  
  # Add a block of text to the contents of the current node, formatting it
  # according to the current formatting instructions as we do.
  sub _handle_text {
      my ($self, $text) = @_;
      DEBUG > 3 and print "== $text\n";
      my $tag = $$self{PENDING}[-1];
      $$tag[2] .= $self->format_text ($$tag[1], $text);
  }
  
  # Given an element name, get the corresponding method name.
  sub method_for_element {
      my ($self, $element) = @_;
      $element =~ tr/A-Z-/a-z_/;
      $element =~ tr/_a-z0-9//cd;
      return $element;
  }
  
  # Handle the start of a new element.  If cmd_element is defined, assume that
  # we need to collect the entire tree for this element before passing it to the
  # element method, and create a new tree into which we'll collect blocks of
  # text and nested elements.  Otherwise, if start_element is defined, call it.
  sub _handle_element_start {
      my ($self, $element, $attrs) = @_;
      DEBUG > 3 and print "++ $element (<", join ('> <', %$attrs), ">)\n";
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, we need to accumulate the contents of the
      # tag before calling it.  Turn off IN_NAME for any command other than
      # <Para> and the formatting codes so that IN_NAME isn't still set for the
      # first heading after the NAME heading.
      if ($self->can ("cmd_$method")) {
          DEBUG > 2 and print "<$element> starts saving a tag\n";
          $$self{IN_NAME} = 0 if ($element ne 'Para' && length ($element) > 1);
  
          # How we're going to format embedded text blocks depends on the tag
          # and also depends on our parent tags.  Thankfully, inside tags that
          # turn off guesswork and reformatting, nothing else can turn it back
          # on, so this can be strictly inherited.
          my $formatting = {
              %{ $$self{PENDING}[-1][1] || $FORMATTING{DEFAULT} },
              %{ $FORMATTING{$element} || {} },
          };
          push (@{ $$self{PENDING} }, [ $attrs, $formatting, '' ]);
          DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
      } elsif (my $start_method = $self->can ("start_$method")) {
          $self->$start_method ($attrs, '');
      } else {
          DEBUG > 2 and print "No $method start method, skipping\n";
      }
  }
  
  # Handle the end of an element.  If we had a cmd_ method for this element,
  # this is where we pass along the tree that we built.  Otherwise, if we have
  # an end_ method for the element, call that.
  sub _handle_element_end {
      my ($self, $element) = @_;
      DEBUG > 3 and print "-- $element\n";
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, pull off the pending text and pass it to
      # the handler along with the saved attribute hash.
      if (my $cmd_method = $self->can ("cmd_$method")) {
          DEBUG > 2 and print "</$element> stops saving a tag\n";
          my $tag = pop @{ $$self{PENDING} };
          DEBUG > 4 and print "Popped: [", pretty ($tag), "]\n";
          DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
          my $text = $self->$cmd_method ($$tag[0], $$tag[2]);
          if (defined $text) {
              if (@{ $$self{PENDING} } > 1) {
                  $$self{PENDING}[-1][2] .= $text;
              } else {
                  $self->output ($text);
              }
          }
      } elsif (my $end_method = $self->can ("end_$method")) {
          $self->$end_method ();
      } else {
          DEBUG > 2 and print "No $method end method, skipping\n";
      }
  }
  
  ##############################################################################
  # General formatting
  ##############################################################################
  
  # Format a text block.  Takes a hash of formatting options and the text to
  # format.  Currently, the only formatting options are guesswork, cleanup, and
  # convert, all of which are boolean.
  sub format_text {
      my ($self, $options, $text) = @_;
      my $guesswork = $$options{guesswork} && !$$self{IN_NAME};
      my $cleanup = $$options{cleanup};
      my $convert = $$options{convert};
      my $literal = $$options{literal};
  
      # Cleanup just tidies up a few things, telling *roff that the hyphens are
      # hard, putting a bit of space between consecutive underscores, and
      # escaping backslashes.  Be careful not to mangle our character
      # translations by doing this before processing character translation.
      if ($cleanup) {
          $text =~ s/\\/\\e/g;
          $text =~ s/-/\\-/g;
          $text =~ s/_(?=_)/_\\|/g;
      }
  
      # Normally we do character translation, but we won't even do that in
      # <Data> blocks or if UTF-8 output is desired.
      if ($convert && !$$self{utf8} && ASCII) {
          $text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg;
      }
  
      # Ensure that *roff doesn't convert literal quotes to UTF-8 single quotes,
      # but don't mess up our accept escapes.
      if ($literal) {
          $text =~ s/(?<!\\\*)\'/\\*\(Aq/g;
          $text =~ s/(?<!\\\*)\`/\\\`/g;
      }
  
      # If guesswork is asked for, do that.  This involves more substantial
      # formatting based on various heuristics that may only be appropriate for
      # particular documents.
      if ($guesswork) {
          $text = $self->guesswork ($text);
      }
  
      return $text;
  }
  
  # Handles C<> text, deciding whether to put \*C` around it or not.  This is a
  # whole bunch of messy heuristics to try to avoid overquoting, originally from
  # Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
  sub quote_literal {
      my $self = shift;
      local $_ = shift;
  
      # A regex that matches the portion of a variable reference that's the
      # array or hash index, separated out just because we want to use it in
      # several places in the following regex.
      my $index = '(?: \[.*\] | \{.*\} )?';
  
      # If in NAME section, just return an ASCII quoted string to avoid
      # confusing tools like whatis.
      return qq{"$_"} if $$self{IN_NAME};
  
      # Check for things that we don't want to quote, and if we find any of
      # them, return the string with just a font change and no quoting.
      m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
         | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xso and return '\f(FS' . $_ . '\f(FE';
  
      # If we didn't return, go ahead and quote the text.
      return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
  }
  
  # Takes a text block to perform guesswork on.  Returns the text block with
  # formatting codes added.  This is the code that marks up various Perl
  # constructs and things commonly used in man pages without requiring the user
  # to add any explicit markup, and is applied to all non-literal text.  We're
  # guaranteed that the text we're applying guesswork to does not contain any
  # *roff formatting codes.  Note that the inserted font sequences must be
  # treated later with mapfonts or textmapfonts.
  #
  # This method is very fragile, both in the regular expressions it uses and in
  # the ordering of those modifications.  Care and testing is required when
  # modifying it.
  sub guesswork {
      my $self = shift;
      local $_ = shift;
      DEBUG > 5 and print "   Guesswork called on [$_]\n";
  
      # By the time we reach this point, all hyphens will be escaped by adding a
      # backslash.  We want to undo that escaping if they're part of regular
      # words and there's only a single dash, since that's a real hyphen that
      # *roff gets to consider a possible break point.  Make sure that a dash
      # after the first character of a word stays non-breaking, however.
      #
      # Note that this is not user-controllable; we pretty much have to do this
      # transformation or *roff will mangle the output in unacceptable ways.
      s{
          ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
          ( (?: [a-zA-Z\']+ \\-)+ )
          ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
          \b
      } {
          my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
          $hyphen ||= '';
          $main =~ s/\\-/-/g;
          $prefix . $hyphen . $main . $suffix;
      }egx;
  
      # Translate "--" into a real em-dash if it's used like one.  This means
      # that it's either surrounded by whitespace, it follows a regular word, or
      # it occurs between two regular words.
      if ($$self{MAGIC_EMDASH}) {
          s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;
          s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx;
      }
  
      # Make words in all-caps a little bit smaller; they look better that way.
      # However, we don't want to change Perl code (like @ARGV), nor do we want
      # to fix the MIME in MIME-Version since it looks weird with the
      # full-height V.
      #
      # We change only a string of all caps (2) either at the beginning of the
      # line or following regular punctuation (like quotes) or whitespace (1),
      # and followed by either similar punctuation, an em-dash, or the end of
      # the line (3).
      #
      # Allow the text we're changing to small caps to include double quotes,
      # commas, newlines, and periods as long as it doesn't otherwise interrupt
      # the string of small caps and still fits the criteria.  This lets us turn
      # entire warranty disclaimers in man page output into small caps.
      if ($$self{MAGIC_SMALLCAPS}) {
          s{
              ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                           # (1)
              ( [A-Z] [A-Z] (?: \s? [/A-Z+:\d_\$&] | \\- | \s? [.,\"] )* )  # (2)
              (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )            # (3)
          } {
              $1 . '\s-1' . $2 . '\s0'
          }egx;
      }
  
      # Note that from this point forward, we have to adjust for \s-1 and \s-0
      # strings inserted around things that we've made small-caps if later
      # transforms should work on those strings.
  
      # Embolden functions in the form func(), including functions that are in
      # all capitals, but don't embolden if there's anything between the parens.
      # The function must start with an alphabetic character or underscore and
      # then consist of word characters or colons.
      if ($$self{MAGIC_FUNC}) {
          s{
              ( \b | \\s-1 )
              ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
          } {
              $1 . '\f(BS' . $2 . '\f(BE'
          }egx;
      }
  
      # Change references to manual pages to put the page name in bold but
      # the number in the regular font, with a thin space between the name and
      # the number.  Only recognize func(n) where func starts with an alphabetic
      # character or underscore and contains only word characters, periods (for
      # configuration file man pages), or colons, and n is a single digit,
      # optionally followed by some number of lowercase letters.  Note that this
      # does not recognize man page references like perl(l) or socket(3SOCKET).
      if ($$self{MAGIC_MANREF}) {
          s{
              ( \b | \\s-1 )
              (?<! \\ )                                   # rule out \s0(1)
              ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
              ( \( \d [a-z]* \) )
          } {
              $1 . '\f(BS' . $2 . '\f(BE\|' . $3
          }egx;
      }
  
      # Convert simple Perl variable references to a fixed-width font.  Be
      # careful not to convert functions, though; there are too many subtleties
      # with them to want to perform this transformation.
      if ($$self{MAGIC_VARS}) {
          s{
             ( ^ | \s+ )
             ( [\$\@%] [\w:]+ )
             (?! \( )
          } {
              $1 . '\f(FS' . $2 . '\f(FE'
          }egx;
      }
  
      # Fix up double quotes.  Unfortunately, we miss this transformation if the
      # quoted text contains any code with formatting codes and there's not much
      # we can effectively do about that, which makes it somewhat unclear if
      # this is really a good idea.
      s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;
  
      # Make C++ into \*(C+, which is a squinched version.
      if ($$self{MAGIC_CPP}) {
          s{ \b C\+\+ } {\\*\(C+}gx;
      }
  
      # Done.
      DEBUG > 5 and print "   Guesswork returning [$_]\n";
      return $_;
  }
  
  ##############################################################################
  # Output
  ##############################################################################
  
  # When building up the *roff code, we don't use real *roff fonts.  Instead, we
  # embed font codes of the form \f(<font>[SE] where <font> is one of B, I, or
  # F, S stands for start, and E stands for end.  This method turns these into
  # the right start and end codes.
  #
  # We add this level of complexity because the old pod2man didn't get code like
  # B<someI<thing> else> right; after I<> it switched back to normal text rather
  # than bold.  We take care of this by using variables that state whether bold,
  # italic, or fixed are turned on as a combined pointer to our current font
  # sequence, and set each to the number of current nestings of start tags for
  # that font.
  #
  # \fP changes to the previous font, but only one previous font is kept.  We
  # don't know what the outside level font is; normally it's R, but if we're
  # inside a heading it could be something else.  So arrange things so that the
  # outside font is always the "previous" font and end with \fP instead of \fR.
  # Idea from Zack Weinberg.
  sub mapfonts {
      my ($self, $text) = @_;
      my ($fixed, $bold, $italic) = (0, 0, 0);
      my %magic = (F => \$fixed, B => \$bold, I => \$italic);
      my $last = '\fR';
      $text =~ s<
          \\f\((.)(.)
      > <
          my $sequence = '';
          my $f;
          if ($last ne '\fR') { $sequence = '\fP' }
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
          if ($f eq $last) {
              '';
          } else {
              if ($f ne '\fR') { $sequence .= $f }
              $last = $f;
              $sequence;
          }
      >gxe;
      return $text;
  }
  
  # Unfortunately, there is a bug in Solaris 2.6 nroff (not present in GNU
  # groff) where the sequence \fB\fP\f(CW\fP leaves the font set to B rather
  # than R, presumably because \f(CW doesn't actually do a font change.  To work
  # around this, use a separate textmapfonts for text blocks where the default
  # font is always R and only use the smart mapfonts for headings.
  sub textmapfonts {
      my ($self, $text) = @_;
      my ($fixed, $bold, $italic) = (0, 0, 0);
      my %magic = (F => \$fixed, B => \$bold, I => \$italic);
      $text =~ s<
          \\f\((.)(.)
      > <
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
      >gxe;
      return $text;
  }
  
  # Given a command and a single argument that may or may not contain double
  # quotes, handle double-quote formatting for it.  If there are no double
  # quotes, just return the command followed by the argument in double quotes.
  # If there are double quotes, use an if statement to test for nroff, and for
  # nroff output the command followed by the argument in double quotes with
  # embedded double quotes doubled.  For other formatters, remap paired double
  # quotes to LQUOTE and RQUOTE.
  sub switchquotes {
      my ($self, $command, $text, $extra) = @_;
      $text =~ s/\\\*\([LR]\"/\"/g;
  
      # We also have to deal with \*C` and \*C', which are used to add the
      # quotes around C<> text, since they may expand to " and if they do this
      # confuses the .SH macros and the like no end.  Expand them ourselves.
      # Also separate troff from nroff if there are any fixed-width fonts in use
      # to work around problems with Solaris nroff.
      my $c_is_quote = ($$self{LQUOTE} =~ /\"/) || ($$self{RQUOTE} =~ /\"/);
      my $fixedpat = join '|', @{ $$self{FONTS} }{'100', '101', '110', '111'};
      $fixedpat =~ s/\\/\\\\/g;
      $fixedpat =~ s/\(/\\\(/g;
      if ($text =~ m/\"/ || $text =~ m/$fixedpat/) {
          $text =~ s/\"/\"\"/g;
          my $nroff = $text;
          my $troff = $text;
          $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
          if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/) {
              $nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;
              $nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;
              $troff =~ s/\\\*\(C[\'\`]//g;
          }
          $nroff = qq("$nroff") . ($extra ? " $extra" : '');
          $troff = qq("$troff") . ($extra ? " $extra" : '');
  
          # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
          # to Roman rather than the actual previous font when used in headings.
          # troff output may still be broken, but at least we can fix nroff by
          # just switching the font changes to the non-fixed versions.
          my $font_end = "(?:\\f[PR]|\Q$$self{FONTS}{100}\E)";
          $nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f([PR])/$1/g;
          $nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)$font_end/\\fI$1\\fP/g;
          $nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)$font_end/\\fB$1\\fP/g;
          $nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)$font_end/\\f\(BI$1\\fP/g;
  
          # Now finally output the command.  Bother with .ie only if the nroff
          # and troff output aren't the same.
          if ($nroff ne $troff) {
              return ".ie n $command $nroff\n.el $command $troff\n";
          } else {
              return "$command $nroff\n";
          }
      } else {
          $text = qq("$text") . ($extra ? " $extra" : '');
          return "$command $text\n";
      }
  }
  
  # Protect leading quotes and periods against interpretation as commands.  Also
  # protect anything starting with a backslash, since it could expand or hide
  # something that *roff would interpret as a command.  This is overkill, but
  # it's much simpler than trying to parse *roff here.
  sub protect {
      my ($self, $text) = @_;
      $text =~ s/^([.\'\\])/\\&$1/mg;
      return $text;
  }
  
  # Make vertical whitespace if NEEDSPACE is set, appropriate to the indentation
  # level the situation.  This function is needed since in *roff one has to
  # create vertical whitespace after paragraphs and between some things, but
  # other macros create their own whitespace.  Also close out a sequence of
  # repeated =items, since calling makespace means we're about to begin the item
  # body.
  sub makespace {
      my ($self) = @_;
      $self->output (".PD\n") if $$self{ITEMS} > 1;
      $$self{ITEMS} = 0;
      $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
          if $$self{NEEDSPACE};
  }
  
  # Output any pending index entries, and optionally an index entry given as an
  # argument.  Support multiple index entries in X<> separated by slashes, and
  # strip special escapes from index entries.
  sub outindex {
      my ($self, $section, $index) = @_;
      my @entries = map { split m%\s*/\s*% } @{ $$self{INDEX} };
      return unless ($section || @entries);
  
      # We're about to output all pending entries, so clear our pending queue.
      $$self{INDEX} = [];
  
      # Build the output.  Regular index entries are marked Xref, and headings
      # pass in their own section.  Undo some *roff formatting on headings.
      my @output;
      if (@entries) {
          push @output, [ 'Xref', join (' ', @entries) ];
      }
      if ($section) {
          $index =~ s/\\-/-/g;
          $index =~ s/\\(?:s-?\d|.\(..|.)//g;
          push @output, [ $section, $index ];
      }
  
      # Print out the .IX commands.
      for (@output) {
          my ($type, $entry) = @$_;
          $entry =~ s/\s+/ /g;
          $entry =~ s/\"/\"\"/g;
          $entry =~ s/\\/\\\\/g;
          $self->output (".IX $type " . '"' . $entry . '"' . "\n");
      }
  }
  
  # Output some text, without any additional changes.
  sub output {
      my ($self, @text) = @_;
      if ($$self{ENCODE}) {
          print { $$self{output_fh} } Encode::encode ('UTF-8', join ('', @text));
      } else {
          print { $$self{output_fh} } @text;
      }
  }
  
  ##############################################################################
  # Document initialization
  ##############################################################################
  
  # Handle the start of the document.  Here we handle empty documents, as well
  # as setting up our basic macros in a preamble and building the page title.
  sub start_document {
      my ($self, $attrs) = @_;
      if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
          DEBUG and print "Document is contentless\n";
          $$self{CONTENTLESS} = 1;
      } else {
          delete $$self{CONTENTLESS};
      }
  
      # When UTF-8 output is set, check whether our output file handle already
      # has a PerlIO encoding layer set.  If it does not, we'll need to encode
      # our output before printing it (handled in the output() sub).  Wrap the
      # check in an eval to handle versions of Perl without PerlIO.
      #
      # PerlIO::get_layers still requires its argument be a glob, so coerce the
      # file handle to a glob.
      $$self{ENCODE} = 0;
      if ($$self{utf8}) {
          $$self{ENCODE} = 1;
          eval {
              my @options = (output => 1, details => 1);
              my @layers = PerlIO::get_layers (*{$$self{output_fh}}, @options);
              if ($layers[-1] && ($layers[-1] & PerlIO::F_UTF8 ())) {
                  $$self{ENCODE} = 0;
              }
          }
      }
  
      # Determine information for the preamble and then output it unless the
      # document was content-free.
      if (!$$self{CONTENTLESS}) {
          my ($name, $section);
          if (defined $$self{name}) {
              $name = $$self{name};
              $section = $$self{section} || 1;
          } else {
              ($name, $section) = $self->devise_title;
          }
          my $date = defined($$self{date}) ? $$self{date} : $self->devise_date;
          $self->preamble ($name, $section, $date)
              unless $self->bare_output or DEBUG > 9;
      }
  
      # Initialize a few per-document variables.
      $$self{INDENT}    = 0;      # Current indentation level.
      $$self{INDENTS}   = [];     # Stack of indentations.
      $$self{INDEX}     = [];     # Index keys waiting to be printed.
      $$self{IN_NAME}   = 0;      # Whether processing the NAME section.
      $$self{ITEMS}     = 0;      # The number of consecutive =items.
      $$self{ITEMTYPES} = [];     # Stack of =item types, one per list.
      $$self{SHIFTWAIT} = 0;      # Whether there is a shift waiting.
      $$self{SHIFTS}    = [];     # Stack of .RS shifts.
      $$self{PENDING}   = [[]];   # Pending output.
  }
  
  # Handle the end of the document.  This handles dying on POD errors, since
  # Pod::Parser currently doesn't.  Otherwise, does nothing but print out a
  # final comment at the end of the document under debugging.
  sub end_document {
      my ($self) = @_;
      if ($$self{complain_die} && $self->errors_seen) {
          croak ("POD document had syntax errors");
      }
      return if $self->bare_output;
      return if ($$self{CONTENTLESS} && !$$self{ALWAYS_EMIT_SOMETHING});
      $self->output (q(.\" [End document]) . "\n") if DEBUG;
  }
  
  # Try to figure out the name and section from the file name and return them as
  # a list, returning an empty name and section 1 if we can't find any better
  # information.  Uses File::Basename and File::Spec as necessary.
  sub devise_title {
      my ($self) = @_;
      my $name = $self->source_filename || '';
      my $section = $$self{section} || 1;
      $section = 3 if (!$$self{section} && $name =~ /\.pm\z/i);
      $name =~ s/\.p(od|[lm])\z//i;
  
      # If Pod::Parser gave us an IO::File reference as the source file name,
      # convert that to the empty string as well.  Then, if we don't have a
      # valid name, convert it to STDIN.
      #
      # In podlators 4.00 through 4.07, this also produced a warning, but that
      # was surprising to a lot of programs that had expected to be able to pipe
      # POD through pod2man without specifying the name.  In the name of
      # backward compatibility, just quietly set STDIN as the page title.
      if ($name =~ /^IO::File(?:=\w+)\(0x[\da-f]+\)$/i) {
          $name = '';
      }
      if ($name eq '') {
          $name = 'STDIN';
      }
  
      # If the section isn't 3, then the name defaults to just the basename of
      # the file.
      if ($section !~ /^3/) {
          require File::Basename;
          $name = uc File::Basename::basename ($name);
      } else {
          require File::Spec;
          my ($volume, $dirs, $file) = File::Spec->splitpath ($name);
  
          # Otherwise, assume we're dealing with a module.  We want to figure
          # out the full module name from the path to the file, but we don't
          # want to include too much of the path into the module name.  Lose
          # anything up to the first of:
          #
          #     */lib/*perl*/         standard or site_perl module
          #     */*perl*/lib/         from -Dprefix=/opt/perl
          #     */*perl*/             random module hierarchy
          #
          # Also strip off a leading site, site_perl, or vendor_perl component,
          # any OS-specific component, and any version number component, and
          # strip off an initial component of "lib" or "blib/lib" since that's
          # what ExtUtils::MakeMaker creates.
          #
          # splitdir requires at least File::Spec 0.8.
          my @dirs = File::Spec->splitdir ($dirs);
          if (@dirs) {
              my $cut = 0;
              my $i;
              for ($i = 0; $i < @dirs; $i++) {
                  if ($dirs[$i] =~ /perl/) {
                      $cut = $i + 1;
                      $cut++ if ($dirs[$i + 1] && $dirs[$i + 1] eq 'lib');
                      last;
                  }
              }
              if ($cut > 0) {
                  splice (@dirs, 0, $cut);
                  shift @dirs if ($dirs[0] =~ /^(site|vendor)(_perl)?$/);
                  shift @dirs if ($dirs[0] =~ /^[\d.]+$/);
                  shift @dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
              }
              shift @dirs if $dirs[0] eq 'lib';
              splice (@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');
          }
  
          # Remove empty directories when building the module name; they
          # occur too easily on Unix by doubling slashes.
          $name = join ('::', (grep { $_ ? $_ : () } @dirs), $file);
      }
      return ($name, $section);
  }
  
  # Determine the modification date and return that, properly formatted in ISO
  # format.
  #
  # If POD_MAN_DATE is set, that overrides anything else.  This can be used for
  # reproducible generation of the same file even if the input file timestamps
  # are unpredictable or the POD comes from standard input.
  #
  # Otherwise, if SOURCE_DATE_EPOCH is set and can be parsed as seconds since
  # the UNIX epoch, base the timestamp on that.  See
  # <https://reproducible-builds.org/specs/source-date-epoch/>
  #
  # Otherwise, use the modification date of the input if we can stat it.  Be
  # aware that Pod::Simple returns the stringification of the file handle as
  # source_filename for input from a file handle, so we'll stat some random ref
  # string in that case.  If that fails, instead use the current time.
  #
  # $self - Pod::Man object, used to get the source file
  #
  # Returns: YYYY-MM-DD date suitable for the left-hand footer
  sub devise_date {
      my ($self) = @_;
  
      # If POD_MAN_DATE is set, always use it.
      if (defined($ENV{POD_MAN_DATE})) {
          return $ENV{POD_MAN_DATE};
      }
  
      # If SOURCE_DATE_EPOCH is set and can be parsed, use that.
      my $time;
      if (defined($ENV{SOURCE_DATE_EPOCH}) && $ENV{SOURCE_DATE_EPOCH} !~ /\D/) {
          $time = $ENV{SOURCE_DATE_EPOCH};
      }
  
      # Otherwise, get the input filename and try to stat it.  If that fails,
      # use the current time.
      if (!defined $time) {
          my $input = $self->source_filename;
          if ($input) {
              $time = (stat($input))[9] || time();
          } else {
              $time = time();
          }
      }
  
      # Can't use POSIX::strftime(), which uses Fcntl, because MakeMaker uses
      # this and it has to work in the core which can't load dynamic libraries.
      # Use gmtime instead of localtime so that the generated man page does not
      # depend on the local time zone setting and is more reproducible
      my ($year, $month, $day) = (gmtime($time))[5,4,3];
      return sprintf("%04d-%02d-%02d", $year + 1900, $month + 1, $day);
  }
  
  # Print out the preamble and the title.  The meaning of the arguments to .TH
  # unfortunately vary by system; some systems consider the fourth argument to
  # be a "source" and others use it as a version number.  Generally it's just
  # presented as the left-side footer, though, so it doesn't matter too much if
  # a particular system gives it another interpretation.
  #
  # The order of date and release used to be reversed in older versions of this
  # module, but this order is correct for both Solaris and Linux.
  sub preamble {
      my ($self, $name, $section, $date) = @_;
      my $preamble = $self->preamble_template (!$$self{utf8});
  
      # Build the index line and make sure that it will be syntactically valid.
      my $index = "$name $section";
      $index =~ s/\"/\"\"/g;
  
      # If name or section contain spaces, quote them (section really never
      # should, but we may as well be cautious).
      for ($name, $section) {
          if (/\s/) {
              s/\"/\"\"/g;
              $_ = '"' . $_ . '"';
          }
      }
  
      # Double quotes in date, since it will be quoted.
      $date =~ s/\"/\"\"/g;
  
      # Substitute into the preamble the configuration options.
      $preamble =~ s/\@CFONT\@/$$self{fixed}/;
      $preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;
      $preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;
      chomp $preamble;
  
      # Get the version information.
      my $version = $self->version_report;
  
      # Finally output everything.
      $self->output (<<"----END OF HEADER----");
  .\\" Automatically generated by $version
  .\\"
  .\\" Standard preamble:
  .\\" ========================================================================
  $preamble
  .\\" ========================================================================
  .\\"
  .IX Title "$index"
  .TH $name $section "$date" "$$self{release}" "$$self{center}"
  .\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
  .\\" way too many mistakes in technical documents.
  .if n .ad l
  .nh
  ----END OF HEADER----
      $self->output (".\\\" [End of preamble]\n") if DEBUG;
  }
  
  ##############################################################################
  # Text blocks
  ##############################################################################
  
  # Handle a basic block of text.  The only tricky part of this is if this is
  # the first paragraph of text after an =over, in which case we have to change
  # indentations for *roff.
  sub cmd_para {
      my ($self, $attrs, $text) = @_;
      my $line = $$attrs{start_line};
  
      # Output the paragraph.  We also have to handle =over without =item.  If
      # there's an =over without =item, SHIFTWAIT will be set, and we need to
      # handle creation of the indent here.  Add the shift to SHIFTS so that it
      # will be cleaned up on =back.
      $self->makespace;
      if ($$self{SHIFTWAIT}) {
          $self->output (".RS $$self{INDENT}\n");
          push (@{ $$self{SHIFTS} }, $$self{INDENT});
          $$self{SHIFTWAIT} = 0;
      }
  
      # Add the line number for debugging, but not in the NAME section just in
      # case the comment would confuse apropos.
      $self->output (".\\\" [At source line $line]\n")
          if defined ($line) && DEBUG && !$$self{IN_NAME};
  
      # Force exactly one newline at the end and strip unwanted trailing
      # whitespace at the end, but leave "\ " backslashed space from an S< > at
      # the end of a line.  Reverse the text first, to avoid having to scan the
      # entire paragraph.
      $text = reverse $text;
      $text =~ s/\A\s*?(?= \\|\S|\z)/\n/;
      $text = reverse $text;
  
      # Output the paragraph.
      $self->output ($self->protect ($self->textmapfonts ($text)));
      $self->outindex;
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  # Handle a verbatim paragraph.  Put a null token at the beginning of each line
  # to protect against commands and wrap in .Vb/.Ve (which we define in our
  # prelude).
  sub cmd_verbatim {
      my ($self, $attrs, $text) = @_;
  
      # Ignore an empty verbatim paragraph.
      return unless $text =~ /\S/;
  
      # Force exactly one newline at the end and strip unwanted trailing
      # whitespace at the end.  Reverse the text first, to avoid having to scan
      # the entire paragraph.
      $text = reverse $text;
      $text =~ s/\A\s*/\n/;
      $text = reverse $text;
  
      # Get a count of the number of lines before the first blank line, which
      # we'll pass to .Vb as its parameter.  This tells *roff to keep that many
      # lines together.  We don't want to tell *roff to keep huge blocks
      # together.
      my @lines = split (/\n/, $text);
      my $unbroken = 0;
      for (@lines) {
          last if /^\s*$/;
          $unbroken++;
      }
      $unbroken = 10 if ($unbroken > 12 && !$$self{MAGIC_VNOPAGEBREAK_LIMIT});
  
      # Prepend a null token to each line.
      $text =~ s/^/\\&/gm;
  
      # Output the results.
      $self->makespace;
      $self->output (".Vb $unbroken\n$text.Ve\n");
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  # Handle literal text (produced by =for and similar constructs).  Just output
  # it with the minimum of changes.
  sub cmd_data {
      my ($self, $attrs, $text) = @_;
      $text =~ s/^\n+//;
      $text =~ s/\n{0,2}$/\n/;
      $self->output ($text);
      return '';
  }
  
  ##############################################################################
  # Headings
  ##############################################################################
  
  # Common code for all headings.  This is called before the actual heading is
  # output.  It returns the cleaned up heading text (putting the heading all on
  # one line) and may do other things, like closing bad =item blocks.
  sub heading_common {
      my ($self, $text, $line) = @_;
      $text =~ s/\s+$//;
      $text =~ s/\s*\n\s*/ /g;
  
      # This should never happen; it means that we have a heading after =item
      # without an intervening =back.  But just in case, handle it anyway.
      if ($$self{ITEMS} > 1) {
          $$self{ITEMS} = 0;
          $self->output (".PD\n");
      }
  
      # Output the current source line.
      $self->output ( ".\\\" [At source line $line]\n" )
          if defined ($line) && DEBUG;
      return $text;
  }
  
  # First level heading.  We can't output .IX in the NAME section due to a bug
  # in some versions of catman, so don't output a .IX for that section.  .SH
  # already uses small caps, so remove \s0 and \s-1.  Maintain IN_NAME as
  # appropriate.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\\s-?\d//g;
      $text = $self->heading_common ($text, $$attrs{start_line});
      my $isname = ($text eq 'NAME' || $text =~ /\(NAME\)/);
      $self->output ($self->switchquotes ('.SH', $self->mapfonts ($text)));
      $self->outindex ('Header', $text) unless $isname;
      $$self{NEEDSPACE} = 0;
      $$self{IN_NAME} = $isname;
      return '';
  }
  
  # Second level heading.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->output ($self->switchquotes ('.SS', $self->mapfonts ($text)));
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 0;
      return '';
  }
  
  # Third level heading.  *roff doesn't have this concept, so just put the
  # heading in italics as a normal paragraph.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->makespace;
      $self->output ($self->textmapfonts ('\f(IS' . $text . '\f(IE') . "\n");
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  # Fourth level heading.  *roff doesn't have this concept, so just put the
  # heading as a normal paragraph.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->makespace;
      $self->output ($self->textmapfonts ($text) . "\n");
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  ##############################################################################
  # Formatting codes
  ##############################################################################
  
  # All of the formatting codes that aren't handled internally by the parser,
  # other than L<> and X<>.
  sub cmd_b { return $_[0]->{IN_NAME} ? $_[2] : '\f(BS' . $_[2] . '\f(BE' }
  sub cmd_i { return $_[0]->{IN_NAME} ? $_[2] : '\f(IS' . $_[2] . '\f(IE' }
  sub cmd_f { return $_[0]->{IN_NAME} ? $_[2] : '\f(IS' . $_[2] . '\f(IE' }
  sub cmd_c { return $_[0]->quote_literal ($_[2]) }
  
  # Index entries are just added to the pending entries.
  sub cmd_x {
      my ($self, $attrs, $text) = @_;
      push (@{ $$self{INDEX} }, $text);
      return '';
  }
  
  # Links reduce to the text that we're given, wrapped in angle brackets if it's
  # a URL, followed by the URL.  We take an option to suppress the URL if anchor
  # text is given.  We need to format the "to" value of the link before
  # comparing it to the text since we may escape hyphens.
  sub cmd_l {
      my ($self, $attrs, $text) = @_;
      if ($$attrs{type} eq 'url') {
          my $to = $$attrs{to};
          if (defined $to) {
              my $tag = $$self{PENDING}[-1];
              $to = $self->format_text ($$tag[1], $to);
          }
          if (not defined ($to) or $to eq $text) {
              return "<$text>";
          } elsif ($$self{nourls}) {
              return $text;
          } else {
              return "$text <$$attrs{to}>";
          }
      } else {
          return $text;
      }
  }
  
  ##############################################################################
  # List handling
  ##############################################################################
  
  # Handle the beginning of an =over block.  Takes the type of the block as the
  # first argument, and then the attr hash.  This is called by the handlers for
  # the four different types of lists (bullet, number, text, and block).
  sub over_common_start {
      my ($self, $type, $attrs) = @_;
      my $line = $$attrs{start_line};
      my $indent = $$attrs{indent};
      DEBUG > 3 and print " Starting =over $type (line $line, indent ",
          ($indent || '?'), "\n";
  
      # Find the indentation level.
      unless (defined ($indent) && $indent =~ /^[-+]?\d{1,4}\s*$/) {
          $indent = $$self{indent};
      }
  
      # If we've gotten multiple indentations in a row, we need to emit the
      # pending indentation for the last level that we saw and haven't acted on
      # yet.  SHIFTS is the stack of indentations that we've actually emitted
      # code for.
      if (@{ $$self{SHIFTS} } < @{ $$self{INDENTS} }) {
          $self->output (".RS $$self{INDENT}\n");
          push (@{ $$self{SHIFTS} }, $$self{INDENT});
      }
  
      # Now, do record-keeping.  INDENTS is a stack of indentations that we've
      # seen so far, and INDENT is the current level of indentation.  ITEMTYPES
      # is a stack of list types that we've seen.
      push (@{ $$self{INDENTS} }, $$self{INDENT});
      push (@{ $$self{ITEMTYPES} }, $type);
      $$self{INDENT} = $indent + 0;
      $$self{SHIFTWAIT} = 1;
  }
  
  # End an =over block.  Takes no options other than the class pointer.
  # Normally, once we close a block and therefore remove something from INDENTS,
  # INDENTS will now be longer than SHIFTS, indicating that we also need to emit
  # *roff code to close the indent.  This isn't *always* true, depending on the
  # circumstance.  If we're still inside an indentation, we need to emit another
  # .RE and then a new .RS to unconfuse *roff.
  sub over_common_end {
      my ($self) = @_;
      DEBUG > 3 and print " Ending =over\n";
      $$self{INDENT} = pop @{ $$self{INDENTS} };
      pop @{ $$self{ITEMTYPES} };
  
      # If we emitted code for that indentation, end it.
      if (@{ $$self{SHIFTS} } > @{ $$self{INDENTS} }) {
          $self->output (".RE\n");
          pop @{ $$self{SHIFTS} };
      }
  
      # If we're still in an indentation, *roff will have now lost track of the
      # right depth of that indentation, so fix that.
      if (@{ $$self{INDENTS} } > 0) {
          $self->output (".RE\n");
          $self->output (".RS $$self{INDENT}\n");
      }
      $$self{NEEDSPACE} = 1;
      $$self{SHIFTWAIT} = 0;
  }
  
  # Dispatch the start and end calls as appropriate.
  sub start_over_bullet { my $s = shift; $s->over_common_start ('bullet', @_) }
  sub start_over_number { my $s = shift; $s->over_common_start ('number', @_) }
  sub start_over_text   { my $s = shift; $s->over_common_start ('text',   @_) }
  sub start_over_block  { my $s = shift; $s->over_common_start ('block',  @_) }
  sub end_over_bullet { $_[0]->over_common_end }
  sub end_over_number { $_[0]->over_common_end }
  sub end_over_text   { $_[0]->over_common_end }
  sub end_over_block  { $_[0]->over_common_end }
  
  # The common handler for all item commands.  Takes the type of the item, the
  # attributes, and then the text of the item.
  #
  # Emit an index entry for anything that's interesting, but don't emit index
  # entries for things like bullets and numbers.  Newlines in an item title are
  # turned into spaces since *roff can't handle them embedded.
  sub item_common {
      my ($self, $type, $attrs, $text) = @_;
      my $line = $$attrs{start_line};
      DEBUG > 3 and print "  $type item (line $line): $text\n";
  
      # Clean up the text.  We want to end up with two variables, one ($text)
      # which contains any body text after taking out the item portion, and
      # another ($item) which contains the actual item text.
      $text =~ s/\s+$//;
      my ($item, $index);
      if ($type eq 'bullet') {
          $item = "\\\(bu";
          $text =~ s/\n*$/\n/;
      } elsif ($type eq 'number') {
          $item = $$attrs{number} . '.';
      } else {
          $item = $text;
          $item =~ s/\s*\n\s*/ /g;
          $text = '';
          $index = $item if ($item =~ /\w/);
      }
  
      # Take care of the indentation.  If shifts and indents are equal, close
      # the top shift, since we're about to create an indentation with .IP.
      # Also output .PD 0 to turn off spacing between items if this item is
      # directly following another one.  We only have to do that once for a
      # whole chain of items so do it for the second item in the change.  Note
      # that makespace is what undoes this.
      if (@{ $$self{SHIFTS} } == @{ $$self{INDENTS} }) {
          $self->output (".RE\n");
          pop @{ $$self{SHIFTS} };
      }
      $self->output (".PD 0\n") if ($$self{ITEMS} == 1);
  
      # Now, output the item tag itself.
      $item = $self->textmapfonts ($item);
      $self->output ($self->switchquotes ('.IP', $item, $$self{INDENT}));
      $$self{NEEDSPACE} = 0;
      $$self{ITEMS}++;
      $$self{SHIFTWAIT} = 0;
  
      # If body text for this item was included, go ahead and output that now.
      if ($text) {
          $text =~ s/\s*$/\n/;
          $self->makespace;
          $self->output ($self->protect ($self->textmapfonts ($text)));
          $$self{NEEDSPACE} = 1;
      }
      $self->outindex ($index ? ('Item', $index) : ());
  }
  
  # Dispatch the item commands to the appropriate place.
  sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @_) }
  sub cmd_item_number { my $self = shift; $self->item_common ('number', @_) }
  sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @_) }
  sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @_) }
  
  ##############################################################################
  # Backward compatibility
  ##############################################################################
  
  # Reset the underlying Pod::Simple object between calls to parse_from_file so
  # that the same object can be reused to convert multiple pages.
  sub parse_from_file {
      my $self = shift;
      $self->reinit;
  
      # Fake the old cutting option to Pod::Parser.  This fiddles with internal
      # Pod::Simple state and is quite ugly; we need a better approach.
      if (ref ($_[0]) eq 'HASH') {
          my $opts = shift @_;
          if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
              $$self{in_pod} = 1;
              $$self{last_was_blank} = 1;
          }
      }
  
      # Do the work.
      my $retval = $self->SUPER::parse_from_file (@_);
  
      # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
      # close the file descriptor if we had to open one, but we can't easily
      # figure this out.
      my $fh = $self->output_fh ();
      my $oldfh = select $fh;
      my $oldflush = $|;
      $| = 1;
      print $fh '';
      $| = $oldflush;
      select $oldfh;
      return $retval;
  }
  
  # Pod::Simple failed to provide this backward compatibility function, so
  # implement it ourselves.  File handles are one of the inputs that
  # parse_from_file supports.
  sub parse_from_filehandle {
      my $self = shift;
      return $self->parse_from_file (@_);
  }
  
  # Pod::Simple's parse_file doesn't set output_fh.  Wrap the call and do so
  # ourself unless it was already set by the caller, since our documentation has
  # always said that this should work.
  sub parse_file {
      my ($self, $in) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_file ($in);
  }
  
  # Do the same for parse_lines, just to be polite.  Pod::Simple's man page
  # implies that the caller is responsible for setting this, but I don't see any
  # reason not to set a default.
  sub parse_lines {
      my ($self, @lines) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_lines (@lines);
  }
  
  # Likewise for parse_string_document.
  sub parse_string_document {
      my ($self, $doc) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_string_document ($doc);
  }
  
  ##############################################################################
  # Translation tables
  ##############################################################################
  
  # The following table is adapted from Tom Christiansen's pod2man.  It assumes
  # that the standard preamble has already been printed, since that's what
  # defines all of the accent marks.  We really want to do something better than
  # this when *roff actually supports other character sets itself, since these
  # results are pretty poor.
  #
  # This only works in an ASCII world.  What to do in a non-ASCII world is very
  # unclear -- hopefully we can assume UTF-8 and just leave well enough alone.
  @ESCAPES{0xA0 .. 0xFF} = (
      "\\ ", undef, undef, undef,            undef, undef, undef, undef,
      undef, undef, undef, undef,            undef, "\\%", undef, undef,
  
      undef, undef, undef, undef,            undef, undef, undef, undef,
      undef, undef, undef, undef,            undef, undef, undef, undef,
  
      "A\\*`",  "A\\*'", "A\\*^", "A\\*~",   "A\\*:", "A\\*o", "\\*(Ae", "C\\*,",
      "E\\*`",  "E\\*'", "E\\*^", "E\\*:",   "I\\*`", "I\\*'", "I\\*^",  "I\\*:",
  
      "\\*(D-", "N\\*~", "O\\*`", "O\\*'",   "O\\*^", "O\\*~", "O\\*:",  undef,
      "O\\*/",  "U\\*`", "U\\*'", "U\\*^",   "U\\*:", "Y\\*'", "\\*(Th", "\\*8",
  
      "a\\*`",  "a\\*'", "a\\*^", "a\\*~",   "a\\*:", "a\\*o", "\\*(ae", "c\\*,",
      "e\\*`",  "e\\*'", "e\\*^", "e\\*:",   "i\\*`", "i\\*'", "i\\*^",  "i\\*:",
  
      "\\*(d-", "n\\*~", "o\\*`", "o\\*'",   "o\\*^", "o\\*~", "o\\*:",  undef,
      "o\\*/" , "u\\*`", "u\\*'", "u\\*^",   "u\\*:", "y\\*'", "\\*(th", "y\\*:",
  ) if ASCII;
  
  ##############################################################################
  # Premable
  ##############################################################################
  
  # The following is the static preamble which starts all *roff output we
  # generate.  Most is static except for the font to use as a fixed-width font,
  # which is designed by @CFONT@, and the left and right quotes to use for C<>
  # text, designated by @LQOUTE@ and @RQUOTE@.  However, the second part, which
  # defines the accent marks, is only used if $escapes is set to true.
  sub preamble_template {
      my ($self, $accents) = @_;
      my $preamble = <<'----END OF PREAMBLE----';
  .de Sp \" Vertical space (when we can't use .PP)
  .if t .sp .5v
  .if n .sp
  ..
  .de Vb \" Begin verbatim text
  .ft @CFONT@
  .nf
  .ne \\$1
  ..
  .de Ve \" End verbatim text
  .ft R
  .fi
  ..
  .\" Set up some character translations and predefined strings.  \*(-- will
  .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
  .\" double quote, and \*(R" will give a right double quote.  \*(C+ will
  .\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
  .\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
  .\" nothing in troff, for use with C<>.
  .tr \(*W-
  .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
  .ie n \{\
  .    ds -- \(*W-
  .    ds PI pi
  .    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
  .    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
  .    ds L" ""
  .    ds R" ""
  .    ds C` @LQUOTE@
  .    ds C' @RQUOTE@
  'br\}
  .el\{\
  .    ds -- \|\(em\|
  .    ds PI \(*p
  .    ds L" ``
  .    ds R" ''
  .    ds C`
  .    ds C'
  'br\}
  .\"
  .\" Escape single quotes in literal strings from groff's Unicode transform.
  .ie \n(.g .ds Aq \(aq
  .el       .ds Aq '
  .\"
  .\" If the F register is >0, we'll generate index entries on stderr for
  .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
  .\" entries marked with X<> in POD.  Of course, you'll have to process the
  .\" output yourself in some meaningful fashion.
  .\"
  .\" Avoid warning from groff about undefined register 'F'.
  .de IX
  ..
  .nr rF 0
  .if \n(.g .if rF .nr rF 1
  .if (\n(rF:(\n(.g==0)) \{\
  .    if \nF \{\
  .        de IX
  .        tm Index:\\$1\t\\n%\t"\\$2"
  ..
  .        if !\nF==2 \{\
  .            nr % 0
  .            nr F 2
  .        \}
  .    \}
  .\}
  .rr rF
  ----END OF PREAMBLE----
  #'# for cperl-mode
  
      if ($accents) {
          $preamble .= <<'----END OF PREAMBLE----'
  .\"
  .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
  .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
  .    \" fudge factors for nroff and troff
  .if n \{\
  .    ds #H 0
  .    ds #V .8m
  .    ds #F .3m
  .    ds #[ \f1
  .    ds #] \fP
  .\}
  .if t \{\
  .    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
  .    ds #V .6m
  .    ds #F 0
  .    ds #[ \&
  .    ds #] \&
  .\}
  .    \" simple accents for nroff and troff
  .if n \{\
  .    ds ' \&
  .    ds ` \&
  .    ds ^ \&
  .    ds , \&
  .    ds ~ ~
  .    ds /
  .\}
  .if t \{\
  .    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
  .    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
  .    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
  .    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
  .    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
  .    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
  .\}
  .    \" troff and (daisy-wheel) nroff accents
  .ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
  .ds 8 \h'\*(#H'\(*b\h'-\*(#H'
  .ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
  .ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
  .ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
  .ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
  .ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
  .ds ae a\h'-(\w'a'u*4/10)'e
  .ds Ae A\h'-(\w'A'u*4/10)'E
  .    \" corrections for vroff
  .if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
  .if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
  .    \" for low resolution devices (crt and lpr)
  .if \n(.H>23 .if \n(.V>19 \
  \{\
  .    ds : e
  .    ds 8 ss
  .    ds o a
  .    ds d- d\h'-1'\(ga
  .    ds D- D\h'-1'\(hy
  .    ds th \o'bp'
  .    ds Th \o'LP'
  .    ds ae ae
  .    ds Ae AE
  .\}
  .rm #[ #] #H #V #F C
  ----END OF PREAMBLE----
  #`# for cperl-mode
      }
      return $preamble;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  en em ALLCAPS teeny fixedbold fixeditalic fixedbolditalic stderr utf8 UTF-8
  Allbery Sean Burke Ossanna Solaris formatters troff uppercased Christiansen
  nourls parsers Kernighan lquote rquote
  
  =head1 NAME
  
  Pod::Man - Convert POD data to formatted *roff input
  
  =head1 SYNOPSIS
  
      use Pod::Man;
      my $parser = Pod::Man->new (release => $VERSION, section => 8);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_file (\*STDIN);
  
      # Read POD from file.pod and write to file.1.
      $parser->parse_from_file ('file.pod', 'file.1');
  
  =head1 DESCRIPTION
  
  Pod::Man is a module to convert documentation in the POD format (the
  preferred language for documenting Perl) into *roff input using the man
  macro set.  The resulting *roff code is suitable for display on a terminal
  using L<nroff(1)>, normally via L<man(1)>, or printing using L<troff(1)>.
  It is conventionally invoked using the driver script B<pod2man>, but it can
  also be used directly.
  
  As a derived class from Pod::Simple, Pod::Man supports the same methods and
  interfaces.  See L<Pod::Simple> for all the details.
  
  new() can take options, in the form of key/value pairs that control the
  behavior of the parser.  See below for details.
  
  If no options are given, Pod::Man uses the name of the input file with any
  trailing C<.pod>, C<.pm>, or C<.pl> stripped as the man page title, to
  section 1 unless the file ended in C<.pm> in which case it defaults to
  section 3, to a centered title of "User Contributed Perl Documentation", to
  a centered footer of the Perl version it is run with, and to a left-hand
  footer of the modification date of its input (or the current date if given
  C<STDIN> for input).
  
  Pod::Man assumes that your *roff formatters have a fixed-width font named
  C<CW>.  If yours is called something else (like C<CR>), use the C<fixed>
  option to specify it.  This generally only matters for troff output for
  printing.  Similarly, you can set the fonts used for bold, italic, and
  bold italic fixed-width output.
  
  Besides the obvious pod conversions, Pod::Man also takes care of
  formatting func(), func(3), and simple variable references like $foo or
  @bar so you don't have to use code escapes for them; complex expressions
  like C<$fred{'stuff'}> will still need to be escaped, though.  It also
  translates dashes that aren't used as hyphens into en dashes, makes long
  dashes--like this--into proper em dashes, fixes "paired quotes," makes C++
  look right, puts a little space between double underscores, makes ALLCAPS
  a teeny bit smaller in B<troff>, and escapes stuff that *roff treats as
  special so that you don't have to.
  
  The recognized options to new() are as follows.  All options take a single
  argument.
  
  =over 4
  
  =item center
  
  Sets the centered page header for the C<.TH> macro.  The default, if this
  option is not specified, is "User Contributed Perl Documentation".
  
  =item date
  
  Sets the left-hand footer for the C<.TH> macro.  If this option is not set,
  the contents of the environment variable POD_MAN_DATE, if set, will be used.
  Failing that, the value of SOURCE_DATE_EPOCH, the modification date of the
  input file, or the current time if stat() can't find that file (which will be
  the case if the input is from C<STDIN>) will be used.  If obtained from the
  file modification date or the current time, the date will be formatted as
  C<YYYY-MM-DD> and will be based on UTC (so that the output will be
  reproducible regardless of local time zone).
  
  =item errors
  
  How to report errors.  C<die> says to throw an exception on any POD
  formatting error.  C<stderr> says to report errors on standard error, but
  not to throw an exception.  C<pod> says to include a POD ERRORS section
  in the resulting documentation summarizing the errors.  C<none> ignores
  POD errors entirely, as much as possible.
  
  The default is C<pod>.
  
  =item fixed
  
  The fixed-width font to use for verbatim text and code.  Defaults to
  C<CW>.  Some systems may want C<CR> instead.  Only matters for B<troff>
  output.
  
  =item fixedbold
  
  Bold version of the fixed-width font.  Defaults to C<CB>.  Only matters
  for B<troff> output.
  
  =item fixeditalic
  
  Italic version of the fixed-width font (actually, something of a misnomer,
  since most fixed-width fonts only have an oblique version, not an italic
  version).  Defaults to C<CI>.  Only matters for B<troff> output.
  
  =item fixedbolditalic
  
  Bold italic (probably actually oblique) version of the fixed-width font.
  Pod::Man doesn't assume you have this, and defaults to C<CB>.  Some
  systems (such as Solaris) have this font available as C<CX>.  Only matters
  for B<troff> output.
  
  =item lquote
  
  =item rquote
  
  Sets the quote marks used to surround CE<lt>> text.  C<lquote> sets the
  left quote mark and C<rquote> sets the right quote mark.  Either may also
  be set to the special value C<none>, in which case no quote mark is added
  on that side of CE<lt>> text (but the font is still changed for troff
  output).
  
  Also see the C<quotes> option, which can be used to set both quotes at once.
  If both C<quotes> and one of the other options is set, C<lquote> or C<rquote>
  overrides C<quotes>.
  
  =item name
  
  Set the name of the manual page for the C<.TH> macro.  Without this
  option, the manual name is set to the uppercased base name of the file
  being converted unless the manual section is 3, in which case the path is
  parsed to see if it is a Perl module path.  If it is, a path like
  C<.../lib/Pod/Man.pm> is converted into a name like C<Pod::Man>.  This
  option, if given, overrides any automatic determination of the name.
  
  If generating a manual page from standard input, the name will be set to
  C<STDIN> if this option is not provided.  Providing this option is strongly
  recommended to set a meaningful manual page name.
  
  =item nourls
  
  Normally, LZ<><> formatting codes with a URL but anchor text are formatted
  to show both the anchor text and the URL.  In other words:
  
      L<foo|http://example.com/>
  
  is formatted as:
  
      foo <http://example.com/>
  
  This option, if set to a true value, suppresses the URL when anchor text
  is given, so this example would be formatted as just C<foo>.  This can
  produce less cluttered output in cases where the URLs are not particularly
  important.
  
  =item quotes
  
  Sets the quote marks used to surround CE<lt>> text.  If the value is a
  single character, it is used as both the left and right quote.  Otherwise,
  it is split in half, and the first half of the string is used as the left
  quote and the second is used as the right quote.
  
  This may also be set to the special value C<none>, in which case no quote
  marks are added around CE<lt>> text (but the font is still changed for troff
  output).
  
  Also see the C<lquote> and C<rquote> options, which can be used to set the
  left and right quotes independently.  If both C<quotes> and one of the other
  options is set, C<lquote> or C<rquote> overrides C<quotes>.
  
  =item release
  
  Set the centered footer for the C<.TH> macro.  By default, this is set to
  the version of Perl you run Pod::Man under.  Setting this to the empty
  string will cause some *roff implementations to use the system default
  value.
  
  Note that some system C<an> macro sets assume that the centered footer
  will be a modification date and will prepend something like "Last
  modified: ".  If this is the case for your target system, you may want to
  set C<release> to the last modified date and C<date> to the version
  number.
  
  =item section
  
  Set the section for the C<.TH> macro.  The standard section numbering
  convention is to use 1 for user commands, 2 for system calls, 3 for
  functions, 4 for devices, 5 for file formats, 6 for games, 7 for
  miscellaneous information, and 8 for administrator commands.  There is a lot
  of variation here, however; some systems (like Solaris) use 4 for file
  formats, 5 for miscellaneous information, and 7 for devices.  Still others
  use 1m instead of 8, or some mix of both.  About the only section numbers
  that are reliably consistent are 1, 2, and 3.
  
  By default, section 1 will be used unless the file ends in C<.pm> in which
  case section 3 will be selected.
  
  =item stderr
  
  Send error messages about invalid POD to standard error instead of
  appending a POD ERRORS section to the generated *roff output.  This is
  equivalent to setting C<errors> to C<stderr> if C<errors> is not already
  set.  It is supported for backward compatibility.
  
  =item utf8
  
  By default, Pod::Man produces the most conservative possible *roff output
  to try to ensure that it will work with as many different *roff
  implementations as possible.  Many *roff implementations cannot handle
  non-ASCII characters, so this means all non-ASCII characters are converted
  either to a *roff escape sequence that tries to create a properly accented
  character (at least for troff output) or to C<X>.
  
  If this option is set, Pod::Man will instead output UTF-8.  If your *roff
  implementation can handle it, this is the best output format to use and
  avoids corruption of documents containing non-ASCII characters.  However,
  be warned that *roff source with literal UTF-8 characters is not supported
  by many implementations and may even result in segfaults and other bad
  behavior.
  
  Be aware that, when using this option, the input encoding of your POD
  source should be properly declared unless it's US-ASCII.  Pod::Simple will
  attempt to guess the encoding and may be successful if it's Latin-1 or
  UTF-8, but it will produce warnings.  Use the C<=encoding> command to
  declare the encoding.  See L<perlpod(1)> for more information.
  
  =back
  
  The standard Pod::Simple method parse_file() takes one argument naming the
  POD file to read from.  By default, the output is sent to C<STDOUT>, but
  this can be changed with the output_fh() method.
  
  The standard Pod::Simple method parse_from_file() takes up to two
  arguments, the first being the input file to read POD from and the second
  being the file to write the formatted output to.
  
  You can also call parse_lines() to parse an array of lines or
  parse_string_document() to parse a document already in memory.  As with
  parse_file(), parse_lines() and parse_string_document() default to sending
  their output to C<STDOUT> unless changed with the output_fh() method.  Be
  aware that parse_lines() and parse_string_document() both expect raw bytes,
  not decoded characters.
  
  To put the output from any parse method into a string instead of a file
  handle, call the output_string() method instead of output_fh().
  
  See L<Pod::Simple> for more specific details on the methods available to
  all derived parsers.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item roff font should be 1 or 2 chars, not "%s"
  
  (F) You specified a *roff font (using C<fixed>, C<fixedbold>, etc.) that
  wasn't either one or two characters.  Pod::Man doesn't support *roff fonts
  longer than two characters, although some *roff extensions do (the
  canonical versions of B<nroff> and B<troff> don't either).
  
  =item Invalid errors setting "%s"
  
  (F) The C<errors> parameter to the constructor was set to an unknown value.
  
  =item Invalid quote specification "%s"
  
  (F) The quote specification given (the C<quotes> option to the
  constructor) was invalid.  A quote specification must be either one
  character long or an even number (greater than one) characters long.
  
  =item POD document had syntax errors
  
  (F) The POD document being formatted had syntax errors and the C<errors>
  option was set to C<die>.
  
  =back
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item PERL_CORE
  
  If set and Encode is not available, silently fall back to non-UTF-8 mode
  without complaining to standard error.  This environment variable is set
  during Perl core builds, which build Encode after podlators.  Encode is
  expected to not (yet) be available in that case.
  
  =item POD_MAN_DATE
  
  If set, this will be used as the value of the left-hand footer unless the
  C<date> option is explicitly set, overriding the timestamp of the input
  file or the current time.  This is primarily useful to ensure reproducible
  builds of the same output file given the same source and Pod::Man version,
  even when file timestamps may not be consistent.
  
  =item SOURCE_DATE_EPOCH
  
  If set, and POD_MAN_DATE and the C<date> options are not set, this will be
  used as the modification time of the source file, overriding the timestamp of
  the input file or the current time.  It should be set to the desired time in
  seconds since UNIX epoch.  This is primarily useful to ensure reproducible
  builds of the same output file given the same source and Pod::Man version,
  even when file timestamps may not be consistent.  See
  L<https://reproducible-builds.org/specs/source-date-epoch/> for the full
  specification.
  
  (Arguably, according to the specification, this variable should be used only
  if the timestamp of the input file is not available and Pod::Man uses the
  current time.  However, for reproducible builds in Debian, results were more
  reliable if this variable overrode the timestamp of the input file.)
  
  =back
  
  =head1 BUGS
  
  Encoding handling assumes that PerlIO is available and does not work
  properly if it isn't.  The C<utf8> option is therefore not supported
  unless Perl is built with PerlIO support.
  
  There is currently no way to turn off the guesswork that tries to format
  unmarked text appropriately, and sometimes it isn't wanted (particularly
  when using POD to document something other than Perl).  Most of the work
  toward fixing this has now been done, however, and all that's still needed
  is a user interface.
  
  The NAME section should be recognized specially and index entries emitted
  for everything in that section.  This would have to be deferred until the
  next section, since extraneous things in NAME tends to confuse various man
  page processors.  Currently, no index entries are emitted for anything in
  NAME.
  
  Pod::Man doesn't handle font names longer than two characters.  Neither do
  most B<troff> implementations, but GNU troff does as an extension.  It would
  be nice to support as an option for those who want to use it.
  
  The preamble added to each output file is rather verbose, and most of it
  is only necessary in the presence of non-ASCII characters.  It would
  ideally be nice if all of those definitions were only output if needed,
  perhaps on the fly as the characters are used.
  
  Pod::Man is excessively slow.
  
  =head1 CAVEATS
  
  If Pod::Man is given the C<utf8> option, the encoding of its output file
  handle will be forced to UTF-8 if possible, overriding any existing
  encoding.  This will be done even if the file handle is not created by
  Pod::Man and was passed in from outside.  This maintains consistency
  regardless of PERL_UNICODE and other settings.
  
  The handling of hyphens and em dashes is somewhat fragile, and one may get
  the wrong one under some circumstances.  This should only matter for
  B<troff> output.
  
  When and whether to use small caps is somewhat tricky, and Pod::Man doesn't
  necessarily get it right.
  
  Converting neutral double quotes to properly matched double quotes doesn't
  work unless there are no formatting codes between the quote marks.  This
  only matters for troff output.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>, based I<very> heavily on the original B<pod2man>
  by Tom Christiansen <tchrist@mox.perl.com>.  The modifications to work with
  Pod::Simple instead of Pod::Parser were originally contributed by Sean Burke
  <sburke@cpan.org> (but I've since hacked them beyond recognition and all bugs
  are mine).
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999-2010, 2012-2019 Russ Allbery <rra@cpan.org>
  
  Substantial contributions by Sean Burke <sburke@cpan.org>.
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<perlpod(1)>, L<pod2man(1)>, L<nroff(1)>, L<troff(1)>,
  L<man(1)>, L<man(7)>
  
  Ossanna, Joseph F., and Brian W. Kernighan.  "Troff User's Manual,"
  Computing Science Technical Report No. 54, AT&T Bell Laboratories.  This is
  the best documentation of standard B<nroff> and B<troff>.  At the time of
  this writing, it's available at L<http://www.troff.org/54.pdf>.
  
  The man page documenting the man macro set may be L<man(5)> instead of
  L<man(7)> on your system.  Also, please see L<pod2man(1)> for extensive
  documentation on writing manual pages if you've not done it before and
  aren't familiar with the conventions.
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_MAN

$fatpacked{"Pod/ParseLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSELINK';
  # Parse an L<> formatting code in POD text.
  #
  # This module implements parsing of the text of an L<> formatting code as
  # defined in perlpodspec.  It should be suitable for any POD formatter.  It
  # exports only one function, parselink(), which returns the five-item parse
  # defined in perlpodspec.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::ParseLink;
  
  use 5.008;
  use strict;
  use warnings;
  
  use vars qw(@EXPORT @ISA $VERSION);
  
  use Exporter;
  @ISA    = qw(Exporter);
  @EXPORT = qw(parselink);
  
  $VERSION = '4.14';
  
  ##############################################################################
  # Implementation
  ##############################################################################
  
  # Parse the name and section portion of a link into a name and section.
  sub _parse_section {
      my ($link) = @_;
      $link =~ s/^\s+//;
      $link =~ s/\s+$//;
  
      # If the whole link is enclosed in quotes, interpret it all as a section
      # even if it contains a slash.
      return (undef, $1) if ($link =~ /^"\s*(.*?)\s*"$/);
  
      # Split into page and section on slash, and then clean up quoting in the
      # section.  If there is no section and the name contains spaces, also
      # guess that it's an old section link.
      my ($page, $section) = split (/\s*\/\s*/, $link, 2);
      $section =~ s/^"\s*(.*?)\s*"$/$1/ if $section;
      if ($page && $page =~ / / && !defined ($section)) {
          $section = $page;
          $page = undef;
      } else {
          $page = undef unless $page;
          $section = undef unless $section;
      }
      return ($page, $section);
  }
  
  # Infer link text from the page and section.
  sub _infer_text {
      my ($page, $section) = @_;
      my $inferred;
      if ($page && !$section) {
          $inferred = $page;
      } elsif (!$page && $section) {
          $inferred = '"' . $section . '"';
      } elsif ($page && $section) {
          $inferred = '"' . $section . '" in ' . $page;
      }
      return $inferred;
  }
  
  # Given the contents of an L<> formatting code, parse it into the link text,
  # the possibly inferred link text, the name or URL, the section, and the type
  # of link (pod, man, or url).
  sub parselink {
      my ($link) = @_;
      $link =~ s/\s+/ /g;
      my $text;
      if ($link =~ /\|/) {
          ($text, $link) = split (/\|/, $link, 2);
      }
      if ($link =~ /\A\w+:[^:\s]\S*\Z/) {
          my $inferred;
          if (defined ($text) && length ($text) > 0) {
              return ($text, $text, $link, undef, 'url');
          } else {
              return ($text, $link, $link, undef, 'url');
          }
      } else {
          my ($name, $section) = _parse_section ($link);
          my $inferred;
          if (defined ($text) && length ($text) > 0) {
              $inferred = $text;
          } else {
              $inferred = _infer_text ($name, $section);
          }
          my $type = ($name && $name =~ /\(\S*\)/) ? 'man' : 'pod';
          return ($text, $inferred, $name, $section, $type);
      }
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  # Ensure we evaluate to true.
  1;
  __END__
  
  =for stopwords
  markup Allbery URL
  
  =head1 NAME
  
  Pod::ParseLink - Parse an LE<lt>E<gt> formatting code in POD text
  
  =head1 SYNOPSIS
  
      use Pod::ParseLink;
      my $link = get_link();
      my ($text, $inferred, $name, $section, $type) = parselink($link);
  
  =head1 DESCRIPTION
  
  This module only provides a single function, parselink(), which takes the
  text of an LE<lt>E<gt> formatting code and parses it.  It returns the
  anchor text for the link (if any was given), the anchor text possibly
  inferred from the name and section, the name or URL, the section if any,
  and the type of link.  The type will be one of C<url>, C<pod>, or C<man>,
  indicating a URL, a link to a POD page, or a link to a Unix manual page.
  
  Parsing is implemented per L<perlpodspec>.  For backward compatibility,
  links where there is no section and name contains spaces, or links where the
  entirety of the link (except for the anchor text if given) is enclosed in
  double-quotes are interpreted as links to a section (LE<lt>/sectionE<gt>).
  
  The inferred anchor text is implemented per L<perlpodspec>:
  
      L<name>         =>  L<name|name>
      L</section>     =>  L<"section"|/section>
      L<name/section> =>  L<"section" in name|name/section>
  
  The name may contain embedded EE<lt>E<gt> and ZE<lt>E<gt> formatting codes,
  and the section, anchor text, and inferred anchor text may contain any
  formatting codes.  Any double quotes around the section are removed as part
  of the parsing, as is any leading or trailing whitespace.
  
  If the text of the LE<lt>E<gt> escape is entirely enclosed in double
  quotes, it's interpreted as a link to a section for backward
  compatibility.
  
  No attempt is made to resolve formatting codes.  This must be done after
  calling parselink() (since EE<lt>E<gt> formatting codes can be used to
  escape characters that would otherwise be significant to the parser and
  resolving them before parsing would result in an incorrect parse of a
  formatting code like:
  
      L<verticalE<verbar>barE<sol>slash>
  
  which should be interpreted as a link to the C<vertical|bar/slash> POD page
  and not as a link to the C<slash> section of the C<bar> POD page with an
  anchor text of C<vertical>.  Note that not only the anchor text will need to
  have formatting codes expanded, but so will the target of the link (to deal
  with EE<lt>E<gt> and ZE<lt>E<gt> formatting codes), and special handling of
  the section may be necessary depending on whether the translator wants to
  consider markup in sections to be significant when resolving links.  See
  L<perlpodspec> for more information.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2001, 2008, 2009, 2014, 2018-2019 Russ Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Parser>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_PARSELINK

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  
  require 5;
  package Pod::Simple;
  use strict;
  use Carp ();
  BEGIN           { *DEBUG = sub () {0} unless defined &DEBUG }
  use integer;
  use Pod::Escapes 1.04 ();
  use Pod::Simple::LinkSection ();
  use Pod::Simple::BlackBox ();
  use Pod::Simple::TiedOutFH;
  #use utf8;
  
  use vars qw(
    $VERSION @ISA
    @Known_formatting_codes  @Known_directives
    %Known_formatting_codes  %Known_directives
    $NL
  );
  
  @ISA = ('Pod::Simple::BlackBox');
  $VERSION = '3.43';
  
  @Known_formatting_codes = qw(I B C L E F S X Z); 
  %Known_formatting_codes = map(($_=>1), @Known_formatting_codes);
  @Known_directives       = qw(head1 head2 head3 head4 head5 head6 item over back); 
  %Known_directives       = map(($_=>'Plain'), @Known_directives);
  $NL = $/ unless defined $NL;
  
  #-----------------------------------------------------------------------------
  # Set up some constants:
  
  BEGIN {
    if(defined &ASCII)    { }
    elsif(chr(65) eq 'A') { *ASCII = sub () {1}  }
    else                  { *ASCII = sub () {''} }
  
    unless(defined &MANY_LINES) { *MANY_LINES = sub () {20} }
    DEBUG > 4 and print STDERR "MANY_LINES is ", MANY_LINES(), "\n";
    unless(MANY_LINES() >= 1) {
      die "MANY_LINES is too small (", MANY_LINES(), ")!\nAborting";
    }
    if(defined &UNICODE) { }
    elsif($] >= 5.008)   { *UNICODE = sub() {1}  }
    else                 { *UNICODE = sub() {''} }
  }
  if(DEBUG > 2) {
    print STDERR "# We are ", ASCII ? '' : 'not ', "in ASCII-land\n";
    print STDERR "# We are under a Unicode-safe Perl.\n";
  }
  
  # The NO BREAK SPACE and SOFT HYHPEN are used in several submodules.
  if ($] ge 5.007_003) {  # On sufficiently modern Perls we can handle any
                          # character set
    $Pod::Simple::nbsp = chr utf8::unicode_to_native(0xA0);
    $Pod::Simple::shy  = chr utf8::unicode_to_native(0xAD);
  }
  elsif (Pod::Simple::ASCII) {  # Hard code ASCII early Perl
    $Pod::Simple::nbsp = "\xA0";
    $Pod::Simple::shy  = "\xAD";
  }
  else { # EBCDIC on early Perl.  We know what the values are for the code
          # pages supported then.
    $Pod::Simple::nbsp = "\x41";
    $Pod::Simple::shy  = "\xCA";
  }
  
  # Design note:
  # This is a parser for Pod.  It is not a parser for the set of Pod-like
  #  languages which happens to contain Pod -- it is just for Pod, plus possibly
  #  some extensions.
  
  # @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
  #@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  __PACKAGE__->_accessorize(
    '_output_is_for_JustPod', # For use only by Pod::Simple::JustPod,
                         # If non-zero, don't expand Z<> E<> S<> L<>,
                         # and count how many brackets in format codes
    'nbsp_for_S',        # Whether to map S<...>'s to \xA0 characters
    'source_filename',   # Filename of the source, for use in warnings
    'source_dead',       # Whether to consider this parser's source dead
  
    'output_fh',         # The filehandle we're writing to, if applicable.
                         # Used only in some derived classes.
  
    'hide_line_numbers', # For some dumping subclasses: whether to pointedly
                         # suppress the start_line attribute
  
    'line_count',        # the current line number
    'pod_para_count',    # count of pod paragraphs seen so far
  
    'no_whining',        # whether to suppress whining
    'no_errata_section', # whether to suppress the errata section
    'complain_stderr',   # whether to complain to stderr
  
    'doc_has_started',   # whether we've fired the open-Document event yet
  
    'bare_output',       # For some subclasses: whether to prepend
                         #  header-code and postpend footer-code
  
    'keep_encoding_directive',  # whether to emit =encoding
    'nix_X_codes',       # whether to ignore X<...> codes
    'merge_text',        # whether to avoid breaking a single piece of
                         #  text up into several events
  
    'preserve_whitespace', # whether to try to keep whitespace as-is
    'strip_verbatim_indent', # What indent to strip from verbatim
    'expand_verbatim_tabs',  # 0: preserve tabs in verbatim blocks
                             # n: expand tabs to stops every n columns
  
    'parse_characters',  # Whether parser should expect chars rather than octets
  
   'content_seen',      # whether we've seen any real Pod content
   'errors_seen',       # TODO: document.  whether we've seen any errors (fatal or not)
  
   'codes_in_verbatim', # for PseudoPod extensions
  
   'code_handler',      # coderef to call when a code (non-pod) line is seen
   'cut_handler',       # ... when a =cut line is seen
   'pod_handler',       # ... when a =pod line is seen
   'whiteline_handler', # ... when a line with only whitespace is seen
   #Called like:
   # $code_handler->($line, $self->{'line_count'}, $self) if $code_handler;
   #  $cut_handler->($line, $self->{'line_count'}, $self) if $cut_handler;
   #  $pod_handler->($line, $self->{'line_count'}, $self) if $pod_handler;
   #   $wl_handler->($line, $self->{'line_count'}, $self) if $wl_handler;
   'parse_empty_lists', # whether to acknowledge empty =over/=back blocks
   'raw_mode',          # to report entire raw lines instead of Pod elements
  );
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub any_errata_seen {  # good for using as an exit() value...
    return shift->{'errors_seen'} || 0;
  }
  
  sub errata_seen {
    return shift->{'all_errata'} || {};
  }
  
  # Returns the encoding only if it was recognized as being handled and set
  sub detected_encoding {
    return shift->{'detected_encoding'};
  }
  
  sub encoding {
    my $this = shift;
    return $this->{'encoding'} unless @_;  # GET.
  
    $this->_handle_encoding_line("=encoding $_[0]");
    if ($this->{'_processed_encoding'}) {
      delete $this->{'_processed_encoding'};
      if(! $this->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n";
      } elsif( $this->{'encoding_command_statuses'}[-1] ) {
        $this->scream( "=encoding $_[0]",
           sprintf "Couldn't do %s: %s",
           $this->{'encoding_command_reqs'  }[-1],
           $this->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (encoding successfully handled.)\n";
      }
      return $this->{'encoding'};
    } else {
      return undef;
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  # Pull in some functions that, for some reason, I expect to see here too:
  BEGIN {
    *pretty        = \&Pod::Simple::BlackBox::pretty;
    *stringify_lol = \&Pod::Simple::BlackBox::stringify_lol;
    *my_qr         = \&Pod::Simple::BlackBox::my_qr;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub version_report {
    my $class = ref($_[0]) || $_[0];
    if($class eq __PACKAGE__) {
      return "$class $VERSION";
    } else {
      my $v = $class->VERSION;
      return "$class $v (" . __PACKAGE__ . " $VERSION)";
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  #sub curr_open { # read-only list accessor
  #  return @{ $_[0]{'curr_open'} || return() };
  #}
  #sub _curr_open_listref { $_[0]{'curr_open'} ||= [] }
  
  
  sub output_string {
    # Works by faking out output_fh.  Simplifies our code.
    #
    my $this = shift;
    return $this->{'output_string'} unless @_;  # GET.
    
    my $x = (defined($_[0]) and ref($_[0])) ? $_[0] : \( $_[0] );
    $$x = '' unless defined $$x;
    DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";
    $this->{'output_fh'} = Pod::Simple::TiedOutFH->handle_on($_[0]);
    return
      $this->{'output_string'} = $_[0];
      #${ ${ $this->{'output_fh'} } };
  }
  
  sub abandon_output_string { $_[0]->abandon_output_fh; delete $_[0]{'output_string'} }
  sub abandon_output_fh     { $_[0]->output_fh(undef) }
  # These don't delete the string or close the FH -- they just delete our
  #  references to it/them.
  # TODO: document these
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub new {
    # takes no parameters
    my $class = ref($_[0]) || $_[0];
    #Carp::croak(__PACKAGE__ . " is a virtual base class -- see perldoc "
    #  . __PACKAGE__ );
    my $obj = bless {
      'accept_codes'      => { map( ($_=>$_), @Known_formatting_codes ) },
      'accept_directives' => { %Known_directives },
      'accept_targets'    => {},
    }, $class;
  
    $obj->expand_verbatim_tabs(8);
    return $obj;
  }
  
  
  
  # TODO: an option for whether to interpolate E<...>'s, or just resolve to codes.
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {     # OVERRIDE IN DERIVED CLASS
    my($self, $element_name, $attr_hash_r) = @_;
    return;
  }
  
  sub _handle_element_end {       # OVERRIDE IN DERIVED CLASS
    my($self, $element_name) = @_;
    return;
  }
  
  sub _handle_text          {     # OVERRIDE IN DERIVED CLASS
    my($self, $text) = @_;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now directives (not targets)
  
  sub accept_directive_as_verbatim  { shift->_accept_directives('Verbatim', @_) }
  sub accept_directive_as_data      { shift->_accept_directives('Data',     @_) }
  sub accept_directive_as_processed { shift->_accept_directives('Plain',    @_) }
  
  sub _accept_directives {
    my($this, $type) = splice @_,0,2;
    foreach my $d (@_) {
      next unless defined $d and length $d;
      Carp::croak "\"$d\" isn't a valid directive name"
       unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
      Carp::croak "\"$d\" is already a reserved Pod directive name"
       if exists $Known_directives{$d};
      $this->{'accept_directives'}{$d} = $type;
      DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n";
    }
    DEBUG > 6 and print STDERR "$this\'s accept_directives : ",
     pretty($this->{'accept_directives'}), "\n";
    
    return sort keys %{ $this->{'accept_directives'} } if wantarray;
    return;
  }
  
  #--------------------------------------------------------------------------
  # TODO: document these:
  
  sub unaccept_directive { shift->unaccept_directives(@_) };
  
  sub unaccept_directives {
    my $this = shift;
    foreach my $d (@_) {
      next unless defined $d and length $d;
      Carp::croak "\"$d\" isn't a valid directive name"
       unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
      Carp::croak "But you must accept \"$d\" directives -- it's a builtin!"
       if exists $Known_directives{$d};
      delete $this->{'accept_directives'}{$d};
      DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n";
    }
    return sort keys %{ $this->{'accept_directives'} } if wantarray;
    return
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now targets (not directives)
  
  sub accept_target         { shift->accept_targets(@_)         } # alias
  sub accept_target_as_text { shift->accept_targets_as_text(@_) } # alias
  
  
  sub accept_targets         { shift->_accept_targets('1', @_) }
  
  sub accept_targets_as_text { shift->_accept_targets('force_resolve', @_) }
   # forces them to be processed, even when there's no ":".
  
  sub _accept_targets {
    my($this, $type) = splice @_,0,2;
    foreach my $t (@_) {
      next unless defined $t and length $t;
      # TODO: enforce some limitations on what a target name can be?
      $this->{'accept_targets'}{$t} = $type;
      DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n";
    }    
    return sort keys %{ $this->{'accept_targets'} } if wantarray;
    return;
  }
  
  #--------------------------------------------------------------------------
  sub unaccept_target         { shift->unaccept_targets(@_) }
  
  sub unaccept_targets {
    my $this = shift;
    foreach my $t (@_) {
      next unless defined $t and length $t;
      # TODO: enforce some limitations on what a target name can be?
      delete $this->{'accept_targets'}{$t};
      DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n";
    }    
    return sort keys %{ $this->{'accept_targets'} } if wantarray;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now codes (not targets or directives)
  
  # XXX Probably it is an error that the digit '9' is excluded from these re's.
  # Broken for early Perls on EBCDIC
  my $xml_name_re = my_qr('[^-.0-8:A-Z_a-z[:^ascii:]]', '9');
  $xml_name_re = qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/
                                                              unless $xml_name_re;
  
  sub accept_code { shift->accept_codes(@_) } # alias
  
  sub accept_codes {  # Add some codes
    my $this = shift;
    
    foreach my $new_code (@_) {
      next unless defined $new_code and length $new_code;
      # A good-enough check that it's good as an XML Name symbol:
      Carp::croak "\"$new_code\" isn't a valid element name"
        if $new_code =~ $xml_name_re
            # Characters under 0x80 that aren't legal in an XML Name.
        or $new_code =~ m/^[-\.0-9]/s
        or $new_code =~ m/:[-\.0-9]/s;
            # The legal under-0x80 Name characters that
            #  an XML Name still can't start with.
  
      $this->{'accept_codes'}{$new_code} = $new_code;
  
      # Yes, map to itself -- just so that when we
      #  see "=extend W [whatever] thatelementname", we say that W maps
      #  to whatever $this->{accept_codes}{thatelementname} is,
      #  i.e., "thatelementname".  Then when we go re-mapping,
      #  a "W" in the treelet turns into "thatelementname".  We only
      #  remap once.
      # If we say we accept "W", then a "W" in the treelet simply turns
      #  into "W".
    }
    
    return;
  }
  
  #--------------------------------------------------------------------------
  sub unaccept_code { shift->unaccept_codes(@_) }
  
  sub unaccept_codes { # remove some codes
    my $this = shift;
    
    foreach my $new_code (@_) {
      next unless defined $new_code and length $new_code;
      # A good-enough check that it's good as an XML Name symbol:
      Carp::croak "\"$new_code\" isn't a valid element name"
        if $new_code =~ $xml_name_re
            # Characters under 0x80 that aren't legal in an XML Name.
        or $new_code =~ m/^[-\.0-9]/s
        or $new_code =~ m/:[-\.0-9]/s;
            # The legal under-0x80 Name characters that
            #  an XML Name still can't start with.
  
      Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!"
       if grep $new_code eq $_, @Known_formatting_codes;
  
      delete $this->{'accept_codes'}{$new_code};
  
      DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n";
    }
    
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_string_document {
    my $self = shift;
    my @lines;
    foreach my $line_group (@_) {
      next unless defined $line_group and length $line_group;
      pos($line_group) = 0;
      while($line_group =~
        m/([^\n\r]*)(\r?\n?)/g # supports \r, \n ,\r\n
        #m/([^\n\r]*)((?:\r?\n)?)/g
      ) {
        #print(">> $1\n"),
        $self->parse_lines($1)
         if length($1) or length($2)
          or pos($line_group) != length($line_group);
         # I.e., unless it's a zero-length "empty line" at the very
         #  end of "foo\nbar\n" (i.e., between the \n and the EOS).
      }
    }
    $self->parse_lines(undef); # to signal EOF
    return $self;
  }
  
  sub _init_fh_source {
    my($self, $source) = @_;
  
    #DEBUG > 1 and print STDERR "Declaring $source as :raw for starters\n";
    #$self->_apply_binmode($source, ':raw');
    #binmode($source, ":raw");
  
    return;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  #
  
  sub parse_file {
    my($self, $source) = (@_);
  
    if(!defined $source) {
      Carp::croak("Can't use empty-string as a source for parse_file");
    } elsif(ref(\$source) eq 'GLOB') {
      $self->{'source_filename'} = '' . ($source);
    } elsif(ref $source) {
      $self->{'source_filename'} = '' . ($source);
    } elsif(!length $source) {
      Carp::croak("Can't use empty-string as a source for parse_file");
    } else {
      {
        local *PODSOURCE;
        open(PODSOURCE, "<$source") || Carp::croak("Can't open $source: $!");
        $self->{'source_filename'} = $source;
        $source = *PODSOURCE{IO};
      }
      $self->_init_fh_source($source);
    }
    # By here, $source is a FH.
  
    $self->{'source_fh'} = $source;
  
    my($i, @lines);
    until( $self->{'source_dead'} ) {
      splice @lines;
  
      for($i = MANY_LINES; $i--;) {  # read those many lines at a time
        local $/ = $NL;
        push @lines, scalar(<$source>);  # readline
        last unless defined $lines[-1];
         # but pass thru the undef, which will set source_dead to true
      }
  
      my $at_eof = ! $lines[-1]; # keep track of the undef
      pop @lines if $at_eof; # silence warnings
  
      # be eol agnostic
      s/\r\n?/\n/g for @lines;
   
      # make sure there are only one line elements for parse_lines
      @lines = split(/(?<=\n)/, join('', @lines));
  
      # push the undef back after popping it to set source_dead to true
      push @lines, undef if $at_eof;
  
      $self->parse_lines(@lines);
    }
    delete($self->{'source_fh'}); # so it can be GC'd
    return $self;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub parse_from_file {
    # An emulation of Pod::Parser's interface, for the sake of Perldoc.
    # Basically just a wrapper around parse_file.
  
    my($self, $source, $to) = @_;
    $self = $self->new unless ref($self); # so we tolerate being a class method
    
    if(!defined $source)             { $source = *STDIN{IO}
    } elsif(ref(\$source) eq 'GLOB') { # stet
    } elsif(ref($source)           ) { # stet
    } elsif(!length $source
       or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i
    ) { 
      $source = *STDIN{IO};
    }
  
    if(!defined $to) {             $self->output_fh( *STDOUT{IO}   );
    } elsif(ref(\$to) eq 'GLOB') { $self->output_fh( $to );
    } elsif(ref($to)) {            $self->output_fh( $to );
    } elsif(!length $to
       or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i
    ) {
      $self->output_fh( *STDOUT{IO} );
    } elsif($to =~ m/^>&(?:STDERR|2)$/i) {
      $self->output_fh( *STDERR{IO} );
    } else {
      require Symbol;
      my $out_fh = Symbol::gensym();
      DEBUG and print STDERR "Write-opening to $to\n";
      open($out_fh, ">$to")  or  Carp::croak "Can't write-open $to: $!";
      binmode($out_fh)
       if $self->can('write_with_binmode') and $self->write_with_binmode;
      $self->output_fh($out_fh);
    }
  
    return $self->parse_file($source);
  }
  
  #-----------------------------------------------------------------------------
  
  sub whine {
    #my($self,$line,$complaint) = @_;
    my $self = shift(@_);
    ++$self->{'errors_seen'};
    if($self->{'no_whining'}) {
      DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";
      return;
    }
    push @{$self->{'all_errata'}{$_[0]}}, $_[1];
    return $self->_complain_warn(@_) if $self->{'complain_stderr'};
    return $self->_complain_errata(@_);
  }
  
  sub scream {    # like whine, but not suppressible
    #my($self,$line,$complaint) = @_;
    my $self = shift(@_);
    ++$self->{'errors_seen'};
    push @{$self->{'all_errata'}{$_[0]}}, $_[1];
    return $self->_complain_warn(@_) if $self->{'complain_stderr'};
    return $self->_complain_errata(@_);
  }
  
  sub _complain_warn {
    my($self,$line,$complaint) = @_;
    return printf STDERR "%s around line %s: %s\n",
      $self->{'source_filename'} || 'Pod input', $line, $complaint;
  }
  
  sub _complain_errata {
    my($self,$line,$complaint) = @_;
    if( $self->{'no_errata_section'} ) {
      DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n";
    } else {
      DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";
      push @{$self->{'errata'}{$line}}, $complaint
        # for a report to be generated later!
    }
    return 1;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _get_initial_item_type {
    # A hack-wrapper here for when you have like "=over\n\n=item 456\n\n"
    my($self, $para) = @_;
    return $para->[1]{'~type'}  if $para->[1]{'~type'};
  
    return $para->[1]{'~type'} = 'text'
     if join("\n", @{$para}[2 .. $#$para]) =~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';
    # Else fall thru to the general case:
    return $self->_get_item_type($para);
  }
  
  
  
  sub _get_item_type {       # mutates the item!!
    my($self, $para) = @_;
    return $para->[1]{'~type'} if $para->[1]{'~type'};
  
  
    # Otherwise we haven't yet been to this node.  Maybe alter it...
    
    my $content = join "\n", @{$para}[2 .. $#$para];
  
    if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s) {
      # Like: "=item *", "=item   *   ", "=item"
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      $para->[1]{'~orig_content'} = $content;
      return $para->[1]{'~type'} = 'bullet';
  
    } elsif($content =~ m/^\s*\*\s+(.+)/s) {  # tolerance
    
      # Like: "=item * Foo bar baz";
      $para->[1]{'~orig_content'}      = $content;
      $para->[1]{'~_freaky_para_hack'} = $1;
      DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      return $para->[1]{'~type'} = 'bullet';
  
    } elsif($content =~ m/^\s*(\d+)\.?\s*$/s) {
      # Like: "=item 1.", "=item    123412"
      
      $para->[1]{'~orig_content'} = $content;
      $para->[1]{'number'} = $1;  # Yes, stores the number there!
  
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      return $para->[1]{'~type'} = 'number';
      
    } else {
      # It's anything else.
      return $para->[1]{'~type'} = 'text';
  
    }
  }
  
  #-----------------------------------------------------------------------------
  
  sub _make_treelet {
    my $self = shift;  # and ($para, $start_line)
    my $treelet;
    if(!@_) {
      return [''];
    } if(ref $_[0] and ref $_[0][0] and $_[0][0][0] eq '~Top') {
      # Hack so we can pass in fake-o pre-cooked paragraphs:
      #  just have the first line be a reference to a ['~Top', {}, ...]
      # We use this feechure in gen_errata and stuff.
  
      DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";
      $treelet = $_[0][0];
      splice @$treelet, 0, 2;  # lop the top off
      return $treelet;
    } else {
      $treelet = $self->_treelet_from_formatting_codes(@_);
    }
    
    if( ! $self->{'_output_is_for_JustPod'}   # Retain these as-is for pod output
       && $self->_remap_sequences($treelet) )
    {
      $self->_treat_Zs($treelet);  # Might as well nix these first
      $self->_treat_Ls($treelet);  # L has to precede E and S
      $self->_treat_Es($treelet);
      $self->_treat_Ss($treelet);  # S has to come after E
      $self->_wrap_up($treelet); # Nix X's and merge texties
      
    } else {
      DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n";
       # Very common case!
    }
    
    splice @$treelet, 0, 2;  # lop the top off
  
    return $treelet;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _wrap_up {
    my($self, @stack) = @_;
    my $nixx  = $self->{'nix_X_codes'};
    my $merge = $self->{'merge_text' };
    return unless $nixx or $merge;
  
    DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",
     $merge ? (" Merge mode on\n") : (),
     $nixx  ? (" Nix-X mode on\n") : (),
    ;    
    
  
    my($i, $treelet);
    while($treelet = shift @stack) {
      DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        DEBUG > 3 and print STDERR " Considering child at $i ", pretty($treelet->[$i]), "\n";
        if($nixx and ref $treelet->[$i] and $treelet->[$i][0] eq 'X') {
          DEBUG > 3 and print STDERR "   Nixing X node at $i\n";
          splice(@$treelet, $i, 1); # just nix this node (and its descendants)
          # no need to back-update the counter just yet
          redo;
  
        } elsif($merge and $i != 2 and  # non-initial
           !ref $treelet->[$i] and !ref $treelet->[$i - 1]
        ) {
          DEBUG > 3 and print STDERR "   Merging ", $i-1,
           ":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";
          $treelet->[$i-1] .= ( splice(@$treelet, $i, 1) )[0];
          DEBUG > 4 and print STDERR "    Now: ", $i-1, ":[$treelet->[$i-1]]\n";
          --$i;
          next; 
          # since we just pulled the possibly last node out from under
          #  ourselves, we can't just redo()
  
        } elsif( ref $treelet->[$i] ) {
          DEBUG > 4 and print STDERR "  Enqueuing ", pretty($treelet->[$i]), " for traversal.\n";
          push @stack, $treelet->[$i];
  
          if($treelet->[$i][0] eq 'L') {
            my $thing;
            foreach my $attrname ('section', 'to') {        
              if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
                unshift @stack, $thing;
                DEBUG > 4 and print STDERR "  +Enqueuing ",
                 pretty( $treelet->[$i][1]{$attrname} ),
                 " as an attribute value to tweak.\n";
              }
            }
          }
        }
      }
    }
    DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";
  
    return;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _remap_sequences {
    my($self,@stack) = @_;
    
    if(@stack == 1 and @{ $stack[0] } == 3 and !ref $stack[0][2]) {
      # VERY common case: abort it.
      DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";
      return 0;
    }
    
    my $map = ($self->{'accept_codes'} || die "NO accept_codes in $self?!?");
  
    my $start_line = $stack[0][1]{'start_line'};
    DEBUG > 2 and printf
     "\nAbout to start _remap_sequences on treelet from line %s.\n",
     $start_line || '[?]'
    ;
    DEBUG > 3 and print STDERR " Map: ",
      join('; ', map "$_=" . (
          ref($map->{$_}) ? join(",", @{$map->{$_}}) : $map->{$_}
        ),
        sort keys %$map ),
      ("B~C~E~F~I~L~S~X~Z" eq join '~', sort keys %$map)
       ? "  (all normal)\n" : "\n"
    ;
  
    # A recursive algorithm implemented iteratively!  Whee!
    
    my($is, $was, $i, $treelet); # scratch
    while($treelet = shift @stack) {
      DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        
        DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";
        
        $is = $treelet->[$i][0] = $map->{ $was = $treelet->[$i][0] };
        if( DEBUG > 3 ) {
          if(!defined $is) {
            print STDERR "   Code $was<> is UNKNOWN!\n";
          } elsif($is eq $was) {
            DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n";
          } else  {
            print STDERR "   Code $was<> maps to ",
             ref($is)
              ? ( "tags ", map("$_<", @$is), '...', map('>', @$is), "\n" )
              : "tag $is<...>.\n";
          }
        }
        
        if(!defined $is) {
          $self->whine($start_line, "Deleting unknown formatting code $was<>");
          $is = $treelet->[$i][0] = '1';  # But saving the children!
          # I could also insert a leading "$was<" and tailing ">" as
          # children of this node, but something about that seems icky.
        }
        if(ref $is) {
          my @dynasty = @$is;
          DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";
          $treelet->[$i][0] = pop @dynasty;
          my $nugget;
          while(@dynasty) {
            DEBUG > 4 and printf
             "    Grafting a new %s node between %s and %s\n",
             $dynasty[-1], $treelet->[0], $treelet->[$i][0], 
            ;
            
            #$nugget = ;
            splice @$treelet, $i, 1, [pop(@dynasty), {}, $treelet->[$i]];
              # relace node with a new parent
          }
        } elsif($is eq '0') {
          splice(@$treelet, $i, 1); # just nix this node (and its descendants)
          --$i;  # back-update the counter
        } elsif($is eq '1') {
          splice(@$treelet, $i, 1 # replace this node with its children!
            => splice @{ $treelet->[$i] },2
                # (not catching its first two (non-child) items)
          );
          --$i;  # back up for new stuff
        } else {
          # otherwise it's unremarkable
          unshift @stack, $treelet->[$i];  # just recurse
        }
      }
    }
    
    DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";
  
    if(@_ == 2 and @{ $_[1] } == 3 and !ref $_[1][2]) {
      DEBUG and print STDERR "Noting that the treelet is now formatless.\n";
      return 0;
    }
    return 1;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _ponder_extend {
  
    # "Go to an extreme, move back to a more comfortable place"
    #  -- /Oblique Strategies/,  Brian Eno and Peter Schmidt
    
    my($self, $para) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";
  
    if($content =~
      m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs
    ) {
      my $new_letter = $1;
      my $fallbacks_one = $2;
      my $elements_one;
      $elements_one = defined($3) ? $3 : $1;
  
      DEBUG > 2 and print STDERR "Extensor has good syntax.\n";
  
      unless($new_letter =~ m/^[A-Z]$/s or $new_letter) {
        DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You can extend only formatting codes A-Z, not like \"$new_letter\""
        );
        return;
      }
      
      if(grep $new_letter eq $_, @Known_formatting_codes) {
        DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You can't extend an established code like \"$new_letter\""
        );
        
        #TODO: or allow if last bit is same?
        
        return;
      }
  
      unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s  # like "B", "M,I", etc.
        or $fallbacks_one eq '0' or $fallbacks_one eq '1'
      ) {
        $self->whine(
          $para->[1]{'start_line'},
          "Format for second =extend parameter must be like"
          . " M or 1 or 0 or M,N or M,N,O but you have it like "
          . $fallbacks_one
        );
        return;
      }
      
      unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s) { # like "B", "M,I", etc.
        $self->whine(
          $para->[1]{'start_line'},
          "Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like "
          . $elements_one
        );
        return;
      }
  
      my @fallbacks  = split ',', $fallbacks_one,  -1;
      my @elements   = split ',', $elements_one, -1;
  
      foreach my $f (@fallbacks) {
        next if exists $Known_formatting_codes{$f} or $f eq '0' or $f eq '1';
        DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";
        $self->whine(
          $para->[1]{'start_line'},
          "Can't use unknown formatting code '$f' as a fallback for '$new_letter'"
        );
        return;
      }
  
      DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",
       @fallbacks, @elements;
  
      my $canonical_form;
      foreach my $e (@elements) {
        if(exists $self->{'accept_codes'}{$e}) {
          DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";
          $canonical_form = $e;
          last; # first acceptable elementname wins!
        } else {
          DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n";
        }
      }
  
  
      if( defined $canonical_form ) {
        # We found a good N => elementname mapping
        $self->{'accept_codes'}{$new_letter} = $canonical_form;
        DEBUG > 2 and print
         "Extensor maps $new_letter => known element $canonical_form.\n";
      } else {
        # We have to use the fallback(s), which might be '0', or '1'.
        $self->{'accept_codes'}{$new_letter}
          = (@fallbacks == 1) ? $fallbacks[0] : \@fallbacks;
        DEBUG > 2 and print
         "Extensor maps $new_letter => fallbacks @fallbacks.\n";
      }
  
    } else {
      DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";
      $self->whine(
        $para->[1]{'start_line'},
        "Unknown =extend syntax: $content"
      )
    }
    return;
  }
  
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _treat_Zs {  # Nix Z<...>'s
    my($self,@stack) = @_;
  
    my($i, $treelet);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    while($treelet = shift @stack) {
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        unless($treelet->[$i][0] eq 'Z') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
          
        DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";
          
        # bitch UNLESS it's empty
        unless(  @{$treelet->[$i]} == 2
             or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
        ) {
          $self->whine( $start_line, "A non-empty Z<>" );
        }      # but kill it anyway
          
        splice(@$treelet, $i, 1); # thereby just nix this node.
        --$i;
          
      }
    }
    
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  # Quoting perlpodspec:
  
  # In parsing an L<...> code, Pod parsers must distinguish at least four
  # attributes:
  
  ############# Not used.  Expressed via the element children plus
  #############  the value of the "content-implicit" flag.
  # First:
  # The link-text. If there is none, this must be undef. (E.g., in "L<Perl
  # Functions|perlfunc>", the link-text is "Perl Functions". In
  # "L<Time::HiRes>" and even "L<|Time::HiRes>", there is no link text. Note
  # that link text may contain formatting.)
  # 
  
  ############# The element children
  # Second:
  # The possibly inferred link-text -- i.e., if there was no real link text,
  # then this is the text that we'll infer in its place. (E.g., for
  # "L<Getopt::Std>", the inferred link text is "Getopt::Std".)
  #
  
  ############# The "to" attribute (which might be text, or a treelet)
  # Third:
  # The name or URL, or undef if none. (E.g., in "L<Perl
  # Functions|perlfunc>", the name -- also sometimes called the page -- is
  # "perlfunc". In "L</CAVEATS>", the name is undef.)
  # 
  
  ############# The "section" attribute (which might be next, or a treelet)
  # Fourth:
  # The section (AKA "item" in older perlpods), or undef if none. E.g., in
  # Getopt::Std/DESCRIPTION, "DESCRIPTION" is the section. (Note that this
  # is not the same as a manpage section like the "5" in "man 5 crontab".
  # "Section Foo" in the Pod sense means the part of the text that's
  # introduced by the heading or item whose text is "Foo".)
  # 
  # Pod parsers may also note additional attributes including:
  #
  
  ############# The "type" attribute.
  # Fifth:
  # A flag for whether item 3 (if present) is a URL (like
  # "http://lists.perl.org" is), in which case there should be no section
  # attribute; a Pod name (like "perldoc" and "Getopt::Std" are); or
  # possibly a man page name (like "crontab(5)" is).
  #
  
  ############# The "raw" attribute that is already there.
  # Sixth:
  # The raw original L<...> content, before text is split on "|", "/", etc,
  # and before E<...> codes are expanded.
  
  
  # For L<...> codes without a "name|" part, only E<...> and Z<> codes may
  # occur -- no other formatting codes. That is, authors should not use
  # "L<B<Foo::Bar>>".
  #
  # Note, however, that formatting codes and Z<>'s can occur in any and all
  # parts of an L<...> (i.e., in name, section, text, and url).
  
  sub _treat_Ls {  # Process our dear dear friends, the L<...> sequences
  
    # L<name>
    # L<name/"sec"> or L<name/sec>
    # L</"sec"> or L</sec> or L<"sec">
    # L<text|name>
    # L<text|name/"sec"> or L<text|name/sec>
    # L<text|/"sec"> or L<text|/sec> or L<text|"sec">
    # L<scheme:...>
    # L<text|scheme:...>
  
    my($self,@stack) = @_;
  
    my($i, $treelet);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    while($treelet = shift @stack) {
      for(my $i = 2; $i < @$treelet; ++$i) {
        # iterate over children of current tree node
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        unless($treelet->[$i][0] eq 'L') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
        
        
        # By here, $treelet->[$i] is definitely an L node
        my $ell = $treelet->[$i];
        DEBUG > 1 and print STDERR "Ogling L node " . pretty($ell) . "\n";
          
        # bitch if it's empty or is just '/'
        if (@{$ell} == 3 and $ell->[2] =~ m!\A\s*/\s*\z!) {
          $self->whine( $start_line, "L<> contains only '/'" );
          $treelet->[$i] = 'L</>';  # just make it a text node
          next;  # and move on
        }
        if(  @{$ell} == 2
         or (@{$ell} == 3 and $ell->[2] eq '')
        ) {
          $self->whine( $start_line, "An empty L<>" );
          $treelet->[$i] = 'L<>';  # just make it a text node
          next;  # and move on
        }
  
        if( (! ref $ell->[2]  && $ell->[2] =~ /\A\s/)
          ||(! ref $ell->[-1] && $ell->[-1] =~ /\s\z/)
        ) {
          $self->whine( $start_line, "L<> starts or ends with whitespace" );
        }
       
        # Catch URLs:
  
        # there are a number of possible cases:
        # 1) text node containing url: http://foo.com
        #   -> [ 'http://foo.com' ]
        # 2) text node containing url and text: foo|http://foo.com
        #   -> [ 'foo|http://foo.com' ]
        # 3) text node containing url start: mailto:xE<at>foo.com
        #   -> [ 'mailto:x', [ E ... ], 'foo.com' ]
        # 4) text node containing url start and text: foo|mailto:xE<at>foo.com
        #   -> [ 'foo|mailto:x', [ E ... ], 'foo.com' ]
        # 5) other nodes containing text and url start: OE<39>Malley|http://foo.com
        #   -> [ 'O', [ E ... ], 'Malley', '|http://foo.com' ]
        # ... etc.
  
        # anything before the url is part of the text.
        # anything after it is part of the url.
        # the url text node itself may contain parts of both.
  
        if (my ($url_index, $text_part, $url_part) =
          # grep is no good here; we want to bail out immediately so that we can
          # use $1, $2, etc. without having to do the match twice.
          sub {
            for (2..$#$ell) {
              next if ref $ell->[$_];
              next unless $ell->[$_] =~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;
              return ($_, $1, $2);
            }
            return;
          }->()
        ) {
          $ell->[1]{'type'} = 'url';
  
          my @text = @{$ell}[2..$url_index-1];
          push @text, $text_part if defined $text_part;
  
          my @url  = @{$ell}[$url_index+1..$#$ell];
          unshift @url, $url_part;
  
          unless (@text) {
            $ell->[1]{'content-implicit'} = 'yes';
            @text = @url;
          }
  
          $ell->[1]{to} = Pod::Simple::LinkSection->new(
            @url == 1
            ? $url[0]
            : [ '', {}, @url ],
          );
  
          splice @$ell, 2, $#$ell, @text;
  
          next;
        }
        
        # Catch some very simple and/or common cases
        if(@{$ell} == 3 and ! ref $ell->[2]) {
          my $it = $ell->[2];
          if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s) { # man sections
            # Hopefully neither too broad nor too restrictive a RE
            DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";
            $ell->[1]{'type'} = 'man';
            # This's the only place where man links can get made.
            $ell->[1]{'content-implicit'} = 'yes';
            $ell->[1]{'to'  } =
              Pod::Simple::LinkSection->new( $it ); # treelet!
  
            next;
          }
          if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s) {
            # Extremely forgiving idea of what constitutes a bare
            #  modulename link like L<Foo::Bar> or even L<Thing::1.0::Docs::Tralala>
            DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";
            $ell->[1]{'type'} = 'pod';
            $ell->[1]{'content-implicit'} = 'yes';
            $ell->[1]{'to'  } =
              Pod::Simple::LinkSection->new( $it ); # treelet!
            next;
          }
          # else fall thru...
        }
        
        
  
        # ...Uhoh, here's the real L<...> parsing stuff...
        # "With the ill behavior, with the ill behavior, with the ill behavior..."
  
        DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";
        
        
        my $link_text; # set to an arrayref if found
        my @ell_content = @$ell;
        splice @ell_content,0,2; # Knock off the 'L' and {} bits
  
        DEBUG > 3 and print STDERR " Ell content to start: ",
         pretty(@ell_content), "\n";
  
  
        # Look for the "|" -- only in CHILDREN (not all underlings!)
        # Like L<I like the strictness|strict>
        DEBUG > 3 and
           print STDERR "  Peering at L content for a '|' ...\n";
        for(my $j = 0; $j < @ell_content; ++$j) {
          next if ref $ell_content[$j];
          DEBUG > 3 and
           print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";
  
          if($ell_content[$j] =~ m/^([^\|]*)\|(.*)$/s) {
            my @link_text = ($1);   # might be 0-length
            $ell_content[$j] = $2;  # might be 0-length
  
            DEBUG > 3 and
             print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";
  
            if ($link_text[0] =~ m{[|/]}) {
              $self->whine(
                $start_line,
                "alternative text '$link_text[0]' contains non-escaped | or /"
              );
            }
  
            unshift @link_text, splice @ell_content, 0, $j;
              # leaving only things at J and after
            @ell_content =  grep ref($_)||length($_), @ell_content ;
            $link_text   = [grep ref($_)||length($_), @link_text  ];
            DEBUG > 3 and printf
             "  So link text is %s\n  and remaining ell content is %s\n",
              pretty($link_text), pretty(@ell_content);
            last;
          }
        }
        
        
        # Now look for the "/" -- only in CHILDREN (not all underlings!)
        # And afterward, anything left in @ell_content will be the raw name
        # Like L<Foo::Bar/Object Methods>
        my $section_name;  # set to arrayref if found
        DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";
        for(my $j = 0; $j < @ell_content; ++$j) {
          next if ref $ell_content[$j];
          DEBUG > 3 and
           print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";
  
          if($ell_content[$j] =~ m/^([^\/]*)\/(.*)$/s) {
            my @section_name = ($2); # might be 0-length
            $ell_content[$j] =  $1;  # might be 0-length
  
            DEBUG > 3 and
             print STDERR "     FOUND a '/' in it.",
               "  Splitting to page [...$1] + section [$2...]\n";
  
            push @section_name, splice @ell_content, 1+$j;
              # leaving only things before and including J
            
            @ell_content  = grep ref($_)||length($_), @ell_content  ;
            @section_name = grep ref($_)||length($_), @section_name ;
  
            # Turn L<.../"foo"> into L<.../foo>
            if(@section_name
              and !ref($section_name[0]) and !ref($section_name[-1])
              and $section_name[ 0] =~ m/^\"/s
              and $section_name[-1] =~ m/\"$/s
              and !( # catch weird degenerate case of L<"> !
                @section_name == 1 and $section_name[0] eq '"'
              )
            ) {
              $section_name[ 0] =~ s/^\"//s;
              $section_name[-1] =~ s/\"$//s;
              DEBUG > 3 and
               print STDERR "     Quotes removed: ", pretty(@section_name), "\n";
            } else {
              DEBUG > 3 and
               print STDERR "     No need to remove quotes in ", pretty(@section_name), "\n";
            }
  
            $section_name = \@section_name;
            last;
          }
        }
  
        # Turn L<"Foo Bar"> into L</Foo Bar>
        if(!$section_name and @ell_content
           and !ref($ell_content[0]) and !ref($ell_content[-1])
           and $ell_content[ 0] =~ m/^\"/s
           and $ell_content[-1] =~ m/\"$/s
           and !( # catch weird degenerate case of L<"> !
             @ell_content == 1 and $ell_content[0] eq '"'
           )
        ) {
          $section_name = [splice @ell_content];
          $section_name->[ 0] =~ s/^\"//s;
          $section_name->[-1] =~ s/\"$//s;
          $ell->[1]{'~tolerated'} = 1;
        }
  
        # Turn L<Foo Bar> into L</Foo Bar>.
        if(!$section_name and !$link_text and @ell_content
           and grep !ref($_) && m/ /s, @ell_content
        ) {
          $section_name = [splice @ell_content];
          $ell->[1]{'~deprecated'} = 1;
          # That's support for the now-deprecated syntax.
          # Note that it deliberately won't work on L<...|Foo Bar>
        }
  
  
        # Now make up the link_text
        # L<Foo>     -> L<Foo|Foo>
        # L</Bar>    -> L<"Bar"|Bar>
        # L<Foo/Bar> -> L<"Bar" in Foo/Foo>
        unless($link_text) {
          $ell->[1]{'content-implicit'} = 'yes';
          $link_text = [];
          push @$link_text, '"', @$section_name, '"' if $section_name;
  
          if(@ell_content) {
            $link_text->[-1] .= ' in ' if $section_name;
            push @$link_text, @ell_content;
          }
        }
  
  
        # And the E resolver will have to deal with all our treeletty things:
  
        if(@ell_content == 1 and !ref($ell_content[0])
           and $ell_content[0] =~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s
        ) {
          $ell->[1]{'type'}    = 'man';
          DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n";
        } else {
          $ell->[1]{'type'}    = 'pod';
          DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n";
        }
  
        if( defined $section_name ) {
          $ell->[1]{'section'} = Pod::Simple::LinkSection->new(
            ['', {}, @$section_name]
          );
          DEBUG > 3 and print STDERR "L-section content: ", pretty($ell->[1]{'section'}), "\n";
        }
  
        if( @ell_content ) {
          $ell->[1]{'to'} = Pod::Simple::LinkSection->new(
            ['', {}, @ell_content]
          );
          DEBUG > 3 and print STDERR "L-to content: ", pretty($ell->[1]{'to'}), "\n";
        }
        
        # And update children to be the link-text:
        @$ell = (@$ell[0,1], defined($link_text) ? splice(@$link_text) : '');
        
        DEBUG > 2 and print STDERR "End of L-parsing for this node " . pretty($treelet->[$i]) . "\n";
  
        unshift @stack, $treelet->[$i]; # might as well recurse
      }
    }
  
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _treat_Es {
    my($self,@stack) = @_;
  
    my($i, $treelet, $content, $replacer, $charnum);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
  
    # Has frightening side effects on L nodes' attributes.
  
    #my @ells_to_tweak;
  
    while($treelet = shift @stack) {
      for(my $i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        if($treelet->[$i][0] eq 'L') {
          # SPECIAL STUFF for semi-processed L<>'s
          
          my $thing;
          foreach my $attrname ('section', 'to') {        
            if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
              unshift @stack, $thing;
              DEBUG > 2 and print STDERR "  Enqueuing ",
               pretty( $treelet->[$i][1]{$attrname} ),
               " as an attribute value to tweak.\n";
            }
          }
          
          unshift @stack, $treelet->[$i]; # recurse
          next;
        } elsif($treelet->[$i][0] ne 'E') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
        
        DEBUG > 1 and print STDERR "Ogling E node ", pretty($treelet->[$i]), "\n";
  
        # bitch if it's empty
        if(  @{$treelet->[$i]} == 2
         or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
        ) {
          $self->whine( $start_line, "An empty E<>" );
          $treelet->[$i] = 'E<>'; # splice in a literal
          next;
        }
          
        # bitch if content is weird
        unless(@{$treelet->[$i]} == 3 and !ref($content = $treelet->[$i][2])) {
          $self->whine( $start_line, "An E<...> surrounding strange content" );
          $replacer = $treelet->[$i]; # scratch
          splice(@$treelet, $i, 1,   # fake out a literal
            'E<',
            splice(@$replacer,2), # promote its content
            '>'
          );
          # Don't need to do --$i, as the 'E<' we just added isn't interesting.
          next;
        }
  
        DEBUG > 1 and print STDERR "Ogling E<$content>\n";
  
        # XXX E<>'s contents *should* be a valid char in the scope of the current
        # =encoding directive. Defaults to iso-8859-1, I believe. Fix this in the
        # future sometime.
  
        $charnum  = Pod::Escapes::e2charnum($content);
        DEBUG > 1 and print STDERR " Considering E<$content> with char ",
          defined($charnum) ? $charnum : "undef", ".\n";
  
        if(!defined( $charnum )) {
          DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";
          $self->whine( $start_line, "Unknown E content in E<$content>" );
          $replacer = "E<$content>"; # better than nothing
        } elsif($charnum >= 255 and !UNICODE) {
          $replacer = ASCII ? "\xA4" : "?";
          DEBUG > 1 and print STDERR "This Perl version can't handle ",
            "E<$content> (chr $charnum), so replacing with $replacer\n";
        } else {
          $replacer = Pod::Escapes::e2char($content);
          DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n";
        }
  
        splice(@$treelet, $i, 1, $replacer); # no need to back up $i, tho
      }
    }
  
    return;
  }
  
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _treat_Ss {
    my($self,$treelet) = @_;
    
    _change_S_to_nbsp($treelet,0) if $self->{'nbsp_for_S'};
  
    # TODO: or a change_nbsp_to_S
    #  Normalizing nbsp's to S is harder: for each text node, make S content
    #  out of anything matching m/([^ \xA0]*(?:\xA0+[^ \xA0]*)+)/
  
  
    return;
  }
  
  sub _change_S_to_nbsp { #  a recursive function
    # Sanely assumes that the top node in the excursion won't be an S node.
    my($treelet, $in_s) = @_;
    
    my $is_s = ('S' eq $treelet->[0]);
    $in_s ||= $is_s; # So in_s is on either by this being an S element,
                     #  or by an ancestor being an S element.
  
    for(my $i = 2; $i < @$treelet; ++$i) {
      if(ref $treelet->[$i]) {
        if( _change_S_to_nbsp( $treelet->[$i], $in_s ) ) {
          my $to_pull_up = $treelet->[$i];
          splice @$to_pull_up,0,2;   # ...leaving just its content
          splice @$treelet, $i, 1, @$to_pull_up;  # Pull up content
          $i +=  @$to_pull_up - 1;   # Make $i skip the pulled-up stuff
        }
      } else {
        $treelet->[$i] =~ s/\s/$Pod::Simple::nbsp/g if $in_s;
         
         # Note that if you apply nbsp_for_S to text, and so turn
         # "foo S<bar baz> quux" into "foo bar&#160;faz quux", you
         # end up with something that fails to say "and don't hyphenate
         # any part of 'bar baz'".  However, hyphenation is such a vexing
         # problem anyway, that most Pod renderers just don't render it
         # at all.  But if you do want to implement hyphenation, I guess
         # that you'd better have nbsp_for_S off.
      }
    }
  
    return $is_s;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _accessorize {  # A simple-minded method-maker
    no strict 'refs';
    foreach my $attrname (@_) {
      next if $attrname =~ m/::/; # a hack
      *{caller() . '::' . $attrname} = sub {
        use strict;
        $Carp::CarpLevel = 1,  Carp::croak(
         "Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
        ) unless (@_ == 1 or @_ == 2) and ref $_[0];
  
        (@_ == 1) ?  $_[0]->{$attrname}
                  : ($_[0]->{$attrname} = $_[1]);
      };
    }
    # Ya know, they say accessories make the ensemble!
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  #=============================================================================
  
  sub filter {
    my($class, $source) = @_;
    my $new = $class->new;
    $new->output_fh(*STDOUT{IO});
    
    if(ref($source || '') eq 'SCALAR') {
      $new->parse_string_document( $$source );
    } elsif(ref($source)) {  # it's a file handle
      $new->parse_file($source);
    } else {  # it's a filename
      $new->parse_file($source);
    }
    
    return $new;
  }
  
  
  #-----------------------------------------------------------------------------
  
  sub _out {
    # For use in testing: Class->_out($source)
    #  returns the transformation of $source
    
    my $class = shift(@_);
  
    my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
  
    DEBUG and print STDERR "\n\n", '#' x 76,
     "\nAbout to parse source: {{\n$_[0]\n}}\n\n";
    
    
    my $parser = ref $class && $class->isa(__PACKAGE__) ? $class : $class->new;
    $parser->hide_line_numbers(1);
  
    my $out = '';
    $parser->output_string( \$out );
    DEBUG and print STDERR " _out to ", \$out, "\n";
    
    $mutor->($parser) if $mutor;
  
    $parser->parse_string_document( $_[0] );
    # use Data::Dumper; print STDERR Dumper($parser), "\n";
    return $out;
  }
  
  
  sub _duo {
    # For use in testing: Class->_duo($source1, $source2)
    #  returns the parse trees of $source1 and $source2.
    # Good in things like: &ok( Class->duo(... , ...) );
    
    my $class = shift(@_);
    
    Carp::croak "But $class->_duo is useful only in list context!"
     unless wantarray;
  
    my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
  
    Carp::croak "But $class->_duo takes two parameters, not: @_"
     unless @_ == 2;
  
    my(@out);
    
    while( @_ ) {
      my $parser = $class->new;
  
      push @out, '';
      $parser->output_string( \( $out[-1] ) );
  
      DEBUG and print STDERR " _duo out to ", $parser->output_string(),
        " = $parser->{'output_string'}\n";
  
      $parser->hide_line_numbers(1);
      $mutor->($parser) if $mutor;
      $parser->parse_string_document( shift( @_ ) );
      # use Data::Dumper; print STDERR Dumper($parser), "\n";
    }
  
    return @out;
  }
  
  
  
  #-----------------------------------------------------------------------------
  1;
  __END__
  
  TODO:
  A start_formatting_code and end_formatting_code methods, which in the
  base class call start_L, end_L, start_C, end_C, etc., if they are
  defined.
  
  have the POD FORMATTING ERRORS section note the localtime, and the
  version of Pod::Simple.
  
  option to delete all E<shy>s?
  option to scream if under-0x20 literals are found in the input, or
  under-E<32> E codes are found in the tree. And ditto \x7f-\x9f
  
  Option to turn highbit characters into their compromised form? (applies
  to E parsing too)
  
  TODO: BOM/encoding things.
  
  TODO: ascii-compat things in the XML classes?
  
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;
  #
  # "What's in the box?"  "Pain."
  #
  ###########################################################################
  #
  # This is where all the scary things happen: parsing lines into
  #  paragraphs; and then into directives, verbatims, and then also
  #  turning formatting sequences into treelets.
  #
  # Are you really sure you want to read this code?
  #
  #-----------------------------------------------------------------------------
  #
  # The basic work of this module Pod::Simple::BlackBox is doing the dirty work
  # of parsing Pod into treelets (generally one per non-verbatim paragraph), and
  # to call the proper callbacks on the treelets.
  #
  # Every node in a treelet is a ['name', {attrhash}, ...children...]
  
  use integer; # vroom!
  use strict;
  use Carp ();
  use vars qw($VERSION );
  $VERSION = '3.43';
  #use constant DEBUG => 7;
  
  sub my_qr ($$) {
  
      # $1 is a pattern to compile and return.  Older perls compile any
      # syntactically valid property, even if it isn't legal.  To cope with
      # this, return an empty string unless the compiled pattern also
      # successfully matches $2, which the caller furnishes.
  
      my ($input_re, $should_match) = @_;
      # XXX could have a third parameter $shouldnt_match for extra safety
  
      my $use_utf8 = ($] le 5.006002) ? 'use utf8;' : "";
  
      my $re = eval "no warnings; $use_utf8 qr/$input_re/";
      #print STDERR  __LINE__, ": $input_re: $@\n" if $@;
      return "" if $@;
  
      my $matches = eval "no warnings; $use_utf8 '$should_match' =~ /$re/";
      #print STDERR  __LINE__, ": $input_re: $@\n" if $@;
      return "" if $@;
  
      #print STDERR  __LINE__, ": SUCCESS: $re\n" if $matches;
      return $re if $matches;
  
      #print STDERR  __LINE__, ": $re: didn't match\n";
      return "";
  }
  
  BEGIN {
    require Pod::Simple;
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG
  }
  
  # Matches a character iff the character will have a different meaning
  # if we choose CP1252 vs UTF-8 if there is no =encoding line.
  # This is broken for early Perls on non-ASCII platforms.
  my $non_ascii_re = my_qr('[[:^ascii:]]', "\xB6");
  $non_ascii_re = qr/[\x80-\xFF]/ unless $non_ascii_re;
  
  # Use patterns understandable by Perl 5.6, if possible
  my $cs_re = do { no warnings; my_qr('\p{IsCs}', "\x{D800}") };
  my $cn_re = my_qr('\p{IsCn}', "\x{09E4}");  # <reserved> code point unlikely
                                              # to get assigned
  my $rare_blocks_re = my_qr('[\p{InIPAExtensions}\p{InSpacingModifierLetters}]',
                             "\x{250}");
  $rare_blocks_re = my_qr('[\x{0250}-\x{02FF}]', "\x{250}") unless $rare_blocks_re;
  
  my $script_run_re = eval 'no warnings "experimental::script_run";
                            qr/(*script_run: ^ .* $ )/x';
  my $latin_re = my_qr('[\p{IsLatin}\p{IsInherited}\p{IsCommon}]', "\x{100}");
  unless ($latin_re) {
      # This was machine generated to be the ranges of the union of the above
      # three properties, with things that were undefined by Unicode 4.1 filling
      # gaps.  That is the version in use when Perl advanced enough to
      # successfully compile and execute the above pattern.
      $latin_re = my_qr('[\x00-\x{02E9}\x{02EC}-\x{0374}\x{037E}\x{0385}\x{0387}\x{0485}\x{0486}\x{0589}\x{060C}\x{061B}\x{061F}\x{0640}\x{064B}-\x{0655}\x{0670}\x{06DD}\x{0951}-\x{0954}\x{0964}\x{0965}\x{0E3F}\x{10FB}\x{16EB}-\x{16ED}\x{1735}\x{1736}\x{1802}\x{1803}\x{1805}\x{1D00}-\x{1D25}\x{1D2C}-\x{1D5C}\x{1D62}-\x{1D65}\x{1D6B}-\x{1D77}\x{1D79}-\x{1DBE}\x{1DC0}-\x{1EF9}\x{2000}-\x{2125}\x{2127}-\x{27FF}\x{2900}-\x{2B13}\x{2E00}-\x{2E1D}\x{2FF0}-\x{3004}\x{3006}\x{3008}-\x{3020}\x{302A}-\x{302D}\x{3030}-\x{3037}\x{303C}-\x{303F}\x{3099}-\x{309C}\x{30A0}\x{30FB}\x{30FC}\x{3190}-\x{319F}\x{31C0}-\x{31CF}\x{3220}-\x{325F}\x{327F}-\x{32CF}\x{3358}-\x{33FF}\x{4DC0}-\x{4DFF}\x{A700}-\x{A716}\x{FB00}-\x{FB06}\x{FD3E}\x{FD3F}\x{FE00}-\x{FE6B}\x{FEFF}-\x{FF65}\x{FF70}\x{FF9E}\x{FF9F}\x{FFE0}-\x{FFFD}\x{10100}-\x{1013F}\x{1D000}-\x{1D1DD}\x{1D300}-\x{1D7FF}]', "\x{100}");
  }
  
  my $every_char_is_latin_re = my_qr("^(?:$latin_re)*\\z", "A");
  
  # Latin script code points not in the first release of Unicode
  my $later_latin_re = my_qr('[^\P{IsLatin}\p{IsAge=1.1}]', "\x{1F6}");
  
  # If this perl doesn't have the Deprecated property, there's only one code
  # point in it that we need be concerned with.
  my $deprecated_re = my_qr('\p{IsDeprecated}', "\x{149}");
  $deprecated_re = qr/\x{149}/ unless $deprecated_re;
  
  my $utf8_bom;
  if (($] ge 5.007_003)) {
    $utf8_bom = "\x{FEFF}";
    utf8::encode($utf8_bom);
  } else {
    $utf8_bom = "\xEF\xBB\xBF";   # No EBCDIC BOM detection for early Perls.
  }
  
  # This is used so that the 'content_seen' method doesn't return true on a
  # file that just happens to have a line that matches /^=[a-zA-z]/.  Only if
  # there is a valid =foo line will we return that content was seen.
  my $seen_legal_directive = 0;
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_line { shift->parse_lines(@_) } # alias
  
  # - - -  Turn back now!  Run away!  - - -
  
  sub parse_lines {             # Usage: $parser->parse_lines(@lines)
    # an undef means end-of-stream
    my $self = shift;
  
    my $code_handler = $self->{'code_handler'};
    my $cut_handler  = $self->{'cut_handler'};
    my $wl_handler   = $self->{'whiteline_handler'};
    $self->{'line_count'} ||= 0;
  
    my $scratch;
  
    DEBUG > 4 and
     print STDERR "# Parsing starting at line ", $self->{'line_count'}, ".\n";
  
    DEBUG > 5 and
     print STDERR "#  About to parse lines: ",
       join(' ', map defined($_) ? "[$_]" : "EOF", @_), "\n";
  
    my $paras = ($self->{'paras'} ||= []);
     # paragraph buffer.  Because we need to defer processing of =over
     # directives and verbatim paragraphs.  We call _ponder_paragraph_buffer
     # to process this.
  
    $self->{'pod_para_count'} ||= 0;
  
    # An attempt to match the pod portions of a line.  This is not fool proof,
    # but is good enough to serve as part of the heuristic for guessing the pod
    # encoding if not specified.
    my $codes = join '', grep { / ^ [A-Za-z] $/x } sort keys %{$self->{accept_codes}};
    my $pod_chars_re = qr/ ^ = [A-Za-z]+ | [\Q$codes\E] < /x;
  
    my $line;
    foreach my $source_line (@_) {
      if( $self->{'source_dead'} ) {
        DEBUG > 4 and print STDERR "# Source is dead.\n";
        last;
      }
  
      unless( defined $source_line ) {
        DEBUG > 4 and print STDERR "# Undef-line seen.\n";
  
        push @$paras, ['~end', {'start_line' => $self->{'line_count'}}];
        push @$paras, $paras->[-1], $paras->[-1];
         # So that it definitely fills the buffer.
        $self->{'source_dead'} = 1;
        $self->_ponder_paragraph_buffer;
        next;
      }
  
  
      if( $self->{'line_count'}++ ) {
        ($line = $source_line) =~ tr/\n\r//d;
         # If we don't have two vars, we'll end up with that there
         # tr/// modding the (potentially read-only) original source line!
  
      } else {
        DEBUG > 2 and print STDERR "First line: [$source_line]\n";
  
        if( ($line = $source_line) =~ s/^$utf8_bom//s ) {
          DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";
          $self->_handle_encoding_line( "=encoding utf8" );
          delete $self->{'_processed_encoding'};
          $line =~ tr/\n\r//d;
  
        } elsif( $line =~ s/^\xFE\xFF//s ) {
          DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
  
        } elsif( $line =~ s/^\xFF\xFE//s ) {
          DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
  
        } else {
          DEBUG > 2 and print STDERR "First line is BOM-less.\n";
          ($line = $source_line) =~ tr/\n\r//d;
        }
      }
  
      if(!$self->{'parse_characters'} && !$self->{'encoding'}
        && ($self->{'in_pod'} || $line =~ /^=/s)
        && $line =~ /$non_ascii_re/
      ) {
  
        my $encoding;
  
        # No =encoding line, and we are at the first pod line in the input that
        # contains a non-ascii byte, that is, one whose meaning varies depending
        # on whether the file is encoded in UTF-8 or CP1252, which are the two
        # possibilities permitted by the pod spec.  (ASCII is assumed if the
        # file only contains ASCII bytes.)  In order to process this line, we
        # need to figure out what encoding we will use for the file.
        #
        # Strictly speaking ISO 8859-1 (Latin 1) refers to the code points
        # 160-255, but it is used here, as it often colloquially is, to refer to
        # the complete set of code points 0-255, including ASCII (0-127), the C1
        # controls (128-159), and strict Latin 1 (160-255).
        #
        # CP1252 is effectively a superset of Latin 1, because it differs only
        # from colloquial 8859-1 in the C1 controls, which are very unlikely to
        # actually be present in 8859-1 files, so can be used for other purposes
        # without conflict.  CP 1252 uses most of them for graphic characters.
        #
        # Note that all ASCII-range bytes represent their corresponding code
        # points in both CP1252 and UTF-8.  In ASCII platform UTF-8, all other
        # code points require multiple (non-ASCII) bytes to represent.  (A
        # separate paragraph for EBCDIC is below.)  The multi-byte
        # representation is quite structured.  If we find an isolated byte that
        # would require multiple bytes to represent in UTF-8, we know that the
        # encoding is not UTF-8.  If we find a sequence of bytes that violates
        # the UTF-8 structure, we also can presume the encoding isn't UTF-8, and
        # hence must be 1252.
        #
        # But there are ambiguous cases where we could guess wrong.  If so, the
        # user will end up having to supply an =encoding line.  We use all
        # readily available information to improve our chances of guessing
        # right.  The odds of something not being UTF-8, but still passing a
        # UTF-8 validity test go down very rapidly with increasing length of the
        # sequence.  Therefore we look at all non-ascii sequences on the line.
        # If any of the sequences can't be UTF-8, we quit there and choose
        # CP1252.  If all could be UTF-8, we see if any of the code points
        # represented are unlikely to be in pod.  If so, we guess CP1252.  If
        # not, we check if the line is all in the same script; if not guess
        # CP1252; otherwise UTF-8.  For perls that don't have convenient script
        # run testing, see if there is both Latin and non-Latin.  If so, CP1252,
        # otherwise UTF-8.
        #
        # On EBCDIC platforms, the situation is somewhat different.  In
        # UTF-EBCDIC, not only do ASCII-range bytes represent their code points,
        # but so do the bytes that are for the C1 controls.  Recall that these
        # correspond to the unused portion of 8859-1 that 1252 mostly takes
        # over.  That means that there are fewer code points that are
        # represented by multi-bytes.  But, note that the these controls are
        # very unlikely to be in pod text.  So if we encounter one of them, it
        # means that it is quite likely CP1252 and not UTF-8.  The net result is
        # the same code below is used for both platforms.
        #
        # XXX probably if the line has E<foo> that evaluates to illegal CP1252,
        # then it is UTF-8.  But we haven't processed E<> yet.
  
        goto set_1252 if $] lt 5.006_000;    # No UTF-8 on very early perls
  
        my $copy;
  
        no warnings 'utf8';
  
        if ($] ge 5.007_003) {
          $copy = $line;
  
          # On perls that have this function, we can use it to easily see if the
          # sequence is valid UTF-8 or not; if valid it turns on the UTF-8 flag
          # needed below for script run detection
          goto set_1252 if ! utf8::decode($copy);
        }
        elsif (ord("A") != 65) {  # Early EBCDIC, assume UTF-8.  What's a windows
                                  # code page doing here anyway?
          goto set_utf8;
        }
        else { # ASCII, no decode(): do it ourselves using the fundamental
               # characteristics of UTF-8
          use if $] le 5.006002, 'utf8';
  
          my $char_ord;
          my $needed;         # How many continuation bytes to gobble up
  
          # Initialize the translated line with a dummy character that will be
          # deleted after everything else is done.  This dummy makes sure that
          # $copy will be in UTF-8.  Doing it now avoids the bugs in early perls
          # with upgrading in the middle
          $copy = chr(0x100);
  
          # Parse through the line
          for (my $i = 0; $i < length $line; $i++) {
            my $byte = substr($line, $i, 1);
  
            # ASCII bytes are trivially dealt with
            if ($byte !~ $non_ascii_re) {
              $copy .= $byte;
              next;
            }
  
            my $b_ord = ord $byte;
  
            # Now figure out what this code point would be if the input is
            # actually in UTF-8.  If, in the process, we discover that it isn't
            # well-formed UTF-8, we guess CP1252.
            #
            # Start the process.  If it is UTF-8, we are at the first, start
            # byte, of a multi-byte sequence.  We look at this byte to figure
            # out how many continuation bytes are needed, and to initialize the
            # code point accumulator with the data from this byte.
            #
            # Normally the minimum continuation byte is 0x80, but in certain
            # instances the minimum is a higher number.  So the code below
            # overrides this for those instances.
            my $min_cont = 0x80;
  
            if ($b_ord < 0xC2) { #  A start byte < C2 is malformed
              goto set_1252;
            }
            elsif ($b_ord <= 0xDF) {
              $needed = 1;
              $char_ord = $b_ord & 0x1F;
            }
            elsif ($b_ord <= 0xEF) {
              $min_cont = 0xA0 if $b_ord == 0xE0;
              $needed = 2;
              $char_ord = $b_ord & (0x1F >> 1);
            }
            elsif ($b_ord <= 0xF4) {
              $min_cont = 0x90 if $b_ord == 0xF0;
              $needed = 3;
              $char_ord = $b_ord & (0x1F >> 2);
            }
            else { # F4 is the highest start byte for legal Unicode; higher is
                   # unlikely to be in pod.
              goto set_1252;
            }
  
            # ? not enough continuation bytes available
            goto set_1252 if $i + $needed >= length $line;
  
            # Accumulate the ordinal of the character from the remaining
            # (continuation) bytes.
            while ($needed-- > 0) {
              my $cont = substr($line, ++$i, 1);
              $b_ord = ord $cont;
              goto set_1252 if $b_ord < $min_cont || $b_ord > 0xBF;
  
              # In all cases, any next continuation bytes all have the same
              # minimum legal value
              $min_cont = 0x80;
  
              # Accumulate this byte's contribution to the code point
              $char_ord <<= 6;
              $char_ord |= ($b_ord & 0x3F);
            }
  
            # Here, the sequence that formed this code point was valid UTF-8,
            # so add the completed character to the output
            $copy .= chr $char_ord;
          } # End of loop through line
  
          # Delete the dummy first character
          $copy = substr($copy, 1);
        }
  
        # Here, $copy is legal UTF-8.
  
        # If it can't be legal CP1252, no need to look further.  (These bytes
        # aren't valid in CP1252.)  This test could have been placed higher in
        # the code, but it seemed wrong to set the encoding to UTF-8 without
        # making sure that the very first instance is well-formed.  But what if
        # it isn't legal CP1252 either?  We have to choose one or the other, and
        # It seems safer to favor the single-byte encoding over the multi-byte.
        goto set_utf8 if ord("A") == 65 && $line =~ /[\x81\x8D\x8F\x90\x9D]/;
  
        # The C1 controls are not likely to appear in pod
        goto set_1252 if ord("A") == 65 && $copy =~ /[\x80-\x9F]/;
  
        # Nor are surrogates nor unassigned, nor deprecated.
        DEBUG > 8 and print STDERR __LINE__, ": $copy: surrogate\n" if $copy =~ $cs_re;
        goto set_1252 if $cs_re && $copy =~ $cs_re;
        DEBUG > 8 and print STDERR __LINE__, ": $copy: unassigned\n" if $cn_re && $copy =~ $cn_re;
        goto set_1252 if $cn_re && $copy =~ $cn_re;
        DEBUG > 8 and print STDERR __LINE__, ": $copy: deprecated\n" if $copy =~ $deprecated_re;
        goto set_1252 if $copy =~ $deprecated_re;
  
        # Nor are rare code points.  But this is hard to determine.  khw
        # believes that IPA characters and the modifier letters are unlikely to
        # be in pod (and certainly very unlikely to be the in the first line in
        # the pod containing non-ASCII)
        DEBUG > 8 and print STDERR __LINE__, ": $copy: rare\n" if $copy =~ $rare_blocks_re;
        goto set_1252 if $rare_blocks_re && $copy =~ $rare_blocks_re;
  
        # The first Unicode version included essentially every Latin character
        # in modern usage.  So, a Latin character not in the first release will
        # unlikely be in pod.
        DEBUG > 8 and print STDERR __LINE__, ": $copy: later_latin\n" if $later_latin_re && $copy =~ $later_latin_re;
        goto set_1252 if $later_latin_re && $copy =~ $later_latin_re;
  
        # On perls that handle script runs, if the UTF-8 interpretation yields
        # a single script, we guess UTF-8, otherwise just having a mixture of
        # scripts is suspicious, so guess CP1252.  We first strip off, as best
        # we can, the ASCII characters that look like they are pod directives,
        # as these would always show as mixed with non-Latin text.
        $copy =~ s/$pod_chars_re//g;
  
        if ($script_run_re) {
          goto set_utf8 if $copy =~ $script_run_re;
          DEBUG > 8 and print STDERR __LINE__, ":  not script run\n";
          goto set_1252;
        }
  
        # Even without script runs, but on recent enough perls and Unicodes, we
        # can check if there is a mixture of both Latin and non-Latin.  Again,
        # having a mixture of scripts is suspicious, so assume CP1252
  
        # If it's all non-Latin, there is no CP1252, as that is Latin
        # characters and punct, etc.
        DEBUG > 8 and print STDERR __LINE__, ": $copy: not latin\n" if $copy !~ $latin_re;
        goto set_utf8 if $copy !~ $latin_re;
  
        DEBUG > 8 and print STDERR __LINE__, ": $copy: all latin\n" if $copy =~ $every_char_is_latin_re;
        goto set_utf8 if $copy =~ $every_char_is_latin_re;
  
        DEBUG > 8 and print STDERR __LINE__, ": $copy: mixed\n";
  
       set_1252:
        DEBUG > 9 and print STDERR __LINE__, ": $copy: is 1252\n";
        $encoding = 'CP1252';
        goto done_set;
  
       set_utf8:
        DEBUG > 9 and print STDERR __LINE__, ": $copy: is UTF-8\n";
        $encoding = 'UTF-8';
  
       done_set:
        $self->_handle_encoding_line( "=encoding $encoding" );
        delete $self->{'_processed_encoding'};
        $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
        my ($word) = $line =~ /(\S*$non_ascii_re\S*)/;
  
        $self->whine(
          $self->{'line_count'},
          "Non-ASCII character seen before =encoding in '$word'. Assuming $encoding"
        );
      }
  
      DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";
  
      if(!$self->{'in_pod'}) {
        if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s) {
          if($1 eq 'cut') {
            $self->scream(
              $self->{'line_count'},
              "=cut found outside a pod block.  Skipping to next block."
            );
  
            ## Before there were errata sections in the world, it was
            ## least-pessimal to abort processing the file.  But now we can
            ## just barrel on thru (but still not start a pod block).
            #splice @_;
            #push @_, undef;
  
            next;
          } else {
            $self->{'in_pod'} = $self->{'start_of_pod_block'}
                              = $self->{'last_was_blank'}     = 1;
            # And fall thru to the pod-mode block further down
          }
        } else {
          DEBUG > 5 and print STDERR "# It's a code-line.\n";
          $code_handler->(map $_, $line, $self->{'line_count'}, $self)
           if $code_handler;
          # Note: this may cause code to be processed out of order relative
          #  to pods, but in order relative to cuts.
  
          # Note also that we haven't yet applied the transcoding to $line
          #  by time we call $code_handler!
  
          if( $line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/ ) {
            # That RE is from perlsyn, section "Plain Old Comments (Not!)",
            #$fname = $2 if defined $2;
            #DEBUG > 1 and defined $2 and print STDERR "# Setting fname to \"$fname\"\n";
            DEBUG > 1 and print STDERR "# Setting nextline to $1\n";
            $self->{'line_count'} = $1 - 1;
          }
  
          next;
        }
      }
  
      # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
      # Else we're in pod mode:
  
      # Apply any necessary transcoding:
      $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
      # HERE WE CATCH =encoding EARLY!
      if( $line =~ m/^=encoding\s+\S+\s*$/s ) {
        next if $self->parse_characters;   # Ignore this line
        $line = $self->_handle_encoding_line( $line );
      }
  
      if($line =~ m/^=cut/s) {
        # here ends the pod block, and therefore the previous pod para
        DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";
        $self->{'in_pod'} = 0;
        # ++$self->{'pod_para_count'};
        $self->_ponder_paragraph_buffer();
         # by now it's safe to consider the previous paragraph as done.
        DEBUG > 6 and print STDERR "Processing any cut handler, line ${$self}{'line_count'}\n";
        $cut_handler->(map $_, $line, $self->{'line_count'}, $self)
         if $cut_handler;
  
        # TODO: add to docs: Note: this may cause cuts to be processed out
        #  of order relative to pods, but in order relative to code.
  
      } elsif($line =~ m/^(\s*)$/s) {  # it's a blank line
        if (defined $1 and $1 =~ /[^\S\r\n]/) { # it's a white line
          $wl_handler->(map $_, $line, $self->{'line_count'}, $self)
            if $wl_handler;
        }
  
        if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
          DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";
          push @{$paras->[-1]}, $line;
        }  # otherwise it's not interesting
  
        if(!$self->{'start_of_pod_block'} and !$self->{'last_was_blank'}) {
          DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n";
        }
  
        $self->{'last_was_blank'} = 1;
  
      } elsif($self->{'last_was_blank'}) {  # A non-blank line starting a new para...
  
        if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(\s+|$)(.*)/s) {
          # THIS IS THE ONE PLACE WHERE WE CONSTRUCT NEW DIRECTIVE OBJECTS
          my $new = [$1, {'start_line' => $self->{'line_count'}}, $3];
          $new->[1]{'~orig_spacer'} = $2 if $2 && $2 ne " ";
           # Note that in "=head1 foo", the WS is lost.
           # Example: ['=head1', {'start_line' => 123}, ' foo']
  
          ++$self->{'pod_para_count'};
  
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
  
          push @$paras, $new; # the new incipient paragraph
          DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n";
  
        } elsif($line =~ m/^\s/s) {
  
          if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
            DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";
            push @{$paras->[-1]}, $line;
          } else {
            ++$self->{'pod_para_count'};
            $self->_ponder_paragraph_buffer();
             # by now it's safe to consider the previous paragraph as done.
            DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";
            push @$paras, ['~Verbatim', {'start_line' => $self->{'line_count'}}, $line];
          }
        } else {
          ++$self->{'pod_para_count'};
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
          push @$paras, ['~Para',  {'start_line' => $self->{'line_count'}}, $line];
          DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
  
      } else {
        # It's a non-blank line /continuing/ the current para
        if(@$paras) {
          DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";
          push @{$paras->[-1]}, $line;
        } else {
          # Unexpected case!
          die "Continuing a paragraph but \@\$paras is empty?";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
      }
  
    } # ends the big while loop
  
    DEBUG > 1 and print STDERR (pretty(@$paras), "\n");
    return $self;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_encoding_line {
    my($self, $line) = @_;
  
    return if $self->parse_characters;
  
    # The point of this routine is to set $self->{'_transcoder'} as indicated.
  
    return $line unless $line =~ m/^=encoding\s+(\S+)\s*$/s;
    DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";
  
    my $e    = $1;
    my $orig = $e;
    push @{ $self->{'encoding_command_reqs'} }, "=encoding $orig";
  
    my $enc_error;
  
    # Cf.   perldoc Encode   and   perldoc Encode::Supported
  
    require Pod::Simple::Transcode;
  
    if( $self->{'encoding'} ) {
      my $norm_current = $self->{'encoding'};
      my $norm_e = $e;
      foreach my $that ($norm_current, $norm_e) {
        $that =  lc($that);
        $that =~ s/[-_]//g;
      }
      if($norm_current eq $norm_e) {
        DEBUG > 1 and print STDERR "The '=encoding $orig' line is ",
         "redundant.  ($norm_current eq $norm_e).  Ignoring.\n";
        $enc_error = '';
         # But that doesn't necessarily mean that the earlier one went okay
      } else {
        $enc_error = "Encoding is already set to " . $self->{'encoding'};
        DEBUG > 1 and print STDERR $enc_error;
      }
    } elsif (
      # OK, let's turn on the encoding
      do {
        DEBUG > 1 and print STDERR " Setting encoding to $e\n";
        $self->{'encoding'} = $e;
        1;
      }
      and $e eq 'HACKRAW'
    ) {
      DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n";
  
    } elsif( Pod::Simple::Transcode::->encoding_is_available($e) ) {
  
      die($enc_error = "WHAT? _transcoder is already set?!")
       if $self->{'_transcoder'};   # should never happen
      require Pod::Simple::Transcode;
      $self->{'_transcoder'} = Pod::Simple::Transcode::->make_transcoder($e);
      eval {
        my @x = ('', "abc", "123");
        $self->{'_transcoder'}->(@x);
      };
      $@ && die( $enc_error =
        "Really unexpected error setting up encoding $e: $@\nAborting"
      );
      $self->{'detected_encoding'} = $e;
  
    } else {
      my @supported = Pod::Simple::Transcode::->all_encodings;
  
      # Note unsupported, and complain
      DEBUG and print STDERR " Encoding [$e] is unsupported.",
        "\nSupporteds: @supported\n";
      my $suggestion = '';
  
      # Look for a near match:
      my $norm = lc($e);
      $norm =~ tr[-_][]d;
      my $n;
      foreach my $enc (@supported) {
        $n = lc($enc);
        $n =~ tr[-_][]d;
        next unless $n eq $norm;
        $suggestion = "  (Maybe \"$e\" should be \"$enc\"?)";
        last;
      }
      my $encmodver = Pod::Simple::Transcode::->encmodver;
      $enc_error = join '' =>
        "This document probably does not appear as it should, because its ",
        "\"=encoding $e\" line calls for an unsupported encoding.",
        $suggestion, "  [$encmodver\'s supported encodings are: @supported]"
      ;
  
      $self->scream( $self->{'line_count'}, $enc_error );
    }
    push @{ $self->{'encoding_command_statuses'} }, $enc_error;
    if (defined($self->{'_processed_encoding'})) {
      # Double declaration.
      $self->scream( $self->{'line_count'}, 'Cannot have multiple =encoding directives');
    }
    $self->{'_processed_encoding'} = $orig;
  
    return $line;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _handle_encoding_second_level {
    # By time this is called, the encoding (if well formed) will already
    #  have been acted on.
    my($self, $para) = @_;
    my @x = @$para;
    my $content = join ' ', splice @x, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";
  
    if (defined($self->{'_processed_encoding'})) {
      #if($content ne $self->{'_processed_encoding'}) {
      #  Could it happen?
      #}
      delete $self->{'_processed_encoding'};
      # It's already been handled.  Check for errors.
      if(! $self->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n";
      } elsif( $self->{'encoding_command_statuses'}[-1] ) {
        $self->whine( $para->[1]{'start_line'},
          sprintf "Couldn't do %s: %s",
            $self->{'encoding_command_reqs'  }[-1],
            $self->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n";
      }
  
    } else {
      # Otherwise it's a syntax error
      $self->whine( $para->[1]{'start_line'},
        "Invalid =encoding syntax: $content"
      );
    }
  
    return;
  }
  
  #~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`
  
  {
  my $m = -321;   # magic line number
  
  sub _gen_errata {
    my $self = $_[0];
    # Return 0 or more fake-o paragraphs explaining the accumulated
    #  errors on this document.
  
    return() unless $self->{'errata'} and keys %{$self->{'errata'}};
  
    my @out;
  
    foreach my $line (sort {$a <=> $b} keys %{$self->{'errata'}}) {
      push @out,
        ['=item', {'start_line' => $m}, "Around line $line:"],
        map( ['~Para', {'start_line' => $m, '~cooked' => 1},
          #['~Top', {'start_line' => $m},
          $_
          #]
          ],
          @{$self->{'errata'}{$line}}
        )
      ;
    }
  
    # TODO: report of unknown entities? unrenderable characters?
  
    unshift @out,
      ['=head1', {'start_line' => $m, 'errata' => 1}, 'POD ERRORS'],
      ['~Para', {'start_line' => $m, '~cooked' => 1, 'errata' => 1},
       "Hey! ",
       ['B', {},
        'The above document had some coding errors, which are explained below:'
       ]
      ],
      ['=over',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    push @out,
      ['=back',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    DEBUG and print STDERR "\n<<\n", pretty(\@out), "\n>>\n\n";
  
    return @out;
  }
  
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  ##############################################################################
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##                         HERE IT BECOMES REALLY SCARY
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##############################################################################
  
  sub _ponder_paragraph_buffer {
  
    # Para-token types as found in the buffer.
    #   ~Verbatim, ~Para, ~end, =head1..4, =for, =begin, =end,
    #   =over, =back, =item
    #   and the null =pod (to be complained about if over one line)
    #
    # "~data" paragraphs are something we generate at this level, depending on
    # a currently open =over region
  
    # Events fired:  Begin and end for:
    #                   directivename (like head1 .. head4), item, extend,
    #                   for (from =begin...=end, =for),
    #                   over-bullet, over-number, over-text, over-block,
    #                   item-bullet, item-number, item-text,
    #                   Document,
    #                   Data, Para, Verbatim
    #                   B, C, longdirname (TODO -- wha?), etc. for all directives
    #
  
    my $self = $_[0];
    my $paras;
    return unless @{$paras = $self->{'paras'}};
    my $curr_open = ($self->{'curr_open'} ||= []);
  
    my $scratch;
  
    DEBUG > 10 and print STDERR "# Paragraph buffer: <<", pretty($paras), ">>\n";
  
    # We have something in our buffer.  So apparently the document has started.
    unless($self->{'doc_has_started'}) {
      $self->{'doc_has_started'} = 1;
  
      my $starting_contentless;
      $starting_contentless =
       (
         !@$curr_open
         and @$paras and ! grep $_->[0] ne '~end', @$paras
          # i.e., if the paras is all ~ends
       )
      ;
      DEBUG and print STDERR "# Starting ",
        $starting_contentless ? 'contentless' : 'contentful',
        " document\n"
      ;
  
      $self->_handle_element_start(
        ($scratch = 'Document'),
        {
          'start_line' => $paras->[0][1]{'start_line'},
          $starting_contentless ? ( 'contentless' => 1 ) : (),
        },
      );
    }
  
    my($para, $para_type);
    while(@$paras) {
  
      # If a directive, assume it's legal; subtract below if found not to be
      $seen_legal_directive++ if $paras->[0][0] =~ /^=/;
  
      last if      @$paras == 1
              and (    $paras->[0][0] eq '=over'
                   or  $paras->[0][0] eq '=item'
                   or ($paras->[0][0] eq '~Verbatim' and $self->{'in_pod'}));
      # Those're the three kinds of paragraphs that require lookahead.
      #   Actually, an "=item Foo" inside an <over type=text> region
      #   and any =item inside an <over type=block> region (rare)
      #   don't require any lookahead, but all others (bullets
      #   and numbers) do.
      # The verbatim is different from the other two, because those might be
      # like:
      #
      #   =item
      #   ...
      #   =cut
      #   ...
      #   =item
      #
      # The =cut here finishes the paragraph but doesn't terminate the =over
      # they should be in. (khw apologizes that he didn't comment at the time
      # why the 'in_pod' works, and no longer remembers why, and doesn't think
      # it is currently worth the effort to re-figure it out.)
  
  # TODO: whinge about many kinds of directives in non-resolving =for regions?
  # TODO: many?  like what?  =head1 etc?
  
      $para = shift @$paras;
      $para_type = $para->[0];
  
      DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",
        $self->_dump_curr_open(), ")\n";
  
      if($para_type eq '=for') {
        next if $self->_ponder_for($para,$curr_open,$paras);
  
      } elsif($para_type eq '=begin') {
        next if $self->_ponder_begin($para,$curr_open,$paras);
  
      } elsif($para_type eq '=end') {
        next if $self->_ponder_end($para,$curr_open,$paras);
  
      } elsif($para_type eq '~end') { # The virtual end-document signal
        next if $self->_ponder_doc_end($para,$curr_open,$paras);
      }
  
  
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      if(grep $_->[1]{'~ignore'}, @$curr_open) {
        DEBUG > 1 and
         print STDERR "Skipping $para_type paragraph because in ignore mode.\n";
        next;
      }
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
      if($para_type eq '=pod') {
        $self->_ponder_pod($para,$curr_open,$paras);
  
      } elsif($para_type eq '=over') {
        next if $self->_ponder_over($para,$curr_open,$paras);
  
      } elsif($para_type eq '=back') {
        next if $self->_ponder_back($para,$curr_open,$paras);
  
      } else {
  
        # All non-magical codes!!!
  
        # Here we start using $para_type for our own twisted purposes, to
        #  mean how it should get treated, not as what the element name
        #  should be.
  
        DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";
  
        my $i;
  
        # Enforce some =headN discipline
        if($para_type =~ m/^=head\d$/s
           and ! $self->{'accept_heads_anywhere'}
           and @$curr_open
           and $curr_open->[-1][0] eq '=over'
        ) {
          DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";
          $self->whine(
            $para->[1]{'start_line'},
            "You forgot a '=back' before '$para_type'"
          );
          unshift @$paras, ['=back', {}, ''], $para;   # close the =over
          next;
        }
  
  
        if($para_type eq '=item') {
  
          my $over;
          unless(@$curr_open and
                 $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
            $self->whine(
              $para->[1]{'start_line'},
              "'=item' outside of any '=over'"
            );
            unshift @$paras,
              ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
              $para
            ;
            next;
          }
  
  
          my $over_type = $over->[1]{'~type'};
  
          if(!$over_type) {
            # Shouldn't happen1
            die "Typeless over in stack, starting at line "
             . $over->[1]{'start_line'};
  
          } elsif($over_type eq 'block') {
            unless($curr_open->[-1][1]{'~bitched_about'}) {
              $curr_open->[-1][1]{'~bitched_about'} = 1;
              $self->whine(
                $curr_open->[-1][1]{'start_line'},
                "You can't have =items (as at line "
                . $para->[1]{'start_line'}
                . ") unless the first thing after the =over is an =item"
              );
            }
            # Just turn it into a paragraph and reconsider it
            $para->[0] = '~Para';
            unshift @$paras, $para;
            next;
  
          } elsif($over_type eq 'text') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
            if($item_type eq 'text') {
              # Nothing special needs doing for 'text'
            } elsif($item_type eq 'number' or $item_type eq 'bullet') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected text after =item, not a $item_type"
              );
              # Undo our clobbering:
              push @$para, $para->[1]{'~orig_content'};
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
  
            # =item-text thingies don't need any assimilation, it seems.
  
          } elsif($over_type eq 'number') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
            my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
  
            if($item_type eq 'bullet') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              push @$para, $para->[1]{'~orig_content'};
                # restore the bullet, blocking the assimilation of next para
  
            } elsif($item_type eq 'text') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              # Text content will still be there and will block next ~Para
  
            } elsif($item_type ne 'number') {
              die "Unknown item type $item_type"; # should never happen
  
            } elsif($expected_value == $para->[1]{'number'}) {
              DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
  
            } else {
              DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
               " instead of the expected value of $expected_value\n";
              $self->whine(
                $para->[1]{'start_line'},
                "You have '=item " . $para->[1]{'number'} .
                "' instead of the expected '=item $expected_value'"
              );
              $para->[1]{'number'} = $expected_value;  # correcting!!
            }
  
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
  
          } elsif($over_type eq 'bullet') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
            if($item_type eq 'bullet') {
              # as expected!
  
              if( $para->[1]{'~_freaky_para_hack'} ) {
                DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
                push @$para, $para->[1]{'~_freaky_para_hack'};
              }
  
            } elsif($item_type eq 'number') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
              push @$para, $para->[1]{'~orig_content'};
               # and block assimilation of the next paragraph
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } elsif($item_type eq 'text') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
               # But doesn't need processing.  But it'll block assimilation
               #  of the next para.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
  
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
          } else {
            die "Unhandled =over type \"$over_type\"?";
            # Shouldn't happen!
          }
  
          $para_type = 'Plain';
          $para->[0] .= '-' . $over_type;
          # Whew.  Now fall thru and process it.
  
  
        } elsif($para_type eq '=extend') {
          # Well, might as well implement it here.
          $self->_ponder_extend($para);
          next;  # and skip
        } elsif($para_type eq '=encoding') {
          # Not actually acted on here, but we catch errors here.
          $self->_handle_encoding_second_level($para);
          next unless $self->keep_encoding_directive;
          $para_type = 'Plain';
        } elsif($para_type eq '~Verbatim') {
          $para->[0] = 'Verbatim';
          $para_type = '?Verbatim';
        } elsif($para_type eq '~Para') {
          $para->[0] = 'Para';
          $para_type = '?Plain';
        } elsif($para_type eq 'Data') {
          $para->[0] = 'Data';
          $para_type = '?Data';
        } elsif( $para_type =~ s/^=//s
          and defined( $para_type = $self->{'accept_directives'}{$para_type} )
        ) {
          DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n";
        } else {
          # An unknown directive!
          $seen_legal_directive--;
          DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",
           $para->[0], join(' ', sort keys %{$self->{'accept_directives'}} )
          ;
          $self->whine(
            $para->[1]{'start_line'},
            "Unknown directive: $para->[0]"
          );
  
          # And maybe treat it as text instead of just letting it go?
          next;
        }
  
        if($para_type =~ s/^\?//s) {
          if(! @$curr_open) {  # usual case
            DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n";
          } else {
            my @fors = grep $_->[0] eq '=for', @$curr_open;
            DEBUG > 1 and print STDERR "Containing fors: ",
              join(',', map $_->[1]{'target'}, @fors), "\n";
  
            if(! @fors) {
              DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n";
  
            #} elsif(grep $_->[1]{'~resolve'}, @fors) {
            #} elsif(not grep !$_->[1]{'~resolve'}, @fors) {
            } elsif( $fors[-1][1]{'~resolve'} ) {
              # Look to the immediately containing for
  
              if($para_type eq 'Data') {
                DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
                $para->[0] = 'Para';
                $para_type = 'Plain';
              } else {
                DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
              }
            } else {
              DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";
              $para->[0] = $para_type = 'Data';
            }
          }
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if($para_type eq 'Plain') {
          $self->_ponder_Plain($para);
        } elsif($para_type eq 'Verbatim') {
          $self->_ponder_Verbatim($para);
        } elsif($para_type eq 'Data') {
          $self->_ponder_Data($para);
        } else {
          die "\$para type is $para_type -- how did that happen?";
          # Shouldn't happen.
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        $para->[0] =~ s/^[~=]//s;
  
        DEBUG and print STDERR "\n", pretty($para), "\n";
  
        # traverse the treelet (which might well be just one string scalar)
        $self->{'content_seen'} ||= 1 if   $seen_legal_directive
                                      && ! $self->{'~tried_gen_errata'};
        $self->_traverse_treelet_bit(@$para);
      }
    }
  
    return;
  }
  
  ###########################################################################
  # The sub-ponderers...
  
  
  
  sub _ponder_for {
    my ($self,$para,$curr_open,$paras) = @_;
  
    # Fake it out as a begin/end
    my $target;
  
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";
      return 1;
    }
  
    for(my $i = 2; $i < @$para; ++$i) {
      if($para->[$i] =~ s/^\s*(\S+)\s*//s) {
        $target = $1;
        last;
      }
    }
    unless(defined $target) {
      $self->whine(
        $para->[1]{'start_line'},
        "=for without a target?"
      );
      return 1;
    }
    DEBUG > 1 and
     print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";
  
    $para->[0] = 'Data';
  
    unshift @$paras,
      ['=begin',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
      $para,
      ['=end',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
    ;
  
    return 1;
  }
  
  sub _ponder_begin {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "=begin without a target?"
      );
      DEBUG and print STDERR "Ignoring targetless =begin\n";
      return 1;
    }
  
    my ($target, $title) = $content =~ m/^(\S+)\s*(.*)$/;
    $para->[1]{'title'} = $title if ($title);
    $para->[1]{'target'} = $target;  # without any ':'
    $content = $target; # strip off the title
  
    $content =~ s/^:!/!:/s;
    my $neg;  # whether this is a negation-match
    $neg = 1        if $content =~ s/^!//s;
    my $to_resolve;  # whether to process formatting codes
    $to_resolve = 1 if $content =~ s/^://s;
  
    my $dont_ignore; # whether this target matches us
  
    foreach my $target_name (
      split(',', $content, -1),
      $neg ? () : '*'
    ) {
      DEBUG > 2 and
       print STDERR " Considering whether =begin $content matches $target_name\n";
      next unless $self->{'accept_targets'}{$target_name};
  
      DEBUG > 2 and
       print STDERR "  It DOES match the acceptable target $target_name!\n";
      $to_resolve = 1
        if $self->{'accept_targets'}{$target_name} eq 'force_resolve';
      $dont_ignore = 1;
      $para->[1]{'target_matching'} = $target_name;
      last; # stop looking at other target names
    }
  
    if($neg) {
      if( $dont_ignore ) {
        $dont_ignore = '';
        delete $para->[1]{'target_matching'};
        DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n";
      } else {
        $dont_ignore = 1;
        $para->[1]{'target_matching'} = '!';
        DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n";
      }
    }
  
    $para->[0] = '=for';  # Just what we happen to call these, internally
    $para->[1]{'~really'} ||= '=begin';
    $para->[1]{'~ignore'}   = (! $dont_ignore) || 0;
    $para->[1]{'~resolve'}  = $to_resolve || 0;
  
    DEBUG > 1 and print STDERR " Making note to ", $dont_ignore ? 'not ' : '',
      "ignore contents of this region\n";
    DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",
      ($to_resolve ? 'verbatim/plain' : 'data'), " paragraphs\n";
    DEBUG > 1 and print STDERR " (Stack now: ", $self->_dump_curr_open(), ")\n";
  
    push @$curr_open, $para;
    if(!$dont_ignore or scalar grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n";
    } else {
      $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
      $self->_handle_element_start((my $scratch='for'), $para->[1]);
    }
  
    return 1;
  }
  
  sub _ponder_end {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    DEBUG and print STDERR "Ogling '=end $content' directive\n";
  
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=end' without a target?" . (
          ( @$curr_open and $curr_open->[-1][0] eq '=for' )
          ? ( " (Should be \"=end " . $curr_open->[-1][1]{'target'} . '")' )
          : ''
        )
      );
      DEBUG and print STDERR "Ignoring targetless =end\n";
      return 1;
    }
  
    unless($content =~ m/^\S+$/) {  # i.e., unless it's one word
      $self->whine(
        $para->[1]{'start_line'},
        "'=end $content' is invalid.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
  
    unless(@$curr_open and $curr_open->[-1][0] eq '=for') {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content without matching =begin.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
  
    unless($content eq $curr_open->[-1][1]{'target'}) {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content doesn't match =begin "
        . $curr_open->[-1][1]{'target'}
        . ".  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";
      return 1;
    }
  
    # Else it's okay to close...
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n";
      # And that may be because of this to-be-closed =for region, or some
      #  other one, but it doesn't matter.
    } else {
      $curr_open->[-1][1]{'start_line'} = $para->[1]{'start_line'};
        # what's that for?
  
      $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
      $self->_handle_element_end( my $scratch = 'for', $para->[1]);
    }
    DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";
    pop @$curr_open;
  
    return 1;
  }
  
  sub _ponder_doc_end {
    my ($self,$para,$curr_open,$paras) = @_;
    if(@$curr_open) { # Deal with things left open
      DEBUG and print STDERR "Stack is nonempty at end-document: (",
        $self->_dump_curr_open(), ")\n";
  
      DEBUG > 9 and print STDERR "Stack: ", pretty($curr_open), "\n";
      unshift @$paras, $self->_closers_for_all_curr_open;
      # Make sure there is exactly one ~end in the parastack, at the end:
      @$paras = grep $_->[0] ne '~end', @$paras;
      push @$paras, $para, $para;
       # We need two -- once for the next cycle where we
       #  generate errata, and then another to be at the end
       #  when that loop back around to process the errata.
      return 1;
  
    } else {
      DEBUG and print STDERR "Okay, stack is empty now.\n";
    }
  
    # Try generating errata section, if applicable
    unless($self->{'~tried_gen_errata'}) {
      $self->{'~tried_gen_errata'} = 1;
      my @extras = $self->_gen_errata();
      if(@extras) {
        unshift @$paras, @extras;
        DEBUG and print STDERR "Generated errata... relooping...\n";
        return 1;  # I.e., loop around again to process these fake-o paragraphs
      }
    }
  
    splice @$paras; # Well, that's that for this paragraph buffer.
    DEBUG and print STDERR "Throwing end-document event.\n";
  
    $self->_handle_element_end( my $scratch = 'Document' );
    return 1; # Hasta la byebye
  }
  
  sub _ponder_pod {
    my ($self,$para,$curr_open,$paras) = @_;
    $self->whine(
      $para->[1]{'start_line'},
      "=pod directives shouldn't be over one line long!  Ignoring all "
       . (@$para - 2) . " lines of content"
    ) if @$para > 3;
  
    # Content ignored unless 'pod_handler' is set
    if (my $pod_handler = $self->{'pod_handler'}) {
        my ($line_num, $line) = map $_, $para->[1]{'start_line'}, $para->[2];
        $line = $line eq '' ? "=pod" : "=pod $line"; # imitate cut_handler output
        $pod_handler->($line, $line_num, $self);
    }
  
    # The surrounding methods set content_seen, so let us remain consistent.
    # I do not know why it was not here before -- should it not be here?
    # $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
  
    return;
  }
  
  sub _ponder_over {
    my ($self,$para,$curr_open,$paras) = @_;
    return 1 unless @$paras;
    my $list_type;
  
    if($paras->[0][0] eq '=item') { # most common case
      $list_type = $self->_get_initial_item_type($paras->[0]);
  
    } elsif($paras->[0][0] eq '=back') {
      # Ignore empty lists by default
      if ($self->{'parse_empty_lists'}) {
        $list_type = 'empty';
      } else {
        shift @$paras;
        return 1;
      }
    } elsif($paras->[0][0] eq '~end') {
      $self->whine(
        $para->[1]{'start_line'},
        "=over is the last thing in the document?!"
      );
      return 1; # But feh, ignore it.
    } else {
      $list_type = 'block';
    }
    $para->[1]{'~type'} = $list_type;
    push @$curr_open, $para;
     # yes, we reuse the paragraph as a stack item
  
    my $content = join ' ', splice @$para, 2;
    $para->[1]{'~orig_content'} = $content;
    my $overness;
    if($content =~ m/^\s*$/s) {
      $para->[1]{'indent'} = 4;
    } elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s) {
      no integer;
      $para->[1]{'indent'} = $1;
      if($1 == 0) {
        $self->whine(
          $para->[1]{'start_line'},
          "Can't have a 0 in =over $content"
        );
        $para->[1]{'indent'} = 4;
      }
    } else {
      $self->whine(
        $para->[1]{'start_line'},
        "=over should be: '=over' or '=over positive_number'"
      );
      $para->[1]{'indent'} = 4;
    }
    DEBUG > 1 and print STDERR "=over found of type $list_type\n";
  
    $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
    $self->_handle_element_start((my $scratch = 'over-' . $list_type), $para->[1]);
  
    return;
  }
  
  sub _ponder_back {
    my ($self,$para,$curr_open,$paras) = @_;
    # TODO: fire off </item-number> or </item-bullet> or </item-text> ??
  
    my $content = join ' ', splice @$para, 2;
    if($content =~ m/\S/) {
      $self->whine(
        $para->[1]{'start_line'},
        "=back doesn't take any parameters, but you said =back $content"
      );
    }
  
    if(@$curr_open and $curr_open->[-1][0] eq '=over') {
      DEBUG > 1 and print STDERR "=back happily closes matching =over\n";
      # Expected case: we're closing the most recently opened thing
      #my $over = pop @$curr_open;
      $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
      $self->_handle_element_end( my $scratch =
        'over-' . ( (pop @$curr_open)->[1]{'~type'} ), $para->[1]
      );
    } else {
      DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",
          join(', ', map $_->[0], @$curr_open), ").\n";
      $self->whine(
        $para->[1]{'start_line'},
        '=back without =over'
      );
      return 1; # and ignore it
    }
  }
  
  sub _ponder_item {
    my ($self,$para,$curr_open,$paras) = @_;
    my $over;
    unless(@$curr_open and
           $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=item' outside of any '=over'"
      );
      unshift @$paras,
        ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
        $para
      ;
      return 1;
    }
  
  
    my $over_type = $over->[1]{'~type'};
  
    if(!$over_type) {
      # Shouldn't happen1
      die "Typeless over in stack, starting at line "
       . $over->[1]{'start_line'};
  
    } elsif($over_type eq 'block') {
      unless($curr_open->[-1][1]{'~bitched_about'}) {
        $curr_open->[-1][1]{'~bitched_about'} = 1;
        $self->whine(
          $curr_open->[-1][1]{'start_line'},
          "You can't have =items (as at line "
          . $para->[1]{'start_line'}
          . ") unless the first thing after the =over is an =item"
        );
      }
      # Just turn it into a paragraph and reconsider it
      $para->[0] = '~Para';
      unshift @$paras, $para;
      return 1;
  
    } elsif($over_type eq 'text') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
      if($item_type eq 'text') {
        # Nothing special needs doing for 'text'
      } elsif($item_type eq 'number' or $item_type eq 'bullet') {
        $self->whine(
            $para->[1]{'start_line'},
            "Expected text after =item, not a $item_type"
        );
        # Undo our clobbering:
        push @$para, $para->[1]{'~orig_content'};
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
  
      # =item-text thingies don't need any assimilation, it seems.
  
    } elsif($over_type eq 'number') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
      my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
  
      if($item_type eq 'bullet') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        push @$para, $para->[1]{'~orig_content'};
          # restore the bullet, blocking the assimilation of next para
  
      } elsif($item_type eq 'text') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        # Text content will still be there and will block next ~Para
  
      } elsif($item_type ne 'number') {
        die "Unknown item type $item_type"; # should never happen
  
      } elsif($expected_value == $para->[1]{'number'}) {
        DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
  
      } else {
        DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
         " instead of the expected value of $expected_value\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You have '=item " . $para->[1]{'number'} .
          "' instead of the expected '=item $expected_value'"
        );
        $para->[1]{'number'} = $expected_value;  # correcting!!
      }
  
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
  
    } elsif($over_type eq 'bullet') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
      if($item_type eq 'bullet') {
        # as expected!
  
        if( $para->[1]{'~_freaky_para_hack'} ) {
          DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
          push @$para, $para->[1]{'~_freaky_para_hack'};
        }
  
      } elsif($item_type eq 'number') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
        push @$para, $para->[1]{'~orig_content'};
         # and block assimilation of the next paragraph
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } elsif($item_type eq 'text') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
         # But doesn't need processing.  But it'll block assimilation
         #  of the next para.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
  
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
    } else {
      die "Unhandled =over type \"$over_type\"?";
      # Shouldn't happen!
    }
    $para->[0] .= '-' . $over_type;
  
    return;
  }
  
  sub _ponder_Plain {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving plain treatment...\n";
    unless( @$para == 2 or ( @$para == 3 and $para->[2] eq '' )
      or $para->[1]{'~cooked'}
    ) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}
      )};
    }
    # Empty paragraphs don't need a treelet for any reason I can see.
    # And precooked paragraphs already have a treelet.
    return;
  }
  
  sub _ponder_Verbatim {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving verbatim treatment...\n";
  
    $para->[1]{'xml:space'} = 'preserve';
  
    unless ($self->{'_output_is_for_JustPod'}) {
      # Fix illegal settings for expand_verbatim_tabs()
      # This is because this module doesn't do input error checking, but khw
      # doesn't want to add yet another instance of that.
      $self->expand_verbatim_tabs(8)
                              if ! defined $self->expand_verbatim_tabs()
                              ||   $self->expand_verbatim_tabs() =~ /\D/;
  
      my $indent = $self->strip_verbatim_indent;
      if ($indent && ref $indent eq 'CODE') {
          my @shifted = (shift @{$para}, shift @{$para});
          $indent = $indent->($para);
          unshift @{$para}, @shifted;
      }
  
      for(my $i = 2; $i < @$para; $i++) {
        foreach my $line ($para->[$i]) { # just for aliasing
          # Strip indentation.
          $line =~ s/^\Q$indent// if $indent;
          next unless $self->expand_verbatim_tabs;
  
              # This is commented out because of github issue #85, and the
              # current maintainers don't know why it was there in the first
              # place.
              #&& !($self->{accept_codes} && $self->{accept_codes}{VerbatimFormatted});
          while( $line =~
            # Sort of adapted from Text::Tabs.
            s/^([^\t]*)(\t+)/$1.(" " x ((length($2)
                                         * $self->expand_verbatim_tabs)
                                         -(length($1)&7)))/e
          ) {}
  
          # TODO: whinge about (or otherwise treat) unindented or overlong lines
  
        }
      }
    }
  
    # Now the VerbatimFormatted hoodoo...
    if( $self->{'accept_codes'} and
        $self->{'accept_codes'}{'VerbatimFormatted'}
    ) {
      while(@$para > 3 and $para->[-1] !~ m/\S/) { pop @$para }
       # Kill any number of terminal newlines
      $self->_verbatim_format($para);
    } elsif ($self->{'codes_in_verbatim'}) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}, $para->[1]{'xml:space'}
      )};
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    } else {
      push @$para, join "\n", splice(@$para, 2) if @$para > 3;
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    }
    return;
  }
  
  sub _ponder_Data {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving data treatment...\n";
    $para->[1]{'xml:space'} = 'preserve';
    push @$para, join "\n", splice(@$para, 2) if @$para > 3;
    return;
  }
  
  
  
  
  ###########################################################################
  
  sub _traverse_treelet_bit {  # for use only by the routine above
    my($self, $name) = splice @_,0,2;
  
    my $scratch;
    $self->_handle_element_start(($scratch=$name), shift @_);
  
    while (@_) {
      my $x = shift;
      if (ref($x)) {
        &_traverse_treelet_bit($self, @$x);
      } else {
        $x .= shift while @_ && !ref($_[0]);
        $self->_handle_text($x);
      }
    }
  
    $self->_handle_element_end($scratch=$name);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _closers_for_all_curr_open {
    my $self = $_[0];
    my @closers;
    foreach my $still_open (@{  $self->{'curr_open'} || return  }) {
      my @copy = @$still_open;
      $copy[1] = {%{ $copy[1] }};
      #$copy[1]{'start_line'} = -1;
      if($copy[0] eq '=for') {
        $copy[0] = '=end';
      } elsif($copy[0] eq '=over') {
        $self->whine(
          $still_open->[1]{start_line} ,
          "=over without closing =back"
        );
  
        $copy[0] = '=back';
      } else {
        die "I don't know how to auto-close an open $copy[0] region";
      }
  
      unless( @copy > 2 ) {
        push @copy, $copy[1]{'target'};
        $copy[-1] = '' unless defined $copy[-1];
         # since =over's don't have targets
      }
  
      $copy[1]{'fake-closer'} = 1;
  
      DEBUG and print STDERR "Queuing up fake-o event: ", pretty(\@copy), "\n";
      unshift @closers, \@copy;
    }
    return @closers;
  }
  
  #--------------------------------------------------------------------------
  
  sub _verbatim_format {
    my($it, $p) = @_;
  
    my $formatting;
  
    for(my $i = 2; $i < @$p; $i++) { # work backwards over the lines
      DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";
      $p->[$i] .= "\n";
       # Unlike with simple Verbatim blocks, we don't end up just doing
       # a join("\n", ...) on the contents, so we have to append a
       # newline to every line, and then nix the last one later.
    }
  
    if( DEBUG > 4 ) {
      print STDERR "<<\n";
      for(my $i = $#$p; $i >= 2; $i--) { # work backwards over the lines
        print STDERR "_verbatim_format $i: $p->[$i]";
      }
      print STDERR ">>\n";
    }
  
    for(my $i = $#$p; $i > 2; $i--) {
      # work backwards over the lines, except the first (#2)
  
      #next unless $p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s
      #        and $p->[$i-1] !~ m{^#:[ \^\/\%]*\n?$}s;
       # look at a formatty line preceding a nonformatty one
      DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";
      if($p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s) {
        DEBUG > 5 and print STDERR "  It's a formatty line.  ",
         "Peeking at previous line ", $i-1, ": $$p[$i-1]: \n";
  
        if( $p->[$i-1] =~ m{^#:[ \^\/\%]*\n?$}s ) {
          DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";
          next;
        } else {
          DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n";
        }
      } else {
        DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";
        next;
      }
  
      # A formatty line has to have #: in the first two columns, and uses
      # "^" to mean bold, "/" to mean underline, and "%" to mean bold italic.
      # Example:
      #   What do you want?  i like pie. [or whatever]
      # #:^^^^^^^^^^^^^^^^^              /////////////
  
  
      DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";
  
      $formatting = '  ' . $1;
      $formatting =~ s/\s+$//s; # nix trailing whitespace
      unless(length $formatting and $p->[$i-1] =~ m/\S/) { # no-op
        splice @$p,$i,1; # remove this line
        $i--; # don't consider next line
        next;
      }
  
      if( length($formatting) >= length($p->[$i-1]) ) {
        $formatting = substr($formatting, 0, length($p->[$i-1]) - 1) . ' ';
      } else {
        $formatting .= ' ' x (length($p->[$i-1]) - length($formatting));
      }
      # Make $formatting and the previous line be exactly the same length,
      # with $formatting having a " " as the last character.
  
      DEBUG > 4 and print STDERR "Formatting <$formatting>    on <", $p->[$i-1], ">\n";
  
  
      my @new_line;
      while( $formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g ) {
        #print STDERR "Format matches $1\n";
  
        if($2) {
          #print STDERR "SKIPPING <$2>\n";
          push @new_line,
            substr($p->[$i-1], pos($formatting)-length($1), length($1));
        } else {
          #print STDERR "SNARING $+\n";
          push @new_line, [
            (
              $3 ? 'VerbatimB'  :
              $4 ? 'VerbatimI'  :
              $5 ? 'VerbatimBI' : die("Should never get called")
            ), {},
            substr($p->[$i-1], pos($formatting)-length($1), length($1))
          ];
          #print STDERR "Formatting <$new_line[-1][-1]> as $new_line[-1][0]\n";
        }
      }
      my @nixed =
        splice @$p, $i-1, 2, @new_line; # replace myself and the next line
      DEBUG > 10 and print STDERR "Nixed count: ", scalar(@nixed), "\n";
  
      DEBUG > 6 and print STDERR "New version of the above line is these tokens (",
        scalar(@new_line), "):",
        map( ref($_)?"<@$_> ":"<$_>", @new_line ), "\n";
      $i--; # So the next line we scrutinize is the line before the one
            #  that we just went and formatted
    }
  
    $p->[0] = 'VerbatimFormatted';
  
    # Collapse adjacent text nodes, just for kicks.
    for( my $i = 2; $i > $#$p; $i++ ) { # work forwards over the tokens except for the last
      if( !ref($p->[$i]) and !ref($p->[$i + 1]) ) {
        DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";
        $p->[$i] .= splice @$p, $i+1, 1; # merge
        --$i;  # and back up
      }
    }
  
    # Now look for the last text token, and remove the terminal newline
    for( my $i = $#$p; $i >= 2; $i-- ) {
      # work backwards over the tokens, even the first
      if( !ref($p->[$i]) ) {
        if($p->[$i] =~ s/\n$//s) {
          DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n";
        } else {
          DEBUG > 5 and print STDERR
           "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n";
        }
        last; # we only want the next one
      }
    }
  
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  
  sub _treelet_from_formatting_codes {
    # Given a paragraph, returns a treelet.  Full of scary tokenizing code.
    #  Like [ '~Top', {'start_line' => $start_line},
    #            "I like ",
    #            [ 'B', {}, "pie" ],
    #            "!"
    #       ]
    # This illustrates the general format of a treelet.  It is an array:
    #     [0]       is a scalar indicating its type.  In the example above, the
    #               types are '~Top' and 'B'
    #     [1]       is a hash of various flags about it, possibly empty
    #     [2] - [N] are an ordered list of the subcomponents of the treelet.
    #               Scalars are literal text, refs are sub-treelets, to
    #               arbitrary levels.  Stringifying a treelet will recursively
    #               stringify the sub-treelets, concatentating everything
    #               together to form the exact text of the treelet.
  
    my($self, $para, $start_line, $preserve_space) = @_;
  
    my $treelet = ['~Top', {'start_line' => $start_line},];
  
    unless ($preserve_space || $self->{'preserve_whitespace'}) {
      $para =~ s/\s+/ /g; # collapse and trim all whitespace first.
      $para =~ s/ $//;
      $para =~ s/^ //;
    }
  
    # Only apparent problem the above code is that N<<  >> turns into
    # N<< >>.  But then, word wrapping does that too!  So don't do that!
  
  
    # As a Start-code is encountered, the number of opening bracket '<'
    # characters minus 1 is pushed onto @stack (so 0 means a single bracket,
    # etc).  When closing brackets are found in the text, at least this number
    # (plus the 1) will be required to mean the Start-code is terminated.  When
    # those are found, @stack is popped.
    my @stack;
  
    my @lineage = ($treelet);
    my $raw = ''; # raw content of L<> fcode before splitting/processing
      # XXX 'raw' is not 100% accurate: all surrounding whitespace is condensed
      # into just 1 ' '. Is this the regex's doing or 'raw's?  Answer is it's
      # the 'collapse and trim all whitespace first' lines just above.
    my $inL = 0;
  
    DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";
  
    # Here begins our frightening tokenizer RE.  The following regex matches
    # text in four main parts:
    #
    #  * Start-codes.  The first alternative matches C< or C<<, the latter
    #    followed by some whitespace.  $1 will hold the entire start code
    #    (including any space following a multiple-angle-bracket delimiter),
    #    and $2 will hold only the additional brackets past the first in a
    #    multiple-bracket delimiter.  length($2) + 1 will be the number of
    #    closing brackets we have to find.
    #
    #  * Closing brackets.  Match some amount of whitespace followed by
    #    multiple close brackets.  The logic to see if this closes anything
    #    is down below.  Note that in order to parse C<<  >> correctly, we
    #    have to use look-behind (?<=\s\s), since the match of the starting
    #    code will have consumed the whitespace.
    #
    #  * A single closing bracket, to close a simple code like C<>.
    #
    #  * Something that isn't a start or end code.  We have to be careful
    #    about accepting whitespace, since perlpodspec says that any whitespace
    #    before a multiple-bracket closing delimiter should be ignored.
    #
    while($para =~
      m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.  ($3 can be empty if the
          # construct is empty, like C<<  >>, and all the white-space has been
          # gobbled up already, considered to be space after the opening
          # bracket.  In this case we use look-behind to verify that there are
          # at least 2 spaces in a row before the ">".)
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo
    ) {
      DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";
      if(defined $1) {
        my $bracket_count;    # How many '<<<' in a row this has.  Needed for
                              # Pod::Simple::JustPod
        if(defined $2) {
          DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";
          $bracket_count = length($2) + 1;
          push @stack, $bracket_count; # length of the necessary complex
                                       # end-code string
        } else {
          DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";
          push @stack, 0;  # signal that we're looking for simple
          $bracket_count = 1;
        }
        my $code = substr($1,0,1);
        if ('L' eq $code) {
          if ($inL) {
              $raw .= $1;
              $self->scream( $start_line,
                             'Nested L<> are illegal.  Pretending inner one is '
                           . 'X<...> so can continue looking for other errors.');
              $code = "X";
          }
          else {
              $raw = ""; # reset raw content accumulator
              $inL = @stack;
          }
        } else {
          $raw .= $1 if $inL;
        }
        push @lineage, [ $code, {}, ];  # new node object
  
        # Tell Pod::Simple::JustPod how many brackets there were, but to save
        # space, not in the most usual case of there was just 1.  It can be
        # inferred by the absence of this element.  Similarly, if there is more
        # than one bracket, extract the white space between the final bracket
        # and the real beginning of the interior.  Save that if it isn't just a
        # single space
        if ($self->{'_output_is_for_JustPod'} && $bracket_count > 1) {
          $lineage[-1][1]{'~bracket_count'} = $bracket_count;
          my $lspacer = substr($1, 1 + $bracket_count);
          $lineage[-1][1]{'~lspacer'} = $lspacer if $lspacer ne " ";
        }
        push @{ $lineage[-2] }, $lineage[-1];
      } elsif(defined $4) {
        DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";
        # This is where it gets messy...
        if(! @stack) {
          # We saw " >>>>" but needed nothing.  This is ALL just stuff then.
          DEBUG > 4 and print STDERR " But it's really just stuff.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        } elsif(!$stack[-1]) {
          # We saw " >>>>" but needed only ">".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";
          push @{ $lineage[-1] }, $3; # That was a for-real space, too.
          pos($para) = pos($para) - length($4) + 1;
        } elsif($stack[-1] == length($4)) {
          # We found " >>>>", and it was exactly what we needed.  Commonest case.
          DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n";
        } elsif($stack[-1] < length($4)) {
          # We saw " >>>>" but needed only " >>".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";
          pos($para) = pos($para) - length($4) + $stack[-1];
        } else {
          # We saw " >>>>" but needed " >>>>>>".  So this is all just stuff!
          DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        }
        #print STDERR "\nHOOBOY ", scalar(@{$lineage[-1]}), "!!!\n";
  
        if ($3 ne " " && $self->{'_output_is_for_JustPod'}) {
          if ($3 ne "") {
            $lineage[-1][1]{'~rspacer'} = $3;
          }
          elsif ($lineage[-1][1]{'~lspacer'} eq "  ") {
  
            # Here we had something like C<<  >> which was a false positive
            delete $lineage[-1][1]{'~lspacer'};
          }
          else {
            $lineage[-1][1]{'~rspacer'}
                                  = substr($lineage[-1][1]{'~lspacer'}, -1, 1);
            chop $lineage[-1][1]{'~lspacer'};
          }
        }
  
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Keep the element from being childless
  
        if ($inL == @stack) {
          $lineage[-1][1]{'raw'} = $raw;
          $inL = 0;
        }
  
        pop @stack;
        pop @lineage;
  
        $raw .= $3.$4 if $inL;
  
      } elsif(defined $5) {
        DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";
  
        if(@stack and ! $stack[-1]) {
          # We're indeed expecting a simple end-code
          DEBUG > 4 and print STDERR " It's indeed an end-code.\n";
  
          if(length($5) == 2) { # There was a space there: " >"
            push @{ $lineage[-1] }, ' ';
          } elsif( 2 == @{ $lineage[-1] } ) { # Closing a childless element
            push @{ $lineage[-1] }, ''; # keep it from being really childless
          }
  
          if ($inL == @stack) {
            $lineage[-1][1]{'raw'} = $raw;
            $inL = 0;
          }
  
          pop @stack;
          pop @lineage;
        } else {
          DEBUG > 4 and print STDERR " It's just stuff.\n";
          push @{ $lineage[-1] }, $5;
        }
  
        $raw .= $5 if $inL;
  
      } elsif(defined $6) {
        DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";
        push @{ $lineage[-1] }, $6;
        $raw .= $6 if $inL;
          # XXX does not capture multiplace whitespaces -- 'raw' ends up with
          #     at most 1 leading/trailing whitespace, why not all of it?
          #     Answer, because we deliberately trimmed it above
  
      } else {
        # should never ever ever ever happen
        DEBUG and print STDERR "AYYAYAAAAA at line ", __LINE__, "\n";
        die "SPORK 512512!";
      }
    }
  
    if(@stack) { # Uhoh, some sequences weren't closed.
      my $x= "...";
      while(@stack) {
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Hmmmmm!
  
        my $code         = (pop @lineage)->[0];
        my $ender_length =  pop @stack;
        if($ender_length) {
          --$ender_length;
          $x = $code . ("<" x $ender_length) . " $x " . (">" x $ender_length);
        } else {
          $x = $code . "<$x>";
        }
      }
      DEBUG > 1 and print STDERR "Unterminated $x sequence\n";
      $self->whine($start_line,
        "Unterminated $x sequence",
      );
    }
  
    return $treelet;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub text_content_of_treelet {  # method: $parser->text_content_of_treelet($lol)
    return stringify_lol($_[1]);
  }
  
  sub stringify_lol {  # function: stringify_lol($lol)
    my $string_form = '';
    _stringify_lol( $_[0] => \$string_form );
    return $string_form;
  }
  
  sub _stringify_lol {  # the real recursor
    my($lol, $to) = @_;
    for(my $i = 2; $i < @$lol; ++$i) {
      if( ref($lol->[$i] || '') and UNIVERSAL::isa($lol->[$i], 'ARRAY') ) {
        _stringify_lol( $lol->[$i], $to);  # recurse!
      } else {
        $$to .= $lol->[$i];
      }
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _dump_curr_open { # return a string representation of the stack
    my $curr_open = $_[0]{'curr_open'};
  
    return '[empty]' unless @$curr_open;
    return join '; ',
      map {;
             ($_->[0] eq '=for')
               ? ( ($_->[1]{'~really'} || '=over')
                 . ' ' . $_->[1]{'target'})
               : $_->[0]
          }
      @$curr_open
    ;
  }
  
  ###########################################################################
  my %pretty_form = (
    "\a" => '\a', # ding!
    "\b" => '\b', # BS
    "\e" => '\e', # ESC
    "\f" => '\f', # FF
    "\t" => '\t', # tab
    "\cm" => '\cm',
    "\cj" => '\cj',
    "\n" => '\n', # probably overrides one of either \cm or \cj
    '"' => '\"',
    '\\' => '\\\\',
    '$' => '\\$',
    '@' => '\\@',
    '%' => '\\%',
    '#' => '\\#',
  );
  
  sub pretty { # adopted from Class::Classless
    # Not the most brilliant routine, but passable.
    # Don't give it a cyclic data structure!
    my @stuff = @_; # copy
    my $x;
    my $out =
      # join ",\n" .
      join ", ",
      map {;
      if(!defined($_)) {
        "undef";
      } elsif(ref($_) eq 'ARRAY' or ref($_) eq 'Pod::Simple::LinkSection') {
        $x = "[ " . pretty(@$_) . " ]" ;
        $x;
      } elsif(ref($_) eq 'SCALAR') {
        $x = "\\" . pretty($$_) ;
        $x;
      } elsif(ref($_) eq 'HASH') {
        my $hr = $_;
        $x = "{" . join(", ",
          map(pretty($_) . '=>' . pretty($hr->{$_}),
              sort keys %$hr ) ) . "}" ;
        $x;
      } elsif(!length($_)) { q{''} # empty string
      } elsif(
        $_ eq '0' # very common case
        or(
           m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s
           and $_ ne '-0' # the strange case that RE lets thru
        )
      ) { $_;
      } else {
          # Yes, explicitly name every character desired. There are shorcuts one
          # could make, but I (Karl Williamson) was afraid that some Perl
          # releases would have bugs in some of them. For example [A-Z] works
          # even on EBCDIC platforms to match exactly the 26 uppercase English
          # letters, but I don't know if it has always worked without bugs. It
          # seemed safest just to list the characters.
          # s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
          s<([^ !"#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;
           #<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
        qq{"$_"};
      }
    } @stuff;
    # $out =~ s/\n */ /g if length($out) < 75;
    return $out;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # A rather unsubtle method of blowing away all the state information
  # from a parser object so it can be reused. Provided as a utility for
  # backward compatibility in Pod::Man, etc. but not recommended for
  # general use.
  
  sub reinit {
    my $self = shift;
    foreach (qw(source_dead source_filename doc_has_started
  start_of_pod_block content_seen last_was_blank paras curr_open
  line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen
  Title)) {
  
      delete $self->{$_};
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  
  # A quite dimwitted pod2plaintext that need only know how to format whatever
  # text comes out of Pod::BlackBox's _gen_errata
  
  require 5;
  package Pod::Simple::Checker;
  use strict;
  use Carp ();
  use Pod::Simple::Methody ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION );
  $VERSION = '3.43';
  @ISA = ('Pod::Simple::Methody');
  BEGIN { *DEBUG = defined(&Pod::Simple::DEBUG)
            ? \&Pod::Simple::DEBUG
            : sub() {0}
        }
  
  use Text::Wrap 98.112902 (); # was 2001.0131, but I don't think we need that
  $Text::Wrap::wrap = 'overflow';
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub any_errata_seen {  # read-only accessor
    return $_[1]->{'Errata_seen'};
  }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->{'Thispara'} = '';
    $new->{'Indent'} = 0;
    $new->{'Indentstring'} = '   ';
    $new->{'Errata_seen'} = 0;
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_text {  $_[0]{'Errata_seen'} and $_[0]{'Thispara'} .= $_[1] }
  
  sub start_Para  {  $_[0]{'Thispara'} = '' }
  
  sub start_head1 {
    if($_[0]{'Errata_seen'}) {
      $_[0]{'Thispara'} = '';
    } else {
      if($_[1]{'errata'}) { # start of errata!
        $_[0]{'Errata_seen'} = 1;
        $_[0]{'Thispara'} = $_[0]{'source_filename'} ?
          "$_[0]{'source_filename'} -- " : ''
      }
    }
  }
  sub start_head2 {  $_[0]{'Thispara'} = '' }
  sub start_head3 {  $_[0]{'Thispara'} = '' }
  sub start_head4 {  $_[0]{'Thispara'} = '' }
  
  sub start_Verbatim    { $_[0]{'Thispara'} = ''   }
  sub start_item_bullet { $_[0]{'Thispara'} = '* ' }
  sub start_item_number { $_[0]{'Thispara'} = "$_[1]{'number'}. "  }
  sub start_item_text   { $_[0]{'Thispara'} = ''   }
  
  sub start_over_bullet  { ++$_[0]{'Indent'} }
  sub start_over_number  { ++$_[0]{'Indent'} }
  sub start_over_text    { ++$_[0]{'Indent'} }
  sub start_over_block   { ++$_[0]{'Indent'} }
  
  sub   end_over_bullet  { --$_[0]{'Indent'} }
  sub   end_over_number  { --$_[0]{'Indent'} }
  sub   end_over_text    { --$_[0]{'Indent'} }
  sub   end_over_block   { --$_[0]{'Indent'} }
  
  
  # . . . . . Now the actual formatters:
  
  sub end_head1       { $_[0]->emit_par(-4) }
  sub end_head2       { $_[0]->emit_par(-3) }
  sub end_head3       { $_[0]->emit_par(-2) }
  sub end_head4       { $_[0]->emit_par(-1) }
  sub end_Para        { $_[0]->emit_par( 0) }
  sub end_item_bullet { $_[0]->emit_par( 0) }
  sub end_item_number { $_[0]->emit_par( 0) }
  sub end_item_text   { $_[0]->emit_par(-2) }
  
  sub emit_par {
    return unless $_[0]{'Errata_seen'};
    my($self, $tweak_indent) = splice(@_,0,2);
    my $length = 2 * $self->{'Indent'} + ($tweak_indent||0);
    my $indent = ' ' x ($length > 0 ? $length : 0);
     # Yes, 'STRING' x NEGATIVE gives '', same as 'STRING' x 0
     # 'Negative repeat count does nothing' since 5.22
  
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
    my $out = Text::Wrap::wrap($indent, $indent, $self->{'Thispara'} .= "\n");
    $out =~ s/$Pod::Simple::nbsp/ /g;
    print {$self->{'output_fh'}} $out,
      #"\n"
    ;
    $self->{'Thispara'} = '';
    
    return;
  }
  
  # . . . . . . . . . . And then off by its lonesome:
  
  sub end_Verbatim  {
    return unless $_[0]{'Errata_seen'};
    my $self = shift;
    $self->{'Thispara'} =~ s/$Pod::Simple::nbsp/ /g;
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
  
    my $i = ' ' x ( 2 * $self->{'Indent'} + 4);
    
    $self->{'Thispara'} =~ s/^/$i/mg;
    
    print { $self->{'output_fh'} }   '', 
      $self->{'Thispara'},
      "\n\n"
    ;
    $self->{'Thispara'} = '';
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Checker -- check the Pod syntax of a document
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::Checker -e \
     "exit Pod::Simple::Checker->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is for checking the syntactic validity of Pod.
  It works by basically acting like a simple-minded version of
  L<Pod::Simple::Text> that formats only the "Pod Errors" section
  (if Pod::Simple even generates one for the given document).
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Checker>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  require 5;
  package Pod::Simple::Debug;
  use strict;
  use vars qw($VERSION );
  $VERSION = '3.43';
  
  sub import {
    my($value,$variable);
    
    if(@_ == 2) {
      $value = $_[1];
    } elsif(@_ == 3) {
      ($variable, $value) = @_[1,2];
      
      ($variable, $value) = ($value, $variable)
         if     defined $value    and ref($value)    eq 'SCALAR'
        and not(defined $variable and ref($variable) eq 'SCALAR')
      ; # tolerate getting it backwards
      
      unless( defined $variable and ref($variable) eq 'SCALAR') {
        require Carp;
        Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                  . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
      }
    } else {
      require Carp;
      Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                      . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
    }
  
    if( defined &Pod::Simple::DEBUG ) {
      require Carp;
      Carp::croak("It's too late to call Pod::Simple::Debug -- "
                . "Pod::Simple has already loaded\nAborting");
    }
    
    $value = 0 unless defined $value;
  
    unless($value =~ m/^-?\d+$/) {
      require Carp;
      Carp::croak( "$value isn't a numeric value."
              . "\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                      . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
    }
  
    if( defined $variable ) {
      # make a not-really-constant
      *Pod::Simple::DEBUG = sub () { $$variable } ;
      $$variable = $value;
      print STDERR "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n";
    } else {
      *Pod::Simple::DEBUG = eval " sub () { $value } ";
      print STDERR "# Starting Pod::Simple::DEBUG = $value\n";
    }
    
    require Pod::Simple;
    return;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Debug -- put Pod::Simple into trace/debug mode
  
  =head1 SYNOPSIS
  
   use Pod::Simple::Debug (5);  # or some integer
  
  Or:
  
   my $debuglevel;
   use Pod::Simple::Debug (\$debuglevel, 0);
   ...some stuff that uses Pod::Simple to do stuff, but which
    you don't want debug output from...
  
   $debug_level = 4;
   ...some stuff that uses Pod::Simple to do stuff, but which
    you DO want debug output from...
  
   $debug_level = 0;
  
  =head1 DESCRIPTION
  
  This is an internal module for controlling the debug level (a.k.a. trace
  level) of Pod::Simple.  This is of interest only to Pod::Simple
  developers.
  
  
  =head1 CAVEATS
  
  Note that you should load this module I<before> loading Pod::Simple (or
  any Pod::Simple-based class).  If you try loading Pod::Simple::Debug
  after &Pod::Simple::DEBUG is already defined, Pod::Simple::Debug will
  throw a fatal error to the effect that
  "It's too late to call Pod::Simple::Debug".
  
  Note that the C<use Pod::Simple::Debug (\$x, I<somenum>)> mode will make
  Pod::Simple (et al) run rather slower, since &Pod::Simple::DEBUG won't
  be a constant sub anymore, and so Pod::Simple (et al) won't compile with
  constant-folding.
  
  
  =head1 GUTS
  
  Doing this:
  
    use Pod::Simple::Debug (5);  # or some integer
  
  is basically equivalent to:
  
    BEGIN { sub Pod::Simple::DEBUG () {5} }  # or some integer
    use Pod::Simple ();
  
  And this:
  
    use Pod::Simple::Debug (\$debug_level,0);  # or some integer
  
  is basically equivalent to this:
  
    my $debug_level;
    BEGIN { $debug_level = 0 }
    BEGIN { sub Pod::Simple::DEBUG () { $debug_level }
    use Pod::Simple ();
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  The article "Constants in Perl", in I<The Perl Journal> issue
  21.  See L<http://interglacial.com/tpj/21/>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  
  require 5;
  package Pod::Simple::DumpAsText;
  $VERSION = '3.43';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  
  use Carp ();
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_codes('VerbatimFormatted');
    $new->keep_encoding_directive(1);
    return $new;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    
    print $fh   '  ' x ($_[0]{'indent'} || 0),  "++", $_[1], "\n";
    $_[0]{'indent'}++;
    while(($key,$value) = each %{$_[2]}) {
      unless($key =~ m/^~/s) {
        next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
        _perly_escape($key);
        _perly_escape($value);
        printf $fh qq{%s \\ "%s" => "%s"\n},
          '  ' x ($_[0]{'indent'} || 0), $key, $value;
      }
    }
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    
    if(length $_[1]) {
      my $indent = '  ' x $_[0]{'indent'};
      my $text = $_[1];
      _perly_escape($text);
      $text =~  # A not-totally-brilliant wrapping algorithm:
        s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \ {1,10}(?!\n)     # capture some spaces not at line-end
         /$1"\n$indent . "/gx     # => line-break here
      ;
      
      print {$_[0]{'output_fh'}} $indent, '* "', $text, "\"\n";
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}}
     '  ' x --$_[0]{'indent'}, "--", $_[1], "\n";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _perly_escape {
    foreach my $x (@_) {
      $x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;
      # Escape things very cautiously:
      $x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg;
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::DumpAsText -- dump Pod-parsing events as text
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::DumpAsText -e \
     "exit Pod::Simple::DumpAsText->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is for dumping, as text, the events gotten from parsing a Pod
  document.  This class is of interest to people writing Pod formatters
  based on Pod::Simple. It is useful for seeing exactly what events you
  get out of some Pod that you feed in.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple::DumpAsXML>
  
  L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  
  require 5;
  package Pod::Simple::DumpAsXML;
  $VERSION = '3.43';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  
  use Carp ();
  use Text::Wrap qw(wrap);
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_codes('VerbatimFormatted');
    $new->keep_encoding_directive(1);
    return $new;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    
    print $fh   '  ' x ($_[0]{'indent'} || 0),  "<", $_[1];
  
    foreach my $key (sort keys %{$_[2]}) {
      unless($key =~ m/^~/s) {
        next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
        _xml_escape($value = $_[2]{$key});
        print $fh ' ', $key, '="', $value, '"';
      }
    }
  
  
    print $fh ">\n";
    $_[0]{'indent'}++;
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    if(length $_[1]) {
      my $indent = '  ' x $_[0]{'indent'};
      my $text = $_[1];
      _xml_escape($text);
      local $Text::Wrap::huge = 'overflow';
      $text = wrap('', $indent, $text);
      print {$_[0]{'output_fh'}} $indent, $text, "\n";
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}}
     '  ' x --$_[0]{'indent'}, "</", $_[1], ">\n";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _xml_escape {
    foreach my $x (@_) {
      # Escape things very cautiously:
      if ($] ge 5.007_003) {
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
      } else { # Is broken for non-ASCII platforms on early perls
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
      }
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::DumpAsXML -- turn Pod into XML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::DumpAsXML -e \
     "exit Pod::Simple::DumpAsXML->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  Pod::Simple::DumpAsXML is a subclass of L<Pod::Simple> that parses Pod
  and turns it into indented and wrapped XML.  This class is of
  interest to people writing Pod formatters based on Pod::Simple.
  
  Pod::Simple::DumpAsXML inherits methods from
  L<Pod::Simple>.
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple::XMLOutStream> is rather like this class.
  Pod::Simple::XMLOutStream's output is space-padded in a way
  that's better for sending to an XML processor (that is, it has
  no ignorable whitespace). But
  Pod::Simple::DumpAsXML's output is much more human-readable, being
  (more-or-less) one token per line, with line-wrapping.
  
  L<Pod::Simple::DumpAsText> is rather like this class,
  except that it doesn't dump with XML syntax.  Try them and see
  which one you like best!
  
  L<Pod::Simple>, L<Pod::Simple::DumpAsXML>
  
  The older libraries L<Pod::PXML>, L<Pod::XML>, L<Pod::SAX>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  require 5;
  package Pod::Simple::HTML;
  use strict;
  use Pod::Simple::PullParser ();
  use vars qw(
    @ISA %Tagmap $Computerese $LamePad $Linearization_Limit $VERSION
    $Perldoc_URL_Prefix $Perldoc_URL_Postfix $Man_URL_Prefix $Man_URL_Postfix
    $Title_Prefix $Title_Postfix $HTML_EXTENSION %ToIndex
    $Doctype_decl  $Content_decl
  );
  @ISA = ('Pod::Simple::PullParser');
  $VERSION = '3.43';
  BEGIN {
    if(defined &DEBUG) { } # no-op
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG }
    else { *DEBUG = sub () {0}; }
  }
  
  $Doctype_decl ||= '';  # No.  Just No.  Don't even ask me for it.
   # qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   #    "http://www.w3.org/TR/html4/loose.dtd">\n};
  
  $Content_decl ||=
   q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};
  
  $HTML_EXTENSION = '.html' unless defined $HTML_EXTENSION;
  $Computerese =  "" unless defined $Computerese;
  $LamePad = '' unless defined $LamePad;
  
  $Linearization_Limit = 120 unless defined $Linearization_Limit;
   # headings/items longer than that won't get an <a name="...">
  $Perldoc_URL_Prefix  = 'https://metacpan.org/pod/'
   unless defined $Perldoc_URL_Prefix;
  $Perldoc_URL_Postfix = ''
   unless defined $Perldoc_URL_Postfix;
  
  
  $Man_URL_Prefix  = 'http://man.he.net/man';
  $Man_URL_Postfix = '';
  
  $Title_Prefix  = '' unless defined $Title_Prefix;
  $Title_Postfix = '' unless defined $Title_Postfix;
  %ToIndex = map {; $_ => 1 } qw(head1 head2 head3 head4 ); # item-text
    # 'item-text' stuff in the index doesn't quite work, and may
    # not be a good idea anyhow.
  
  
  __PACKAGE__->_accessorize(
   'perldoc_url_prefix',
     # In turning L<Foo::Bar> into http://whatever/Foo%3a%3aBar, what
     #  to put before the "Foo%3a%3aBar".
     # (for singleton mode only?)
   'perldoc_url_postfix',
     # what to put after "Foo%3a%3aBar" in the URL.  Normally "".
  
   'man_url_prefix',
     # In turning L<crontab(5)> into http://whatever/man/1/crontab, what
     #  to put before the "1/crontab".
   'man_url_postfix',
     #  what to put after the "1/crontab" in the URL. Normally "".
  
   'batch_mode', # whether we're in batch mode
   'batch_mode_current_level',
      # When in batch mode, how deep the current module is: 1 for "LWP",
      #  2 for "LWP::Procotol", 3 for "LWP::Protocol::GHTTP", etc
      
   'title_prefix',  'title_postfix',
    # What to put before and after the title in the head.
    # Should already be &-escaped
  
   'html_h_level',
    
   'html_header_before_title',
   'html_header_after_title',
   'html_footer',
   'top_anchor',
  
   'index', # whether to add an index at the top of each page
      # (actually it's a table-of-contents, but we'll call it an index,
      #  out of apparently longstanding habit)
  
   'html_css', # URL of CSS file to point to
   'html_javascript', # URL of Javascript file to point to
  
   'force_title',   # should already be &-escaped
   'default_title', # should already be &-escaped
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  my @_to_accept;
  
  %Tagmap = (
    'Verbatim'  => "\n<pre$Computerese>",
    '/Verbatim' => "</pre>\n",
    'VerbatimFormatted'  => "\n<pre$Computerese>",
    '/VerbatimFormatted' => "</pre>\n",
    'VerbatimB'  => "<b>",
    '/VerbatimB' => "</b>",
    'VerbatimI'  => "<i>",
    '/VerbatimI' => "</i>",
    'VerbatimBI'  => "<b><i>",
    '/VerbatimBI' => "</i></b>",
  
  
    'Data'  => "\n",
    '/Data' => "\n",
    
    'head1' => "\n<h1>",  # And also stick in an <a name="...">
    'head2' => "\n<h2>",  #  ''
    'head3' => "\n<h3>",  #  ''
    'head4' => "\n<h4>",  #  ''
    'head5' => "\n<h5>",  #  ''
    'head6' => "\n<h6>",  #  ''
    '/head1' => "</a></h1>\n",
    '/head2' => "</a></h2>\n",
    '/head3' => "</a></h3>\n",
    '/head4' => "</a></h4>\n",
    '/head5' => "</a></h5>\n",
    '/head6' => "</a></h6>\n",
  
    'X'  => "<!--\n\tINDEX: ",
    '/X' => "\n-->",
  
    changes(qw(
      Para=p
      B=b I=i
      over-bullet=ul
      over-number=ol
      over-text=dl
      over-block=blockquote
      item-bullet=li
      item-number=li
      item-text=dt
    )),
    changes2(
      map {; m/^([-a-z]+)/s && push @_to_accept, $1; $_ }
      qw[
        sample=samp
        definition=dfn
        keyboard=kbd
        variable=var
        citation=cite
        abbreviation=abbr
        acronym=acronym
        subscript=sub
        superscript=sup
        big=big
        small=small
        underline=u
        strikethrough=s
        preformat=pre
        teletype=tt
      ]  # no point in providing a way to get <q>...</q>, I think
    ),
    
    '/item-bullet' => "</li>$LamePad\n",
    '/item-number' => "</li>$LamePad\n",
    '/item-text'   => "</a></dt>$LamePad\n",
    'item-body'    => "\n<dd>",
    '/item-body'   => "</dd>\n",
  
  
    'B'      =>  "<b>",                  '/B'     =>  "</b>",
    'I'      =>  "<i>",                  '/I'     =>  "</i>",
    'F'      =>  "<em$Computerese>",     '/F'     =>  "</em>",
    'C'      =>  "<code$Computerese>",   '/C'     =>  "</code>",
    'L'  =>  "<a href='YOU_SHOULD_NEVER_SEE_THIS'>", # ideally never used!
    '/L' =>  "</a>",
  );
  
  sub changes {
    return map {; m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s
       ? ( $1, => "\n<$2>", "/$1", => "</$2>\n" ) : die "Funky $_"
    } @_;
  }
  sub changes2 {
    return map {; m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s
       ? ( $1, => "<$2>", "/$1", => "</$2>" ) : die "Funky $_"
    } @_;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub go { Pod::Simple::HTML->parse_from_file(@ARGV); exit 0 }
   # Just so we can run from the command line.  No options.
   #  For that, use perldoc!
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $new = shift->SUPER::new(@_);
    #$new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->accept_targets( 'html', 'HTML' );
    $new->accept_codes('VerbatimFormatted');
    $new->accept_codes(@_to_accept);
    DEBUG > 2 and print STDERR "To accept: ", join(' ',@_to_accept), "\n";
  
    $new->perldoc_url_prefix(  $Perldoc_URL_Prefix  );
    $new->perldoc_url_postfix( $Perldoc_URL_Postfix );
    $new->man_url_prefix(  $Man_URL_Prefix  );
    $new->man_url_postfix( $Man_URL_Postfix );
    $new->title_prefix(  $Title_Prefix  );
    $new->title_postfix( $Title_Postfix );
  
    $new->html_header_before_title(
     qq[$Doctype_decl<html><head><title>]
    );
    $new->html_header_after_title( join "\n" =>
      "</title>",
      $Content_decl,
      "</head>\n<body class='pod'>",
      $new->version_tag_comment,
      "<!-- start doc -->\n",
    );
    $new->html_footer( qq[\n<!-- end doc -->\n\n</body></html>\n] );
    $new->top_anchor( "<a name='___top' class='dummyTopAnchor' ></a>\n" );
  
    $new->{'Tagmap'} = {%Tagmap};
  
    return $new;
  }
  
  sub __adjust_html_h_levels {
    my ($self) = @_;
    my $Tagmap = $self->{'Tagmap'};
  
    my $add = $self->html_h_level;
    return unless defined $add;
    return if ($self->{'Adjusted_html_h_levels'}||0) == $add;
  
    $add -= 1;
    for (1 .. 6) {
      $Tagmap->{"head$_"}  =~ s/$_/$_ + $add/e;
      $Tagmap->{"/head$_"} =~ s/$_/$_ + $add/e;
    }
  }
  
  sub batch_mode_page_object_init {
    my($self, $batchconvobj, $module, $infile, $outfile, $depth) = @_;
    DEBUG and print STDERR "Initting $self\n  for $module\n",
      "  in $infile\n  out $outfile\n  depth $depth\n";
    $self->batch_mode(1);
    $self->batch_mode_current_level($depth);
    return $self;
  }
  
  sub run {
    my $self = $_[0];
    return $self->do_middle if $self->bare_output;
    return
     $self->do_beginning && $self->do_middle && $self->do_end;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub do_beginning {
    my $self = $_[0];
  
    my $title;
    
    if(defined $self->force_title) {
      $title = $self->force_title;
      DEBUG and print STDERR "Forcing title to be $title\n";
    } else {
      # Actually try looking for the title in the document:
      $title = $self->get_short_title();
      unless($self->content_seen) {
        DEBUG and print STDERR "No content seen in search for title.\n";
        return;
      }
      $self->{'Title'} = $title;
  
      if(defined $title and $title =~ m/\S/) {
        $title = $self->title_prefix . esc($title) . $self->title_postfix;
      } else {
        $title = $self->default_title;    
        $title = '' unless defined $title;
        DEBUG and print STDERR "Title defaults to $title\n";
      }
    }
  
    
    my $after = $self->html_header_after_title  || '';
    if($self->html_css) {
      my $link =
      $self->html_css =~ m/</
       ? $self->html_css # It's a big blob of markup, let's drop it in
       : sprintf(        # It's just a URL, so let's wrap it up
        qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],
        $self->html_css,
      );
      $after =~ s{(</head>)}{$link\n$1}i;  # otherwise nevermind
    }
    $self->_add_top_anchor(\$after);
  
    if($self->html_javascript) {
      my $link =
      $self->html_javascript =~ m/</
       ? $self->html_javascript # It's a big blob of markup, let's drop it in
       : sprintf(        # It's just a URL, so let's wrap it up
        qq[<script type="text/javascript" src="%s"></script>\n],
        $self->html_javascript,
      );
      $after =~ s{(</head>)}{$link\n$1}i;  # otherwise nevermind
    }
  
    print {$self->{'output_fh'}}
      $self->html_header_before_title || '',
      $title, # already escaped
      $after,
    ;
  
    DEBUG and print STDERR "Returning from do_beginning...\n";
    return 1;
  }
  
  sub _add_top_anchor {
    my($self, $text_r) = @_;
    unless($$text_r and $$text_r =~ m/name=['"]___top['"]/) { # a hack
      $$text_r .= $self->top_anchor || '';
    }
    return;
  }
  
  sub version_tag_comment {
    my $self = shift;
    return sprintf
     "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",
     esc(
      ref($self), $self->VERSION(), $ISA[0], $ISA[0]->VERSION(),
      $], scalar(gmtime($ENV{SOURCE_DATE_EPOCH} || time)),
     ), $self->_modnote(),
    ;
  }
  
  sub _modnote {
    my $class = ref($_[0]) || $_[0];
    return join "\n   " => grep m/\S/, split "\n",
  
  qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  };
  
  }
  
  sub do_end {
    my $self = $_[0];
    print {$self->{'output_fh'}}  $self->html_footer || '';
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Normally this would just be a call to _do_middle_main_loop -- but we
  #  have to do some elaborate things to emit all the content and then
  #  summarize it and output it /before/ the content that it's a summary of.
  
  sub do_middle {
    my $self = $_[0];
    return $self->_do_middle_main_loop unless $self->index;
  
    if( $self->output_string ) {
      # An efficiency hack
      my $out = $self->output_string; #it's a reference to it
      my $sneakytag = "\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";
      $$out .= $sneakytag;
      $self->_do_middle_main_loop;
      $sneakytag = quotemeta($sneakytag);
      my $index = $self->index_as_html();
      if( $$out =~ s/$sneakytag/$index/s ) {
        # Expected case
        DEBUG and print STDERR "Inserted ", length($index), " bytes of index HTML into $out.\n";
      } else {
        DEBUG and print STDERR "Odd, couldn't find where to insert the index in the output!\n";
        # I don't think this should ever happen.
      }
      return 1;
    }
  
    unless( $self->output_fh ) {
      require Carp;
      Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.");
    }
  
    # If we get here, we're outputting to a FH.  So we need to do some magic.
    # Namely, divert all content to a string, which we output after the index.
    my $fh = $self->output_fh;
    my $content = '';
    {
      # Our horrible bait and switch:
      $self->output_string( \$content );
      $self->_do_middle_main_loop;
      $self->abandon_output_string();
      $self->output_fh($fh);
    }
    print $fh $self->index_as_html();
    print $fh $content;
  
    return 1;
  }
  
  ###########################################################################
  
  sub index_as_html {
    my $self = $_[0];
    # This is meant to be called AFTER the input document has been parsed!
  
    my $points = $self->{'PSHTML_index_points'} || [];
    
    @$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];
     # There's no point in having a 0-item or 1-item index, I dare say.
    
    my(@out) = qq{\n<div class='indexgroup'>};
    my $level = 0;
  
    my( $target_level, $previous_tagname, $tagname, $text, $anchorname, $indent);
    foreach my $p (@$points, ['head0', '(end)']) {
      ($tagname, $text) = @$p;
      $anchorname = $self->section_escape($text);
      if( $tagname =~ m{^head(\d+)$} ) {
        $target_level = 0 + $1;
      } else {  # must be some kinda list item
        if($previous_tagname =~ m{^head\d+$} ) {
          $target_level = $level + 1;
        } else {
          $target_level = $level;  # no change needed
        }
      }
      
      # Get to target_level by opening or closing ULs
      while($level > $target_level)
       { --$level; push @out, ("  " x $level) . "</ul>"; }
      while($level < $target_level)
       { ++$level; push @out, ("  " x ($level-1))
         . "<ul   class='indexList indexList$level'>"; }
  
      $previous_tagname = $tagname;
      next unless $level;
      
      $indent = '  '  x $level;
      push @out, sprintf
        "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",
        $indent, $level, esc($anchorname), esc($text)
      ;
    }
    push @out, "</div>\n";
    return join "\n", @out;
  }
  
  ###########################################################################
  
  sub _do_middle_main_loop {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    my $tagmap = $self->{'Tagmap'};
  
    $self->__adjust_html_h_levels;
    
    my($token, $type, $tagname, $linkto, $linktype);
    my @stack;
    my $dont_wrap = 0;
  
    while($token = $self->get_token) {
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if( ($type = $token->type) eq 'start' ) {
        if(($tagname = $token->tagname) eq 'L') {
          $linktype = $token->attr('type') || 'insane';
          
          $linkto = $self->do_link($token);
  
          if(defined $linkto and length $linkto) {
            esc($linkto);
              #   (Yes, SGML-escaping applies on top of %-escaping!
              #   But it's rarely noticeable in practice.)
            print $fh qq{<a href="$linkto" class="podlink$linktype"\n>};
          } else {
            print $fh "<a>"; # Yes, an 'a' element with no attributes!
          }
  
        } elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s) {
          print $fh $tagmap->{$tagname} || next;
  
          my @to_unget;
          while(1) {
            push @to_unget, $self->get_token;
            last if $to_unget[-1]->is_end
                and $to_unget[-1]->tagname eq $tagname;
            
            # TODO: support for X<...>'s found in here?  (maybe hack into linearize_tokens)
          }
  
          my $name = $self->linearize_tokens(@to_unget);
          $name = $self->do_section($name, $token) if defined $name;
  
          print $fh "<a ";
          if ($tagname =~ m/^head\d$/s) {
              print $fh "class='u'", $self->index
                  ? " href='#___top' title='click to go to top of document'\n"
                  : "\n";
          }
          
          if(defined $name) {
            my $esc = esc(  $self->section_name_tidy( $name ) );
            print $fh qq[name="$esc"];
            DEBUG and print STDERR "Linearized ", scalar(@to_unget),
             " tokens as \"$name\".\n";
            push @{ $self->{'PSHTML_index_points'} }, [$tagname, $name]
             if $ToIndex{ $tagname };
              # Obviously, this discards all formatting codes (saving
              #  just their content), but ahwell.
             
          } else {  # ludicrously long, so nevermind
            DEBUG and print STDERR "Linearized ", scalar(@to_unget),
             " tokens, but it was too long, so nevermind.\n";
          }
          print $fh "\n>";
          $self->unget_token(@to_unget);
  
        } elsif ($tagname eq 'Data') {
          my $next = $self->get_token;
          next unless defined $next;
          unless( $next->type eq 'text' ) {
            $self->unget_token($next);
            next;
          }
          DEBUG and print STDERR "    raw text ", $next->text, "\n";
          # The parser sometimes preserves newlines and sometimes doesn't!
          (my $text = $next->text) =~ s/\n\z//;
          print $fh $text, "\n";
          next;
         
        } else {
          if( $tagname =~ m/^over-/s ) {
            push @stack, '';
          } elsif( $tagname =~ m/^item-/s and @stack and $stack[-1] ) {
            print $fh $stack[-1];
            $stack[-1] = '';
          }
          print $fh $tagmap->{$tagname} || next;
          ++$dont_wrap if $tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted"
            or $tagname eq 'X';
        }
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      } elsif( $type eq 'end' ) {
        if( ($tagname = $token->tagname) =~ m/^over-/s ) {
          if( my $end = pop @stack ) {
            print $fh $end;
          }
        } elsif( $tagname =~ m/^item-/s and @stack) {
          $stack[-1] = $tagmap->{"/$tagname"};
          if( $tagname eq 'item-text' and defined(my $next = $self->get_token) ) {
            $self->unget_token($next);
            if( $next->type eq 'start' ) {
              print $fh $tagmap->{"/item-text"},$tagmap->{"item-body"};
              $stack[-1] = $tagmap->{"/item-body"};
            }
          }
          next;
        }
        print $fh $tagmap->{"/$tagname"} || next;
        --$dont_wrap if $tagname eq 'Verbatim' or $tagname eq 'X';
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      } elsif( $type eq 'text' ) {
        esc($type = $token->text);  # reuse $type, why not
        $type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless $dont_wrap;
        print $fh $type;
      }
  
    }
    return 1;
  }
  
  ###########################################################################
  #
  
  sub do_section {
    my($self, $name, $token) = @_;
    return $name;
  }
  
  sub do_link {
    my($self, $token) = @_;
    my $type = $token->attr('type');
    if(!defined $type) {
      $self->whine("Typeless L!?", $token->attr('start_line'));
    } elsif( $type eq 'pod') { return $self->do_pod_link($token);
    } elsif( $type eq 'url') { return $self->do_url_link($token);
    } elsif( $type eq 'man') { return $self->do_man_link($token);
    } else {
      $self->whine("L of unknown type $type!?", $token->attr('start_line'));
    }
    return 'FNORG'; # should never get called
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub do_url_link { return $_[1]->attr('to') }
  
  sub do_man_link {
    my ($self, $link) = @_;
    my $to = $link->attr('to');
    my $frag = $link->attr('section');
  
    return undef unless defined $to and length $to; # should never happen
  
    $frag = $self->section_escape($frag)
     if defined $frag and length($frag .= ''); # (stringify)
  
    DEBUG and print STDERR "Resolving \"$to/$frag\"\n\n";
  
    return $self->resolve_man_page_link($to, $frag);
  }
  
  
  sub do_pod_link {
    # And now things get really messy...
    my($self, $link) = @_;
    my $to = $link->attr('to');
    my $section = $link->attr('section');
    return undef unless(  # should never happen
      (defined $to and length $to) or
      (defined $section and length $section)
    );
  
    $section = $self->section_escape($section)
     if defined $section and length($section .= ''); # (stringify)
  
    DEBUG and printf STDERR "Resolving \"%s\" \"%s\"...\n",
     $to || "(nil)",  $section || "(nil)";
     
    {
      # An early hack:
      my $complete_url = $self->resolve_pod_link_by_table($to, $section);
      if( $complete_url ) {
        DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T,S) gives ",
          $complete_url, "\n  (Returning that.)\n";
        return $complete_url;
      } else {
        DEBUG > 4 and print STDERR " resolve_pod_link_by_table(T,S)",
         " didn't return anything interesting.\n";
      }
    }
  
    if(defined $to and length $to) {
      # Give this routine first hack again
      my $there = $self->resolve_pod_link_by_table($to);
      if(defined $there and length $there) {
        DEBUG > 1
         and print STDERR "resolve_pod_link_by_table(T) gives $there\n";
      } else {
        $there = 
          $self->resolve_pod_page_link($to, $section);
           # (I pass it the section value, but I don't see a
           #  particular reason it'd use it.)
        DEBUG > 1 and print STDERR "resolve_pod_page_link gives ", $there || "(nil)", "\n";
        unless( defined $there and length $there ) {
          DEBUG and print STDERR "Can't resolve $to\n";
          return undef;
        }
        # resolve_pod_page_link returning undef is how it
        #  can signal that it gives up on making a link
      }
      $to = $there;
    }
  
    #DEBUG and print STDERR "So far [", $to||'nil', "] [", $section||'nil', "]\n";
  
    my $out = (defined $to and length $to) ? $to : '';
    $out .= "#" . $section if defined $section and length $section;
    
    unless(length $out) { # sanity check
      DEBUG and printf STDERR "Oddly, couldn't resolve \"%s\" \"%s\"...\n",
       $to || "(nil)",  $section || "(nil)";
      return undef;
    }
  
    DEBUG and print STDERR "Resolved to $out\n";
    return $out;  
  }
  
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub section_escape {
    my($self, $section) = @_;
    return $self->section_url_escape(
      $self->section_name_tidy($section)
    );
  }
  
  sub section_name_tidy {
    my($self, $section) = @_;
    $section =~ s/^\s+//;
    $section =~ s/\s+$//;
    $section =~ tr/ /_/;
    if ($] ge 5.006) {
      $section =~ s/[[:cntrl:][:^ascii:]]//g; # drop crazy characters
    } elsif ('A' eq chr(65)) { # But not on early EBCDIC
      $section =~ tr/\x00-\x1F\x80-\x9F//d;
    }
    $section = $self->unicode_escape_url($section);
    $section = '_' unless length $section;
    return $section;
  }
  
  sub section_url_escape  { shift->general_url_escape(@_) }
  sub pagepath_url_escape { shift->general_url_escape(@_) }
  sub manpage_url_escape  { shift->general_url_escape(@_) }
  
  sub general_url_escape {
    my($self, $string) = @_;
   
    $string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;
       # express Unicode things as urlencode(utf(orig)).
    
    # A pretty conservative escaping, behoovey even for query components
    #  of a URL (see RFC 2396)
    
    if ($] ge 5.007_003) {
      $string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',utf8::native_to_unicode(ord($1)))/eg;
    } else { # Is broken for non-ASCII platforms on early perls
      $string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg;
    }
     # Yes, stipulate the list without a range, so that this can work right on
     #  all charsets that this module happens to run under.
    
    return $string;
  }
  
  #--------------------------------------------------------------------------
  #
  # Oh look, a yawning portal to Hell!  Let's play touch football right by it!
  #
  
  sub resolve_pod_page_link {
    # resolve_pod_page_link must return a properly escaped URL
    my $self = shift;
    return $self->batch_mode()
     ? $self->resolve_pod_page_link_batch_mode(@_)
     : $self->resolve_pod_page_link_singleton_mode(@_)
    ;
  }
  
  sub resolve_pod_page_link_singleton_mode {
    my($self, $it) = @_;
    return undef unless defined $it and length $it;
    my $url = $self->pagepath_url_escape($it);
    
    $url =~ s{::$}{}s; # probably never comes up anyway
    $url =~ s{::}{/}g unless $self->perldoc_url_prefix =~ m/\?/s; # sane DWIM?
    
    return undef unless length $url;
    return $self->perldoc_url_prefix . $url . $self->perldoc_url_postfix;
  }
  
  sub resolve_pod_page_link_batch_mode {
    my($self, $to) = @_;
    DEBUG > 1 and print STDERR " During batch mode, resolving $to ...\n";
    my @path = grep length($_), split m/::/s, $to, -1;
    unless( @path ) { # sanity
      DEBUG and print STDERR "Very odd!  Splitting $to gives (nil)!\n";
      return undef;
    }
    $self->batch_mode_rectify_path(\@path);
    my $out = join('/', map $self->pagepath_url_escape($_), @path)
      . $HTML_EXTENSION;
    DEBUG > 1 and print STDERR " => $out\n";
    return $out;
  }
  
  sub batch_mode_rectify_path {
    my($self, $pathbits) = @_;
    my $level = $self->batch_mode_current_level;
    $level--; # how many levels up to go to get to the root
    if($level < 1) {
      unshift @$pathbits, '.'; # just to be pretty
    } else {
      unshift @$pathbits, ('..') x $level;
    }
    return;
  }
  
  sub resolve_man_page_link {
    my ($self, $to, $frag) = @_;
    my ($page, $section) = $to =~ /^([^(]+)(?:[(](\d+)[)])?$/;
  
    return undef unless defined $page and length $page;
    $section ||= 1;
  
    return $self->man_url_prefix . "$section/"
        . $self->manpage_url_escape($page)
        . $self->man_url_postfix;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub resolve_pod_link_by_table {
    # A crazy hack to allow specifying custom L<foo> => URL mappings
  
    return unless $_[0]->{'podhtml_LOT'};  # An optimizy shortcut
  
    my($self, $to, $section) = @_;
  
    # TODO: add a method that actually populates podhtml_LOT from a file?
  
    if(defined $section) {
      $to = '' unless defined $to and length $to;
      return $self->{'podhtml_LOT'}{"$to#$section"}; # quite possibly undef!
    } else {
      return $self->{'podhtml_LOT'}{$to};            # quite possibly undef!
    }
    return;
  }
  
  ###########################################################################
  
  sub linearize_tokens {  # self, tokens
    my $self = shift;
    my $out = '';
    
    my $t;
    while($t = shift @_) {
      if(!ref $t or !UNIVERSAL::can($t, 'is_text')) {
        $out .= $t; # a string, or some insane thing
      } elsif($t->is_text) {
        $out .= $t->text;
      } elsif($t->is_start and $t->tag eq 'X') {
        # Ignore until the end of this X<...> sequence:
        my $x_open = 1;
        while($x_open) {
          next if( ($t = shift @_)->is_text );
          if(   $t->is_start and $t->tag eq 'X') { ++$x_open }
          elsif($t->is_end   and $t->tag eq 'X') { --$x_open }
        }
      }
    }
    return undef if length $out > $Linearization_Limit;
    return $out;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub unicode_escape_url {
    my($self, $string) = @_;
    $string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;
      #  Turn char 1234 into "(1234)"
    return $string;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub esc { # a function.
    if(defined wantarray) {
      if(wantarray) {
        @_ = splice @_; # break aliasing
      } else {
        my $x = shift;
        if ($] ge 5.007_003) {
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
        } else { # Is broken for non-ASCII platforms on early perls
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
        }
        return $x;
      }
    }
    foreach my $x (@_) {
      # Escape things very cautiously:
      if (defined $x) {
        if ($] ge 5.007_003) {
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg
        } else { # Is broken for non-ASCII platforms on early perls
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg
        }
      }
      # Leave out "- so that "--" won't make it thru in X-generated comments
      #  with text in them.
  
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return @_;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  1;
  __END__
  
  =head1 NAME
  
  Pod::Simple::HTML - convert Pod to HTML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::HTML -e Pod::Simple::HTML::go thingy.pod
  
  
  =head1 DESCRIPTION
  
  This class is for making an HTML rendering of a Pod document.
  
  This is a subclass of L<Pod::Simple::PullParser> and inherits all its
  methods (and options).
  
  Note that if you want to do a batch conversion of a lot of Pod
  documents to HTML, you should see the module L<Pod::Simple::HTMLBatch>.
  
  
  
  =head1 CALLING FROM THE COMMAND LINE
  
  TODO
  
    perl -MPod::Simple::HTML -e Pod::Simple::HTML::go Thing.pod Thing.html
  
  
  
  =head1 CALLING FROM PERL
  
  =head2 Minimal code
  
    use Pod::Simple::HTML;
    my $p = Pod::Simple::HTML->new;
    $p->output_string(\my $html);
    $p->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die "Cannot open 'out.html': $!\n";
    print $out $html;
  
  =head2 More detailed example
  
    use Pod::Simple::HTML;
  
  Set the content type:
  
    $Pod::Simple::HTML::Content_decl =  q{<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >};
  
    my $p = Pod::Simple::HTML->new;
  
  Include a single javascript source:
  
    $p->html_javascript('http://abc.com/a.js');
  
  Or insert multiple javascript source in the header 
  (or for that matter include anything, thought this is not recommended)
  
    $p->html_javascript('
        <script type="text/javascript" src="http://abc.com/b.js"></script>
        <script type="text/javascript" src="http://abc.com/c.js"></script>');
  
  Include a single css source in the header:
  
    $p->html_css('/style.css');
  
  or insert multiple css sources:
  
    $p->html_css('
        <link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://remote.server.com/jquery.css">
        <link rel="stylesheet" type="text/css" title="pod_stylesheet" href="/style.css">');
  
  Tell the parser where should the output go. In this case it will be placed in the $html variable:
  
    my $html;
    $p->output_string(\$html);
  
  Parse and process a file with pod in it:
  
    $p->parse_file('path/to/Module/Name.pm');
  
  =head1 METHODS
  
  TODO
  all (most?) accessorized methods
  
  The following variables need to be set B<before> the call to the ->new constructor.
  
  Set the string that is included before the opening <html> tag:
  
    $Pod::Simple::HTML::Doctype_decl = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
  	 "http://www.w3.org/TR/html4/loose.dtd">\n};
  
  Set the content-type in the HTML head: (defaults to ISO-8859-1)
  
    $Pod::Simple::HTML::Content_decl =  q{<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >};
  
  Set the value that will be embedded in the opening tags of F, C tags and verbatim text.
  F maps to <em>, C maps to <code>, Verbatim text maps to <pre> (Computerese defaults to "")
  
    $Pod::Simple::HTML::Computerese =  ' class="some_class_name';
  
  =head2 html_css
  
  =head2 html_javascript
  
  =head2 title_prefix
  
  =head2 title_postfix
  
  =head2 html_header_before_title
  
  This includes everything before the <title> opening tag including the Document type
  and including the opening <title> tag. The following call will set it to be a simple HTML
  file:
  
    $p->html_header_before_title('<html><head><title>');
  
  =head2 top_anchor
  
  By default Pod::Simple::HTML adds a dummy anchor at the top of the HTML.
  You can change it by calling
  
    $p->top_anchor('<a name="zz" >');
  
  =head2 html_h_level
  
  Normally =head1 will become <h1>, =head2 will become <h2> etc.
  Using the html_h_level method will change these levels setting the h level
  of =head1 tags:
  
    $p->html_h_level(3);
  
  Will make sure that =head1 will become <h3> and =head2 will become <h4> etc...
  
  
  =head2 index
  
  Set it to some true value if you want to have an index (in reality a table of contents)
  to be added at the top of the generated HTML.
  
    $p->index(1);
  
  =head2 html_header_after_title
  
  Includes the closing tag of </title> and through the rest of the head
  till the opening of the body
  
    $p->html_header_after_title('</title>...</head><body id="my_id">');
  
  =head2 html_footer
  
  The very end of the document:
  
    $p->html_footer( qq[\n<!-- end doc -->\n\n</body></html>\n] );
  
  =head1 SUBCLASSING
  
  Can use any of the methods described above but for further customization
  one needs to override some of the methods:
  
    package My::Pod;
    use strict;
    use warnings;
  
    use base 'Pod::Simple::HTML';
  
    # needs to return a URL string such
    # http://some.other.com/page.html
    # #anchor_in_the_same_file
    # /internal/ref.html
    sub do_pod_link {
      # My::Pod object and Pod::Simple::PullParserStartToken object
      my ($self, $link) = @_;
  
      say $link->tagname;          # will be L for links
      say $link->attr('to');       # 
      say $link->attr('type');     # will be 'pod' always
      say $link->attr('section');
  
      # Links local to our web site
      if ($link->tagname eq 'L' and $link->attr('type') eq 'pod') {
        my $to = $link->attr('to');
        if ($to =~ /^Padre::/) {
            $to =~ s{::}{/}g;
            return "/docs/Padre/$to.html";
        }
      }
  
      # all other links are generated by the parent class
      my $ret = $self->SUPER::do_pod_link($link);
      return $ret;
    }
  
    1;
  
  Meanwhile in script.pl:
  
    use My::Pod;
  
    my $p = My::Pod->new;
  
    my $html;
    $p->output_string(\$html);
    $p->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die;
    print $out $html;
  
  TODO
  
  maybe override do_beginning do_end
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::HTMLBatch>
  
  TODO: a corpus of sample Pod input and HTML output?  Or common
  idioms?
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002-2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to L<Hurricane Electric|http://he.net/> for permission to use its
  L<Linux man pages online|http://man.he.net/> site for man page links.
  
  Thanks to L<search.cpan.org|http://search.cpan.org/> for permission to use the
  site for Perl module links.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  
  require 5;
  package Pod::Simple::HTMLBatch;
  use strict;
  use vars qw( $VERSION $HTML_RENDER_CLASS $HTML_EXTENSION
   $CSS $JAVASCRIPT $SLEEPY $SEARCH_CLASS @ISA
  );
  $VERSION = '3.43';
  @ISA = ();  # Yup, we're NOT a subclass of Pod::Simple::HTML!
  
  # TODO: nocontents stylesheets. Strike some of the color variations?
  
  use Pod::Simple::HTML ();
  BEGIN {*esc = \&Pod::Simple::HTML::esc }
  use File::Spec ();
  
  use Pod::Simple::Search;
  $SEARCH_CLASS ||= 'Pod::Simple::Search';
  
  BEGIN {
    if(defined &DEBUG) { } # no-op
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG }
    else { *DEBUG = sub () {0}; }
  }
  
  $SLEEPY = 1 if !defined $SLEEPY and $^O =~ /mswin|mac/i;
  # flag to occasionally sleep for $SLEEPY - 1 seconds.
  
  $HTML_RENDER_CLASS ||= "Pod::Simple::HTML";
  
  #
  # Methods beginning with "_" are particularly internal and possibly ugly.
  #
  
  Pod::Simple::_accessorize( __PACKAGE__,
   'verbose', # how verbose to be during batch conversion
   'html_render_class', # what class to use to render
   'search_class', # what to use to search for POD documents
   'contents_file', # If set, should be the name of a file (in current directory)
                    # to write the list of all modules to
   'index', # will set $htmlpage->index(...) to this (true or false)
   'progress', # progress object
   'contents_page_start',  'contents_page_end',
  
   'css_flurry', '_css_wad', 'javascript_flurry', '_javascript_wad',
   'no_contents_links', # set to true to suppress automatic adding of << links.
   '_contents',
  );
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Just so we can run from the command line more easily
  sub go {
    @ARGV == 2 or die sprintf(
      "Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",
      __PACKAGE__, __PACKAGE__, 
    );
    
    if(defined($ARGV[1]) and length($ARGV[1])) {
      my $d = $ARGV[1];
      -e $d or die "I see no output directory named \"$d\"\nAborting";
      -d $d or die "But \"$d\" isn't a directory!\nAborting";
      -w $d or die "Directory \"$d\" isn't writeable!\nAborting";
    }
    
    __PACKAGE__->batch_convert(@ARGV);
  }
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  
  sub new {
    my $new = bless {}, ref($_[0]) || $_[0];
    $new->html_render_class($HTML_RENDER_CLASS);
    $new->search_class($SEARCH_CLASS);
    $new->verbose(1 + DEBUG);
    $new->_contents([]);
    
    $new->index(1);
  
    $new->       _css_wad([]);         $new->css_flurry(1);
    $new->_javascript_wad([]);  $new->javascript_flurry(1);
    
    $new->contents_file(
      'index' . ($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION)
    );
    
    $new->contents_page_start( join "\n", grep $_,
      $Pod::Simple::HTML::Doctype_decl,
      "<html><head>",
      "<title>Perl Documentation</title>",
      $Pod::Simple::HTML::Content_decl,
      "</head>",
      "\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n"
    ); # override if you need a different title
    
    
    $new->contents_page_end( sprintf(
      "\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT.</p>\n\n</body></html>\n",
      esc(
        ref($new),
        eval {$new->VERSION} || $VERSION,
        $], scalar(gmtime($ENV{SOURCE_DATE_EPOCH} || time)),
    )));
  
    return $new;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub muse {
    my $self = shift;
    if($self->verbose) {
      print 'T+', int(time() - $self->{'_batch_start_time'}), "s: ", @_, "\n";
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub batch_convert {
    my($self, $dirs, $outdir) = @_;
    $self ||= __PACKAGE__; # tolerate being called as an optionless function
    $self = $self->new unless ref $self; # tolerate being used as a class method
  
    if(!defined($dirs)  or  $dirs eq ''  or  $dirs eq '@INC' ) {
      $dirs = '';
    } elsif(ref $dirs) {
      # OK, it's an explicit set of dirs to scan, specified as an arrayref.
    } else {
      # OK, it's an explicit set of dirs to scan, specified as a
      #  string like "/thing:/also:/whatever/perl" (":"-delim, as usual)
      #  or, under MSWin, like "c:/thing;d:/also;c:/whatever/perl" (";"-delim!)
      require Config;
      my $ps = quotemeta( $Config::Config{'path_sep'} || ":" );
      $dirs = [ grep length($_), split qr/$ps/, $dirs ];
    }
  
    $outdir = $self->filespecsys->curdir
     unless defined $outdir and length $outdir;
  
    $self->_batch_convert_main($dirs, $outdir);
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _batch_convert_main {
    my($self, $dirs, $outdir) = @_;
    # $dirs is either false, or an arrayref.    
    # $outdir is a pathspec.
    
    $self->{'_batch_start_time'} ||= time();
  
    $self->muse( "= ", scalar(localtime) );
    $self->muse( "Starting batch conversion to \"$outdir\"" );
  
    my $progress = $self->progress;
    if(!$progress and $self->verbose > 0 and $self->verbose() <= 5) {
      require Pod::Simple::Progress;
      $progress = Pod::Simple::Progress->new(
          ($self->verbose  < 2) ? () # Default omission-delay
        : ($self->verbose == 2) ? 1  # Reduce the omission-delay
                                : 0  # Eliminate the omission-delay
      );
      $self->progress($progress);
    }
    
    if($dirs) {
      $self->muse(scalar(@$dirs), " dirs to scan: @$dirs");
    } else {
      $self->muse("Scanning \@INC.  This could take a minute or two.");
    }
    my $mod2path = $self->find_all_pods($dirs ? $dirs : ());
    $self->muse("Done scanning.");
  
    my $total = keys %$mod2path;
    unless($total) {
      $self->muse("No pod found.  Aborting batch conversion.\n");
      return $self;
    }
  
    $progress and $progress->goal($total);
    $self->muse("Now converting pod files to HTML.",
      ($total > 25) ? "  This will take a while more." : ()
    );
  
    $self->_spray_css(        $outdir );
    $self->_spray_javascript( $outdir );
  
    $self->_do_all_batch_conversions($mod2path, $outdir);
  
    $progress and $progress->done(sprintf (
      "Done converting %d files.",  $self->{"__batch_conv_page_count"}
    ));
    return $self->_batch_convert_finish($outdir);
    return $self;
  }
  
  
  sub _do_all_batch_conversions {
    my($self, $mod2path, $outdir) = @_;
    $self->{"__batch_conv_page_count"} = 0;
  
    foreach my $module (sort {lc($a) cmp lc($b)} keys %$mod2path) {
      $self->_do_one_batch_conversion($module, $mod2path, $outdir);
      sleep($SLEEPY - 1) if $SLEEPY;
    }
  
    return;
  }
  
  sub _batch_convert_finish {
    my($self, $outdir) = @_;
    $self->write_contents_file($outdir);
    $self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");
    $self->muse( "= ", scalar(localtime) );
    $self->progress and $self->progress->done("All done!");
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _do_one_batch_conversion {
    my($self, $module, $mod2path, $outdir, $outfile) = @_;
  
    my $retval;
    my $total    = scalar keys %$mod2path;
    my $infile   = $mod2path->{$module};
    my @namelets = grep m/\S/, split "::", $module;
          # this can stick around in the contents LoL
    my $depth    = scalar @namelets;
    die "Contentless thingie?! $module $infile" unless @namelets; #sanity
      
    $outfile  ||= do {
      my @n = @namelets;
      $n[-1] .= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;
      $self->filespecsys->catfile( $outdir, @n );
    };
  
    my $progress = $self->progress;
  
    my $page = $self->html_render_class->new;
    if(DEBUG > 5) {
      $self->muse($self->{"__batch_conv_page_count"} + 1, "/$total: ",
        ref($page), " render ($depth) $module => $outfile");
    } elsif(DEBUG > 2) {
      $self->muse($self->{"__batch_conv_page_count"} + 1, "/$total: $module => $outfile")
    }
  
    # Give each class a chance to init the converter:
    $page->batch_mode_page_object_init($self, $module, $infile, $outfile, $depth)
     if $page->can('batch_mode_page_object_init');
    # Init for the index (TOC), too.
    $self->batch_mode_page_object_init($page, $module, $infile, $outfile, $depth)
     if $self->can('batch_mode_page_object_init');
      
    # Now get busy...
    $self->makepath($outdir => \@namelets);
  
    $progress and $progress->reach($self->{"__batch_conv_page_count"}, "Rendering $module");
  
    if( $retval = $page->parse_from_file($infile, $outfile) ) {
      ++ $self->{"__batch_conv_page_count"} ;
      $self->note_for_contents_file( \@namelets, $infile, $outfile );
    } else {
      $self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.");
    }
  
    $page->batch_mode_page_object_kill($self, $module, $infile, $outfile, $depth)
     if $page->can('batch_mode_page_object_kill');
    # The following isn't a typo.  Note that it switches $self and $page.
    $self->batch_mode_page_object_kill($page, $module, $infile, $outfile, $depth)
     if $self->can('batch_mode_page_object_kill');
      
    DEBUG > 4 and printf STDERR "%s %sb < $infile %s %sb\n",
       $outfile, -s $outfile, $infile, -s $infile
    ;
  
    undef($page);
    return $retval;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub filespecsys { $_[0]{'_filespecsys'} || 'File::Spec' }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub note_for_contents_file {
    my($self, $namelets, $infile, $outfile) = @_;
  
    # I think the infile and outfile parts are never used. -- SMB
    # But it's handy to have them around for debugging.
  
    if( $self->contents_file ) {
      my $c = $self->_contents();
      push @$c,
       [ join("::", @$namelets), $infile, $outfile, $namelets ]
       #            0               1         2         3
      ;
      DEBUG > 3 and print STDERR "Noting @$c[-1]\n";
    }
    return;
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub write_contents_file {
    my($self, $outdir) = @_;
    my $outfile  = $self->_contents_filespec($outdir) || return;
  
    $self->muse("Preparing list of modules for ToC");
  
    my($toplevel,           # maps  toplevelbit => [all submodules]
       $toplevel_form_freq, # ends up being  'foo' => 'Foo'
      ) = $self->_prep_contents_breakdown;
  
    my $Contents = eval { $self->_wopen($outfile) };
    if( $Contents ) {
      $self->muse( "Writing contents file $outfile" );
    } else {
      warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";
      return;
    }
  
    $self->_write_contents_start(  $Contents, $outfile, );
    $self->_write_contents_middle( $Contents, $outfile, $toplevel, $toplevel_form_freq );
    $self->_write_contents_end(    $Contents, $outfile, );
    return $outfile;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_start {
    my($self, $Contents, $outfile) = @_;
    my $starter = $self->contents_page_start || '';
    
    {
      my $css_wad = $self->_css_wad_to_markup(1);
      if( $css_wad ) {
        $starter =~ s{(</head>)}{\n$css_wad\n$1}i;  # otherwise nevermind
      }
      
      my $javascript_wad = $self->_javascript_wad_to_markup(1);
      if( $javascript_wad ) {
        $starter =~ s{(</head>)}{\n$javascript_wad\n$1}i;   # otherwise nevermind
      }
    }
  
    unless(print $Contents $starter, "<dl class='superindex'>\n" ) {
      warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Contents);
      return 0;
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_middle {
    my($self, $Contents, $outfile, $toplevel2submodules, $toplevel_form_freq) = @_;
  
    foreach my $t (sort keys %$toplevel2submodules) {
      my @downlines = sort {$a->[-1] cmp $b->[-1]}
                            @{ $toplevel2submodules->{$t} };
      
      printf $Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],
        esc( $t, $toplevel_form_freq->{$t} )
      ;
      
      my($path, $name);
      foreach my $e (@downlines) {
        $name = $e->[0];
        $path = join( "/", '.', esc( @{$e->[3]} ) )
          . ($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);
        print $Contents qq{  <a href="$path">}, esc($name), "</a>&nbsp;&nbsp;\n";
      }
      print $Contents "</dd>\n\n";
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_end {
    my($self, $Contents, $outfile) = @_;
    unless(
      print $Contents "</dl>\n",
        $self->contents_page_end || '',
    ) {
      warn "Couldn't write to $outfile: $!";
    }
    close($Contents) or warn "Couldn't close $outfile: $!";
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _prep_contents_breakdown {
    my($self) = @_;
    my $contents = $self->_contents;
    my %toplevel; # maps  lctoplevelbit => [all submodules]
    my %toplevel_form_freq; # ends up being  'foo' => 'Foo'
                                 # (mapping anycase forms to most freq form)
    
    foreach my $entry (@$contents) {
      my $toplevel = 
        $entry->[0] =~ m/^perl\w*$/ ? 'perl_core_docs'
            # group all the perlwhatever docs together
        : $entry->[3][0] # normal case
      ;
      ++$toplevel_form_freq{ lc $toplevel }{ $toplevel };
      push @{ $toplevel{ lc $toplevel } }, $entry;
      push @$entry, lc($entry->[0]); # add a sort-order key to the end
    }
  
    foreach my $toplevel (sort keys %toplevel) {
      my $fgroup = $toplevel_form_freq{$toplevel};
      $toplevel_form_freq{$toplevel} =
      (
        sort { $fgroup->{$b} <=> $fgroup->{$a}  or  $a cmp $b }
          keys %$fgroup
        # This hash is extremely unlikely to have more than 4 members, so this
        # sort isn't so very wasteful
      )[0];
    }
  
    return(\%toplevel, \%toplevel_form_freq) if wantarray;
    return \%toplevel;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _contents_filespec {
    my($self, $outdir) = @_;
    my $outfile = $self->contents_file;
    return unless $outfile;
    return $self->filespecsys->catfile( $outdir, $outfile );
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub makepath {
    my($self, $outdir, $namelets) = @_;
    return unless @$namelets > 1;
    for my $i (0 .. ($#$namelets - 1)) {
      my $dir = $self->filespecsys->catdir( $outdir, @$namelets[0 .. $i] );
      if(-e $dir) {
        die "$dir exists but not as a directory!?" unless -d $dir;
        next;
      }
      DEBUG > 3 and print STDERR "  Making $dir\n";
      mkdir $dir, 0777
       or die "Can't mkdir $dir: $!\nAborting"
      ;
    }
    return;
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub batch_mode_page_object_init {
    my $self = shift;
    my($page, $module, $infile, $outfile, $depth) = @_;
    
    # TODO: any further options to percolate onto this new object here?
  
    $page->default_title($module);
    $page->index( $self->index );
  
    $page->html_css(        $self->       _css_wad_to_markup($depth) );
    $page->html_javascript( $self->_javascript_wad_to_markup($depth) );
  
    $self->add_header_backlink($page, $module, $infile, $outfile, $depth);
    $self->add_footer_backlink($page, $module, $infile, $outfile, $depth);
  
  
    return $self;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub add_header_backlink {
    my $self = shift;
    return if $self->no_contents_links;
    my($page, $module, $infile, $outfile, $depth) = @_;
    $page->html_header_after_title( join '',
      $page->html_header_after_title || '',
  
      qq[<p class="backlinktop"><b><a name="___top" href="],
      $self->url_up_to_contents($depth),
      qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],
    )
     if $self->contents_file
    ;
    return;
  }
  
  sub add_footer_backlink {
    my $self = shift;
    return if $self->no_contents_links;
    my($page, $module, $infile, $outfile, $depth) = @_;
    $page->html_footer( join '',
      qq[<p class="backlinkbottom"><b><a name="___bottom" href="],
      $self->url_up_to_contents($depth),
      qq[" title="All Documents">&lt;&lt;</a></b></p>\n],
      
      $page->html_footer || '',
    )
     if $self->contents_file
    ;
    return;
  }
  
  sub url_up_to_contents {
    my($self, $depth) = @_;
    --$depth;
    return join '/', ('..') x $depth, esc($self->contents_file);
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub find_all_pods {
    my($self, $dirs) = @_;
    # You can override find_all_pods in a subclass if you want to
    #  do extra filtering or whatnot.  But for the moment, we just
    #  pass to modnames2paths:
    return $self->modnames2paths($dirs);
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub modnames2paths { # return a hashref mapping modulenames => paths
    my($self, $dirs) = @_;
  
    my $m2p;
    {
      my $search = $self->search_class->new;
      DEBUG and print STDERR "Searching via $search\n";
      $search->verbose(1) if DEBUG > 10;
      $search->progress( $self->progress->copy->goal(0) ) if $self->progress;
      $search->shadows(0);  # don't bother noting shadowed files
      $search->inc(     $dirs ? 0      :  1 );
      $search->survey(  $dirs ? @$dirs : () );
      $m2p = $search->name2path;
      die "What, no name2path?!" unless $m2p;
    }
  
    $self->muse("That's odd... no modules found!") unless keys %$m2p;
    if( DEBUG > 4 ) {
      print STDERR "Modules found (name => path):\n";
      foreach my $m (sort {lc($a) cmp lc($b)} keys %$m2p) {
        print STDERR "  $m  $$m2p{$m}\n";
      }
      print STDERR "(total ",     scalar(keys %$m2p), ")\n\n";
    } elsif( DEBUG ) {
      print STDERR      "Found ", scalar(keys %$m2p), " modules.\n";
    }
    $self->muse( "Found ", scalar(keys %$m2p), " modules." );
    
    # return the Foo::Bar => /whatever/Foo/Bar.pod|pm hashref
    return $m2p;
  }
  
  #===========================================================================
  
  sub _wopen {
    # this is abstracted out so that the daemon class can override it
    my($self, $outpath) = @_;
    require Symbol;
    my $out_fh = Symbol::gensym();
    DEBUG > 5 and print STDERR "Write-opening to $outpath\n";
    return $out_fh if open($out_fh, "> $outpath");
    require Carp;  
    Carp::croak("Can't write-open $outpath: $!");
  }
  
  #==========================================================================
  
  sub add_css {
    my($self, $url, $is_default, $name, $content_type, $media, $_code) = @_;
    return unless $url;
    unless($name) {
      # cook up a reasonable name based on the URL
      $name = $url;
      if( $name !~ m/\?/ and $name =~ m{([^/]+)$}s ) {
        $name = $1;
        $name =~ s/\.css//i;
      }
    }
    $media        ||= 'all';
    $content_type ||= 'text/css';
    
    my $bunch = [$url, $name, $content_type, $media, $_code];
    if($is_default) { unshift @{ $self->_css_wad }, $bunch }
    else            { push    @{ $self->_css_wad }, $bunch }
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _spray_css {
    my($self, $outdir) = @_;
  
    return unless $self->css_flurry();
    $self->_gen_css_wad();
  
    my $lol = $self->_css_wad;
    foreach my $chunk (@$lol) {
      my $url = $chunk->[0];
      my $outfile;
      if( ref($chunk->[-1]) and $url =~ m{^(_[-a-z0-9_]+\.css$)} ) {
        $outfile = $self->filespecsys->catfile( $outdir, "$1" );
        DEBUG > 5 and print STDERR "Noting $$chunk[0] as a file I'll create.\n";
      } else {
        DEBUG > 5 and print STDERR "OK, noting $$chunk[0] as an external CSS.\n";
        # Requires no further attention.
        next;
      }
      
      #$self->muse( "Writing autogenerated CSS file $outfile" );
      my $Cssout = $self->_wopen($outfile);
      print $Cssout ${$chunk->[-1]}
       or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Cssout);
      DEBUG > 5 and print STDERR "Wrote $outfile\n";
    }
  
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _css_wad_to_markup {
    my($self, $depth) = @_;
    
    my @css  = @{ $self->_css_wad || return '' };
    return '' unless @css;
    
    my $rel = 'stylesheet';
    my $out = '';
  
    --$depth;
    my $uplink = $depth ? ('../' x $depth) : '';
  
    foreach my $chunk (@css) {
      next unless $chunk and @$chunk;
  
      my( $url1, $url2, $title, $type, $media) = (
        $self->_maybe_uplink( $chunk->[0], $uplink ),
        esc(grep !ref($_), @$chunk)
      );
  
      $out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};
  
      $rel = 'alternate stylesheet'; # alternates = all non-first iterations
    }
    return $out;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub _maybe_uplink {
    # if the given URL looks relative, return the given uplink string --
    # otherwise return emptystring
    my($self, $url, $uplink) = @_;
    ($url =~ m{^\./} or $url !~ m{[/\:]} )
      ? $uplink
      : ''
      # qualify it, if/as needed
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub _gen_css_wad {
    my $self = $_[0];
    my $css_template = $self->_css_template;
    foreach my $variation (
  
     # Commented out for sake of concision:
     #
     #  011n=black_with_red_on_white
     #  001n=black_with_yellow_on_white
     #  101n=black_with_green_on_white
     #  110=white_with_yellow_on_black
     #  010=white_with_green_on_black
     #  011=white_with_blue_on_black
     #  100=white_with_red_on_black
      '110n=blkbluw',  # black_with_blue_on_white
      '010n=blkmagw',  # black_with_magenta_on_white
      '100n=blkcynw',  # black_with_cyan_on_white
      '101=whtprpk',   # white_with_purple_on_black
      '001=whtnavk',   # white_with_navy_blue_on_black
      '010a=grygrnk',  # grey_with_green_on_black
      '010b=whtgrng',  # white_with_green_on_grey
      '101an=blkgrng', # black_with_green_on_grey
      '101bn=grygrnw', # grey_with_green_on_white
    ) {
  
      my $outname = $variation;
      my($flipmode, @swap) = ( ($4 || ''), $1,$2,$3)
        if $outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;
      @swap = () if '010' eq join '', @swap; # 010 is a swop-no-op!
    
      my $this_css =
        "/* This file is autogenerated.  Do not edit.  $variation */\n\n"
        . $css_template;
  
      # Only look at three-digitty colors, for now at least.
      if( $flipmode =~ m/n/ ) {
        $this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;
        $this_css =~ s/\bthin\b/medium/g;
      }
      $this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg   if @swap;
  
      if(   $flipmode =~ m/a/)
         { $this_css =~ s/#fff\b/#999/gi } # black -> dark grey
      elsif($flipmode =~ m/b/)
         { $this_css =~ s/#000\b/#666/gi } # white -> light grey
  
      my $name = $outname;    
      $name =~ tr/-_/  /;
      $self->add_css( "_$outname.css", 0, $name, 0, 0, \$this_css);
    }
  
    # Now a few indexless variations:
    for (my ($outfile, $variation) = each %{{
        blkbluw => 'black_with_blue_on_white',
        whtpurk => 'white_with_purple_on_black',
        whtgrng => 'white_with_green_on_grey',
        grygrnw => 'grey_with_green_on_white',
    }}) {
      my $this_css = join "\n",
        "/* This file is autogenerated.  Do not edit.  $outfile */\n",
        "\@import url(\"./_$variation.css\");",
        ".indexgroup { display: none; }",
        "\n",
      ;
      my $name = $outfile;
      $name =~ tr/-_/  /;
      $self->add_css( "_$outfile.css", 0, $name, 0, 0, \$this_css);
    }
  
    return;
  }
  
  sub _color_negate {
    my $x = lc $_[0];
    $x =~ tr[0123456789abcdef]
            [fedcba9876543210];
    return $x;
  }
  
  #===========================================================================
  
  sub add_javascript {
    my($self, $url, $content_type, $_code) = @_;
    return unless $url;
    push  @{ $self->_javascript_wad }, [
      $url, $content_type || 'text/javascript', $_code
    ];
    return;
  }
  
  sub _spray_javascript {
    my($self, $outdir) = @_;
    return unless $self->javascript_flurry();
    $self->_gen_javascript_wad();
  
    my $lol = $self->_javascript_wad;
    foreach my $script (@$lol) {
      my $url = $script->[0];
      my $outfile;
      
      if( ref($script->[-1]) and $url =~ m{^(_[-a-z0-9_]+\.js$)} ) {
        $outfile = $self->filespecsys->catfile( $outdir, "$1" );
        DEBUG > 5 and print STDERR "Noting $$script[0] as a file I'll create.\n";
      } else {
        DEBUG > 5 and print STDERR "OK, noting $$script[0] as an external JavaScript.\n";
        next;
      }
      
      #$self->muse( "Writing JavaScript file $outfile" );
      my $Jsout = $self->_wopen($outfile);
  
      print $Jsout ${$script->[-1]}
       or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Jsout);
      DEBUG > 5 and print STDERR "Wrote $outfile\n";
    }
  
    return;
  }
  
  sub _gen_javascript_wad {
    my $self = $_[0];
    my $js_code = $self->_javascript || return;
    $self->add_javascript( "_podly.js", 0, \$js_code);
    return;
  }
  
  sub _javascript_wad_to_markup {
    my($self, $depth) = @_;
    
    my @scripts  = @{ $self->_javascript_wad || return '' };
    return '' unless @scripts;
    
    my $out = '';
  
    --$depth;
    my $uplink = $depth ? ('../' x $depth) : '';
  
    foreach my $s (@scripts) {
      next unless $s and @$s;
  
      my( $url1, $url2, $type, $media) = (
        $self->_maybe_uplink( $s->[0], $uplink ),
        esc(grep !ref($_), @$s)
      );
  
      $out .= qq{<script type="$type" src="$url1$url2"></script>\n};
    }
    return $out;
  }
  
  #===========================================================================
  
  sub _css_template { return $CSS }
  sub _javascript   { return $JAVASCRIPT }
  
  $CSS = <<'EOCSS';
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3,
    body.pod h4, body.pod h5, body.pod h6  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
    
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
    body.pod h5  { border-top-color: #010; }
    body.pod h6  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h5 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h6 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
    
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
    
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
    
  }
  
  /* The End */
  
  EOCSS
  
  #==========================================================================
  
  $JAVASCRIPT = <<'EOJAVASCRIPT';
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  1;
  __END__
  
  
  =head1 NAME
  
  Pod::Simple::HTMLBatch - convert several Pod files to several HTML files
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::HTMLBatch -e 'Pod::Simple::HTMLBatch::go' in out
  
  
  =head1 DESCRIPTION
  
  This module is used for running batch-conversions of a lot of HTML
  documents 
  
  This class is NOT a subclass of Pod::Simple::HTML
  (nor of bad old Pod::Html) -- although it uses
  Pod::Simple::HTML for doing the conversion of each document.
  
  The normal use of this class is like so:
  
    use Pod::Simple::HTMLBatch;
    my $batchconv = Pod::Simple::HTMLBatch->new;
    $batchconv->some_option( some_value );
    $batchconv->some_other_option( some_other_value );
    $batchconv->batch_convert( \@search_dirs, $output_dir );
  
  =head2 FROM THE COMMAND LINE
  
  Note that this class also provides
  (but does not export) the function Pod::Simple::HTMLBatch::go.
  This is basically just a shortcut for C<<
  Pod::Simple::HTMLBatch->batch_convert(@ARGV) >>.
  It's meant to be handy for calling from the command line.
  
  However, the shortcut requires that you specify exactly two command-line
  arguments, C<indirs> and C<outdir>.
  
  Example:
  
    % mkdir out_html
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go @INC out_html
        (to convert the pod from Perl's @INC
         files under the directory ./out_html)
  
  (Note that the command line there contains a literal atsign-I-N-C.  This
  is handled as a special case by batch_convert, in order to save you having
  to enter the odd-looking "" as the first command-line parameter when you
  mean "just use whatever's in @INC".)
  
  Example:
  
    % mkdir ../seekrut
    % chmod og-rx ../seekrut
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go . ../seekrut
        (to convert the pod under the current dir into HTML
         files under the directory ./seekrut)
  
  Example:
  
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go happydocs .
        (to convert all pod from happydocs into the current directory)
  
  
  
  =head1 MAIN METHODS
  
  =over
  
  =item $batchconv = Pod::Simple::HTMLBatch->new;
  
  This creates a new batch converter.  The method doesn't take parameters.
  To change the converter's attributes, use the L<"/ACCESSOR METHODS">
  below.
  
  =item $batchconv->batch_convert( I<indirs>, I<outdir> );
  
  This searches the directories given in I<indirs> and writes
  HTML files for each of these to a corresponding directory
  in I<outdir>.  The directory I<outdir> must exist.
  
  =item $batchconv->batch_convert( undef    , ...);
  
  =item $batchconv->batch_convert( q{@INC}, ...);
  
  These two values for I<indirs> specify that the normal Perl @INC
  
  =item $batchconv->batch_convert( \@dirs , ...);
  
  This specifies that the input directories are the items in
  the arrayref C<\@dirs>.
  
  =item $batchconv->batch_convert( "somedir" , ...);
  
  This specifies that the director "somedir" is the input.
  (This can be an absolute or relative path, it doesn't matter.)
  
  A common value you might want would be just "." for the current
  directory:
  
       $batchconv->batch_convert( "." , ...);
  
  
  =item $batchconv->batch_convert( 'somedir:someother:also' , ...);
  
  This specifies that you want the dirs "somedir", "someother", and "also"
  scanned, just as if you'd passed the arrayref
  C<[qw( somedir someother also)]>.  Note that a ":"-separator is normal
  under Unix, but Under MSWin, you'll need C<'somedir;someother;also'>
  instead, since the pathsep on MSWin is ";" instead of ":".  (And
  I<that> is because ":" often comes up in paths, like
  C<"c:/perl/lib">.)
  
  (Exactly what separator character should be used, is gotten from
  C<$Config::Config{'path_sep'}>, via the L<Config> module.)
  
  =item $batchconv->batch_convert( ... , undef );
  
  This specifies that you want the HTML output to go into the current
  directory.
  
  (Note that a missing or undefined value means a different thing in
  the first slot than in the second.  That's so that C<batch_convert()>
  with no arguments (or undef arguments) means "go from @INC, into
  the current directory.)
  
  =item $batchconv->batch_convert( ... , 'somedir' );
  
  This specifies that you want the HTML output to go into the
  directory 'somedir'.
  (This can be an absolute or relative path, it doesn't matter.)
  
  =back
  
  
  Note that you can also call C<batch_convert> as a class method,
  like so:
  
    Pod::Simple::HTMLBatch->batch_convert( ... );
  
  That is just short for this:
  
    Pod::Simple::HTMLBatch-> new-> batch_convert(...);
  
  That is, it runs a conversion with default options, for
  whatever inputdirs and output dir you specify.
  
  
  =head2 ACCESSOR METHODS
  
  The following are all accessor methods -- that is, they don't do anything
  on their own, but just alter the contents of the conversion object,
  which comprises the options for this particular batch conversion.
  
  We show the "put" form of the accessors below (i.e., the syntax you use
  for setting the accessor to a specific value).  But you can also
  call each method with no parameters to get its current value.  For
  example, C<< $self->contents_file() >> returns the current value of
  the contents_file attribute.
  
  =over
  
  
  =item $batchconv->verbose( I<nonnegative_integer> );
  
  This controls how verbose to be during batch conversion, as far as
  notes to STDOUT (or whatever is C<select>'d) about how the conversion
  is going.  If 0, no progress information is printed.
  If 1 (the default value), some progress information is printed.
  Higher values print more information.
  
  
  =item $batchconv->index( I<true-or-false> );
  
  This controls whether or not each HTML page is liable to have a little
  table of contents at the top (which we call an "index" for historical
  reasons).  This is true by default.
  
  
  =item $batchconv->contents_file( I<filename> );
  
  If set, should be the name of a file (in the output directory)
  to write the HTML index to.  The default value is "index.html".
  If you set this to a false value, no contents file will be written.
  
  =item $batchconv->contents_page_start( I<HTML_string> );
  
  This specifies what string should be put at the beginning of
  the contents page.
  The default is a string more or less like this:
  
    <html>
    <head><title>Perl Documentation</title></head>
    <body class='contentspage'>
    <h1>Perl Documentation</h1>
  
  =item $batchconv->contents_page_end( I<HTML_string> );
  
  This specifies what string should be put at the end of the contents page.
  The default is a string more or less like this:
  
    <p class='contentsfooty'>Generated by
    Pod::Simple::HTMLBatch v3.01 under Perl v5.008
    <br >At Fri May 14 22:26:42 2004 GMT,
    which is Fri May 14 14:26:42 2004 local time.</p>
  
  
  
  =item $batchconv->add_css( $url );
  
  TODO
  
  =item $batchconv->add_javascript( $url );
  
  TODO
  
  =item $batchconv->css_flurry( I<true-or-false> );
  
  If true (the default value), we autogenerate some CSS files in the
  output directory, and set our HTML files to use those.
  TODO: continue
  
  =item $batchconv->javascript_flurry( I<true-or-false> );
  
  If true (the default value), we autogenerate a JavaScript in the
  output directory, and set our HTML files to use it.  Currently,
  the JavaScript is used only to get the browser to remember what
  stylesheet it prefers.
  TODO: continue
  
  =item $batchconv->no_contents_links( I<true-or-false> );
  
  TODO
  
  =item $batchconv->html_render_class( I<classname> );
  
  This sets what class is used for rendering the files.
  The default is "Pod::Simple::HTML".  If you set it to something else,
  it should probably be a subclass of Pod::Simple::HTML, and you should
  C<require> or C<use> that class so that's it's loaded before
  Pod::Simple::HTMLBatch tries loading it.
  
  =item $batchconv->search_class( I<classname> );
  
  This sets what class is used for searching for the files.
  The default is "Pod::Simple::Search".  If you set it to something else,
  it should probably be a subclass of Pod::Simple::Search, and you should
  C<require> or C<use> that class so that's it's loaded before
  Pod::Simple::HTMLBatch tries loading it.
  
  =back
  
  
  
  
  =head1 NOTES ON CUSTOMIZATION
  
  TODO
  
    call add_css($someurl) to add stylesheet as alternate
    call add_css($someurl,1) to add as primary stylesheet
  
    call add_javascript
  
    subclass Pod::Simple::HTML and set $batchconv->html_render_class to
      that classname
    and maybe override
      $page->batch_mode_page_object_init($self, $module, $infile, $outfile, $depth)
    or maybe override
      $batchconv->batch_mode_page_object_init($page, $module, $infile, $outfile, $depth)
    subclass Pod::Simple::Search and set $batchconv->search_class to
      that classname
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::HTMLBatch>, L<perlpod>, L<perlpodspec>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  
  require 5;
  package Pod::Simple::HTMLLegacy;
  use strict;
  
  use vars qw($VERSION);
  use Getopt::Long;
  
  $VERSION = "5.01";
  
  #--------------------------------------------------------------------------
  # 
  # This class is meant to thinly emulate bad old Pod::Html
  #
  # TODO: some basic docs
  
  sub pod2html {
    my @args = (@_);
    
    my( $verbose, $infile, $outfile, $title );
    my $index = 1;
   
    {
      my($help);
  
      my($netscape); # dummy
      local @ARGV = @args;
      GetOptions(
        "help"       => \$help,
        "verbose!"   => \$verbose,
        "infile=s"   => \$infile,
        "outfile=s"  => \$outfile,
        "title=s"    => \$title,
        "index!"     => \$index,
  
        "netscape!"   => \$netscape,
      ) or return bad_opts(@args);
      bad_opts(@args) if @ARGV; # it should be all switches!
      return help_message() if $help;
    }
  
    for($infile, $outfile) { $_ = undef unless defined and length }
    
    if($verbose) {
      warn sprintf "%s version %s\n", __PACKAGE__, $VERSION;
      warn "OK, processed args [@args] ...\n";
      warn sprintf
        " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",
        map defined($_) ? $_ : "(nil)",
         $verbose,     $index,     $infile,     $outfile,     $title,
      ;
      *Pod::Simple::HTML::DEBUG = sub(){1};
    }
    require Pod::Simple::HTML;
    Pod::Simple::HTML->VERSION(3);
    
    die "No such input file as $infile\n"
     if defined $infile and ! -e $infile;
  
    
    my $pod = Pod::Simple::HTML->new;
    $pod->force_title($title) if defined $title;
    $pod->index($index);
    return $pod->parse_from_file($infile, $outfile);
  }
  
  #--------------------------------------------------------------------------
  
  sub bad_opts     { die _help_message();         }
  sub help_message { print STDOUT _help_message() }
  
  #--------------------------------------------------------------------------
  
  sub _help_message {
  
    join '',
  
  "[", __PACKAGE__, " version ", $VERSION, qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~;
  
  }
  
  1;
  __END__
  
  OVER the underpass! UNDER the overpass! Around the FUTURE and BEYOND REPAIR!!
  
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/JustPod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_JUSTPOD';
  use 5;
  package Pod::Simple::JustPod;
  # ABSTRACT: Pod::Simple formatter that extracts POD from a file containing
  #           other things as well
  use strict;
  use warnings;
  
  use Pod::Simple::Methody ();
  our @ISA = ('Pod::Simple::Methody');
  
  sub new {
    my $self = shift;
    my $new  = $self->SUPER::new(@_);
  
    $new->accept_targets('*');
    $new->keep_encoding_directive(1);
    $new->preserve_whitespace(1);
    $new->complain_stderr(1);
    $new->_output_is_for_JustPod(1);
  
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub check_that_all_is_closed {
  
    # Actually checks that the things we depend on being balanced in fact are,
    # so that we can continue in spit of pod errors
  
    my $self = shift;
    while ($self->{inL}) {
      $self->end_L(@_);
    }
    while ($self->{fcode_end} && @{$self->{fcode_end}}) {
      $self->_end_fcode(@_);
    }
  }
  
  sub handle_text {
  
    # Add text to the output buffer.  This is skipped if within a L<>, as we use
    # the 'raw' attribute of that tag instead.
  
    $_[0]{buffer} .= $_[1] unless $_[0]{inL} ;
  }
  
  sub spacer {
  
    # Prints the white space following things like =head1.  This is normally a
    # blank, unless BlackBox has told us otherwise.
  
    my ($self, $arg) = @_;
    return unless $arg;
  
    my $spacer = ($arg->{'~orig_spacer'})
                  ? $arg->{'~orig_spacer'}
                  : " ";
    $self->handle_text($spacer);
  }
  
  sub _generic_start {
  
    # Called from tags like =head1, etc.
  
    my ($self, $text, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text($text);
    $self->spacer($arg);
  }
  
  sub start_Document    { shift->_generic_start("=pod\n\n"); }
  sub start_head1       { shift->_generic_start('=head1', @_); }
  sub start_head2       { shift->_generic_start('=head2', @_); }
  sub start_head3       { shift->_generic_start('=head3', @_); }
  sub start_head4       { shift->_generic_start('=head4', @_); }
  sub start_head5       { shift->_generic_start('=head5', @_); }
  sub start_head6       { shift->_generic_start('=head6', @_); }
  sub start_encoding    { shift->_generic_start('=encoding', @_); }
  # sub start_Para
  # sub start_Verbatim
  
  sub start_item_bullet { # Handle =item *
    my ($self, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text('=item');
  
    # It can be that they said simply '=item', and it is inferred that it is to
    # be a bullet.
    if (! $arg->{'~orig_content'}) {
      $self->handle_text("\n\n");
    }
    else {
      $self->spacer($arg);
      if ($arg->{'~_freaky_para_hack'}) {
  
          # See Message Id <87y3gtcwa2.fsf@hope.eyrie.org>
          my $item_text = $arg->{'~orig_content'};
          my $trailing = quotemeta $arg->{'~_freaky_para_hack'};
          $item_text =~ s/$trailing$//;
          $self->handle_text($item_text);
      }
      else {
          $self->handle_text("*\n\n");
      }
    }
  }
  
  sub start_item_number {     # Handle '=item 2'
    my ($self, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text("=item");
    $self->spacer($arg);
    $self->handle_text("$arg->{'~orig_content'}\n\n");
  }
  
  sub start_item_text {   # Handle '=item foo bar baz'
    my ($self, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text('=item');
    $self->spacer($arg);
  }
  
  sub _end_item {
    my $self = shift;
    $self->check_that_all_is_closed();
    $self->emit;
  }
  
  *end_item_bullet = *_end_item;
  *end_item_number = *_end_item;
  *end_item_text   = *_end_item;
  
  sub _start_over  {  # Handle =over
    my ($self, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text("=over");
  
    # The =over amount is optional
    if ($arg->{'~orig_content'}) {
      $self->spacer($arg);
      $self->handle_text("$arg->{'~orig_content'}");
    }
    $self->handle_text("\n\n");
  }
  
  *start_over_bullet = *_start_over;
  *start_over_number = *_start_over;
  *start_over_text   = *_start_over;
  *start_over_block  = *_start_over;
  
  sub _end_over  {
    my $self = shift;
    $self->check_that_all_is_closed();
    $self->handle_text('=back');
    $self->emit;
  }
  
  *end_over_bullet = *_end_over;
  *end_over_number = *_end_over;
  *end_over_text   = *_end_over;
  *end_over_block  = *_end_over;
  
  sub end_Document    {
    my $self = shift;
    $self->emit;        # Make sure buffer gets flushed
    print {$self->{'output_fh'} } "=cut\n"
  }
  
  sub _end_generic  {
    my $self = shift;
    $self->check_that_all_is_closed();
    $self->emit;
  }
  
  *end_head1    = *_end_generic;
  *end_head2    = *_end_generic;
  *end_head3    = *_end_generic;
  *end_head4    = *_end_generic;
  *end_head5    = *_end_generic;
  *end_head6    = *_end_generic;
  *end_encoding = *_end_generic;
  *end_Para     = *_end_generic;
  *end_Verbatim = *_end_generic;
  
  sub _start_fcode {
    my ($type, $self, $flags) = @_;
  
    # How many brackets is set by BlackBox unless the count is 1
    my $bracket_count = (exists $flags->{'~bracket_count'})
                         ? $flags->{'~bracket_count'}
                         : 1;
    $self->handle_text($type . ( "<" x $bracket_count));
  
    my $rspacer = "";
    if ($bracket_count > 1) {
      my $lspacer = (exists $flags->{'~lspacer'})
                    ? $flags->{'~lspacer'}
                    : " ";
      $self->handle_text($lspacer);
  
      $rspacer = (exists $flags->{'~rspacer'})
                    ? $flags->{'~rspacer'}
                    : " ";
    }
  
    # BlackBox doesn't output things for for the ending code callbacks, so save
    # what we need.
    push @{$self->{'fcode_end'}}, [ $bracket_count, $rspacer ];
  }
  
  sub start_B { _start_fcode('B', @_); }
  sub start_C { _start_fcode('C', @_); }
  sub start_E { _start_fcode('E', @_); }
  sub start_F { _start_fcode('F', @_); }
  sub start_I { _start_fcode('I', @_); }
  sub start_S { _start_fcode('S', @_); }
  sub start_X { _start_fcode('X', @_); }
  sub start_Z { _start_fcode('Z', @_); }
  
  sub _end_fcode {
      my $self = shift;
      my $fcode_end = pop @{$self->{'fcode_end'}};
      my $bracket_count = 1;
      my $rspacer = "";
  
      if (! defined $fcode_end) { # If BlackBox is working, this shouldn't
                                  # happen, but verify
        $self->whine($self->{line_count}, "Extra '>'");
      }
      else {
        $bracket_count = $fcode_end->[0];
        $rspacer = $fcode_end->[1];
      }
  
      $self->handle_text($rspacer) if $bracket_count > 1;
      $self->handle_text(">" x $bracket_count);
  }
  
  *end_B   = *_end_fcode;
  *end_C   = *_end_fcode;
  *end_E   = *_end_fcode;
  *end_F   = *_end_fcode;
  *end_I   = *_end_fcode;
  *end_S   = *_end_fcode;
  *end_X   = *_end_fcode;
  *end_Z   = *_end_fcode;
  
  sub start_L {
      _start_fcode('L', @_);
      $_[0]->handle_text($_[1]->{raw});
      $_[0]->{inL}++
  }
  
  sub end_L {
    my $self = shift;
    $self->{inL}--;
    if ($self->{inL} < 0) {   # If BlackBox is working, this shouldn't
                              # happen, but verify
      $self->whine($self->{line_count}, "Extra '>' ending L<>");
      $self->{inL} = 0;
    }
  
    $self->_end_fcode(@_);
  }
  
  sub emit {
    my $self = shift;
  
    if ($self->{buffer} ne "") {
      print { $self->{'output_fh'} } "",$self->{buffer} ,"\n\n";
  
      $self->{buffer} = "";
    }
  
    return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::JustPod -- just the Pod, the whole Pod, and nothing but the Pod
  
  =head1 SYNOPSIS
  
   my $infile  = "mixed_code_and_pod.pm";
   my $outfile = "just_the_pod.pod";
   open my $fh, ">$outfile" or die "Can't write to $outfile: $!";
  
   my $parser = Pod::Simple::JustPod->new();
   $parser->output_fh($fh);
   $parser->parse_file($infile);
   close $fh or die "Can't close $outfile: $!";
  
  =head1 DESCRIPTION
  
  This class returns a copy of its input, translated into Perl's internal
  encoding (UTF-8), and with all the non-Pod lines removed.
  
  This is a subclass of L<Pod::Simple::Methody> and inherits all its methods.
  And since, that in turn is a subclass of L<Pod::Simple>, you can use any of
  its methods.  This means you can output to a string instead of a file, or
  you can parse from an array.
  
  This class strives to return the Pod lines of the input completely unchanged,
  except for any necessary translation into Perl's internal encoding, and it makes
  no effort to return trailing spaces on lines; these likely will be stripped.
  If the input pod is well-formed with no warnings nor errors generated, the
  extracted pod should generate the same documentation when formatted by a Pod
  formatter as the original file does.
  
  By default, warnings are output to STDERR
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Methody>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  L<mailto:pod-people@perl.org> mail list. Send an empty email to
  L<mailto:pod-people-subscribe@perl.org> to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/theory/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/theory/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  L<mailto:<bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  Pod::Simple::JustPod was developed by John SJ Anderson
  C<genehack@genehack.org>, with contributions from Karl Williamson
  C<khw@cpan.org>.
  
  =cut
POD_SIMPLE_JUSTPOD

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  
  require 5;
  package Pod::Simple::LinkSection;
    # Based somewhat dimly on Array::Autojoin
  
  use strict;
  use Pod::Simple::BlackBox;
  use vars qw($VERSION );
  $VERSION = '3.43';
  
  use overload( # So it'll stringify nice
    '""'   => \&Pod::Simple::BlackBox::stringify_lol,
    'bool' => \&Pod::Simple::BlackBox::stringify_lol,
    # '.='   => \&tack_on,  # grudgingly support
    
    'fallback' => 1,         # turn on cleverness
  );
  
  sub tack_on {
    $_[0] = ['', {}, "$_[0]" ];
    return $_[0][2] .= $_[1];
  }
  
  sub as_string {
    goto &Pod::Simple::BlackBox::stringify_lol;
  }
  sub stringify {
    goto &Pod::Simple::BlackBox::stringify_lol;
  }
  
  sub new {
    my $class = shift;
    $class = ref($class) || $class;
    my $new;
    if(@_ == 1) {
      if (!ref($_[0] || '')) { # most common case: one bare string
        return bless ['', {}, $_[0] ], $class;
      } elsif( ref($_[0] || '') eq 'ARRAY') {
        $new = [ @{ $_[0] } ];
      } else {
        Carp::croak( "$class new() doesn't know to clone $new" );
      }
    } else { # misc stuff
      $new = [ '', {}, @_ ];
    }
  
    # By now it's a treelet:  [ 'foo', {}, ... ]
    foreach my $x (@$new) {
      if(ref($x || '') eq 'ARRAY') {
        $x = $class->new($x); # recurse
      } elsif(ref($x || '') eq 'HASH') {
        $x = { %$x };
      }
       # otherwise leave it.
    }
  
    return bless $new, $class;
  }
  
  # Not much in this class is likely to be link-section specific --
  # but it just so happens that link-sections are about the only treelets
  # that are exposed to the user.
  
  1;
  
  __END__
  
  # TODO: let it be an option whether a given subclass even wants little treelets?
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::LinkSection -- represent "section" attributes of L codes
  
  =head1 SYNOPSIS
  
   # a long story
  
  =head1 DESCRIPTION
  
  This class is not of interest to general users.
  
  Pod::Simple uses this class for representing the value of the
  "section" attribute of "L" start-element events.  Most applications
  can just use the normal stringification of objects of this class;
  they stringify to just the text content of the section,
  such as "foo" for
  C<< LZ<><Stuff/foo> >>, and "bar" for 
  C<< LZ<><Stuff/bIZ<><ar>> >>.
  
  However, anyone particularly interested in getting the full value of
  the treelet, can just traverse the content of the treeleet
  @$treelet_object.  To wit:
  
  
    % perl -MData::Dumper -e
      "use base qw(Pod::Simple::Methody);
       sub start_L { print Dumper($_[1]{'section'} ) }
       __PACKAGE__->new->parse_string_document('=head1 L<Foo/bI<ar>baz>>')
      "
  Output:
    $VAR1 = bless( [
                     '',
                     {},
                     'b',
                     bless( [
                              'I',
                              {},
                              'ar'
                            ], 'Pod::Simple::LinkSection' ),
                     'baz'
                   ], 'Pod::Simple::LinkSection' );
  
  But stringify it and you get just the text content:
  
    % perl -MData::Dumper -e
      "use base qw(Pod::Simple::Methody);
       sub start_L { print Dumper( '' . $_[1]{'section'} ) }
       __PACKAGE__->new->parse_string_document('=head1 L<Foo/bI<ar>baz>>')
      "
  Output:
    $VAR1 = 'barbaz';
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  
  require 5;
  package Pod::Simple::Methody;
  use strict;
  use Pod::Simple ();
  use vars qw(@ISA $VERSION);
  $VERSION = '3.43';
  @ISA = ('Pod::Simple');
  
  # Yes, we could use named variables, but I want this to be impose
  # as little an additional performance hit as possible.
  
  sub _handle_element_start {
    $_[1] =~ tr/-:./__/;
    ( $_[0]->can( 'start_' . $_[1] )
      || return
    )->(
      $_[0], $_[2]
    );
  }
  
  sub _handle_text {
    ( $_[0]->can( 'handle_text' )
      || return
    )->(
      @_
    );
  }
  
  sub _handle_element_end {
    $_[1] =~ tr/-:./__/;
    ( $_[0]->can( 'end_' . $_[1] )
      || return
    )->(
      $_[0], $_[2]
    );
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Methody -- turn Pod::Simple events into method calls
  
  =head1 SYNOPSIS
  
   require 5;
   use strict;
   package SomePodFormatter;
   use base qw(Pod::Simple::Methody);
  
   sub handle_text {
     my($self, $text) = @_;
     ...
   }
  
   sub start_head1 {
     my($self, $attrs) = @_;
     ...
   }
   sub end_head1 {
     my($self) = @_;
     ...
   }
  
  ...and start_/end_ methods for whatever other events you want to catch.
  
  =head1 DESCRIPTION
  
  This class is of
  interest to people writing Pod formatters based on Pod::Simple.
  
  This class (which is very small -- read the source) overrides
  Pod::Simple's _handle_element_start, _handle_text, and
  _handle_element_end methods so that parser events are turned into method
  calls. (Otherwise, this is a subclass of L<Pod::Simple> and inherits all
  its methods.)
  
  You can use this class as the base class for a Pod formatter/processor.
  
  =head1 METHOD CALLING
  
  When Pod::Simple sees a "=head1 Hi there", for example, it basically does
  this:
  
    $parser->_handle_element_start( "head1", \%attributes );
    $parser->_handle_text( "Hi there" );
    $parser->_handle_element_end( "head1" );
  
  But if you subclass Pod::Simple::Methody, it will instead do this
  when it sees a "=head1 Hi there":
  
    $parser->start_head1( \%attributes ) if $parser->can('start_head1');
    $parser->handle_text( "Hi there" )   if $parser->can('handle_text');
    $parser->end_head1()                 if $parser->can('end_head1');
  
  If Pod::Simple sends an event where the element name has a dash,
  period, or colon, the corresponding method name will have a underscore
  in its place.  For example, "foo.bar:baz" becomes start_foo_bar_baz
  and end_foo_bar_baz.
  
  See the source for Pod::Simple::Text for an example of using this class.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  
  require 5;
  package Pod::Simple::Progress;
  $VERSION = '3.43';
  use strict;
  
  # Objects of this class are used for noting progress of an
  #  operation every so often.  Messages delivered more often than that
  #  are suppressed.
  #
  # There's actually nothing in here that's specific to Pod processing;
  #  but it's ad-hoc enough that I'm not willing to give it a name that
  #  implies that it's generally useful, like "IO::Progress" or something.
  #
  # -- sburke
  #
  #--------------------------------------------------------------------------
  
  sub new {
    my($class,$delay) = @_;
    my $self = bless {'quiet_until' => 1},  ref($class) || $class;
    $self->to(*STDOUT{IO});
    $self->delay(defined($delay) ? $delay : 5);
    return $self;
  }
  
  sub copy { 
    my $orig = shift;
    bless {%$orig, 'quiet_until' => 1}, ref($orig);
  }
  #--------------------------------------------------------------------------
  
  sub reach {
    my($self, $point, $note) = @_;
    if( (my $now = time) >= $self->{'quiet_until'}) {
      my $goal;
      my    $to = $self->{'to'};
      print $to join('',
        ($self->{'quiet_until'} == 1) ? () : '... ',
        (defined $point) ? (
          '#',
          ($goal = $self->{'goal'}) ? (
            ' ' x (length($goal) - length($point)),
            $point, '/', $goal,
          ) : $point,
          $note ? ': ' : (),
        ) : (),
        $note || '',
        "\n"
      );
      $self->{'quiet_until'} = $now + $self->{'delay'};
    }
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub done {
    my($self, $note) = @_;
    $self->{'quiet_until'} = 1;
    return $self->reach( undef, $note );
  }
  
  #--------------------------------------------------------------------------
  # Simple accessors:
  
  sub delay {
    return $_[0]{'delay'} if @_ == 1; $_[0]{'delay'} = $_[1]; return $_[0] }
  sub goal {
    return $_[0]{'goal' } if @_ == 1; $_[0]{'goal' } = $_[1]; return $_[0] }
  sub to   {
    return $_[0]{'to'   } if @_ == 1; $_[0]{'to'   } = $_[1]; return $_[0] }
  
  #--------------------------------------------------------------------------
  
  unless(caller) { # Simple self-test:
    my $p = __PACKAGE__->new->goal(5);
    $p->reach(1, "Primus!");
    sleep 1;
    $p->reach(2, "Secundus!");
    sleep 3;
    $p->reach(3, "Tertius!");
    sleep 5;
    $p->reach(4);
    $p->reach(5, "Quintus!");
    sleep 1;
    $p->done("All done");
  }
  
  #--------------------------------------------------------------------------
  1;
  __END__
  
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  require 5;
  package Pod::Simple::PullParser;
  $VERSION = '3.43';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  use Carp ();
  
  use Pod::Simple::PullParserStartToken;
  use Pod::Simple::PullParserEndToken;
  use Pod::Simple::PullParserTextToken;
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  __PACKAGE__->_accessorize(
    'source_fh',         # the filehandle we're reading from
    'source_scalar_ref', # the scalarref we're reading from
    'source_arrayref',   # the arrayref we're reading from
  );
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  #  And here is how we implement a pull-parser on top of a push-parser...
  
  sub filter {
    my($self, $source) = @_;
    $self = $self->new unless ref $self;
  
    $source = *STDIN{IO} unless defined $source;
    $self->set_source($source);
    $self->output_fh(*STDOUT{IO});
  
    $self->run; # define run() in a subclass if you want to use filter()!
    return $self;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub parse_string_document {
    my $this = shift;
    $this->set_source(\ $_[0]);
    $this->run;
  }
  
  sub parse_file {
    my($this, $filename) = @_;
    $this->set_source($filename);
    $this->run;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #  In case anyone tries to use them:
  
  sub run {
    use Carp ();
    if( __PACKAGE__ eq ref($_[0]) || $_[0]) { # I'm not being subclassed!
      Carp::croak "You can call run() only on subclasses of "
       . __PACKAGE__;
    } else {
      Carp::croak join '',
        "You can't call run() because ",
        ref($_[0]) || $_[0], " didn't define a run() method";
    }
  }
  
  sub parse_lines {
    use Carp ();
    Carp::croak "Use set_source with ", __PACKAGE__,
      " and subclasses, not parse_lines";
  }
  
  sub parse_line {
    use Carp ();
    Carp::croak "Use set_source with ", __PACKAGE__,
      " and subclasses, not parse_line";
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $class = shift;
    my $self = $class->SUPER::new(@_);
    die "Couldn't construct for $class" unless $self;
  
    $self->{'token_buffer'} ||= [];
    $self->{'start_token_class'} ||= 'Pod::Simple::PullParserStartToken';
    $self->{'text_token_class'}  ||= 'Pod::Simple::PullParserTextToken';
    $self->{'end_token_class'}   ||= 'Pod::Simple::PullParserEndToken';
  
    DEBUG > 1 and print STDERR "New pullparser object: $self\n";
  
    return $self;
  }
  
  # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
  sub get_token {
    my $self = shift;
    DEBUG > 1 and print STDERR "\nget_token starting up on $self.\n";
    DEBUG > 2 and print STDERR " Items in token-buffer (",
     scalar( @{ $self->{'token_buffer'} } ) ,
     ") :\n", map(
       "    " . $_->dump . "\n", @{ $self->{'token_buffer'} }
     ),
     @{ $self->{'token_buffer'} } ? '' : '       (no tokens)',
     "\n"
    ;
  
    until( @{ $self->{'token_buffer'} } ) {
      DEBUG > 3 and print STDERR "I need to get something into my empty token buffer...\n";
      if($self->{'source_dead'}) {
        DEBUG and print STDERR "$self 's source is dead.\n";
        push @{ $self->{'token_buffer'} }, undef;
      } elsif(exists $self->{'source_fh'}) {
        my @lines;
        my $fh = $self->{'source_fh'}
         || Carp::croak('You have to call set_source before you can call get_token');
         
        DEBUG and print STDERR "$self 's source is filehandle $fh.\n";
        # Read those many lines at a time
        for(my $i = Pod::Simple::MANY_LINES; $i--;) {
          DEBUG > 3 and print STDERR " Fetching a line from source filehandle $fh...\n";
          local $/ = $Pod::Simple::NL;
          push @lines, scalar(<$fh>); # readline
          DEBUG > 3 and print STDERR "  Line is: ",
            defined($lines[-1]) ? $lines[-1] : "<undef>\n";
          unless( defined $lines[-1] ) {
            DEBUG and print STDERR "That's it for that source fh!  Killing.\n";
            delete $self->{'source_fh'}; # so it can be GC'd
            last;
          }
           # but pass thru the undef, which will set source_dead to true
  
          # TODO: look to see if $lines[-1] is =encoding, and if so,
          # do horribly magic things
  
        }
        
        if(DEBUG > 8) {
          print STDERR "* I've gotten ", scalar(@lines), " lines:\n";
          foreach my $l (@lines) {
            if(defined $l) {
              print STDERR "  line {$l}\n";
            } else {
              print STDERR "  line undef\n";
            }
          }
          print STDERR "* end of ", scalar(@lines), " lines\n";
        }
  
        $self->SUPER::parse_lines(@lines);
        
      } elsif(exists $self->{'source_arrayref'}) {
        DEBUG and print STDERR "$self 's source is arrayref $self->{'source_arrayref'}, with ",
         scalar(@{$self->{'source_arrayref'}}), " items left in it.\n";
  
        DEBUG > 3 and print STDERR "  Fetching ", Pod::Simple::MANY_LINES, " lines.\n";
        $self->SUPER::parse_lines(
          splice @{ $self->{'source_arrayref'} },
          0,
          Pod::Simple::MANY_LINES
        );
        unless( @{ $self->{'source_arrayref'} } ) {
          DEBUG and print STDERR "That's it for that source arrayref!  Killing.\n";
          $self->SUPER::parse_lines(undef);
          delete $self->{'source_arrayref'}; # so it can be GC'd
        }
         # to make sure that an undef is always sent to signal end-of-stream
  
      } elsif(exists $self->{'source_scalar_ref'}) {
  
        DEBUG and print STDERR "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",
          length(${ $self->{'source_scalar_ref'} }) -
          (pos(${ $self->{'source_scalar_ref'} }) || 0),
          " characters left to parse.\n";
  
        DEBUG > 3 and print STDERR " Fetching a line from source-string...\n";
        if( ${ $self->{'source_scalar_ref'} } =~
          m/([^\n\r]*)((?:\r?\n)?)/g
        ) {
          #print(">> $1\n"),
          $self->SUPER::parse_lines($1)
           if length($1) or length($2)
            or pos(     ${ $self->{'source_scalar_ref'} })
             != length( ${ $self->{'source_scalar_ref'} });
           # I.e., unless it's a zero-length "empty line" at the very
           #  end of "foo\nbar\n" (i.e., between the \n and the EOS).
        } else { # that's the end.  Byebye
          $self->SUPER::parse_lines(undef);
          delete $self->{'source_scalar_ref'};
          DEBUG and print STDERR "That's it for that source scalarref!  Killing.\n";
        }
  
        
      } else {
        die "What source??";
      }
    }
    DEBUG and print STDERR "get_token about to return ",
     Pod::Simple::pretty( @{$self->{'token_buffer'}}
       ? $self->{'token_buffer'}[-1] : undef
     ), "\n";
    return shift @{$self->{'token_buffer'}}; # that's an undef if empty
  }
  
  sub unget_token {
    my $self = shift;
    DEBUG and print STDERR "Ungetting ", scalar(@_), " tokens: ",
     @_ ? "@_\n" : "().\n";
    foreach my $t (@_) {
      Carp::croak "Can't unget that, because it's not a token -- it's undef!"
       unless defined $t;
      Carp::croak "Can't unget $t, because it's not a token -- it's a string!"
       unless ref $t;
      Carp::croak "Can't unget $t, because it's not a token object!"
       unless UNIVERSAL::can($t, 'type');
    }
    
    unshift @{$self->{'token_buffer'}}, @_;
    DEBUG > 1 and print STDERR "Token buffer now has ",
     scalar(@{$self->{'token_buffer'}}), " items in it.\n";
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # $self->{'source_filename'} = $source;
  
  sub set_source {
    my $self = shift @_;
    return $self->{'source_fh'} unless @_;
    Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")
        if $self->{'source_fh'} || $self->{'source_scalar_ref'} || $self->{'source_arrayref'};
    my $handle;
    if(!defined $_[0]) {
      Carp::croak("Can't use empty-string as a source for set_source");
    } elsif(ref(\( $_[0] )) eq 'GLOB') {
      $self->{'source_filename'} = '' . ($handle = $_[0]);
      DEBUG and print STDERR "$self 's source is glob $_[0]\n";
      # and fall thru   
    } elsif(ref( $_[0] ) eq 'SCALAR') {
      $self->{'source_scalar_ref'} = $_[0];
      DEBUG and print STDERR "$self 's source is scalar ref $_[0]\n";
      return;
    } elsif(ref( $_[0] ) eq 'ARRAY') {
      $self->{'source_arrayref'} = $_[0];
      DEBUG and print STDERR "$self 's source is array ref $_[0]\n";
      return;
    } elsif(ref $_[0]) {
      $self->{'source_filename'} = '' . ($handle = $_[0]);
      DEBUG and print STDERR "$self 's source is fh-obj $_[0]\n";
    } elsif(!length $_[0]) {
      Carp::croak("Can't use empty-string as a source for set_source");
    } else {  # It's a filename!
      DEBUG and print STDERR "$self 's source is filename $_[0]\n";
      {
        local *PODSOURCE;
        open(PODSOURCE, "<$_[0]") || Carp::croak "Can't open $_[0]: $!";
        $handle = *PODSOURCE{IO};
      }
      $self->{'source_filename'} = $_[0];
      DEBUG and print STDERR "  Its name is $_[0].\n";
  
      # TODO: file-discipline things here!
    }
  
    $self->{'source_fh'} = $handle;
    DEBUG and print STDERR "  Its handle is $handle\n";
    return 1;
  }
  
  # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
  sub get_title_short {  shift->get_short_title(@_)  } # alias
  
  sub get_short_title {
    my $title = shift->get_title(@_);
    $title = $1 if $title =~ m/^(\S{1,60})\s+--?\s+./s;
      # turn "Foo::Bar -- bars for your foo" into "Foo::Bar"
    return $title;
  }
  
  sub get_title       { shift->_get_titled_section(
    'NAME', max_token => 50, desperate => 1, @_)
  }
  sub get_version     { shift->_get_titled_section(
     'VERSION',
      max_token => 400,
      accept_verbatim => 1,
      max_content_length => 3_000,
     @_,
    );
  }
  sub get_description { shift->_get_titled_section(
     'DESCRIPTION',
      max_token => 400,
      max_content_length => 3_000,
     @_,
  ) }
  
  sub get_authors     { shift->get_author(@_) }  # a harmless alias
  
  sub get_author      {
    my $this = shift;
    # Max_token is so high because these are
    #  typically at the end of the document:
    $this->_get_titled_section('AUTHOR' , max_token => 10_000, @_) ||
    $this->_get_titled_section('AUTHORS', max_token => 10_000, @_);
  }
  
  #--------------------------------------------------------------------------
  
  sub _get_titled_section {
    # Based on a get_title originally contributed by Graham Barr
    my($self, $titlename, %options) = (@_);
    
    my $max_token            = delete $options{'max_token'};
    my $desperate_for_title  = delete $options{'desperate'};
    my $accept_verbatim      = delete $options{'accept_verbatim'};
    my $max_content_length   = delete $options{'max_content_length'};
    my $nocase               = delete $options{'nocase'};
    $max_content_length = 120 unless defined $max_content_length;
  
    Carp::croak( "Unknown " . ((1 == keys %options) ? "option: " : "options: ")
      . join " ", map "[$_]", sort keys %options
    )
     if keys %options;
  
    my %content_containers;
    $content_containers{'Para'} = 1;
    if($accept_verbatim) {
      $content_containers{'Verbatim'} = 1;
      $content_containers{'VerbatimFormatted'} = 1;
    }
  
    my $token_count = 0;
    my $title;
    my @to_unget;
    my $state = 0;
    my $depth = 0;
  
    Carp::croak "What kind of titlename is \"$titlename\"?!" unless
     defined $titlename and $titlename =~ m/^[A-Z ]{1,60}$/s; #sanity
    my $titlename_re = quotemeta($titlename);
  
    my $head1_text_content;
    my $para_text_content;
    my $skipX;
  
    while(
      ++$token_count <= ($max_token || 1_000_000)
      and defined(my $token = $self->get_token)
    ) {
      push @to_unget, $token;
  
      if ($state == 0) { # seeking =head1
        if( $token->is_start and $token->tagname eq 'head1' ) {
          DEBUG and print STDERR "  Found head1.  Seeking content...\n";
          ++$state;
          $head1_text_content = '';
        }
      }
  
      elsif($state == 1) { # accumulating text until end of head1
        if( $token->is_text ) {
            unless ($skipX) {
              DEBUG and print STDERR "   Adding \"", $token->text, "\" to head1-content.\n";
              $head1_text_content .= $token->text;
            }
        } elsif( $token->is_tagname('X') ) {
            # We're going to want to ignore X<> stuff.
            $skipX = $token->is_start;
            DEBUG and print STDERR +($skipX ? 'Start' : 'End'), 'ing ignoring of X<> tag';
        } elsif( $token->is_end and $token->tagname eq 'head1' ) {
          DEBUG and print STDERR "  Found end of head1.  Considering content...\n";
          $head1_text_content = uc $head1_text_content if $nocase;
          if($head1_text_content eq $titlename
            or $head1_text_content =~ m/\($titlename_re\)/s
            # We accept "=head1 Nomen Modularis (NAME)" for sake of i18n
          ) {
            DEBUG and print STDERR "  Yup, it was $titlename.  Seeking next para-content...\n";
            ++$state;
          } elsif(
            $desperate_for_title
             # if we're so desperate we'll take the first
             #  =head1's content as a title
            and $head1_text_content =~ m/\S/
            and $head1_text_content !~ m/^[ A-Z]+$/s
            and $head1_text_content !~
              m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx
              # avoid accepting things like =head1 Thingy Thongy (DESCRIPTION)
            and ($max_content_length
              ? (length($head1_text_content) <= $max_content_length) # sanity
              : 1)
          ) {
            # Looks good; trim it
            ($title = $head1_text_content) =~ s/\s+$//;
            DEBUG and print STDERR "  It looks titular: \"$title\".\n\n  Using that.\n";
            last;
          } else {
            --$state;
            DEBUG and print STDERR "  Didn't look titular ($head1_text_content).\n",
              "\n  Dropping back to seeking-head1-content mode...\n";
          }
        }
      }
      
      elsif($state == 2) {
        # seeking start of para (which must immediately follow)
        if($token->is_start and $content_containers{ $token->tagname }) {
          DEBUG and print STDERR "  Found start of Para.  Accumulating content...\n";
          $para_text_content = '';
          ++$state;
        } else {
          DEBUG and print
           "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";
          $state = 0;
        }
      }
      
      elsif($state == 3) {
        # accumulating text until end of Para
        if( $token->is_text ) {
          DEBUG and print STDERR "   Adding \"", $token->text, "\" to para-content.\n";
          $para_text_content .= $token->text;
          # and keep looking
          
        } elsif( $token->is_end and $content_containers{ $token->tagname } ) {
          DEBUG and print STDERR "  Found end of Para.  Considering content: ",
            $para_text_content, "\n";
  
          if( $para_text_content =~ m/\S/
            and ($max_content_length
             ? (length($para_text_content) <= $max_content_length)
             : 1)
          ) {
            # Some minimal sanity constraints, I think.
            DEBUG and print STDERR "  It looks contentworthy, I guess.  Using it.\n";
            $title = $para_text_content;
            last;
          } else {
            DEBUG and print STDERR "  Doesn't look at all contentworthy!\n  Giving up.\n";
            undef $title;
            last;
          }
        }
      }
      
      else {
        die "IMPOSSIBLE STATE $state!\n";  # should never happen
      }
      
    }
    
    # Put it all back!
    $self->unget_token(@to_unget);
    
    if(DEBUG) {
      if(defined $title) { print STDERR "  Returning title <$title>\n" }
      else { print STDERR "Returning title <>\n" }
    }
    
    return '' unless defined $title;
    $title =~ s/^\s+//;
    return $title;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  #  Methods that actually do work at parse-time:
  
  sub _handle_element_start {
    my $self = shift;   # leaving ($element_name, $attr_hash_r)
    DEBUG > 2 and print STDERR "++ $_[0] (", map("<$_> ", %{$_[1]}), ")\n";
    
    push @{ $self->{'token_buffer'} },
         $self->{'start_token_class'}->new(@_);
    return;
  }
  
  sub _handle_text {
    my $self = shift;   # leaving ($text)
    DEBUG > 2 and print STDERR "== $_[0]\n";
    push @{ $self->{'token_buffer'} },
         $self->{'text_token_class'}->new(@_);
    return;
  }
  
  sub _handle_element_end {
    my $self = shift;   # leaving ($element_name);
    DEBUG > 2 and print STDERR "-- $_[0]\n";
    push @{ $self->{'token_buffer'} }, 
         $self->{'end_token_class'}->new(@_);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParser -- a pull-parser interface to parsing Pod
  
  =head1 SYNOPSIS
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( "whatever.pod" );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( $some_filehandle_object );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( \$document_source );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( \@document_lines );
   $parser->run;
  
  And elsewhere:
  
   require 5;
   package SomePodProcessor;
   use strict;
   use base qw(Pod::Simple::PullParser);
  
   sub run {
     my $self = shift;
    Token:
     while(my $token = $self->get_token) {
       ...process each token...
     }
   }
  
  =head1 DESCRIPTION
  
  This class is for using Pod::Simple to build a Pod processor -- but
  one that uses an interface based on a stream of token objects,
  instead of based on events.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  A subclass of Pod::Simple::PullParser should define a C<run> method
  that calls C<< $token = $parser->get_token >> to pull tokens.
  
  See the source for Pod::Simple::RTF for an example of a formatter
  that uses Pod::Simple::PullParser.
  
  =head1 METHODS
  
  =over
  
  =item my $token = $parser->get_token
  
  This returns the next token object (which will be of a subclass of
  L<Pod::Simple::PullParserToken>), or undef if the parser-stream has hit
  the end of the document.
  
  =item $parser->unget_token( $token )
  
  =item $parser->unget_token( $token1, $token2, ... )
  
  This restores the token object(s) to the front of the parser stream.
  
  =back
  
  The source has to be set before you can parse anything.  The lowest-level
  way is to call C<set_source>:
  
  =over
  
  =item $parser->set_source( $filename )
  
  =item $parser->set_source( $filehandle_object )
  
  =item $parser->set_source( \$document_source )
  
  =item $parser->set_source( \@document_lines )
  
  =back
  
  Or you can call these methods, which Pod::Simple::PullParser has defined
  to work just like Pod::Simple's same-named methods:
  
  =over
  
  =item $parser->parse_file(...)
  
  =item $parser->parse_string_document(...)
  
  =item $parser->filter(...)
  
  =item $parser->parse_from_file(...)
  
  =back
  
  For those to work, the Pod-processing subclass of
  Pod::Simple::PullParser has to have defined a $parser->run method --
  so it is advised that all Pod::Simple::PullParser subclasses do so.
  See the Synopsis above, or the source for Pod::Simple::RTF.
  
  Authors of formatter subclasses might find these methods useful to
  call on a parser object that you haven't started pulling tokens
  from yet:
  
  =over
  
  =item my $title_string = $parser->get_title
  
  This tries to get the title string out of $parser, by getting some tokens,
  and scanning them for the title, and then ungetting them so that you can
  process the token-stream from the beginning.
  
  For example, suppose you have a document that starts out:
  
    =head1 NAME
  
    Hoo::Boy::Wowza -- Stuff B<wow> yeah!
  
  $parser->get_title on that document will return "Hoo::Boy::Wowza --
  Stuff wow yeah!". If the document starts with:
  
    =head1 Name
  
    Hoo::Boy::W00t -- Stuff B<w00t> yeah!
  
  Then you'll need to pass the C<nocase> option in order to recognize "Name":
  
    $parser->get_title(nocase => 1);
  
  In cases where get_title can't find the title, it will return empty-string
  ("").
  
  =item my $title_string = $parser->get_short_title
  
  This is just like get_title, except that it returns just the modulename, if
  the title seems to be of the form "SomeModuleName -- description".
  
  For example, suppose you have a document that starts out:
  
    =head1 NAME
  
    Hoo::Boy::Wowza -- Stuff B<wow> yeah!
  
  then $parser->get_short_title on that document will return
  "Hoo::Boy::Wowza".
  
  But if the document starts out:
  
    =head1 NAME
  
    Hooboy, stuff B<wow> yeah!
  
  then $parser->get_short_title on that document will return "Hooboy,
  stuff wow yeah!". If the document starts with:
  
    =head1 Name
  
    Hoo::Boy::W00t -- Stuff B<w00t> yeah!
  
  Then you'll need to pass the C<nocase> option in order to recognize "Name":
  
    $parser->get_short_title(nocase => 1);
  
  If the title can't be found, then get_short_title returns empty-string
  ("").
  
  =item $author_name   = $parser->get_author
  
  This works like get_title except that it returns the contents of the
  "=head1 AUTHOR\n\nParagraph...\n" section, assuming that that section
  isn't terribly long. To recognize a "=head1 Author\n\nParagraph\n"
  section, pass the C<nocase> option:
  
    $parser->get_author(nocase => 1);
  
  (This method tolerates "AUTHORS" instead of "AUTHOR" too.)
  
  =item $description_name = $parser->get_description
  
  This works like get_title except that it returns the contents of the
  "=head1 DESCRIPTION\n\nParagraph...\n" section, assuming that that section
  isn't terribly long. To recognize a "=head1 Description\n\nParagraph\n"
  section, pass the C<nocase> option:
  
    $parser->get_description(nocase => 1);
  
  =item $version_block = $parser->get_version
  
  This works like get_title except that it returns the contents of
  the "=head1 VERSION\n\n[BIG BLOCK]\n" block.  Note that this does NOT
  return the module's C<$VERSION>!! To recognize a
  "=head1 Version\n\n[BIG BLOCK]\n" section, pass the C<nocase> option:
  
    $parser->get_version(nocase => 1);
  
  =back
  
  =head1 NOTE
  
  You don't actually I<have> to define a C<run> method.  If you're
  writing a Pod-formatter class, you should define a C<run> just so
  that users can call C<parse_file> etc, but you don't I<have> to.
  
  And if you're not writing a formatter class, but are instead just
  writing a program that does something simple with a Pod::PullParser
  object (and not an object of a subclass), then there's no reason to
  bother subclassing to add a C<run> method.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  L<Pod::Simple::PullParserToken> -- and its subclasses
  L<Pod::Simple::PullParserStartToken>,
  L<Pod::Simple::PullParserTextToken>, and
  L<Pod::Simple::PullParserEndToken>.
  
  L<HTML::TokeParser>, which inspired this.
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  
  JUNK:
  
  sub _old_get_title {  # some witchery in here
    my $self = $_[0];
    my $title;
    my @to_unget;
  
    while(1) {
      push @to_unget, $self->get_token;
      unless(defined $to_unget[-1]) { # whoops, short doc!
        pop @to_unget;
        last;
      }
  
      DEBUG and print STDERR "-Got token ", $to_unget[-1]->dump, "\n";
  
      (DEBUG and print STDERR "Too much in the buffer.\n"),
       last if @to_unget > 25; # sanity
      
      my $pattern = '';
      if( #$to_unget[-1]->type eq 'end'
          #and $to_unget[-1]->tagname eq 'Para'
          #and
          ($pattern = join('',
           map {;
              ($_->type eq 'start') ? ("<" . $_->tagname .">")
            : ($_->type eq 'end'  ) ? ("</". $_->tagname .">")
            : ($_->type eq 'text' ) ? ($_->text =~ m<^([A-Z]+)$>s ? $1 : 'X')
            : "BLORP"
           } @to_unget
         )) =~ m{<head1>NAME</head1><Para>(X|</?[BCIFLS]>)+</Para>$}s
      ) {
        # Whee, it fits the pattern
        DEBUG and print STDERR "Seems to match =head1 NAME pattern.\n";
        $title = '';
        foreach my $t (reverse @to_unget) {
          last if $t->type eq 'start' and $t->tagname eq 'Para';
          $title = $t->text . $title if $t->type eq 'text';
        }
        undef $title if $title =~ m<^\s*$>; # make sure it's contentful!
        last;
  
      } elsif ($pattern =~ m{<head(\d)>(.+)</head\d>$}
        and !( $1 eq '1' and $2 eq 'NAME' )
      ) {
        # Well, it fits a fallback pattern
        DEBUG and print STDERR "Seems to match NAMEless pattern.\n";
        $title = '';
        foreach my $t (reverse @to_unget) {
          last if $t->type eq 'start' and $t->tagname =~ m/^head\d$/s;
          $title = $t->text . $title if $t->type eq 'text';
        }
        undef $title if $title =~ m<^\s*$>; # make sure it's contentful!
        last;
        
      } else {
        DEBUG and $pattern and print STDERR "Leading pattern: $pattern\n";
      }
    }
    
    # Put it all back:
    $self->unget_token(@to_unget);
    
    if(DEBUG) {
      if(defined $title) { print STDERR "  Returning title <$title>\n" }
      else { print STDERR "Returning title <>\n" }
    }
    
    return '' unless defined $title;
    return $title;
  }
  
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  
  require 5;
  package Pod::Simple::PullParserEndToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.43';
  
  sub new {  # Class->new(tagname);
    my $class = shift;
    return bless ['end', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub tagname { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  sub tag { shift->tagname(@_) }
  
  # shortcut:
  sub is_tagname { $_[0][1] eq $_[1] }
  sub is_tag { shift->is_tagname(@_) }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserEndToken -- end-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->tagname
  
  This returns the tagname for this end-token object.
  For example, parsing a "=head1 ..." line will give you
  a start-token with the tagname of "head1", token(s) for its
  content, and then an end-token with the tagname of "head1".
  
  =item $token->tagname(I<somestring>)
  
  This changes the tagname for this end-token object.
  You probably won't need to do this.
  
  =item $token->tag(...)
  
  A shortcut for $token->tagname(...)
  
  =item $token->is_tag(I<somestring>) or $token->is_tagname(I<somestring>)
  
  These are shortcuts for C<< $token->tag() eq I<somestring> >>
  
  =back
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserEndToken->new( I<tagname> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  
  require 5;
  package Pod::Simple::PullParserStartToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.43';
  
  sub new {  # Class->new(tagname, optional_attrhash);
    my $class = shift;
    return bless ['start', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub tagname   { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  sub tag { shift->tagname(@_) }
  
  sub is_tagname { $_[0][1] eq $_[1] }
  sub is_tag { shift->is_tagname(@_) }
  
  
  sub attr_hash { $_[0][2] ||= {} }
  
  sub attr      {
    if(@_ == 2) {      # Reading: $token->attr('attrname')
      ${$_[0][2] || return undef}{ $_[1] };
    } elsif(@_ > 2) {  # Writing: $token->attr('attrname', 'newval')
      ${$_[0][2] ||= {}}{ $_[1] } = $_[2];
    } else {
      require Carp;
      Carp::croak(
        'usage: $object->attr("val") or $object->attr("key", "newval")');
      return undef;
    }
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserStartToken -- start-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser> object, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->tagname
  
  This returns the tagname for this start-token object.
  For example, parsing a "=head1 ..." line will give you
  a start-token with the tagname of "head1", token(s) for its
  content, and then an end-token with the tagname of "head1".
  
  =item $token->tagname(I<somestring>)
  
  This changes the tagname for this start-token object.
  You probably won't need
  to do this.
  
  =item $token->tag(...)
  
  A shortcut for $token->tagname(...)
  
  =item $token->is_tag(I<somestring>) or $token->is_tagname(I<somestring>)
  
  These are shortcuts for C<< $token->tag() eq I<somestring> >>
  
  =item $token->attr(I<attrname>)
  
  This returns the value of the I<attrname> attribute for this start-token
  object, or undef.
  
  For example, parsing a LZ<><Foo/"Bar"> link will produce a start-token
  with a "to" attribute with the value "Foo", a "type" attribute with the
  value "pod", and a "section" attribute with the value "Bar".
  
  =item $token->attr(I<attrname>, I<newvalue>)
  
  This sets the I<attrname> attribute for this start-token object to
  I<newvalue>.  You probably won't need to do this.
  
  =item $token->attr_hash
  
  This returns the hashref that is the attribute set for this start-token.
  This is useful if (for example) you want to ask what all the attributes
  are -- you can just do C<< keys %{$token->attr_hash} >>
  
  =back
  
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserStartToken->new( I<tagname>, I<attrhash> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  
  require 5;
  package Pod::Simple::PullParserTextToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.43';
  
  sub new {  # Class->new(text);
    my $class = shift;
    return bless ['text', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub text { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  
  sub text_r { \ $_[0][1] }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserTextToken -- text-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->text
  
  This returns the text that this token holds.  For example, parsing
  CZ<><foo> will return a C start-token, a text-token, and a C end-token.  And
  if you want to get the "foo" out of the text-token, call C<< $token->text >>
  
  =item $token->text(I<somestring>)
  
  This changes the string that this token holds.  You probably won't need
  to do this.
  
  =item $token->text_r()
  
  This returns a scalar reference to the string that this token holds.
  This can be useful if you don't want to memory-copy the potentially
  large text value (well, as large as a paragraph or a verbatim block)
  as calling $token->text would do.
  
  Or, if you want to alter the value, you can even do things like this:
  
    for ( ${  $token->text_r  } ) {  # Aliases it with $_ !!
  
      s/ The / the /g; # just for example
  
      if( 'A' eq chr(65) ) {  # (if in an ASCII world)
        tr/\xA0/ /;
        tr/\xAD//d;
      }
  
      ...or however you want to alter the value...
      (Note that starting with Perl v5.8, you can use, e.g.,
  
          my $nbsp = chr utf8::unicode_to_native(0xA0);
          s/$nbsp/ /g;
  
      to handle the above regardless if it's an ASCII world or not)
    }
  
  =back
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserTextToken->new( I<text> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  
  require 5;
  package Pod::Simple::PullParserToken;
   # Base class for tokens gotten from Pod::Simple::PullParser's $parser->get_token
  @ISA = ();
  $VERSION = '3.43';
  use strict;
  
  sub new {  # Class->new('type', stuff...);  ## Overridden in derived classes anyway
    my $class = shift;
    return bless [@_], ref($class) || $class;
  }
  
  sub type { $_[0][0] }  # Can't change the type of an object
  sub dump { Pod::Simple::pretty( [ @{ $_[0] } ] ) }
  
  sub is_start { $_[0][0] eq 'start' }
  sub is_end   { $_[0][0] eq 'end'   }
  sub is_text  { $_[0][0] eq 'text'  }
  
  1;
  __END__
  
  sub dump { '[' . _esc( @{ $_[0] } ) . ']' }
  
  # JUNK:
  
  sub _esc {
    return '' unless @_;
    my @out;
    foreach my $in (@_) {
      push @out, '"' . $in . '"';
      $out[-1] =~ s/([^- \:\:\.\,\'\>\<\"\/\=\?\+\|\[\]\{\}\_a-zA-Z0-9_\`\~\!\#\%\^\&\*\(\)])/
        sprintf( (ord($1) < 256) ? "\\x%02X" : "\\x{%X}", ord($1))
      /eg;
    }
    return join ', ', @out;
  }
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserToken -- tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  Given a $parser that's an object of class Pod::Simple::PullParser
  (or a subclass)...
  
    while(my $token = $parser->get_token) {
      $DEBUG and print STDERR "Token: ", $token->dump, "\n";
      if($token->is_start) {
        ...access $token->tagname, $token->attr, etc...
  
      } elsif($token->is_text) {
        ...access $token->text, $token->text_r, etc...
  
      } elsif($token->is_end) {
        ...access $token->tagname...
  
      }
    }
  
  (Also see L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you should
  get an object of a subclass of Pod::Simple::PullParserToken.
  
  Subclasses will add methods, and will also inherit these methods:
  
  =over
  
  =item $token->type
  
  This returns the type of the token.  This will be either the string
  "start", the string "text", or the string "end".
  
  Once you know what the type of an object is, you then know what
  subclass it belongs to, and therefore what methods it supports.
  
  Yes, you could probably do the same thing with code like
  $token->isa('Pod::Simple::PullParserEndToken'), but that's not so
  pretty as using just $token->type, or even the following shortcuts:
  
  =item $token->is_start
  
  This is a shortcut for C<< $token->type() eq "start" >>
  
  =item $token->is_text
  
  This is a shortcut for C<< $token->type() eq "text" >>
  
  =item $token->is_end
  
  This is a shortcut for C<< $token->type() eq "end" >>
  
  =item $token->dump
  
  This returns a handy stringified value of this object.  This
  is useful for debugging, as in:
  
    while(my $token = $parser->get_token) {
      $DEBUG and print STDERR "Token: ", $token->dump, "\n";
      ...
    }
  
  =back
  
  =head1 SEE ALSO
  
  My subclasses:
  L<Pod::Simple::PullParserStartToken>,
  L<Pod::Simple::PullParserTextToken>, and
  L<Pod::Simple::PullParserEndToken>.
  
  L<Pod::Simple::PullParser> and L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  
  require 5;
  package Pod::Simple::RTF;
  
  #sub DEBUG () {4};
  #sub Pod::Simple::DEBUG () {4};
  #sub Pod::Simple::PullParser::DEBUG () {4};
  
  use strict;
  use vars qw($VERSION @ISA %Escape $WRAP %Tagmap);
  $VERSION = '3.43';
  use Pod::Simple::PullParser ();
  BEGIN {@ISA = ('Pod::Simple::PullParser')}
  
  use Carp ();
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub to_uni ($) {    # Convert native code point to Unicode
      my $x = shift;
  
      # Broken for early EBCDICs
      $x = chr utf8::native_to_unicode(ord $x) if $] ge 5.007_003
                                               && ord("A") != 65;
      return $x;
  }
  
  # We escape out 'F' so that we can send RTF files thru the mail without the
  # slightest worry that paragraphs beginning with "From" will get munged.
  # We also escape '\', '{', '}', and '_'
  my $map_to_self = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEGHIJKLMNOPQRSTUVWXYZ[]^`abcdefghijklmnopqrstuvwxyz|~';
  
  $WRAP = 1 unless defined $WRAP;
  %Escape = (
  
    # Start with every character mapping to its hex equivalent
    map( (chr($_) => sprintf("\\'%02x", $_)), 0 .. 0xFF),
  
    # Override most ASCII printables with themselves (or on non-ASCII platforms,
    # their ASCII values.  This is because the output is UTF-16, which is always
    # based on Unicode code points)
    map( (   substr($map_to_self, $_, 1)
          => to_uni(substr($map_to_self, $_, 1))), 0 .. length($map_to_self) - 1),
  
    # And some refinements:
    "\r"  => "\n",
    "\cj"  => "\n",
    "\n"   => "\n\\line ",
  
    "\t"   => "\\tab ",     # Tabs (altho theoretically raw \t's are okay)
    "\f"   => "\n\\page\n", # Formfeed
    "-"    => "\\_",        # Turn plaintext '-' into a non-breaking hyphen
    $Pod::Simple::nbsp => "\\~",        # Latin-1 non-breaking space
    $Pod::Simple::shy => "\\-",        # Latin-1 soft (optional) hyphen
  
    # CRAZY HACKS:
    "\n" => "\\line\n",
    "\r" => "\n",
    "\cb" => "{\n\\cs21\\lang1024\\noproof ",  # \\cf1
    "\cc" => "}",
  );
  
  # Generate a string of all the characters in %Escape that don't map to
  # themselves.  First, one without the hyphen, then one with.
  my $escaped_sans_hyphen = "";
  $escaped_sans_hyphen .= $_ for grep { $_ ne $Escape{$_} && $_ ne '-' }
                                                              sort keys %Escape;
  my $escaped = "-$escaped_sans_hyphen";
  
  # Then convert to patterns
  $escaped_sans_hyphen = qr/[\Q$escaped_sans_hyphen \E]/;
  $escaped= qr/[\Q$escaped\E]/;
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _openclose {
   return map {;
     m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";
     ( $1,  "{\\$2\n",   "/$1",  "}" );
   } @_;
  }
  
  my @_to_accept;
  
  %Tagmap = (
   # 'foo=bar' means ('foo' => '{\bar'."\n", '/foo' => '}')
   _openclose(
    'B=cs18\b',
    'I=cs16\i',
    'C=cs19\f1\lang1024\noproof',
    'F=cs17\i\lang1024\noproof',
  
    'VerbatimI=cs26\i',
    'VerbatimB=cs27\b',
    'VerbatimBI=cs28\b\i',
  
    map {; m/^([-a-z]+)/s && push @_to_accept, $1; $_ }
     qw[
         underline=ul         smallcaps=scaps  shadow=shad
         superscript=super    subscript=sub    strikethrough=strike
         outline=outl         emboss=embo      engrave=impr   
         dotted-underline=uld          dash-underline=uldash
         dot-dash-underline=uldashd    dot-dot-dash-underline=uldashdd     
         double-underline=uldb         thick-underline=ulth
         word-underline=ulw            wave-underline=ulwave
     ]
     # But no double-strikethrough, because MSWord can't agree with the
     #  RTF spec on whether it's supposed to be \strikedl or \striked1 (!!!)
   ),
  
   # Bit of a hack here:
   'L=pod' => '{\cs22\i'."\n",
   'L=url' => '{\cs23\i'."\n",
   'L=man' => '{\cs24\i'."\n",
   '/L' => '}',
  
   'Data'  => "\n",
   '/Data' => "\n",
  
   'Verbatim'  => "\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",
   '/Verbatim' => "\n\\par}\n",
   'VerbatimFormatted'  => "\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",
   '/VerbatimFormatted' => "\n\\par}\n",
   'Para'    => "\n{\\pard\\li#rtfindent#\\sa180\n",
   '/Para'   => "\n\\par}\n",
   'head1'   => "\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",
   '/head1'  => "\n}\\par}\n",
   'head2'   => "\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",
   '/head2'  => "\n}\\par}\n",
   'head3'   => "\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",
   '/head3'  => "\n}\\par}\n",
   'head4'   => "\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",
   '/head4'  => "\n}\\par}\n",
     # wordpad borks on \tc\tcl1, or I'd put that in =head1 and =head2
  
   'item-bullet'  => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-bullet' => "\n\\par}\n",
   'item-number'  => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-number' => "\n\\par}\n",
   'item-text'    => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-text'   => "\n\\par}\n",
  
   # we don't need any styles for over-* and /over-*
  );
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub new {
    my $new = shift->SUPER::new(@_);
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->accept_targets( 'rtf', 'RTF' );
  
    $new->{'Tagmap'} = {%Tagmap};
  
    $new->accept_codes(@_to_accept);
    $new->accept_codes('VerbatimFormatted');
    DEBUG > 2 and print STDERR "To accept: ", join(' ',@_to_accept), "\n";
    $new->doc_lang(
      (  $ENV{'RTFDEFLANG'} || '') =~ m/^(\d{1,10})$/s ? $1
      : ($ENV{'RTFDEFLANG'} || '') =~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1)
                                        # yes, tolerate hex!
      : ($ENV{'RTFDEFLANG'} || '') =~ m/^([a-fA-F0-9]{4})$/s ? hex($1)
                                        # yes, tolerate even more hex!
      : '1033'
    );
  
    $new->head1_halfpoint_size(32);
    $new->head2_halfpoint_size(28);
    $new->head3_halfpoint_size(25);
    $new->head4_halfpoint_size(22);
    $new->codeblock_halfpoint_size(18);
    $new->header_halfpoint_size(17);
    $new->normal_halfpoint_size(25);
  
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  __PACKAGE__->_accessorize(
   'doc_lang',
   'head1_halfpoint_size',
   'head2_halfpoint_size',
   'head3_halfpoint_size',
   'head4_halfpoint_size',
   'codeblock_halfpoint_size',
   'header_halfpoint_size',
   'normal_halfpoint_size',
   'no_proofing_exemptions',
  );
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub run {
    my $self = $_[0];
    return $self->do_middle if $self->bare_output;
    return
     $self->do_beginning && $self->do_middle && $self->do_end;
  }
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  # Match something like an identifier.  Prefer XID if available, then plain ID,
  # then just ASCII
  my $id_re = Pod::Simple::BlackBox::my_qr('[\'_\p{XIDS}][\'\p{XIDC}]+', "ab");
  $id_re    = Pod::Simple::BlackBox::my_qr('[\'_\p{IDS}][\'\p{IDC}]+', "ab")
                                                                    unless $id_re;
  $id_re = qr/['_a-zA-Z]['a-zA-Z0-9_]+/ unless $id_re;
  
  sub do_middle {      # the main work
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    
    my($token, $type, $tagname, $scratch);
    my @stack;
    my @indent_stack;
    $self->{'rtfindent'} = 0 unless defined $self->{'rtfindent'};
    
    while($token = $self->get_token) {
    
      if( ($type = $token->type) eq 'text' ) {
        if( $self->{'rtfverbatim'} ) {
          DEBUG > 1 and print STDERR "  $type " , $token->text, " in verbatim!\n";
          rtf_esc(0, $scratch = $token->text); # 0 => Don't escape hyphen
          print $fh $scratch;
          next;
        }
  
        DEBUG > 1 and print STDERR "  $type " , $token->text, "\n";
        
        $scratch = $token->text;
        $scratch =~ tr/\t\cb\cc/ /d;
        
        $self->{'no_proofing_exemptions'} or $scratch =~
         s/(?:
             ^
             |
             (?<=[\r\n\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             ${id_re}[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg
        ;
        
        rtf_esc(1, $scratch);     # 1 => escape hyphen
        $scratch =~
           s/(
              [^\r\n]{65}        # Snare 65 characters from a line
              [^\r\n ]{0,50}     #  and finish any current word
             )
             (\ {1,10})(?![\r\n]) # capture some spaces not at line-end
            /$1$2\n/gx     # and put a NL before those spaces
          if $WRAP;
          # This may wrap at well past the 65th column, but not past the 120th.
        
        print $fh $scratch;
  
      } elsif( $type eq 'start' ) {
        DEBUG > 1 and print STDERR "  +$type ",$token->tagname,
          " (", map("<$_> ", %{$token->attr_hash}), ")\n";
  
        if( ($tagname = $token->tagname) eq 'Verbatim'
            or $tagname eq 'VerbatimFormatted'
        ) {
          ++$self->{'rtfverbatim'};
          my $next = $self->get_token;
          next unless defined $next;
          my $line_count = 1;
          if($next->type eq 'text') {
            my $t = $next->text_r;
            while( $$t =~ m/$/mg ) {
              last if  ++$line_count  > 15; # no point in counting further
            }
            DEBUG > 3 and print STDERR "    verbatim line count: $line_count\n";
          }
          $self->unget_token($next);
          $self->{'rtfkeep'} = ($line_count > 15) ? '' : '\keepn' ;     
  
        } elsif( $tagname =~ m/^item-/s ) {
          my @to_unget;
          my $text_count_here = 0;
          $self->{'rtfitemkeepn'} = '';
          # Some heuristics to stop item-*'s functioning as subheadings
          #  from getting split from the things they're subheadings for.
          #
          # It's not terribly pretty, but it really does make things pretty.
          #
          while(1) {
            push @to_unget, $self->get_token;
            pop(@to_unget), last unless defined $to_unget[-1];
             # Erroneously used to be "unshift" instead of pop!  Adds instead
             # of removes, and operates on the beginning instead of the end!
            
            if($to_unget[-1]->type eq 'text') {
              if( ($text_count_here += length ${$to_unget[-1]->text_r}) > 150 ){
                DEBUG > 1 and print STDERR "    item-* is too long to be keepn'd.\n";
                last;
              }
            } elsif (@to_unget > 1 and
              $to_unget[-2]->type eq 'end' and
              $to_unget[-2]->tagname =~ m/^item-/s
            ) {
              # Bail out here, after setting rtfitemkeepn yea or nay.
              $self->{'rtfitemkeepn'} = '\keepn' if 
                $to_unget[-1]->type eq 'start' and
                $to_unget[-1]->tagname eq 'Para';
  
              DEBUG > 1 and printf STDERR "    item-* before %s(%s) %s keepn'd.\n",
                $to_unget[-1]->type,
                $to_unget[-1]->can('tagname') ? $to_unget[-1]->tagname : '',
                $self->{'rtfitemkeepn'} ? "gets" : "doesn't get";
              last;
            } elsif (@to_unget > 40) {
              DEBUG > 1 and print STDERR "    item-* now has too many tokens (",
                scalar(@to_unget),
                (DEBUG > 4) ? (q<: >, map($_->dump, @to_unget)) : (),
                ") to be keepn'd.\n";
              last; # give up
            }
            # else keep while'ing along
          }
          # Now put it aaaaall back...
          $self->unget_token(@to_unget);
  
        } elsif( $tagname =~ m/^over-/s ) {
          push @stack, $1;
          push @indent_stack,
           int($token->attr('indent') * 4 * $self->normal_halfpoint_size);
          DEBUG and print STDERR "Indenting over $indent_stack[-1] twips.\n";
          $self->{'rtfindent'} += $indent_stack[-1];
          
        } elsif ($tagname eq 'L') {
          $tagname .= '=' . ($token->attr('type') || 'pod');
          
        } elsif ($tagname eq 'Data') {
          my $next = $self->get_token;
          next unless defined $next;
          unless( $next->type eq 'text' ) {
            $self->unget_token($next);
            next;
          }
          DEBUG and print STDERR "    raw text ", $next->text, "\n";
          printf $fh "\n" . $next->text . "\n";
          next;
        }
  
        defined($scratch = $self->{'Tagmap'}{$tagname}) or next;
        $scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g; # interpolate
        print $fh $scratch;
        
        if ($tagname eq 'item-number') {
          print $fh $token->attr('number'), ". \n";
        } elsif ($tagname eq 'item-bullet') {
          print $fh "\\'", ord("_"), "\n";
          #for funky testing: print $fh '', rtf_esc(1, "\x{4E4B}\x{9053}");
        }
  
      } elsif( $type eq 'end' ) {
        DEBUG > 1 and print STDERR "  -$type ",$token->tagname,"\n";
        if( ($tagname = $token->tagname) =~ m/^over-/s ) {
          DEBUG and print STDERR "Indenting back $indent_stack[-1] twips.\n";
          $self->{'rtfindent'} -= pop @indent_stack;
          pop @stack;
        } elsif( $tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted') {
          --$self->{'rtfverbatim'};
        }
        defined($scratch = $self->{'Tagmap'}{"/$tagname"}) or next;
        $scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g; # interpolate
        print $fh $scratch;
      }
    }
    return 1;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub do_beginning {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    return print $fh join '',
      $self->doc_init,
      $self->font_table,
      $self->stylesheet,
      $self->color_table,
      $self->doc_info,
      $self->doc_start,
      "\n"
    ;
  }
  
  sub do_end {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    return print $fh '}'; # that should do it
  }
  
  ###########################################################################
  
  sub stylesheet {
    return sprintf <<'END',
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  
     $_[0]->codeblock_halfpoint_size(),
     $_[0]->head1_halfpoint_size(),
     $_[0]->head2_halfpoint_size(),
     $_[0]->head3_halfpoint_size(),
     $_[0]->head4_halfpoint_size(),
    ;
  }
  
  ###########################################################################
  # Override these as necessary for further customization
  
  sub font_table {
    return <<'END';  # text font, code font, heading font
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  }
  
  sub doc_init {
     return <<'END';
  {\rtf1\ansi\deff0
  
  END
  }
  
  sub color_table {
     return <<'END';
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  }
  
  
  sub doc_info {
     my $self = $_[0];
  
     my $class = ref($self) || $self;
  
     my $tag = __PACKAGE__ . ' ' . $VERSION;
     
     unless($class eq __PACKAGE__) {
       $tag = " ($tag)";
       $tag = " v" . $self->VERSION . $tag   if   defined $self->VERSION;
       $tag = $class . $tag;
     }
  
     return sprintf <<'END',
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  
    # None of the following things should need escaping, I dare say!
      $tag, 
      $ISA[0], $ISA[0]->VERSION(),
      $], scalar(gmtime($ENV{SOURCE_DATE_EPOCH} || time)),
    ;
  }
  
  sub doc_start {
    my $self = $_[0];
    my $title = $self->get_short_title();
    DEBUG and print STDERR "Short Title: <$title>\n";
    $title .= ' ' if length $title;
    
    $title =~ s/ *$/ /s;
    $title =~ s/^ //s;
    $title =~ s/ $/, /s;
     # make sure it ends in a comma and a space, unless it's 0-length
  
    my $is_obviously_module_name;
    $is_obviously_module_name = 1
     if $title =~ m/^\S+$/s and $title =~ m/::/s;
      # catches the most common case, at least
  
    DEBUG and print STDERR "Title0: <$title>\n";
    $title = rtf_esc(1, $title);  # 1 => escape hyphen
    DEBUG and print STDERR "Title1: <$title>\n";
    $title = '\lang1024\noproof ' . $title
     if $is_obviously_module_name;
  
    return sprintf <<'END', 
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
      ($self->doc_lang) x 2,
      $self->header_halfpoint_size,
      $title,
      $self->normal_halfpoint_size,
    ;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #-------------------------------------------------------------------------
  
  use integer;
  
  my $question_mark_code_points =
          Pod::Simple::BlackBox::my_qr('([^\x00-\x{D7FF}\x{E000}-\x{10FFFF}])',
                                       "\x{110000}");
  my $plane0 =
          Pod::Simple::BlackBox::my_qr('([\x{100}-\x{FFFF}])', "\x{100}");
  my $other_unicode =
          Pod::Simple::BlackBox::my_qr('([\x{10000}-\x{10FFFF}])', "\x{10000}");
  
  sub esc_uni($) {
      use if $] le 5.006002, 'utf8';
  
      my $x = shift;
  
      # The output is expected to be UTF-16.  Surrogates and above-Unicode get
      # mapped to '?'
      $x =~ s/$question_mark_code_points/?/g if $question_mark_code_points;
  
      # Non-surrogate Plane 0 characters get mapped to their code points.  But
      # the standard calls for a 16bit SIGNED value.
      $x =~ s/$plane0/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg
                                                                      if $plane0;
  
      # Use surrogate pairs for the rest
      $x =~ s/$other_unicode/'\\uc1\\u' . ((ord($1) >> 10) + 0xD7C0 - 65536) . '\\u' . (((ord$1) & 0x03FF) + 0xDC00 - 65536) . '?'/eg if $other_unicode;
  
      return $x;
  }
  
  sub rtf_esc ($$) {
    # The parameter is true if we should escape hyphens
    my $escape_re = ((shift) ? $escaped : $escaped_sans_hyphen);
  
    # When false, it doesn't change "-" to hard-hyphen.
    #  We don't want to change the "-" to hard-hyphen, because we want to
    #  be able to paste this into a file and run it without there being
    #  dire screaming about the mysterious hard-hyphen character (which
    #  looks just like a normal dash character).
    # XXX The comments used to claim that when false it didn't apply computerese
    #     style-smarts, but khw didn't see this actually
  
    my $x; # scratch
    if(!defined wantarray) { # void context: alter in-place!
      for(@_) {
        s/($escape_re)/$Escape{$1}/g;  # ESCAPER
        $_ = esc_uni($_);
      }
      return;
    } elsif(wantarray) {  # return an array
      return map {; ($x = $_) =~
        s/($escape_re)/$Escape{$1}/g;  # ESCAPER
        $x = esc_uni($x);
        $x;
      } @_;
    } else { # return a single scalar
      ($x = ((@_ == 1) ? $_[0] : join '', @_)
      ) =~ s/($escape_re)/$Escape{$1}/g;  # ESCAPER
               # Escape \, {, }, -, control chars, and 7f-ff.
      $x = esc_uni($x);
      return $x;
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::RTF -- format Pod as RTF
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::RTF -e \
     "exit Pod::Simple::RTF->filter(shift)->any_errata_seen" \
     thingy.pod > thingy.rtf
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as RTF, good for
  viewing/printing in MSWord, WordPad/write.exe, TextEdit, etc.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 FORMAT CONTROL ATTRIBUTES
  
  You can set these attributes on the parser object before you
  call C<parse_file> (or a similar method) on it:
  
  =over
  
  =item $parser->head1_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head2_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head3_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head4_halfpoint_size( I<halfpoint_integer> );
  
  These methods set the size (in half-points, like 52 for 26-point)
  that these heading levels will appear as.
  
  =item $parser->codeblock_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 21 for 10.5-point)
  that codeblocks ("verbatim sections") will appear as.
  
  =item $parser->header_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 15 for 7.5-point)
  that the header on each page will appear in.  The header
  is usually just "I<modulename> p. I<pagenumber>".
  
  =item $parser->normal_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 26 for 13-point)
  that normal paragraphic text will appear in.
  
  =item $parser->no_proofing_exemptions( I<true_or_false> );
  
  Set this value to true if you don't want the formatter to try
  putting a hidden code on all Perl symbols (as best as it can
  notice them) that labels them as being not in English, and
  so not worth spellchecking.
  
  =item $parser->doc_lang( I<microsoft_decimal_language_code> )
  
  This sets the language code to tag this document as being in. By
  default, it is currently the value of the environment variable
  C<RTFDEFLANG>, or if that's not set, then the value
  1033 (for US English).
  
  Setting this appropriately is useful if you want to use the RTF
  to spellcheck, and/or if you want it to hyphenate right.
  
  Here are some notable values:
  
    1033  US English
    2057  UK English
    3081  Australia English
    4105  Canada English
    1034  Spain Spanish
    2058  Mexico Spanish
    1031  Germany German
    1036  France French
    3084  Canada French
    1035  Finnish
    1044  Norwegian (Bokmal)
    2068  Norwegian (Nynorsk)
  
  =back
  
  If you are particularly interested in customizing this module's output
  even more, see the source and/or write to me.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<RTF::Writer>, L<RTF::Cookbook>, L<RTF::Document>,
  L<RTF::Generator>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  require 5.005;
  package Pod::Simple::Search;
  use strict;
  
  use vars qw($VERSION $MAX_VERSION_WITHIN $SLEEPY);
  $VERSION = '3.43';   ## Current version of this package
  
  BEGIN { *DEBUG = sub () {0} unless defined &DEBUG; }   # set DEBUG level
  use Carp ();
  
  $SLEEPY = 1 if !defined $SLEEPY and $^O =~ /mswin|mac/i;
    # flag to occasionally sleep for $SLEEPY - 1 seconds.
  
  $MAX_VERSION_WITHIN ||= 60;
  
  #############################################################################
  
  #use diagnostics;
  use File::Spec ();
  use File::Basename qw( basename dirname );
  use Config ();
  use Cwd qw( cwd );
  
  #==========================================================================
  __PACKAGE__->_accessorize(  # Make my dumb accessor methods
   'callback', 'progress', 'dir_prefix', 'inc', 'laborious', 'limit_glob',
   'limit_re', 'shadows', 'verbose', 'name2path', 'path2name', 'recurse',
   'ciseen', 'is_case_insensitive'
  );
  #==========================================================================
  
  sub new {
    my $class = shift;
    my $self = bless {}, ref($class) || $class;
    $self->init;
    return $self;
  }
  
  sub init {
    my $self = shift;
    $self->inc(1);
    $self->recurse(1);
    $self->verbose(DEBUG);
    $self->is_case_insensitive(-e uc __FILE__ && -e lc __FILE__);
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub survey {
    my($self, @search_dirs) = @_;
    $self = $self->new unless ref $self; # tolerate being a class method
  
    $self->_expand_inc( \@search_dirs );
  
    $self->{'_scan_count'} = 0;
    $self->{'_dirs_visited'} = {};
    $self->path2name( {} );
    $self->name2path( {} );
    $self->ciseen( {} );
    $self->limit_re( $self->_limit_glob_to_limit_re ) if $self->{'limit_glob'};
    my $cwd = cwd();
    my $verbose  = $self->verbose;
    local $_; # don't clobber the caller's $_ !
  
    foreach my $try (@search_dirs) {
      unless( File::Spec->file_name_is_absolute($try) ) {
        # make path absolute
        $try = File::Spec->catfile( $cwd ,$try);
      }
      # simplify path
      $try =  File::Spec->canonpath($try);
  
      my $start_in;
      my $modname_prefix;
      if($self->{'dir_prefix'}) {
        $start_in = File::Spec->catdir(
          $try,
          grep length($_), split '[\\/:]+', $self->{'dir_prefix'}
        );
        $modname_prefix = [grep length($_), split m{[:/\\]}, $self->{'dir_prefix'}];
        $verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ",
          "giving $start_in (= @$modname_prefix)\n";
      } else {
        $start_in = $try;
      }
  
      if( $self->{'_dirs_visited'}{$start_in} ) {
        $verbose and print "Directory '$start_in' already seen, skipping.\n";
        next;
      } else {
        $self->{'_dirs_visited'}{$start_in} = 1;
      }
    
      unless(-e $start_in) {
        $verbose and print "Skipping non-existent $start_in\n";
        next;
      }
  
      my $closure = $self->_make_search_callback;
      
      if(-d $start_in) {
        # Normal case:
        $verbose and print "Beginning excursion under $start_in\n";
        $self->_recurse_dir( $start_in, $closure, $modname_prefix );
        $verbose and print "Back from excursion under $start_in\n\n";
          
      } elsif(-f _) {
        # A excursion consisting of just one file!
        $_ = basename($start_in);
        $verbose and print "Pondering $start_in ($_)\n";
        $closure->($start_in, $_, 0, []);
          
      } else {
        $verbose and print "Skipping mysterious $start_in\n";
      }
    }
    $self->progress and $self->progress->done(
     "Noted $$self{'_scan_count'} Pod files total");
    $self->ciseen( {} );
  
    return unless defined wantarray; # void
    return $self->name2path unless wantarray; # scalar
    return $self->name2path, $self->path2name; # list
  }
  
  #==========================================================================
  sub _make_search_callback {
    my $self = $_[0];
  
    # Put the options in variables, for easy access
    my( $laborious, $verbose, $shadows, $limit_re, $callback, $progress,
        $path2name, $name2path, $recurse, $ciseen, $is_case_insensitive) =
      map scalar($self->$_()),
       qw(laborious verbose shadows limit_re callback progress
          path2name name2path recurse ciseen is_case_insensitive);
    my ($seen, $remember, $files_for);
    if ($is_case_insensitive) {
        $seen      = sub { $ciseen->{ lc $_[0] } };
        $remember  = sub { $name2path->{ $_[0] } = $ciseen->{ lc $_[0] } = $_[1]; };
        $files_for = sub { my $n = lc $_[0]; grep { lc $path2name->{$_} eq $n } %{ $path2name } };
    } else {
        $seen      = sub { $name2path->{ $_[0] } };
        $remember  = sub { $name2path->{ $_[0] } = $_[1] };
        $files_for = sub { my $n = $_[0]; grep { $path2name->{$_} eq $n } %{ $path2name } };
    }
  
    my($file, $shortname, $isdir, $modname_bits);
    return sub {
      ($file, $shortname, $isdir, $modname_bits) = @_;
  
      if($isdir) { # this never gets called on the startdir itself, just subdirs
  
        unless( $recurse ) {
          $verbose and print "Not recursing into '$file' as per requested.\n";
          return 'PRUNE';
        }
  
        if( $self->{'_dirs_visited'}{$file} ) {
          $verbose and print "Directory '$file' already seen, skipping.\n";
          return 'PRUNE';
        }
  
        print "Looking in dir $file\n" if $verbose;
  
        unless ($laborious) { # $laborious overrides pruning
          if( m/^(\d+\.[\d_]{3,})\z/s
               and do { my $x = $1; $x =~ tr/_//d; $x != $] }
             ) {
            $verbose and print "Perl $] version mismatch on $_, skipping.\n";
            return 'PRUNE';
          }
  
          if( m/^([A-Za-z][a-zA-Z0-9_]*)\z/s ) {
            $verbose and print "$_ is a well-named module subdir.  Looking....\n";
          } else {
            $verbose and print "$_ is a fishy directory name.  Skipping.\n";
            return 'PRUNE';
          }
        } # end unless $laborious
  
        $self->{'_dirs_visited'}{$file} = 1;
        return; # (not pruning);
      }
  
      # Make sure it's a file even worth even considering
      if($laborious) {
        unless(
          m/\.(pod|pm|plx?)\z/i || -x _ and -T _
           # Note that the cheapest operation (the RE) is run first.
        ) {
          $verbose > 1 and print " Brushing off uninteresting $file\n";
          return;
        }
      } else {
        unless( m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is ) {
          $verbose > 1 and print " Brushing off oddly-named $file\n";
          return;
        }
      }
  
      $verbose and print "Considering item $file\n";
      my $name = $self->_path2modname( $file, $shortname, $modname_bits );
      $verbose > 0.01 and print " Nominating $file as $name\n";
          
      if($limit_re and $name !~ m/$limit_re/i) {
        $verbose and print "Shunning $name as not matching $limit_re\n";
        return;
      }
  
      if( !$shadows and $seen->($name) ) {
        $verbose and print "Not worth considering $file ",
          "-- already saw $name as ",
          join(' ', $files_for->($name)), "\n";
        return;
      }
  
      # Put off until as late as possible the expense of
      #  actually reading the file:
      $progress and $progress->reach($self->{'_scan_count'}, "Scanning $file");
      return unless $self->contains_pod( $file );
      ++ $self->{'_scan_count'};
  
      # Or finally take note of it:
      if ( my $prev = $seen->($name)  ) {
        $verbose and print
         "Duplicate POD found (shadowing?): $name ($file)\n",
         "    Already seen in ", join(' ', $files_for->($name)), "\n";
      } else {
        $remember->($name, $file); # Noting just the first occurrence
      }
      $verbose and print "  Noting $name = $file\n";
      if( $callback ) {
        local $_ = $_; # insulate from changes, just in case
        $callback->($file, $name);
      }
      $path2name->{$file} = $name;
      return;
    }
  }
  
  #==========================================================================
  
  sub _path2modname {
    my($self, $file, $shortname, $modname_bits) = @_;
  
    # this code simplifies the POD name for Perl modules:
    # * remove "site_perl"
    # * remove e.g. "i586-linux" (from 'archname')
    # * remove e.g. 5.00503
    # * remove pod/ if followed by perl*.pod (e.g. in pod/perlfunc.pod)
    # * dig into the file for case-preserved name if not already mixed case
  
    my @m = @$modname_bits;
    my $x;
    my $verbose = $self->verbose;
  
    # Shaving off leading naughty-bits
    while(@m
      and defined($x = lc( $m[0] ))
      and(  $x eq 'site_perl'
         or($x =~ m/^pods?$/ and @m == 1 and $shortname =~ m{^perl.*\.pod$}s )
         or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?}  # if looks like a vernum
         or $x eq lc( $Config::Config{'archname'} )
    )) { shift @m }
  
    my $name = join '::', @m, $shortname;
    $self->_simplify_base($name);
  
    # On VMS, case-preserved document names can't be constructed from
    # filenames, so try to extract them from the "=head1 NAME" tag in the
    # file instead.
    if ($^O eq 'VMS' && ($name eq lc($name) || $name eq uc($name))) {
        open PODFILE, "<$file" or die "_path2modname: Can't open $file: $!";
        my $in_pod = 0;
        my $in_name = 0;
        my $line;
        while ($line = <PODFILE>) {
          chomp $line;
          $in_pod = 1 if ($line =~ m/^=\w/);
          $in_pod = 0 if ($line =~ m/^=cut/);
          next unless $in_pod;         # skip non-pod text
          next if ($line =~ m/^\s*\z/);           # and blank lines
          next if ($in_pod && ($line =~ m/^X</)); # and commands
          if ($in_name) {
            if ($line =~ m/(\w+::)?(\w+)/) {
              # substitute case-preserved version of name
              my $podname = $2;
              my $prefix = $1 || '';
              $verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";
              unless ($name =~ s/$prefix$podname/$prefix$podname/i) {
                $verbose and print "Attempting case restore of '$name' from '$podname'\n";
                $name =~ s/$podname/$podname/i;
              }
              last;
            }
          }
          $in_name = 1 if ($line =~ m/^=head1 NAME/);
      }
      close PODFILE;
    }
  
    return $name;
  }
  
  #==========================================================================
  
  sub _recurse_dir {
    my($self, $startdir, $callback, $modname_bits) = @_;
  
    my $maxdepth = $self->{'fs_recursion_maxdepth'} || 10;
    my $verbose = $self->verbose;
  
    my $here_string = File::Spec->curdir;
    my $up_string   = File::Spec->updir;
    $modname_bits ||= [];
  
    my $recursor;
    $recursor = sub {
      my($dir_long, $dir_bare) = @_;
      if( @$modname_bits >= 10 ) {
        $verbose and print "Too deep! [@$modname_bits]\n";
        return;
      }
  
      unless(-d $dir_long) {
        $verbose > 2 and print "But it's not a dir! $dir_long\n";
        return;
      }
      unless( opendir(INDIR, $dir_long) ) {
        $verbose > 2 and print "Can't opendir $dir_long : $!\n";
        closedir(INDIR);
        return
      }
  
      # Load all items; put no extension before .pod before .pm before .plx?.
      my @items = map { $_->[0] }
        sort { $a->[1] cmp $b->[1] || $b->[2] cmp $a->[2] }
        map {
          (my $t = $_) =~ s/[.]p(m|lx?|od)\z//;
          [$_, $t, lc($1 || 'z') ]
        } readdir(INDIR);
      closedir(INDIR);
  
      push @$modname_bits, $dir_bare unless $dir_bare eq '';
  
      my $i_full;
      foreach my $i (@items) {
        next if $i eq $here_string or $i eq $up_string or $i eq '';
        $i_full = File::Spec->catfile( $dir_long, $i );
  
        if(!-r $i_full) {
          $verbose and print "Skipping unreadable $i_full\n";
         
        } elsif(-f $i_full) {
          $_ = $i;
          $callback->(          $i_full, $i, 0, $modname_bits );
  
        } elsif(-d _) {
          $i =~ s/\.DIR\z//i if $^O eq 'VMS';
          $_ = $i;
          my $rv = $callback->( $i_full, $i, 1, $modname_bits ) || '';
  
          if($rv eq 'PRUNE') {
            $verbose > 1 and print "OK, pruning";
          } else {
            # Otherwise, recurse into it
            $recursor->( File::Spec->catdir($dir_long, $i) , $i);
          }
        } else {
          $verbose > 1 and print "Skipping oddity $i_full\n";
        }
      }
      pop @$modname_bits;
      return;
    };;
  
    local $_;
    $recursor->($startdir, '');
  
    undef $recursor;  # allow it to be GC'd
  
    return;  
  }
  
  
  #==========================================================================
  
  sub run {
    # A function, useful in one-liners
  
    my $self = __PACKAGE__->new;
    $self->limit_glob($ARGV[0]) if @ARGV;
    $self->callback( sub {
      my($file, $name) = @_;
      my $version = '';
       
      # Yes, I know we won't catch the version in like a File/Thing.pm
      #  if we see File/Thing.pod first.  That's just the way the
      #  cookie crumbles.  -- SMB
       
      if($file =~ m/\.pod$/i) {
        # Don't bother looking for $VERSION in .pod files
        DEBUG and print "Not looking for \$VERSION in .pod $file\n";
      } elsif( !open(INPOD, $file) ) {
        DEBUG and print "Couldn't open $file: $!\n";
        close(INPOD);
      } else {
        # Sane case: file is readable
        my $lines = 0;
        while(<INPOD>) {
          last if $lines++ > $MAX_VERSION_WITHIN; # some degree of sanity
          if( s/^\s*\$VERSION\s*=\s*//s and m/\d/ ) {
            DEBUG and print "Found version line (#$lines): $_";
            s/\s*\#.*//s;
            s/\;\s*$//s;
            s/\s+$//s;
            s/\t+/ /s; # nix tabs
            # Optimize the most common cases:
            $_ = "v$1"
              if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s
               # like in $VERSION = "3.14159";
               or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s
               # like in sprintf("%d.%02d", q$Revision: 4.13 $ =~ /(\d+)\.(\d+)/);
            ;
             
            # Like in sprintf("%d.%s", map {s/_//g; $_} q$Name: release-0_55-public $ =~ /-(\d+)_([\d_]+)/)
            $_ = sprintf("v%d.%s",
              map {s/_//g; $_}
                $1 =~ m/-(\d+)_([\d_]+)/) # snare just the numeric part
             if m{\$Name:\s*([^\$]+)\$}s 
            ;
            $version = $_;
            DEBUG and print "Noting $version as version\n";
            last;
          }
        }
        close(INPOD);
      }
      print "$name\t$version\t$file\n";
      return;
      # End of callback!
    });
  
    $self->survey;
  }
  
  #==========================================================================
  
  sub simplify_name {
    my($self, $str) = @_;
      
    # Remove all path components
    #                             XXX Why not just use basename()? -- SMB
  
    if ($^O eq 'MacOS') { $str =~ s{^.*:+}{}s }
    else                { $str =~ s{^.*/+}{}s }
    
    $self->_simplify_base($str);
    return $str;
  }
  
  #==========================================================================
  
  sub _simplify_base {   # Internal method only
  
    # strip Perl's own extensions
    $_[1] =~ s/\.(pod|pm|plx?)\z//i;
  
    # strip meaningless extensions on Win32 and OS/2
    $_[1] =~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;
  
    # strip meaningless extensions on VMS
    $_[1] =~ s/\.(com)\z//i if $^O eq 'VMS';
  
    return;
  }
  
  #==========================================================================
  
  sub _expand_inc {
    my($self, $search_dirs) = @_;
    
    return unless $self->{'inc'};
    my %seen = map { File::Spec->rel2abs($_) => 1 } @{ $search_dirs };
  
    if ($^O eq 'MacOS') {
      push @$search_dirs,
        grep { !$seen{ File::Spec->rel2abs($_) }++ } $self->_mac_whammy(@INC);
    # Any other OSs need custom handling here?
    } else {
      push @$search_dirs,
        grep { !$seen{ File::Spec->rel2abs($_) }++ } @INC;
    }
  
    $self->{'laborious'} = 0;   # Since inc said to use INC
    return;
  }
  
  #==========================================================================
  
  sub _mac_whammy { # Tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
    my @them;
    (undef,@them) = @_;
    for $_ (@them) {
      if ( $_ eq '.' ) {
        $_ = ':';
      } elsif ( $_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e ) {
        $_ = ':'. $_;
      } else {
        $_ =~ s|^\./|:|;
      }
    }
    return @them;
  }
  
  #==========================================================================
  
  sub _limit_glob_to_limit_re {
    my $self = $_[0];
    my $limit_glob = $self->{'limit_glob'} || return;
  
    my $limit_re = '^' . quotemeta($limit_glob) . '$';
    $limit_re =~ s/\\\?/./g;    # glob "?" => "."
    $limit_re =~ s/\\\*/.*?/g;  # glob "*" => ".*?"
    $limit_re =~ s/\.\*\?\$$//s; # final glob "*" => ".*?$" => ""
  
    $self->{'verbose'} and print "Turning limit_glob $limit_glob into re $limit_re\n";
  
    # A common optimization:
    if(!exists($self->{'dir_prefix'})
      and $limit_glob =~ m/^(?:\w+\:\:)+/s  # like "File::*" or "File::Thing*"
      # Optimize for sane and common cases (but not things like "*::File")
    ) {
      $self->{'dir_prefix'} = join "::", $limit_glob =~ m/^(?:\w+::)+/sg;
      $self->{'verbose'} and print " and setting dir_prefix to $self->{'dir_prefix'}\n";
    }
  
    return $limit_re;
  }
  
  #==========================================================================
  
  # contribution mostly from Tim Jenness <t.jenness@jach.hawaii.edu>
  
  sub _actual_filenames {
      my $dir = shift;
      my $fn = lc shift;
      opendir my ($dh), $dir or return;
      return map { File::Spec->catdir($dir, $_) }
          grep { lc $_  eq $fn } readdir $dh;
  }
  
  sub find {
    my($self, $pod, @search_dirs) = @_;
    $self = $self->new unless ref $self; # tolerate being a class method
  
    # Check usage
    Carp::carp 'Usage: \$self->find($podname, ...)'
     unless defined $pod and length $pod;
  
    my $verbose = $self->verbose;
  
    # Split on :: and then join the name together using File::Spec
    my @parts = split /::/, $pod;
    $verbose and print "Chomping {$pod} => {@parts}\n";
  
    #@search_dirs = File::Spec->curdir unless @search_dirs;
    
    $self->_expand_inc(\@search_dirs);
    # Add location of binaries such as pod2text:
    push @search_dirs, $Config::Config{'scriptdir'} if $self->inc;
  
    my %seen_dir;
    while (my $dir = shift @search_dirs ) {
      next unless defined $dir and length $dir;
      next if $seen_dir{$dir};
      $seen_dir{$dir} = 1;
      unless(-d $dir) {
        print "Directory $dir does not exist\n" if $verbose;
      }
  
      print "Looking in directory $dir\n" if $verbose;
      my $fullname = File::Spec->catfile( $dir, @parts );
      print "Filename is now $fullname\n" if $verbose;
  
      foreach my $ext ('', '.pod', '.pm', '.pl') {   # possible extensions
        my $fullext = $fullname . $ext;
        if ( -f $fullext and $self->contains_pod($fullext) ) {
          print "FOUND: $fullext\n" if $verbose;
          if (@parts > 1 && lc $parts[0] eq 'pod' && $self->is_case_insensitive() && $ext eq '.pod') {
            # Well, this file could be for a program (perldoc) but we actually
            # want a module (Pod::Perldoc). So see if there is a .pm with the
            # proper casing.
            my $subdir = dirname $fullext;
            unless (grep { $fullext eq $_  } _actual_filenames $subdir, "$parts[-1].pod") {
              print "# Looking for alternate spelling in $subdir\n" if $verbose;
              # Try the .pm file.
              my $pm = $fullname . '.pm';
              if ( -f $pm and $self->contains_pod($pm) ) {
                # Prefer the .pm if its case matches.
                if (grep { $pm eq $_  } _actual_filenames $subdir, "$parts[-1].pm") {
                  print "FOUND: $fullext\n" if $verbose;
                  return $pm;
                }
              }
            }
          }
          return $fullext;
        }
      }
  
      # Case-insensitively Look for ./pod directories and slip them in.
      for my $subdir ( _actual_filenames($dir, 'pods'), _actual_filenames($dir, 'pod') ) {
        if (-d $subdir) {
          $verbose and print "Noticing $subdir and looking there...\n";
          unshift @search_dirs, $subdir;
        }
      }
    }
  
    return undef;
  }
  
  #==========================================================================
  
  sub contains_pod {
    my($self, $file) = @_;
    my $verbose = $self->{'verbose'};
  
    # check for one line of POD
    $verbose > 1 and print " Scanning $file for pod...\n";
    unless( open(MAYBEPOD,"<$file") ) {
      print "Error: $file is unreadable: $!\n";
      return undef;
    }
  
    sleep($SLEEPY - 1) if $SLEEPY;
     # avoid totally hogging the processor on OSs with poor process control
    
    local $_;
    while( <MAYBEPOD> ) {
      if(m/^=(head\d|pod|over|item)\b/s) {
        close(MAYBEPOD) || die "Bizarre error closing $file: $!\nAborting";
        chomp;
        $verbose > 1 and print "  Found some pod ($_) in $file\n";
        return 1;
      }
    }
    close(MAYBEPOD) || die "Bizarre error closing $file: $!\nAborting";
    $verbose > 1 and print "  No POD in $file, skipping.\n";
    return 0;
  }
  
  #==========================================================================
  
  sub _accessorize {  # A simple-minded method-maker
    shift;
    no strict 'refs';
    foreach my $attrname (@_) {
      *{caller() . '::' . $attrname} = sub {
        use strict;
        $Carp::CarpLevel = 1,  Carp::croak(
         "Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
        ) unless (@_ == 1 or @_ == 2) and ref $_[0];
  
        # Read access:
        return $_[0]->{$attrname} if @_ == 1;
  
        # Write access:
        $_[0]->{$attrname} = $_[1];
        return $_[0]; # RETURNS MYSELF!
      };
    }
    # Ya know, they say accessories make the ensemble!
    return;
  }
  
  #==========================================================================
  sub _state_as_string {
    my $self = $_[0];
    return '' unless ref $self;
    my @out = "{\n  # State of $self ...\n";
    foreach my $k (sort keys %$self) {
      push @out, "  ", _esc($k), " => ", _esc($self->{$k}), ",\n";
    }
    push @out, "}\n";
    my $x = join '', @out;
    $x =~ s/^/#/mg;
    return $x;
  }
  
  sub _esc {
    my $in = $_[0];
    return 'undef' unless defined $in;
    $in =~
      s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;
    return qq{"$in"};
  }
  
  #==========================================================================
  
  run() unless caller;  # run if "perl whatever/Search.pm"
  
  1;
  
  #==========================================================================
  
  __END__
  
  
  =head1 NAME
  
  Pod::Simple::Search - find POD documents in directory trees
  
  =head1 SYNOPSIS
  
    use Pod::Simple::Search;
    my $name2path = Pod::Simple::Search->new->limit_glob('LWP::*')->survey;
    print "Looky see what I found: ",
      join(' ', sort keys %$name2path), "\n";
  
    print "LWPUA docs = ",
      Pod::Simple::Search->new->find('LWP::UserAgent') || "?",
      "\n";
  
  =head1 DESCRIPTION
  
  B<Pod::Simple::Search> is a class that you use for running searches
  for Pod files.  An object of this class has several attributes
  (mostly options for controlling search options), and some methods
  for searching based on those attributes.
  
  The way to use this class is to make a new object of this class,
  set any options, and then call one of the search options
  (probably C<survey> or C<find>).  The sections below discuss the
  syntaxes for doing all that.
  
  
  =head1 CONSTRUCTOR
  
  This class provides the one constructor, called C<new>.
  It takes no parameters:
  
    use Pod::Simple::Search;
    my $search = Pod::Simple::Search->new;
  
  =head1 ACCESSORS
  
  This class defines several methods for setting (and, occasionally,
  reading) the contents of an object. With two exceptions (discussed at
  the end of this section), these attributes are just for controlling the
  way searches are carried out.
  
  Note that each of these return C<$self> when you call them as
  C<< $self->I<whatever(value)> >>.  That's so that you can chain
  together set-attribute calls like this:
  
    my $name2path =
      Pod::Simple::Search->new
      -> inc(0) -> verbose(1) -> callback(\&blab)
      ->survey(@there);
  
  ...which works exactly as if you'd done this:
  
    my $search = Pod::Simple::Search->new;
    $search->inc(0);
    $search->verbose(1);
    $search->callback(\&blab);
    my $name2path = $search->survey(@there);
  
  =over
  
  =item $search->inc( I<true-or-false> );
  
  This attribute, if set to a true value, means that searches should
  implicitly add perl's I<@INC> paths. This
  automatically considers paths specified in the C<PERL5LIB> environment
  as this is prepended to I<@INC> by the Perl interpreter itself.
  This attribute's default value is B<TRUE>.  If you want to search
  only specific directories, set $self->inc(0) before calling
  $inc->survey or $inc->find.
  
  
  =item $search->verbose( I<nonnegative-number> );
  
  This attribute, if set to a nonzero positive value, will make searches output
  (via C<warn>) notes about what they're doing as they do it.
  This option may be useful for debugging a pod-related module.
  This attribute's default value is zero, meaning that no C<warn> messages
  are produced.  (Setting verbose to 1 turns on some messages, and setting
  it to 2 turns on even more messages, i.e., makes the following search(es)
  even more verbose than 1 would make them.)
  
  =item $search->limit_glob( I<some-glob-string> );
  
  This option means that you want to limit the results just to items whose
  podnames match the given glob/wildcard expression. For example, you
  might limit your search to just "LWP::*", to search only for modules
  starting with "LWP::*" (but not including the module "LWP" itself); or
  you might limit your search to "LW*" to see only modules whose (full)
  names begin with "LW"; or you might search for "*Find*" to search for
  all modules with "Find" somewhere in their full name. (You can also use
  "?" in a glob expression; so "DB?" will match "DBI" and "DBD".)
  
  
  =item $search->callback( I<\&some_routine> );
  
  This attribute means that every time this search sees a matching
  Pod file, it should call this callback routine.  The routine is called
  with two parameters: the current file's filespec, and its pod name.
  (For example: C<("/etc/perljunk/File/Crunk.pm", "File::Crunk")> would
  be in C<@_>.)
  
  The callback routine's return value is not used for anything.
  
  This attribute's default value is false, meaning that no callback
  is called.
  
  =item $search->laborious( I<true-or-false> );
  
  Unless you set this attribute to a true value, Pod::Search will 
  apply Perl-specific heuristics to find the correct module PODs quickly.
  This attribute's default value is false.  You won't normally need
  to set this to true.
  
  Specifically: Turning on this option will disable the heuristics for
  seeing only files with Perl-like extensions, omitting subdirectories
  that are numeric but do I<not> match the current Perl interpreter's
  version ID, suppressing F<site_perl> as a module hierarchy name, etc.
  
  =item $search->recurse( I<true-or-false> );
  
  Unless you set this attribute to a false value, Pod::Search will
  recurse into subdirectories of the search directories.
  
  =item $search->shadows( I<true-or-false> );
  
  Unless you set this attribute to a true value, Pod::Simple::Search will
  consider only the first file of a given modulename as it looks thru the
  specified directories; that is, with this option off, if
  Pod::Simple::Search has seen a C<somepathdir/Foo/Bar.pm> already in this
  search, then it won't bother looking at a C<somelaterpathdir/Foo/Bar.pm>
  later on in that search, because that file is merely a "shadow". But if
  you turn on C<< $self->shadows(1) >>, then these "shadow" files are
  inspected too, and are noted in the pathname2podname return hash.
  
  This attribute's default value is false; and normally you won't
  need to turn it on.
  
  =item $search->is_case_insensitive( I<true-or-false> );
  
  Pod::Simple::Search will by default internally make an assumption
  based on the underlying filesystem where the class file is found
  whether it is case insensitive or not.
  
  If it is determined to be case insensitive, during survey() it may
  skip pod files/modules that happen to be equal to names it's already
  seen, ignoring case.
  
  However, it's possible to have distinct files in different directories
  that intentionally has the same name, just differing in case, that should
  be reported. Hence, you may force the behavior by setting this to true
  or false.
  
  =item $search->limit_re( I<some-regxp> );
  
  Setting this attribute (to a value that's a regexp) means that you want
  to limit the results just to items whose podnames match the given
  regexp. Normally this option is not needed, and the more efficient
  C<limit_glob> attribute is used instead.
  
  =item $search->dir_prefix( I<some-string-value> );
  
  Setting this attribute to a string value means that the searches should
  begin in the specified subdirectory name (like "Pod" or "File::Find",
  also expressible as "File/Find"). For example, the search option
  C<< $search->limit_glob("File::Find::R*") >>
  is the same as the combination of the search options
  C<< $search->limit_re("^File::Find::R") -> dir_prefix("File::Find") >>.
  
  Normally you don't need to know about the C<dir_prefix> option, but I
  include it in case it might prove useful for someone somewhere.
  
  (Implementationally, searching with limit_glob ends up setting limit_re
  and usually dir_prefix.)
  
  
  =item $search->progress( I<some-progress-object> );
  
  If you set a value for this attribute, the value is expected
  to be an object (probably of a class that you define) that has a 
  C<reach> method and a C<done> method.  This is meant for reporting
  progress during the search, if you don't want to use a simple
  callback.
  
  Normally you don't need to know about the C<progress> option, but I
  include it in case it might prove useful for someone somewhere.
  
  While a search is in progress, the progress object's C<reach> and
  C<done> methods are called like this:
  
    # Every time a file is being scanned for pod:
    $progress->reach($count, "Scanning $file");   ++$count;
  
    # And then at the end of the search:
    $progress->done("Noted $count Pod files total");
  
  Internally, we often set this to an object of class
  Pod::Simple::Progress.  That class is probably undocumented,
  but you may wish to look at its source.
  
  
  =item $name2path = $self->name2path;
  
  This attribute is not a search parameter, but is used to report the
  result of C<survey> method, as discussed in the next section.
  
  =item $path2name = $self->path2name;
  
  This attribute is not a search parameter, but is used to report the
  result of C<survey> method, as discussed in the next section.
  
  =back
  
  =head1 MAIN SEARCH METHODS
  
  Once you've actually set any options you want (if any), you can go
  ahead and use the following methods to search for Pod files
  in particular ways.
  
  
  =head2 C<< $search->survey( @directories ) >>
  
  The method C<survey> searches for POD documents in a given set of
  files and/or directories.  This runs the search according to the various
  options set by the accessors above.  (For example, if the C<inc> attribute
  is on, as it is by default, then the perl @INC directories are implicitly
  added to the list of directories (if any) that you specify.)
  
  The return value of C<survey> is two hashes:
  
  =over
  
  =item C<name2path>
  
  A hash that maps from each pod-name to the filespec (like
  "Stuff::Thing" => "/whatever/plib/Stuff/Thing.pm")
  
  =item C<path2name>
  
  A hash that maps from each Pod filespec to its pod-name (like
  "/whatever/plib/Stuff/Thing.pm" => "Stuff::Thing")
  
  =back
  
  Besides saving these hashes as the hashref attributes
  C<name2path> and C<path2name>, calling this function also returns
  these hashrefs.  In list context, the return value of
  C<< $search->survey >> is the list C<(\%name2path, \%path2name)>.
  In scalar context, the return value is C<\%name2path>.
  Or you can just call this in void context.
  
  Regardless of calling context, calling C<survey> saves
  its results in its C<name2path> and C<path2name> attributes.
  
  E.g., when searching in F<$HOME/perl5lib>, the file
  F<$HOME/perl5lib/MyModule.pm> would get the POD name I<MyModule>,
  whereas F<$HOME/perl5lib/Myclass/Subclass.pm> would be
  I<Myclass::Subclass>. The name information can be used for POD
  translators.
  
  Only text files containing at least one valid POD command are found.
  
  In verbose mode, a warning is printed if shadows are found (i.e., more
  than one POD file with the same POD name is found, e.g. F<CPAN.pm> in
  different directories).  This usually indicates duplicate occurrences of
  modules in the I<@INC> search path, which is occasionally inadvertent
  (but is often simply a case of a user's path dir having a more recent
  version than the system's general path dirs in general.)
  
  The options to this argument is a list of either directories that are
  searched recursively, or files.  (Usually you wouldn't specify files,
  but just dirs.)  Or you can just specify an empty-list, as in
  $name2path; with the C<inc> option on, as it is by default.
  
  The POD names of files are the plain basenames with any Perl-like
  extension (.pm, .pl, .pod) stripped, and path separators replaced by
  C<::>'s.
  
  Calling Pod::Simple::Search->search(...) is short for
  Pod::Simple::Search->new->search(...).  That is, a throwaway object
  with default attribute values is used.
  
  
  =head2 C<< $search->simplify_name( $str ) >>
  
  The method B<simplify_name> is equivalent to B<basename>, but also
  strips Perl-like extensions (.pm, .pl, .pod) and extensions like
  F<.bat>, F<.cmd> on Win32 and OS/2, or F<.com> on VMS, respectively.
  
  
  =head2 C<< $search->find( $pod ) >>
  
  =head2 C<< $search->find( $pod, @search_dirs ) >>
  
  Returns the location of a Pod file, given a Pod/module/script name
  (like "Foo::Bar" or "perlvar" or "perldoc"), and an idea of
  what files/directories to look in.
  It searches according to the various options set by the accessors above.
  (For example, if the C<inc> attribute is on, as it is by default, then
  the perl @INC directories are implicitly added to the list of
  directories (if any) that you specify.)
  
  This returns the full path of the first occurrence to the file.
  Package names (eg 'A::B') are automatically converted to directory
  names in the selected directory.  Additionally, '.pm', '.pl' and '.pod'
  are automatically appended to the search as required.
  (So, for example, under Unix, "A::B" is converted to "somedir/A/B.pm",
  "somedir/A/B.pod", or "somedir/A/B.pl", as appropriate.)
  
  If no such Pod file is found, this method returns undef.
  
  If any of the given search directories contains a F<pod/> subdirectory,
  then it is searched.  (That's how we manage to find F<perlfunc>,
  for example, which is usually in F<pod/perlfunc> in most Perl dists.)
  
  The C<verbose> and C<inc> attributes influence the behavior of this
  search; notably, C<inc>, if true, adds @INC I<and also
  $Config::Config{'scriptdir'}> to the list of directories to search.
  
  It is common to simply say C<< $filename = Pod::Simple::Search-> new 
  ->find("perlvar") >> so that just the @INC (well, and scriptdir)
  directories are searched.  (This happens because the C<inc>
  attribute is true by default.)
  
  Calling Pod::Simple::Search->find(...) is short for
  Pod::Simple::Search->new->find(...).  That is, a throwaway object
  with default attribute values is used.
  
  
  =head2 C<< $self->contains_pod( $file ) >>
  
  Returns true if the supplied filename (not POD module) contains some Pod
  documentation.
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org> with code borrowed
  from Marek Rouchal's L<Pod::Find>, which in turn heavily borrowed code from
  Nick Ing-Simmons' C<PodToHtml>.
  
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  
  require 5;
  package Pod::Simple::SimpleTree;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( $ATTR_PAD @ISA $VERSION $SORT_ATTRS);
  $VERSION = '3.43';
  BEGIN {
    @ISA = ('Pod::Simple');
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG;
  }
  
  __PACKAGE__->_accessorize(
    'root',   # root of the tree
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start { # self, tagname, attrhash
    DEBUG > 2 and print STDERR "Handling $_[1] start-event\n";
    my $x = [$_[1], $_[2]];
    if($_[0]{'_currpos'}) {
      push    @{ $_[0]{'_currpos'}[0] }, $x; # insert in parent's child-list
      unshift @{ $_[0]{'_currpos'} },    $x; # prefix to stack
    } else {
      DEBUG and print STDERR " And oo, it gets to be root!\n";
      $_[0]{'_currpos'} = [   $_[0]{'root'} = $x   ];
        # first event!  set to stack, and set as root.
    }
    DEBUG > 3 and print STDERR "Stack is now: ",
      join(">", map $_->[0], @{$_[0]{'_currpos'}}), "\n";
    return;
  }
  
  sub _handle_element_end { # self, tagname
    DEBUG > 2 and print STDERR "Handling $_[1] end-event\n";
    shift @{$_[0]{'_currpos'}};
    DEBUG > 3 and print STDERR "Stack is now: ",
      join(">", map $_->[0], @{$_[0]{'_currpos'}}), "\n";
    return;
  }
  
  sub _handle_text { # self, text
    DEBUG > 2 and print STDERR "Handling $_[1] text-event\n";
    push @{ $_[0]{'_currpos'}[0] }, $_[1];
    return;
  }
  
  
  # A bit of evil from the black box...  please avert your eyes, kind souls.
  sub _traverse_treelet_bit {
    DEBUG > 2 and print STDERR "Handling $_[1] paragraph event\n";
    my $self = shift;
    push @{ $self->{'_currpos'}[0] }, [@_];
    return;
  }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1;
  __END__
  
  =head1 NAME
  
  Pod::Simple::SimpleTree -- parse Pod into a simple parse tree 
  
  =head1 SYNOPSIS
  
    % cat ptest.pod
  
    =head1 PIE
  
    I like B<pie>!
  
    % perl -MPod::Simple::SimpleTree -MData::Dumper -e \
       "print Dumper(Pod::Simple::SimpleTree->new->parse_file(shift)->root)" \
       ptest.pod
  
    $VAR1 = [
              'Document',
              { 'start_line' => 1 },
              [
                'head1',
                { 'start_line' => 1 },
                'PIE'
              ],
              [
                'Para',
                { 'start_line' => 3 },
                'I like ',
                [
                  'B',
                  {},
                  'pie'
                ],
                '!'
              ]
            ];
  
  =head1 DESCRIPTION
  
  This class is of interest to people writing a Pod processor/formatter.
  
  This class takes Pod and parses it, returning a parse tree made just
  of arrayrefs, and hashrefs, and strings.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  This class is inspired by XML::Parser's "Tree" parsing-style, although
  it doesn't use exactly the same LoL format.
  
  =head1 METHODS
  
  At the end of the parse, call C<< $parser->root >> to get the
  tree's top node.
  
  =head1 Tree Contents
  
  Every element node in the parse tree is represented by an arrayref of
  the form: C<[ I<elementname>, \%attributes, I<...subnodes...> ]>.
  See the example tree dump in the Synopsis, above.
  
  Every text node in the tree is represented by a simple (non-ref)
  string scalar.  So you can test C<ref($node)> to see whether you have
  an element node or just a text node.
  
  The top node in the tree is C<[ 'Document', \%attributes,
  I<...subnodes...> ]>
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  L<perllol>
  
  L<The "Tree" subsubsection in XML::Parser|XML::Parser/"Tree">
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  
  require 5;
  package Pod::Simple::Text;
  use strict;
  use Carp ();
  use Pod::Simple::Methody ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION $FREAKYMODE);
  $VERSION = '3.43';
  @ISA = ('Pod::Simple::Methody');
  BEGIN { *DEBUG = defined(&Pod::Simple::DEBUG)
            ? \&Pod::Simple::DEBUG
            : sub() {0}
        }
  
  use Text::Wrap 98.112902 ();
  $Text::Wrap::huge = 'overflow';
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_target_as_text(qw( text plaintext plain ));
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->{'Thispara'} = '';
    $new->{'Indent'} = 0;
    $new->{'Indentstring'} = '   ';
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_text {  $_[0]{'Thispara'} .= $_[1] }
  
  sub start_Para  {  $_[0]{'Thispara'} = '' }
  sub start_head1 {  $_[0]{'Thispara'} = '' }
  sub start_head2 {  $_[0]{'Thispara'} = '' }
  sub start_head3 {  $_[0]{'Thispara'} = '' }
  sub start_head4 {  $_[0]{'Thispara'} = '' }
  
  sub start_Verbatim    { $_[0]{'Thispara'} = ''   }
  sub start_item_bullet { $_[0]{'Thispara'} = $FREAKYMODE ? '' : '* ' }
  sub start_item_number { $_[0]{'Thispara'} = $FREAKYMODE ? '' : "$_[1]{'number'}. "  }
  sub start_item_text   { $_[0]{'Thispara'} = ''   }
  
  sub start_over_bullet  { ++$_[0]{'Indent'} }
  sub start_over_number  { ++$_[0]{'Indent'} }
  sub start_over_text    { ++$_[0]{'Indent'} }
  sub start_over_block   { ++$_[0]{'Indent'} }
  
  sub   end_over_bullet  { --$_[0]{'Indent'} }
  sub   end_over_number  { --$_[0]{'Indent'} }
  sub   end_over_text    { --$_[0]{'Indent'} }
  sub   end_over_block   { --$_[0]{'Indent'} }
  
  
  # . . . . . Now the actual formatters:
  
  sub end_head1       { $_[0]->emit_par(-4) }
  sub end_head2       { $_[0]->emit_par(-3) }
  sub end_head3       { $_[0]->emit_par(-2) }
  sub end_head4       { $_[0]->emit_par(-1) }
  sub end_Para        { $_[0]->emit_par( 0) }
  sub end_item_bullet { $_[0]->emit_par( 0) }
  sub end_item_number { $_[0]->emit_par( 0) }
  sub end_item_text   { $_[0]->emit_par(-2) }
  sub start_L         { $_[0]{'Link'} = $_[1] if $_[1]->{type} eq 'url' }
  sub end_L           {
      if (my $link = delete $_[0]{'Link'}) {
          # Append the URL to the output unless it's already present.
          $_[0]{'Thispara'} .= " <$link->{to}>"
              unless $_[0]{'Thispara'} =~ /\b\Q$link->{to}/;
      }
  }
  
  sub emit_par {
    my($self, $tweak_indent) = splice(@_,0,2);
    my $indent = ' ' x ( 2 * $self->{'Indent'} + 4 + ($tweak_indent||0) );
     # Yes, 'STRING' x NEGATIVE gives '', same as 'STRING' x 0
  
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
    my $out = Text::Wrap::wrap($indent, $indent, $self->{'Thispara'} .= "\n");
    $out =~ s/$Pod::Simple::nbsp/ /g;
    print {$self->{'output_fh'}} $out, "\n";
    $self->{'Thispara'} = '';
    
    return;
  }
  
  # . . . . . . . . . . And then off by its lonesome:
  
  sub end_Verbatim  {
    my $self = shift;
    $self->{'Thispara'} =~ s/$Pod::Simple::nbsp/ /g;
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
  
    my $i = ' ' x ( 2 * $self->{'Indent'} + 4);
    #my $i = ' ' x (4 + $self->{'Indent'});
    
    $self->{'Thispara'} =~ s/^/$i/mg;
    
    print { $self->{'output_fh'} }   '', 
      $self->{'Thispara'},
      "\n\n"
    ;
    $self->{'Thispara'} = '';
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Text -- format Pod as plaintext
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::Text -e \
     "exit Pod::Simple::Text->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as
  wrapped plaintext.
  
  Its wrapping is done by L<Text::Wrap>, so you can change
  C<$Text::Wrap::columns> as you like.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::TextContent>, L<Pod::Text>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  
  
  require 5;
  package Pod::Simple::TextContent;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION );
  $VERSION = '3.43';
  @ISA = ('Pod::Simple');
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->nix_X_codes(1);
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start {
    print {$_[0]{'output_fh'}} "\n"  unless $_[1] =~ m/^[A-Z]$/s;
    return;
  }
  
  sub _handle_text {
    $_[1] =~ s/$Pod::Simple::shy//g;
    $_[1] =~ s/$Pod::Simple::nbsp/ /g;
    print {$_[0]{'output_fh'}} $_[1];
    return;
  }
  
  sub _handle_element_end {
    print {$_[0]{'output_fh'}} "\n"  unless $_[1] =~ m/^[A-Z]$/s;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::TextContent -- get the text content of Pod
  
  =head1 SYNOPSIS
  
   TODO
  
    perl -MPod::Simple::TextContent -e \
     "exit Pod::Simple::TextContent->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is that parses Pod and dumps just the text content.  It is
  mainly meant for use by the Pod::Simple test suite, but you may find
  some other use for it.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  
  use strict;
  package Pod::Simple::TiedOutFH;
  use Symbol ('gensym');
  use Carp ();
  use vars qw($VERSION );
  $VERSION = '3.43';
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_on { # some horrible frightening things are encapsulated in here
    my $class = shift;
    $class = ref($class) || $class;
    
    Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;
    
    my $x = (defined($_[0]) and ref($_[0]))
      ? $_[0]
      : ( \( $_[0] ) )[0]
    ;
    $$x = '' unless defined $$x;
    
    #Pod::Simple::DEBUG and print STDERR "New $class handle on $x = \"$$x\"\n";
    
    my $new = gensym();
    tie *$new, $class, $x;
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub TIEHANDLE {  # Ties to just a scalar ref
    my($class, $scalar_ref) = @_;
    $$scalar_ref = '' unless defined $$scalar_ref;
    return bless \$scalar_ref,  ref($class) || $class;
  }
  
  sub PRINT {
    my $it = shift;
    foreach my $x (@_) { $$$it .= $x }
  
    #Pod::Simple::DEBUG > 10 and print STDERR " appended to $$it = \"$$$it\"\n";
  
    return 1;
  }
  
  sub FETCH {
    return ${$_[0]};
  }
  
  sub PRINTF {
    my $it = shift;
    my $format = shift;
    $$$it .= sprintf $format, @_;
    return 1;
  }
  
  sub FILENO { ${ $_[0] } + 100 } # just to produce SOME number
  
  sub CLOSE { 1 }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1;
  __END__
  
  Chole
  
   * 1 large red onion
   * 2 tomatillos
   * 4 or 5 roma tomatoes (optionally with the pulp discarded)
   * 1 tablespoons chopped ginger root (or more, to taste)
   * 2 tablespoons canola oil (or vegetable oil)
   
   * 1 tablespoon garam masala
   * 1/2 teaspoon red chili powder, or to taste
   * Salt, to taste (probably quite a bit)
   * 2 (15-ounce) cans chick peas or garbanzo beans, drained and rinsed
   * juice of one smallish lime
   * a dash of balsamic vinegar (to taste)
   * cooked rice, preferably long-grain white rice (whether plain,
      basmati rice, jasmine rice, or even a mild pilaf)
  
  In a blender or food processor, puree the onions, tomatoes, tomatillos,
  and ginger root.  You can even do it with a Braun hand "mixer", if you
  chop things finer to start with, and work at it.
  
  In a saucepan set over moderate heat, warm the oil until hot.
  
  Add the puree and the balsamic vinegar, and cook, stirring occasionally,
  for 20 to 40 minutes. (Cooking it longer will make it sweeter.)
  
  Add the Garam Masala, chili powder, and cook, stirring occasionally, for
  5 minutes.
  
  Add the salt and chick peas and cook, stirring, until heated through.
  
  Stir in the lime juice, and optionally one or two teaspoons of tahini.
  You can let it simmer longer, depending on how much softer you want the
  garbanzos to get.
  
  Serve over rice, like a curry.
  
  Yields 5 to 7 servings.
  
  
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  
  require 5;
  package Pod::Simple::Transcode;
  use strict;
  use vars qw($VERSION @ISA);
  $VERSION = '3.43';
  
  BEGIN {
    if(defined &DEBUG) {;} # Okay
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG; }
    else { *DEBUG = sub () {0}; }
  }
  
  foreach my $class (
    'Pod::Simple::TranscodeSmart',
    'Pod::Simple::TranscodeDumb',
    '',
  ) {
    $class or die "Couldn't load any encoding classes";
    DEBUG and print STDERR "About to try loading $class...\n";
    eval "require $class;";
    if($@) {
      DEBUG and print STDERR "Couldn't load $class: $@\n";
    } else {
      DEBUG and print STDERR "OK, loaded $class.\n";
      @ISA = ($class);
      last;
    }
  }
  
  sub _blorp { return; } # just to avoid any "empty class" warning
  
  1;
  __END__
  
  
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  
  require 5;
  ## This module is to be use()'d only by Pod::Simple::Transcode
  
  package Pod::Simple::TranscodeDumb;
  use strict;
  use vars qw($VERSION %Supported);
  $VERSION = '3.43';
  # This module basically pretends it knows how to transcode, except
  #  only for null-transcodings!  We use this when Encode isn't
  #  available.
  
  %Supported = (
    'ascii'       => 1,
    'ascii-ctrl'  => 1,
    'iso-8859-1'  => 1,
    'cp1252'      => 1,
    'null'        => 1,
    'latin1'      => 1,
    'latin-1'     => 1,
    %Supported,
  );
  
  sub is_dumb  {1}
  sub is_smart {0}
  
  sub all_encodings {
    return sort keys %Supported;
  }
  
  sub encoding_is_available {
    return exists $Supported{lc $_[1]};
  }
  
  sub encmodver {
    return __PACKAGE__ . " v" .($VERSION || '?');
  }
  
  sub make_transcoder {
      my ($e) = $_[1];
      die "WHAT ENCODING!?!?" unless $e;
      # No-op for all but CP1252.
      return sub {;} if $e !~ /^cp-?1252$/i;
  
      # Replace CP1252 nerbles with their ASCII equivalents.
      return sub {
          # Copied from Encode::ZapCP1252.
          my %ascii_for = (
              # http://en.wikipedia.org/wiki/Windows-1252
              "\x80" => 'e',    # EURO SIGN
              "\x82" => ',',    # SINGLE LOW-9 QUOTATION MARK
              "\x83" => 'f',    # LATIN SMALL LETTER F WITH HOOK
              "\x84" => ',,',   # DOUBLE LOW-9 QUOTATION MARK
              "\x85" => '...',  # HORIZONTAL ELLIPSIS
              "\x86" => '+',    # DAGGER
              "\x87" => '++',   # DOUBLE DAGGER
              "\x88" => '^',    # MODIFIER LETTER CIRCUMFLEX ACCENT
              "\x89" => '%',    # PER MILLE SIGN
              "\x8a" => 'S',    # LATIN CAPITAL LETTER S WITH CARON
              "\x8b" => '<',    # SINGLE LEFT-POINTING ANGLE QUOTATION MARK
              "\x8c" => 'OE',   # LATIN CAPITAL LIGATURE OE
              "\x8e" => 'Z',    # LATIN CAPITAL LETTER Z WITH CARON
              "\x91" => "'",    # LEFT SINGLE QUOTATION MARK
              "\x92" => "'",    # RIGHT SINGLE QUOTATION MARK
              "\x93" => '"',    # LEFT DOUBLE QUOTATION MARK
              "\x94" => '"',    # RIGHT DOUBLE QUOTATION MARK
              "\x95" => '*',    # BULLET
              "\x96" => '-',    # EN DASH
              "\x97" => '--',   # EM DASH
              "\x98" => '~',    # SMALL TILDE
              "\x99" => '(tm)', # TRADE MARK SIGN
              "\x9a" => 's',    # LATIN SMALL LETTER S WITH CARON
              "\x9b" => '>',    # SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
              "\x9c" => 'oe',   # LATIN SMALL LIGATURE OE
              "\x9e" => 'z',    # LATIN SMALL LETTER Z WITH CARON
              "\x9f" => 'Y',    # LATIN CAPITAL LETTER Y WITH DIAERESIS
          );
  
          s{([\x80-\x9f])}{$ascii_for{$1} || $1}emxsg for @_;
    };
  }
  
  
  1;
  
  
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  
  require 5;
  use 5.008;
  ## Anything before 5.8.0 is GIMPY!
  ## This module is to be use()'d only by Pod::Simple::Transcode
  
  package Pod::Simple::TranscodeSmart;
  use strict;
  use Pod::Simple;
  require Encode;
  use vars qw($VERSION );
  $VERSION = '3.43';
  
  sub is_dumb  {0}
  sub is_smart {1}
  
  sub all_encodings {
    return Encode::->encodings(':all');
  }
  
  sub encoding_is_available {
    return Encode::resolve_alias($_[1]);
  }
  
  sub encmodver {
    return "Encode.pm v" .($Encode::VERSION || '?');
  }
  
  sub make_transcoder {
    my $e = Encode::find_encoding($_[1]);
    die "WHAT ENCODING!?!?" unless $e;
    my $x;
    return sub {
      foreach $x (@_) {
        $x = $e->decode($x) unless Encode::is_utf8($x);
      }
      return;
    };
  }
  
  
  1;
  
  
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  =pod
  
  =head1 NAME
  
  Pod::Simple::XHTML -- format Pod as validating XHTML
  
  =head1 SYNOPSIS
  
    use Pod::Simple::XHTML;
  
    my $parser = Pod::Simple::XHTML->new();
  
    ...
  
    $parser->parse_file('path/to/file.pod');
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as XHTML
  validating HTML.
  
  This is a subclass of L<Pod::Simple::Methody> and inherits all its
  methods. The implementation is entirely different than
  L<Pod::Simple::HTML>, but it largely preserves the same interface.
  
  =head2 Minimal code
  
    use Pod::Simple::XHTML;
    my $psx = Pod::Simple::XHTML->new;
    $psx->output_string(\my $html);
    $psx->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die "Cannot open 'out.html': $!\n";
    print $out $html;
  
  You can also control the character encoding and entities. For example, if
  you're sure that the POD is properly encoded (using the C<=encoding> command),
  you can prevent high-bit characters from being encoded as HTML entities and
  declare the output character set as UTF-8 before parsing, like so:
  
    $psx->html_charset('UTF-8');
    $psx->html_encode_chars(q{&<>'"});
  
  =cut
  
  package Pod::Simple::XHTML;
  use strict;
  use vars qw( $VERSION @ISA $HAS_HTML_ENTITIES );
  $VERSION = '3.43';
  use Pod::Simple::Methody ();
  @ISA = ('Pod::Simple::Methody');
  
  BEGIN {
    $HAS_HTML_ENTITIES = eval "require HTML::Entities; 1";
  }
  
  my %entities = (
    q{>} => 'gt',
    q{<} => 'lt',
    q{'} => '#39',
    q{"} => 'quot',
    q{&} => 'amp',
  );
  
  sub encode_entities {
    my $self = shift;
    my $ents = $self->html_encode_chars;
    return HTML::Entities::encode_entities( $_[0], $ents ) if $HAS_HTML_ENTITIES;
    if (defined $ents) {
        $ents =~ s,(?<!\\)([]/]),\\$1,g;
        $ents =~ s,(?<!\\)\\\z,\\\\,;
    } else {
        $ents = join '', keys %entities;
    }
    my $str = $_[0];
    $str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;
    return $str;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head1 METHODS
  
  Pod::Simple::XHTML offers a number of methods that modify the format of
  the HTML output. Call these after creating the parser object, but before
  the call to C<parse_file>:
  
    my $parser = Pod::PseudoPod::HTML->new();
    $parser->set_optional_param("value");
    $parser->parse_file($file);
  
  =head2 perldoc_url_prefix
  
  In turning L<Foo::Bar> into http://whatever/Foo%3a%3aBar, what
  to put before the "Foo%3a%3aBar". The default value is
  "https://metacpan.org/pod/".
  
  =head2 perldoc_url_postfix
  
  What to put after "Foo%3a%3aBar" in the URL. This option is not set by
  default.
  
  =head2 man_url_prefix
  
  In turning C<< L<crontab(5)> >> into http://whatever/man/1/crontab, what
  to put before the "1/crontab". The default value is
  "http://man.he.net/man".
  
  =head2 man_url_postfix
  
  What to put after "1/crontab" in the URL. This option is not set by default.
  
  =head2 title_prefix, title_postfix
  
  What to put before and after the title in the head. The values should
  already be &-escaped.
  
  =head2 html_css
  
    $parser->html_css('path/to/style.css');
  
  The URL or relative path of a CSS file to include. This option is not
  set by default.
  
  =head2 html_javascript
  
  The URL or relative path of a JavaScript file to pull in. This option is
  not set by default.
  
  =head2 html_doctype
  
  A document type tag for the file. This option is not set by default.
  
  =head2 html_charset
  
  The character set to declare in the Content-Type meta tag created by default
  for C<html_header_tags>. Note that this option will be ignored if the value of
  C<html_header_tags> is changed. Defaults to "ISO-8859-1".
  
  =head2 html_header_tags
  
  Additional arbitrary HTML tags for the header of the document. The
  default value is just a content type header tag:
  
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  
  Add additional meta tags here, or blocks of inline CSS or JavaScript
  (wrapped in the appropriate tags).
  
  =head3 html_encode_chars
  
  A string containing all characters that should be encoded as HTML entities,
  specified using the regular expression character class syntax (what you find
  within brackets in regular expressions). This value will be passed as the
  second argument to the C<encode_entities> function of L<HTML::Entities>. If
  L<HTML::Entities> is not installed, then any characters other than C<&<>"'>
  will be encoded numerically.
  
  =head2 html_h_level
  
  This is the level of HTML "Hn" element to which a Pod "head1" corresponds.  For
  example, if C<html_h_level> is set to 2, a head1 will produce an H2, a head2
  will produce an H3, and so on.
  
  =head2 default_title
  
  Set a default title for the page if no title can be determined from the
  content. The value of this string should already be &-escaped.
  
  =head2 force_title
  
  Force a title for the page (don't try to determine it from the content).
  The value of this string should already be &-escaped.
  
  =head2 html_header, html_footer
  
  Set the HTML output at the beginning and end of each file. The default
  header includes a title, a doctype tag (if C<html_doctype> is set), a
  content tag (customized by C<html_header_tags>), a tag for a CSS file
  (if C<html_css> is set), and a tag for a Javascript file (if
  C<html_javascript> is set). The default footer simply closes the C<html>
  and C<body> tags.
  
  The options listed above customize parts of the default header, but
  setting C<html_header> or C<html_footer> completely overrides the
  built-in header or footer. These may be useful if you want to use
  template tags instead of literal HTML headers and footers or are
  integrating converted POD pages in a larger website.
  
  If you want no headers or footers output in the HTML, set these options
  to the empty string.
  
  =head2 index
  
  Whether to add a table-of-contents at the top of each page (called an
  index for the sake of tradition).
  
  =head2 anchor_items
  
  Whether to anchor every definition C<=item> directive. This needs to be
  enabled if you want to be able to link to specific C<=item> directives, which
  are output as C<< <dt> >> elements. Disabled by default.
  
  =head2 backlink
  
  Whether to turn every =head1 directive into a link pointing to the top 
  of the page (specifically, the opening body tag).
  
  =cut
  
  __PACKAGE__->_accessorize(
   'perldoc_url_prefix',
   'perldoc_url_postfix',
   'man_url_prefix',
   'man_url_postfix',
   'title_prefix',  'title_postfix',
   'html_css',
   'html_javascript',
   'html_doctype',
   'html_charset',
   'html_encode_chars',
   'html_h_level',
   'title', # Used internally for the title extracted from the content
   'default_title',
   'force_title',
   'html_header',
   'html_footer',
   'index',
   'anchor_items',
   'backlink',
   'batch_mode', # whether we're in batch mode
   'batch_mode_current_level',
      # When in batch mode, how deep the current module is: 1 for "LWP",
      #  2 for "LWP::Procotol", 3 for "LWP::Protocol::GHTTP", etc
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head1 SUBCLASSING
  
  If the standard options aren't enough, you may want to subclass
  Pod::Simple::XHMTL. These are the most likely candidates for methods
  you'll want to override when subclassing.
  
  =cut
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->perldoc_url_prefix('https://metacpan.org/pod/');
    $new->man_url_prefix('http://man.he.net/man');
    $new->html_charset('ISO-8859-1');
    $new->nix_X_codes(1);
    $new->{'scratch'} = '';
    $new->{'to_index'} = [];
    $new->{'output'} = [];
    $new->{'saved'} = [];
    $new->{'ids'} = { '_podtop_' => 1 }; # used in <body>
    $new->{'in_li'} = [];
  
    $new->{'__region_targets'}  = [];
    $new->{'__literal_targets'} = {};
    $new->accept_targets_as_html( 'html', 'HTML' );
  
    return $new;
  }
  
  sub html_header_tags {
      my $self = shift;
      return $self->{html_header_tags} = shift if @_;
      return $self->{html_header_tags}
          ||= '<meta http-equiv="Content-Type" content="text/html; charset='
              . $self->html_charset . '" />';
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head2 handle_text
  
  This method handles the body of text within any element: it's the body
  of a paragraph, or everything between a "=begin" tag and the
  corresponding "=end" tag, or the text within an L entity, etc. You would
  want to override this if you are adding a custom element type that does
  more than just display formatted text. Perhaps adding a way to generate
  HTML tables from an extended version of POD.
  
  So, let's say you want to add a custom element called 'foo'. In your
  subclass's C<new> method, after calling C<SUPER::new> you'd call:
  
    $new->accept_targets_as_text( 'foo' );
  
  Then override the C<start_for> method in the subclass to check for when
  "$flags->{'target'}" is equal to 'foo' and set a flag that marks that
  you're in a foo block (maybe "$self->{'in_foo'} = 1"). Then override the
  C<handle_text> method to check for the flag, and pass $text to your
  custom subroutine to construct the HTML output for 'foo' elements,
  something like:
  
    sub handle_text {
        my ($self, $text) = @_;
        if ($self->{'in_foo'}) {
            $self->{'scratch'} .= build_foo_html($text);
            return;
        }
        $self->SUPER::handle_text($text);
    }
  
  =head2 handle_code
  
  This method handles the body of text that is marked up to be code.
  You might for instance override this to plug in a syntax highlighter.
  The base implementation just escapes the text.
  
  The callback methods C<start_code> and C<end_code> emits the C<code> tags
  before and after C<handle_code> is invoked, so you might want to override these
  together with C<handle_code> if this wrapping isn't suitable.
  
  Note that the code might be broken into multiple segments if there are
  nested formatting codes inside a C<< CE<lt>...> >> sequence.  In between the
  calls to C<handle_code> other markup tags might have been emitted in that
  case.  The same is true for verbatim sections if the C<codes_in_verbatim>
  option is turned on.
  
  =head2 accept_targets_as_html
  
  This method behaves like C<accept_targets_as_text>, but also marks the region
  as one whose content should be emitted literally, without HTML entity escaping
  or wrapping in a C<div> element.
  
  =cut
  
  sub __in_literal_xhtml_region {
      return unless @{ $_[0]{__region_targets} };
      my $target = $_[0]{__region_targets}[-1];
      return $_[0]{__literal_targets}{ $target };
  }
  
  sub accept_targets_as_html {
      my ($self, @targets) = @_;
      $self->accept_targets(@targets);
      $self->{__literal_targets}{$_} = 1 for @targets;
  }
  
  sub handle_text {
      # escape special characters in HTML (<, >, &, etc)
      my $text = $_[0]->__in_literal_xhtml_region
          ? $_[1]
          : $_[0]->encode_entities( $_[1] );
  
      if ($_[0]{'in_code'} && @{$_[0]{'in_code'}}) {
          # Intentionally use the raw text in $_[1], even if we're not in a
          # literal xhtml region, since handle_code calls encode_entities.
          $_[0]->handle_code( $_[1], $_[0]{'in_code'}[-1] );
      } else {
          if ($_[0]->{in_for}) {
              my $newlines = $_[0]->__in_literal_xhtml_region ? "\n\n" : '';
              if ($_[0]->{started_for}) {
                  if ($text =~ /\S/) {
                      delete $_[0]->{started_for};
                      $_[0]{'scratch'} .= $text . $newlines;
                  }
                  # Otherwise, append nothing until we have something to append.
              } else {
                  # The parser sometimes preserves newlines and sometimes doesn't!
                  $text =~ s/\n\z//;
                  $_[0]{'scratch'} .= $text . $newlines;
              }
          } else {
              # Just plain text.
              $_[0]{'scratch'} .= $text;
          }
      }
  
      $_[0]{htext} .= $text if $_[0]{'in_head'};
  }
  
  sub start_code {
      $_[0]{'scratch'} .= '<code>';
  }
  
  sub end_code {
      $_[0]{'scratch'} .= '</code>';
  }
  
  sub handle_code {
      $_[0]{'scratch'} .= $_[0]->encode_entities( $_[1] );
  }
  
  sub start_Para {
      $_[0]{'scratch'} .= '<p>';
  }
  
  sub start_Verbatim {
      $_[0]{'scratch'} = '<pre>';
      push(@{$_[0]{'in_code'}}, 'Verbatim');
      $_[0]->start_code($_[0]{'in_code'}[-1]);
  }
  
  sub start_head1 {  $_[0]{'in_head'} = 1; $_[0]{htext} = ''; }
  sub start_head2 {  $_[0]{'in_head'} = 2; $_[0]{htext} = ''; }
  sub start_head3 {  $_[0]{'in_head'} = 3; $_[0]{htext} = ''; }
  sub start_head4 {  $_[0]{'in_head'} = 4; $_[0]{htext} = ''; }
  sub start_head5 {  $_[0]{'in_head'} = 5; $_[0]{htext} = ''; }
  sub start_head6 {  $_[0]{'in_head'} = 6; $_[0]{htext} = ''; }
  
  sub start_item_number {
      $_[0]{'scratch'} = "</li>\n" if ($_[0]{'in_li'}->[-1] && pop @{$_[0]{'in_li'}});
      $_[0]{'scratch'} .= '<li><p>';
      push @{$_[0]{'in_li'}}, 1;
  }
  
  sub start_item_bullet {
      $_[0]{'scratch'} = "</li>\n" if ($_[0]{'in_li'}->[-1] && pop @{$_[0]{'in_li'}});
      $_[0]{'scratch'} .= '<li><p>';
      push @{$_[0]{'in_li'}}, 1;
  }
  
  sub start_item_text   {
      # see end_item_text
  }
  
  sub start_over_bullet { $_[0]{'scratch'} = '<ul>'; push @{$_[0]{'in_li'}}, 0; $_[0]->emit }
  sub start_over_block  { $_[0]{'scratch'} = '<ul>'; $_[0]->emit }
  sub start_over_number { $_[0]{'scratch'} = '<ol>'; push @{$_[0]{'in_li'}}, 0; $_[0]->emit }
  sub start_over_text   {
      $_[0]{'scratch'} = '<dl>';
      $_[0]{'dl_level'}++;
      $_[0]{'in_dd'} ||= [];
      $_[0]->emit
  }
  
  sub end_over_block  { $_[0]{'scratch'} .= '</ul>'; $_[0]->emit }
  
  sub end_over_number   {
      $_[0]{'scratch'} = "</li>\n" if ( pop @{$_[0]{'in_li'}} );
      $_[0]{'scratch'} .= '</ol>';
      pop @{$_[0]{'in_li'}};
      $_[0]->emit;
  }
  
  sub end_over_bullet   {
      $_[0]{'scratch'} = "</li>\n" if ( pop @{$_[0]{'in_li'}} );
      $_[0]{'scratch'} .= '</ul>';
      pop @{$_[0]{'in_li'}};
      $_[0]->emit;
  }
  
  sub end_over_text   {
      if ($_[0]{'in_dd'}[ $_[0]{'dl_level'} ]) {
          $_[0]{'scratch'} = "</dd>\n";
          $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 0;
      }
      $_[0]{'scratch'} .= '</dl>';
      $_[0]{'dl_level'}--;
      $_[0]->emit;
  }
  
  # . . . . . Now the actual formatters:
  
  sub end_Para     { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  sub end_Verbatim {
      $_[0]->end_code(pop(@{$_[0]->{'in_code'}}));
      $_[0]{'scratch'} .= '</pre>';
      $_[0]->emit;
  }
  
  sub _end_head {
      my $h = delete $_[0]{in_head};
  
      my $add = $_[0]->html_h_level;
      $add = 1 unless defined $add;
      $h += $add - 1;
  
      my $id = $_[0]->idify($_[0]{htext});
      my $text = $_[0]{scratch};
      $_[0]{'scratch'} = $_[0]->backlink && ($h - $add == 0)
                           # backlinks enabled && =head1
                           ? qq{<a href="#_podtop_"><h$h id="$id">$text</h$h></a>}
                           : qq{<h$h id="$id">$text</h$h>};
      $_[0]->emit;
      push @{ $_[0]{'to_index'} }, [$h, $id, delete $_[0]{'htext'}];
  }
  
  sub end_head1       { shift->_end_head(@_); }
  sub end_head2       { shift->_end_head(@_); }
  sub end_head3       { shift->_end_head(@_); }
  sub end_head4       { shift->_end_head(@_); }
  sub end_head5       { shift->_end_head(@_); }
  sub end_head6       { shift->_end_head(@_); }
  
  sub end_item_bullet { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  sub end_item_number { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  
  sub end_item_text   {
      # idify and anchor =item content if wanted
      my $dt_id = $_[0]{'anchor_items'} 
                   ? ' id="'. $_[0]->idify($_[0]{'scratch'}) .'"'
                   : '';
  
      # reset scratch
      my $text = $_[0]{scratch};
      $_[0]{'scratch'} = '';
  
      if ($_[0]{'in_dd'}[ $_[0]{'dl_level'} ]) {
          $_[0]{'scratch'} = "</dd>\n";
          $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 0;
      }
  
      $_[0]{'scratch'} .= qq{<dt$dt_id>$text</dt>\n<dd>};
      $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 1;
      $_[0]->emit;
  }
  
  # This handles =begin and =for blocks of all kinds.
  sub start_for {
    my ($self, $flags) = @_;
  
    push @{ $self->{__region_targets} }, $flags->{target_matching};
    $self->{started_for} = 1;
    $self->{in_for} = 1;
  
    unless ($self->__in_literal_xhtml_region) {
      $self->{scratch} .= '<div';
      $self->{scratch} .= qq( class="$flags->{target}") if $flags->{target};
      $self->{scratch} .= ">\n\n";
    }
  }
  
  sub end_for {
    my ($self) = @_;
    delete $self->{started_for};
    delete $self->{in_for};
  
    if ($self->__in_literal_xhtml_region) {
      # Remove trailine newlines.
      $self->{'scratch'} =~ s/\s+\z//s;
    } else {
      $self->{'scratch'} .= '</div>';
    }
  
    pop @{ $self->{__region_targets} };
    $self->emit;
  }
  
  sub start_Document {
    my ($self) = @_;
    if (defined $self->html_header) {
      $self->{'scratch'} .= $self->html_header;
      $self->emit unless $self->html_header eq "";
    } else {
      my ($doctype, $title, $metatags, $bodyid);
      $doctype = $self->html_doctype || '';
      $title = $self->force_title || $self->title || $self->default_title || '';
      $metatags = $self->html_header_tags || '';
      if (my $css = $self->html_css) {
          if ($css !~ /<link/) {
              # this is required to be compatible with Pod::Simple::BatchHTML
              $metatags .= '<link rel="stylesheet" href="'
                  . $self->encode_entities($css) . '" type="text/css" />';
          } else {
              $metatags .= $css;
          }
      }
      if ($self->html_javascript) {
        $metatags .= qq{\n<script type="text/javascript" src="} .
                      $self->html_javascript . '"></script>';
      }
      $bodyid = $self->backlink ? ' id="_podtop_"' : '';
      $self->{'scratch'} .= <<"HTML";
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
      $self->emit;
    }
  }
  
  sub end_Document   {
    my ($self) = @_;
    my $to_index = $self->{'to_index'};
    if ($self->index && @{ $to_index } ) {
        my @out;
        my $level  = 0;
        my $indent = -1;
        my $space  = '';
        my $id     = ' id="index"';
  
        for my $h (@{ $to_index }, [0]) {
            my $target_level = $h->[0];
            # Get to target_level by opening or closing ULs
            if ($level == $target_level) {
                $out[-1] .= '</li>';
            } elsif ($level > $target_level) {
                $out[-1] .= '</li>' if $out[-1] =~ /^\s+<li>/;
                while ($level > $target_level) {
                    --$level;
                    push @out, ('  ' x --$indent) . '</li>' if @out && $out[-1] =~ m{^\s+<\/ul};
                    push @out, ('  ' x --$indent) . '</ul>';
                }
                push @out, ('  ' x --$indent) . '</li>' if $level;
            } else {
                while ($level < $target_level) {
                    ++$level;
                    push @out, ('  ' x ++$indent) . '<li>' if @out && $out[-1]=~ /^\s*<ul/;
                    push @out, ('  ' x ++$indent) . "<ul$id>";
                    $id = '';
                }
                ++$indent;
            }
  
            next unless $level;
            $space = '  '  x $indent;
            push @out, sprintf '%s<li><a href="#%s">%s</a>',
                $space, $h->[1], $h->[2];
        }
        # Splice the index in between the HTML headers and the first element.
        my $offset = defined $self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;
        splice @{ $self->{'output'} }, $offset, 0, join "\n", @out;
    }
  
    if (defined $self->html_footer) {
      $self->{'scratch'} .= $self->html_footer;
      $self->emit unless $self->html_footer eq "";
    } else {
      $self->{'scratch'} .= "</body>\n</html>";
      $self->emit;
    }
  
    if ($self->index) {
        print {$self->{'output_fh'}} join ("\n\n", @{ $self->{'output'} }), "\n\n";
        @{$self->{'output'}} = ();
    }
  
  }
  
  # Handling code tags
  sub start_B { $_[0]{'scratch'} .= '<b>' }
  sub end_B   { $_[0]{'scratch'} .= '</b>' }
  
  sub start_C { push(@{$_[0]{'in_code'}}, 'C'); $_[0]->start_code($_[0]{'in_code'}[-1]); }
  sub end_C   { $_[0]->end_code(pop(@{$_[0]{'in_code'}})); }
  
  sub start_F { $_[0]{'scratch'} .= '<i>' }
  sub end_F   { $_[0]{'scratch'} .= '</i>' }
  
  sub start_I { $_[0]{'scratch'} .= '<i>' }
  sub end_I   { $_[0]{'scratch'} .= '</i>' }
  
  sub start_L {
    my ($self, $flags) = @_;
      my ($type, $to, $section) = @{$flags}{'type', 'to', 'section'};
      my $url = $self->encode_entities(
          $type eq 'url' ? $to
              : $type eq 'pod' ? $self->resolve_pod_page_link($to, $section)
              : $type eq 'man' ? $self->resolve_man_page_link($to, $section)
              :                  undef
      );
  
      # If it's an unknown type, use an attribute-less <a> like HTML.pm.
      $self->{'scratch'} .= '<a' . ($url ? ' href="'. $url . '">' : '>');
  }
  
  sub end_L   { $_[0]{'scratch'} .= '</a>' }
  
  sub start_S { $_[0]{'scratch'} .= '<span style="white-space: nowrap;">' }
  sub end_S   { $_[0]{'scratch'} .= '</span>' }
  
  sub emit {
    my($self) = @_;
    if ($self->index) {
        push @{ $self->{'output'} }, $self->{'scratch'};
    } else {
        print {$self->{'output_fh'}} $self->{'scratch'}, "\n\n";
    }
    $self->{'scratch'} = '';
    return;
  }
  
  =head2 resolve_pod_page_link
  
    my $url = $pod->resolve_pod_page_link('Net::Ping', 'INSTALL');
    my $url = $pod->resolve_pod_page_link('perlpodspec');
    my $url = $pod->resolve_pod_page_link(undef, 'SYNOPSIS');
  
  Resolves a POD link target (typically a module or POD file name) and section
  name to a URL. The resulting link will be returned for the above examples as:
  
    https://metacpan.org/pod/Net::Ping#INSTALL
    https://metacpan.org/pod/perlpodspec
    #SYNOPSIS
  
  Note that when there is only a section argument the URL will simply be a link
  to a section in the current document.
  
  =cut
  
  sub resolve_pod_page_link {
      my ($self, $to, $section) = @_;
      return undef unless defined $to || defined $section;
      if (defined $section) {
          $section = '#' . $self->idify($self->encode_entities($section), 1);
          return $section unless defined $to;
      } else {
          $section = ''
      }
  
      return ($self->perldoc_url_prefix || '')
          . $self->encode_entities($to) . $section
          . ($self->perldoc_url_postfix || '');
  }
  
  =head2 resolve_man_page_link
  
    my $url = $pod->resolve_man_page_link('crontab(5)', 'EXAMPLE CRON FILE');
    my $url = $pod->resolve_man_page_link('crontab');
  
  Resolves a man page link target and numeric section to a URL. The resulting
  link will be returned for the above examples as:
  
      http://man.he.net/man5/crontab
      http://man.he.net/man1/crontab
  
  Note that the first argument is required. The section number will be parsed
  from it, and if it's missing will default to 1. The second argument is
  currently ignored, as L<man.he.net|http://man.he.net> does not currently
  include linkable IDs or anchor names in its pages. Subclass to link to a
  different man page HTTP server.
  
  =cut
  
  sub resolve_man_page_link {
      my ($self, $to, $section) = @_;
      return undef unless defined $to;
      my ($page, $part) = $to =~ /^([^(]+)(?:[(](\d+)[)])?$/;
      return undef unless $page;
      return ($self->man_url_prefix || '')
          . ($part || 1) . "/" . $self->encode_entities($page)
          . ($self->man_url_postfix || '');
  
  }
  
  =head2 idify
  
    my $id   = $pod->idify($text);
    my $hash = $pod->idify($text, 1);
  
  This method turns an arbitrary string into a valid XHTML ID attribute value.
  The rules enforced, following
  L<http://webdesign.about.com/od/htmltags/a/aa031707.htm>, are:
  
  =over
  
  =item *
  
  The id must start with a letter (a-z or A-Z)
  
  =item *
  
  All subsequent characters can be letters, numbers (0-9), hyphens (-),
  underscores (_), colons (:), and periods (.).
  
  =item *
  
  The final character can't be a hyphen, colon, or period. URLs ending with these
  characters, while allowed by XHTML, can be awkward to extract from plain text.
  
  =item *
  
  Each id must be unique within the document.
  
  =back
  
  In addition, the returned value will be unique within the context of the
  Pod::Simple::XHTML object unless a second argument is passed a true value. ID
  attributes should always be unique within a single XHTML document, but pass
  the true value if you are creating not an ID but a URL hash to point to
  an ID (i.e., if you need to put the "#foo" in C<< <a href="#foo">foo</a> >>.
  
  =cut
  
  sub idify {
      my ($self, $t, $not_unique) = @_;
      for ($t) {
          s/<[^>]+>//g;            # Strip HTML.
          s/&[^;]+;//g;            # Strip entities.
          s/^\s+//; s/\s+$//;      # Strip white space.
          s/^([^a-zA-Z]+)$/pod$1/; # Prepend "pod" if no valid chars.
          s/^[^a-zA-Z]+//;         # First char must be a letter.
          s/[^-a-zA-Z0-9_:.]+/-/g; # All other chars must be valid.
          s/[-:.]+$//;             # Strip trailing punctuation.
      }
      return $t if $not_unique;
      my $i = '';
      $i++ while $self->{ids}{"$t$i"}++;
      return "$t$i";
  }
  
  =head2 batch_mode_page_object_init
  
    $pod->batch_mode_page_object_init($batchconvobj, $module, $infile, $outfile, $depth);
  
  Called by L<Pod::Simple::HTMLBatch> so that the class has a chance to
  initialize the converter. Internally it sets the C<batch_mode> property to
  true and sets C<batch_mode_current_level()>, but Pod::Simple::XHTML does not
  currently use those features. Subclasses might, though.
  
  =cut
  
  sub batch_mode_page_object_init {
    my ($self, $batchconvobj, $module, $infile, $outfile, $depth) = @_;
    $self->batch_mode(1);
    $self->batch_mode_current_level($depth);
    return $self;
  }
  
  sub html_header_after_title {
  }
  
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2003-2005 Allison Randal.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to L<Hurricane Electric|http://he.net/> for permission to use its
  L<Linux man pages online|http://man.he.net/> site for man page links.
  
  Thanks to L<search.cpan.org|http://search.cpan.org/> for permission to use the
  site for Perl module links.
  
  =head1 AUTHOR
  
  Pod::Simpele::XHTML was created by Allison Randal <allison@perl.org>.
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  
  require 5;
  package Pod::Simple::XMLOutStream;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( $ATTR_PAD @ISA $VERSION $SORT_ATTRS);
  $VERSION = '3.43';
  BEGIN {
    @ISA = ('Pod::Simple');
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG;
  }
  
  $ATTR_PAD = "\n" unless defined $ATTR_PAD;
   # Don't mess with this unless you know what you're doing.
  
  $SORT_ATTRS = 0 unless defined $SORT_ATTRS;
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->keep_encoding_directive(1);
    #$new->accept_codes('VerbatimFormatted');
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    print $fh "<", $_[1];
    if($SORT_ATTRS) {
      foreach my $key (sort keys %{$_[2]}) {
        unless($key =~ m/^~/s) {
          next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
          _xml_escape($value = $_[2]{$key});
          print $fh $ATTR_PAD, $key, '="', $value, '"';
        }
      }
    } else { # faster
      while(($key,$value) = each %{$_[2]}) {
        unless($key =~ m/^~/s) {
          next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
          _xml_escape($value);
          print $fh $ATTR_PAD, $key, '="', $value, '"';
        }
      }
    }
    print $fh ">";
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    if(length $_[1]) {
      my $text = $_[1];
      _xml_escape($text);
      print {$_[0]{'output_fh'}} $text;
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}} "</", $_[1], ">";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _xml_escape {
    foreach my $x (@_) {
      # Escape things very cautiously:
      if ($] ge 5.007_003) {
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
      } else { # Is broken for non-ASCII platforms on early perls
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
      }
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::XMLOutStream -- turn Pod into XML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::XMLOutStream -e \
     "exit Pod::Simple::XMLOutStream->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  Pod::Simple::XMLOutStream is a subclass of L<Pod::Simple> that parses
  Pod and turns it into XML.
  
  Pod::Simple::XMLOutStream inherits methods from
  L<Pod::Simple>.
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple::DumpAsXML> is rather like this class; see its
  documentation for a discussion of the differences.
  
  L<Pod::Simple>, L<Pod::Simple::DumpAsXML>, L<Pod::SAX>
  
  L<Pod::Simple::Subclassing>
  
  The older (and possibly obsolete) libraries L<Pod::PXML>, L<Pod::XML>
  
  
  =head1 ABOUT EXTENDING POD
  
  TODO: An example or two of =extend, then point to Pod::Simple::Subclassing
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002-2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Pod/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT';
  # Convert POD data to formatted text.
  #
  # This module converts POD to formatted text.  It replaces the old Pod::Text
  # module that came with versions of Perl prior to 5.6.0 and attempts to match
  # its output except for some specific circumstances where other decisions
  # seemed to produce better output.  It uses Pod::Parser and is designed to be
  # very easy to subclass.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text;
  
  use 5.008;
  use strict;
  use warnings;
  
  use vars qw(@ISA @EXPORT %ESCAPES $VERSION);
  
  use Carp qw(carp croak);
  use Encode qw(encode);
  use Exporter ();
  use Pod::Simple ();
  
  @ISA = qw(Pod::Simple Exporter);
  
  # We have to export pod2text for backward compatibility.
  @EXPORT = qw(pod2text);
  
  $VERSION = '4.14';
  
  # Ensure that $Pod::Simple::nbsp and $Pod::Simple::shy are available.  Code
  # taken from Pod::Simple 3.32, but was only added in 3.30.
  my ($NBSP, $SHY);
  if ($Pod::Simple::VERSION ge 3.30) {
      $NBSP = $Pod::Simple::nbsp;
      $SHY  = $Pod::Simple::shy;
  } else {
      $NBSP = chr utf8::unicode_to_native(0xA0);
      $SHY  = chr utf8::unicode_to_native(0xAD);
  }
  
  ##############################################################################
  # Initialization
  ##############################################################################
  
  # This function handles code blocks.  It's registered as a callback to
  # Pod::Simple and therefore doesn't work as a regular method call, but all it
  # does is call output_code with the line.
  sub handle_code {
      my ($line, $number, $parser) = @_;
      $parser->output_code ($line . "\n");
  }
  
  # Initialize the object and set various Pod::Simple options that we need.
  # Here, we also process any additional options passed to the constructor or
  # set up defaults if none were given.  Note that all internal object keys are
  # in all-caps, reserving all lower-case object keys for Pod::Simple and user
  # arguments.
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new;
  
      # Tell Pod::Simple to handle S<> by automatically inserting &nbsp;.
      $self->nbsp_for_S (1);
  
      # Tell Pod::Simple to keep whitespace whenever possible.
      if ($self->can ('preserve_whitespace')) {
          $self->preserve_whitespace (1);
      } else {
          $self->fullstop_space_harden (1);
      }
  
      # The =for and =begin targets that we accept.
      $self->accept_targets (qw/text TEXT/);
  
      # Ensure that contiguous blocks of code are merged together.  Otherwise,
      # some of the guesswork heuristics don't work right.
      $self->merge_text (1);
  
      # Pod::Simple doesn't do anything useful with our arguments, but we want
      # to put them in our object as hash keys and values.  This could cause
      # problems if we ever clash with Pod::Simple's own internal class
      # variables.
      my %opts = @_;
      my @opts = map { ("opt_$_", $opts{$_}) } keys %opts;
      %$self = (%$self, @opts);
  
      # Send errors to stderr if requested.
      if ($$self{opt_stderr} and not $$self{opt_errors}) {
          $$self{opt_errors} = 'stderr';
      }
      delete $$self{opt_stderr};
  
      # Validate the errors parameter and act on it.
      if (not defined $$self{opt_errors}) {
          $$self{opt_errors} = 'pod';
      }
      if ($$self{opt_errors} eq 'stderr' || $$self{opt_errors} eq 'die') {
          $self->no_errata_section (1);
          $self->complain_stderr (1);
          if ($$self{opt_errors} eq 'die') {
              $$self{complain_die} = 1;
          }
      } elsif ($$self{opt_errors} eq 'pod') {
          $self->no_errata_section (0);
          $self->complain_stderr (0);
      } elsif ($$self{opt_errors} eq 'none') {
          $self->no_errata_section (1);
          $self->no_whining (1);
      } else {
          croak (qq(Invalid errors setting: "$$self{errors}"));
      }
      delete $$self{errors};
  
      # Initialize various things from our parameters.
      $$self{opt_alt}      = 0  unless defined $$self{opt_alt};
      $$self{opt_indent}   = 4  unless defined $$self{opt_indent};
      $$self{opt_margin}   = 0  unless defined $$self{opt_margin};
      $$self{opt_loose}    = 0  unless defined $$self{opt_loose};
      $$self{opt_sentence} = 0  unless defined $$self{opt_sentence};
      $$self{opt_width}    = 76 unless defined $$self{opt_width};
  
      # Figure out what quotes we'll be using for C<> text.
      $$self{opt_quotes} ||= '"';
      if ($$self{opt_quotes} eq 'none') {
          $$self{LQUOTE} = $$self{RQUOTE} = '';
      } elsif (length ($$self{opt_quotes}) == 1) {
          $$self{LQUOTE} = $$self{RQUOTE} = $$self{opt_quotes};
      } elsif (length ($$self{opt_quotes}) % 2 == 0) {
          my $length = length ($$self{opt_quotes}) / 2;
          $$self{LQUOTE} = substr ($$self{opt_quotes}, 0, $length);
          $$self{RQUOTE} = substr ($$self{opt_quotes}, $length);
      } else {
          croak qq(Invalid quote specification "$$self{opt_quotes}");
      }
  
      # If requested, do something with the non-POD text.
      $self->code_handler (\&handle_code) if $$self{opt_code};
  
      # Return the created object.
      return $self;
  }
  
  ##############################################################################
  # Core parsing
  ##############################################################################
  
  # This is the glue that connects the code below with Pod::Simple itself.  The
  # goal is to convert the event stream coming from the POD parser into method
  # calls to handlers once the complete content of a tag has been seen.  Each
  # paragraph or POD command will have textual content associated with it, and
  # as soon as all of a paragraph or POD command has been seen, that content
  # will be passed in to the corresponding method for handling that type of
  # object.  The exceptions are handlers for lists, which have opening tag
  # handlers and closing tag handlers that will be called right away.
  #
  # The internal hash key PENDING is used to store the contents of a tag until
  # all of it has been seen.  It holds a stack of open tags, each one
  # represented by a tuple of the attributes hash for the tag and the contents
  # of the tag.
  
  # Add a block of text to the contents of the current node, formatting it
  # according to the current formatting instructions as we do.
  sub _handle_text {
      my ($self, $text) = @_;
      my $tag = $$self{PENDING}[-1];
      $$tag[1] .= $text;
  }
  
  # Given an element name, get the corresponding method name.
  sub method_for_element {
      my ($self, $element) = @_;
      $element =~ tr/-/_/;
      $element =~ tr/A-Z/a-z/;
      $element =~ tr/_a-z0-9//cd;
      return $element;
  }
  
  # Handle the start of a new element.  If cmd_element is defined, assume that
  # we need to collect the entire tree for this element before passing it to the
  # element method, and create a new tree into which we'll collect blocks of
  # text and nested elements.  Otherwise, if start_element is defined, call it.
  sub _handle_element_start {
      my ($self, $element, $attrs) = @_;
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, we need to accumulate the contents of the
      # tag before calling it.
      if ($self->can ("cmd_$method")) {
          push (@{ $$self{PENDING} }, [ $attrs, '' ]);
      } elsif ($self->can ("start_$method")) {
          my $method = 'start_' . $method;
          $self->$method ($attrs, '');
      }
  }
  
  # Handle the end of an element.  If we had a cmd_ method for this element,
  # this is where we pass along the text that we've accumulated.  Otherwise, if
  # we have an end_ method for the element, call that.
  sub _handle_element_end {
      my ($self, $element) = @_;
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, pull off the pending text and pass it to
      # the handler along with the saved attribute hash.
      if ($self->can ("cmd_$method")) {
          my $tag = pop @{ $$self{PENDING} };
          my $method = 'cmd_' . $method;
          my $text = $self->$method (@$tag);
          if (defined $text) {
              if (@{ $$self{PENDING} } > 1) {
                  $$self{PENDING}[-1][1] .= $text;
              } else {
                  $self->output ($text);
              }
          }
      } elsif ($self->can ("end_$method")) {
          my $method = 'end_' . $method;
          $self->$method ();
      }
  }
  
  ##############################################################################
  # Output formatting
  ##############################################################################
  
  # Wrap a line, indenting by the current left margin.  We can't use Text::Wrap
  # because it plays games with tabs.  We can't use formline, even though we'd
  # really like to, because it screws up non-printing characters.  So we have to
  # do the wrapping ourselves.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
      while (length > $width) {
          if (s/^([^\n]{0,$width})[ \t\n]+// || s/^([^\n]{$width})//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  # Reformat a paragraph of text for the current margin.  Takes the text to
  # reformat and returns the formatted text.
  sub reformat {
      my $self = shift;
      local $_ = shift;
  
      # If we're trying to preserve two spaces after sentences, do some munging
      # to support that.  Otherwise, smash all repeated whitespace.  Be careful
      # not to use \s here, which in Unicode input may match non-breaking spaces
      # that we don't want to smash.
      if ($$self{opt_sentence}) {
          s/ +$//mg;
          s/\.\n/. \n/g;
          s/\n/ /g;
          s/   +/  /g;
      } else {
          s/[ \t\n]+/ /g;
      }
      return $self->wrap ($_);
  }
  
  # Output text to the output device.  Replace non-breaking spaces with spaces
  # and soft hyphens with nothing, and then try to fix the output encoding if
  # necessary to match the input encoding unless UTF-8 output is forced.  This
  # preserves the traditional pass-through behavior of Pod::Text.
  sub output {
      my ($self, @text) = @_;
      my $text = join ('', @text);
      if ($NBSP) {
          $text =~ s/$NBSP/ /g;
      }
      if ($SHY) {
          $text =~ s/$SHY//g;
      }
      unless ($$self{opt_utf8}) {
          my $encoding = $$self{encoding} || '';
          if ($encoding && $encoding ne $$self{ENCODING}) {
              $$self{ENCODING} = $encoding;
              eval { binmode ($$self{output_fh}, ":encoding($encoding)") };
          }
      }
      if ($$self{ENCODE}) {
          print { $$self{output_fh} } encode ('UTF-8', $text);
      } else {
          print { $$self{output_fh} } $text;
      }
  }
  
  # Output a block of code (something that isn't part of the POD text).  Called
  # by preprocess_paragraph only if we were given the code option.  Exists here
  # only so that it can be overridden by subclasses.
  sub output_code { $_[0]->output ($_[1]) }
  
  ##############################################################################
  # Document initialization
  ##############################################################################
  
  # Set up various things that have to be initialized on a per-document basis.
  sub start_document {
      my ($self, $attrs) = @_;
      if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
          $$self{CONTENTLESS} = 1;
      } else {
          delete $$self{CONTENTLESS};
      }
      my $margin = $$self{opt_indent} + $$self{opt_margin};
  
      # Initialize a few per-document variables.
      $$self{INDENTS} = [];       # Stack of indentations.
      $$self{MARGIN}  = $margin;  # Default left margin.
      $$self{PENDING} = [[]];     # Pending output.
  
      # We have to redo encoding handling for each document.
      $$self{ENCODING} = '';
  
      # When UTF-8 output is set, check whether our output file handle already
      # has a PerlIO encoding layer set.  If it does not, we'll need to encode
      # our output before printing it (handled in the output() sub).
      $$self{ENCODE} = 0;
      if ($$self{opt_utf8}) {
          $$self{ENCODE} = 1;
          eval {
              my @options = (output => 1, details => 1);
              my $flag = (PerlIO::get_layers ($$self{output_fh}, @options))[-1];
              if ($flag && ($flag & PerlIO::F_UTF8 ())) {
                  $$self{ENCODE} = 0;
                  $$self{ENCODING} = 'UTF-8';
              }
          };
      }
  
      return '';
  }
  
  # Handle the end of the document.  The only thing we do is handle dying on POD
  # errors, since Pod::Parser currently doesn't.
  sub end_document {
      my ($self) = @_;
      if ($$self{complain_die} && $self->errors_seen) {
          croak ("POD document had syntax errors");
      }
  }
  
  ##############################################################################
  # Text blocks
  ##############################################################################
  
  # Intended for subclasses to override, this method returns text with any
  # non-printing formatting codes stripped out so that length() correctly
  # returns the length of the text.  For basic Pod::Text, it does nothing.
  sub strip_format {
      my ($self, $string) = @_;
      return $string;
  }
  
  # This method is called whenever an =item command is complete (in other words,
  # we've seen its associated paragraph or know for certain that it doesn't have
  # one).  It gets the paragraph associated with the item as an argument.  If
  # that argument is empty, just output the item tag; if it contains a newline,
  # output the item tag followed by the newline.  Otherwise, see if there's
  # enough room for us to output the item tag in the margin of the text or if we
  # have to put it on a separate line.
  sub item {
      my ($self, $text) = @_;
      my $tag = $$self{ITEM};
      unless (defined $tag) {
          carp "Item called without tag";
          return;
      }
      undef $$self{ITEM};
  
      # Calculate the indentation and margin.  $fits is set to true if the tag
      # will fit into the margin of the paragraph given our indentation level.
      my $indent = $$self{INDENTS}[-1];
      $indent = $$self{opt_indent} unless defined $indent;
      my $margin = ' ' x $$self{opt_margin};
      my $tag_length = length ($self->strip_format ($tag));
      my $fits = ($$self{MARGIN} - $indent >= $tag_length + 1);
  
      # If the tag doesn't fit, or if we have no associated text, print out the
      # tag separately.  Otherwise, put the tag in the margin of the paragraph.
      if (!$text || $text =~ /^\s+$/ || !$fits) {
          my $realindent = $$self{MARGIN};
          $$self{MARGIN} = $indent;
          my $output = $self->reformat ($tag);
          $output =~ s/^$margin /$margin:/ if ($$self{opt_alt} && $indent > 0);
          $output =~ s/\n*$/\n/;
  
          # If the text is just whitespace, we have an empty item paragraph;
          # this can result from =over/=item/=back without any intermixed
          # paragraphs.  Insert some whitespace to keep the =item from merging
          # into the next paragraph.
          $output .= "\n" if $text && $text =~ /^\s*$/;
  
          $self->output ($output);
          $$self{MARGIN} = $realindent;
          $self->output ($self->reformat ($text)) if ($text && $text =~ /\S/);
      } else {
          my $space = ' ' x $indent;
          $space =~ s/^$margin /$margin:/ if $$self{opt_alt};
          $text = $self->reformat ($text);
          $text =~ s/^$margin /$margin:/ if ($$self{opt_alt} && $indent > 0);
          my $tagspace = ' ' x $tag_length;
          $text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";
          $self->output ($text);
      }
  }
  
  # Handle a basic block of text.  The only tricky thing here is that if there
  # is a pending item tag, we need to format this as an item paragraph.
  sub cmd_para {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$/\n/;
      if (defined $$self{ITEM}) {
          $self->item ($text . "\n");
      } else {
          $self->output ($self->reformat ($text . "\n"));
      }
      return '';
  }
  
  # Handle a verbatim paragraph.  Just print it out, but indent it according to
  # our margin.
  sub cmd_verbatim {
      my ($self, $attrs, $text) = @_;
      $self->item if defined $$self{ITEM};
      return if $text =~ /^\s*$/;
      $text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;
      $text =~ s/\s*$/\n\n/;
      $self->output ($text);
      return '';
  }
  
  # Handle literal text (produced by =for and similar constructs).  Just output
  # it with the minimum of changes.
  sub cmd_data {
      my ($self, $attrs, $text) = @_;
      $text =~ s/^\n+//;
      $text =~ s/\n{0,2}$/\n/;
      $self->output ($text);
      return '';
  }
  
  ##############################################################################
  # Headings
  ##############################################################################
  
  # The common code for handling all headers.  Takes the header text, the
  # indentation, and the surrounding marker for the alt formatting method.
  sub heading {
      my ($self, $text, $indent, $marker) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $text =~ s/\s+$//;
      if ($$self{opt_alt}) {
          my $closemark = reverse (split (//, $marker));
          my $margin = ' ' x $$self{opt_margin};
          $self->output ("\n" . "$margin$marker $text $closemark" . "\n\n");
      } else {
          $text .= "\n" if $$self{opt_loose};
          my $margin = ' ' x ($$self{opt_margin} + $indent);
          $self->output ($margin . $text . "\n");
      }
      return '';
  }
  
  # First level heading.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, 0, '====');
  }
  
  # Second level heading.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} / 2, '==  ');
  }
  
  # Third level heading.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} * 2 / 3 + 0.5, '=   ');
  }
  
  # Fourth level heading.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} * 3 / 4 + 0.5, '-   ');
  }
  
  ##############################################################################
  # List handling
  ##############################################################################
  
  # Handle the beginning of an =over block.  Takes the type of the block as the
  # first argument, and then the attr hash.  This is called by the handlers for
  # the four different types of lists (bullet, number, text, and block).
  sub over_common_start {
      my ($self, $attrs) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
  
      # Find the indentation level.
      my $indent = $$attrs{indent};
      unless (defined ($indent) && $indent =~ /^\s*[-+]?\d{1,4}\s*$/) {
          $indent = $$self{opt_indent};
      }
  
      # Add this to our stack of indents and increase our current margin.
      push (@{ $$self{INDENTS} }, $$self{MARGIN});
      $$self{MARGIN} += ($indent + 0);
      return '';
  }
  
  # End an =over block.  Takes no options other than the class pointer.  Output
  # any pending items and then pop one level of indentation.
  sub over_common_end {
      my ($self) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $$self{MARGIN} = pop @{ $$self{INDENTS} };
      return '';
  }
  
  # Dispatch the start and end calls as appropriate.
  sub start_over_bullet { $_[0]->over_common_start ($_[1]) }
  sub start_over_number { $_[0]->over_common_start ($_[1]) }
  sub start_over_text   { $_[0]->over_common_start ($_[1]) }
  sub start_over_block  { $_[0]->over_common_start ($_[1]) }
  sub end_over_bullet { $_[0]->over_common_end }
  sub end_over_number { $_[0]->over_common_end }
  sub end_over_text   { $_[0]->over_common_end }
  sub end_over_block  { $_[0]->over_common_end }
  
  # The common handler for all item commands.  Takes the type of the item, the
  # attributes, and then the text of the item.
  sub item_common {
      my ($self, $type, $attrs, $text) = @_;
      $self->item if defined $$self{ITEM};
  
      # Clean up the text.  We want to end up with two variables, one ($text)
      # which contains any body text after taking out the item portion, and
      # another ($item) which contains the actual item text.  Note the use of
      # the internal Pod::Simple attribute here; that's a potential land mine.
      $text =~ s/\s+$//;
      my ($item, $index);
      if ($type eq 'bullet') {
          $item = '*';
      } elsif ($type eq 'number') {
          $item = $$attrs{'~orig_content'};
      } else {
          $item = $text;
          $item =~ s/\s*\n\s*/ /g;
          $text = '';
      }
      $$self{ITEM} = $item;
  
      # If body text for this item was included, go ahead and output that now.
      if ($text) {
          $text =~ s/\s*$/\n/;
          $self->item ($text);
      }
      return '';
  }
  
  # Dispatch the item commands to the appropriate place.
  sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @_) }
  sub cmd_item_number { my $self = shift; $self->item_common ('number', @_) }
  sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @_) }
  sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @_) }
  
  ##############################################################################
  # Formatting codes
  ##############################################################################
  
  # The simple ones.
  sub cmd_b { return $_[0]{alt} ? "``$_[2]''" : $_[2] }
  sub cmd_f { return $_[0]{alt} ? "\"$_[2]\"" : $_[2] }
  sub cmd_i { return '*' . $_[2] . '*' }
  sub cmd_x { return '' }
  
  # Apply a whole bunch of messy heuristics to not quote things that don't
  # benefit from being quoted.  These originally come from Barrie Slaymaker and
  # largely duplicate code in Pod::Man.
  sub cmd_c {
      my ($self, $attrs, $text) = @_;
  
      # A regex that matches the portion of a variable reference that's the
      # array or hash index, separated out just because we want to use it in
      # several places in the following regex.
      my $index = '(?: \[.*\] | \{.*\} )?';
  
      # Check for things that we don't want to quote, and if we find any of
      # them, return the string with just a font change and no quoting.
      $text =~ m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \` .* \'                                       # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xo && return $text;
  
      # If we didn't return, go ahead and quote the text.
      return $$self{opt_alt}
          ? "``$text''"
          : "$$self{LQUOTE}$text$$self{RQUOTE}";
  }
  
  # Links reduce to the text that we're given, wrapped in angle brackets if it's
  # a URL.
  sub cmd_l {
      my ($self, $attrs, $text) = @_;
      if ($$attrs{type} eq 'url') {
          if (not defined($$attrs{to}) or $$attrs{to} eq $text) {
              return "<$text>";
          } elsif ($$self{opt_nourls}) {
              return $text;
          } else {
              return "$text <$$attrs{to}>";
          }
      } else {
          return $text;
      }
  }
  
  ##############################################################################
  # Backwards compatibility
  ##############################################################################
  
  # The old Pod::Text module did everything in a pod2text() function.  This
  # tries to provide the same interface for legacy applications.
  sub pod2text {
      my @args;
  
      # This is really ugly; I hate doing option parsing in the middle of a
      # module.  But the old Pod::Text module supported passing flags to its
      # entry function, so handle -a and -<number>.
      while ($_[0] =~ /^-/) {
          my $flag = shift;
          if    ($flag eq '-a')       { push (@args, alt => 1)    }
          elsif ($flag =~ /^-(\d+)$/) { push (@args, width => $1) }
          else {
              unshift (@_, $flag);
              last;
          }
      }
  
      # Now that we know what arguments we're using, create the parser.
      my $parser = Pod::Text->new (@args);
  
      # If two arguments were given, the second argument is going to be a file
      # handle.  That means we want to call parse_from_filehandle(), which means
      # we need to turn the first argument into a file handle.  Magic open will
      # handle the <&STDIN case automagically.
      if (defined $_[1]) {
          my @fhs = @_;
          local *IN;
          unless (open (IN, $fhs[0])) {
              croak ("Can't open $fhs[0] for reading: $!\n");
              return;
          }
          $fhs[0] = \*IN;
          $parser->output_fh ($fhs[1]);
          my $retval = $parser->parse_file ($fhs[0]);
          my $fh = $parser->output_fh ();
          close $fh;
          return $retval;
      } else {
          $parser->output_fh (\*STDOUT);
          return $parser->parse_file (@_);
      }
  }
  
  # Reset the underlying Pod::Simple object between calls to parse_from_file so
  # that the same object can be reused to convert multiple pages.
  sub parse_from_file {
      my $self = shift;
      $self->reinit;
  
      # Fake the old cutting option to Pod::Parser.  This fiddles with internal
      # Pod::Simple state and is quite ugly; we need a better approach.
      if (ref ($_[0]) eq 'HASH') {
          my $opts = shift @_;
          if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
              $$self{in_pod} = 1;
              $$self{last_was_blank} = 1;
          }
      }
  
      # Do the work.
      my $retval = $self->Pod::Simple::parse_from_file (@_);
  
      # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
      # close the file descriptor if we had to open one, but we can't easily
      # figure this out.
      my $fh = $self->output_fh ();
      my $oldfh = select $fh;
      my $oldflush = $|;
      $| = 1;
      print $fh '';
      $| = $oldflush;
      select $oldfh;
      return $retval;
  }
  
  # Pod::Simple failed to provide this backward compatibility function, so
  # implement it ourselves.  File handles are one of the inputs that
  # parse_from_file supports.
  sub parse_from_filehandle {
      my $self = shift;
      $self->parse_from_file (@_);
  }
  
  # Pod::Simple's parse_file doesn't set output_fh.  Wrap the call and do so
  # ourself unless it was already set by the caller, since our documentation has
  # always said that this should work.
  sub parse_file {
      my ($self, $in) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_file ($in);
  }
  
  # Do the same for parse_lines, just to be polite.  Pod::Simple's man page
  # implies that the caller is responsible for setting this, but I don't see any
  # reason not to set a default.
  sub parse_lines {
      my ($self, @lines) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_lines (@lines);
  }
  
  # Likewise for parse_string_document.
  sub parse_string_document {
      my ($self, $doc) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_string_document ($doc);
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  alt stderr Allbery Sean Burke's Christiansen UTF-8 pre-Unicode utf8 nourls
  parsers
  
  =head1 NAME
  
  Pod::Text - Convert POD data to formatted text
  
  =head1 SYNOPSIS
  
      use Pod::Text;
      my $parser = Pod::Text->new (sentence => 1, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text is a module that can convert documentation in the POD format
  (the preferred language for documenting Perl) into formatted text.  It
  uses no special formatting controls or codes whatsoever, and its output is
  therefore suitable for nearly any device.
  
  As a derived class from Pod::Simple, Pod::Text supports the same methods and
  interfaces.  See L<Pod::Simple> for all the details; briefly, one creates a
  new parser with C<< Pod::Text->new() >> and then normally calls parse_file().
  
  new() can take options, in the form of key/value pairs, that control the
  behavior of the parser.  The currently recognized options are:
  
  =over 4
  
  =item alt
  
  If set to a true value, selects an alternate output format that, among other
  things, uses a different heading style and marks C<=item> entries with a
  colon in the left margin.  Defaults to false.
  
  =item code
  
  If set to a true value, the non-POD parts of the input file will be included
  in the output.  Useful for viewing code documented with POD blocks with the
  POD rendered and the code left intact.
  
  =item errors
  
  How to report errors.  C<die> says to throw an exception on any POD
  formatting error.  C<stderr> says to report errors on standard error, but
  not to throw an exception.  C<pod> says to include a POD ERRORS section
  in the resulting documentation summarizing the errors.  C<none> ignores
  POD errors entirely, as much as possible.
  
  The default is C<pod>.
  
  =item indent
  
  The number of spaces to indent regular text, and the default indentation for
  C<=over> blocks.  Defaults to 4.
  
  =item loose
  
  If set to a true value, a blank line is printed after a C<=head1> heading.
  If set to false (the default), no blank line is printed after C<=head1>,
  although one is still printed after C<=head2>.  This is the default because
  it's the expected formatting for manual pages; if you're formatting
  arbitrary text documents, setting this to true may result in more pleasing
  output.
  
  =item margin
  
  The width of the left margin in spaces.  Defaults to 0.  This is the margin
  for all text, including headings, not the amount by which regular text is
  indented; for the latter, see the I<indent> option.  To set the right
  margin, see the I<width> option.
  
  =item nourls
  
  Normally, LZ<><> formatting codes with a URL but anchor text are formatted
  to show both the anchor text and the URL.  In other words:
  
      L<foo|http://example.com/>
  
  is formatted as:
  
      foo <http://example.com/>
  
  This option, if set to a true value, suppresses the URL when anchor text
  is given, so this example would be formatted as just C<foo>.  This can
  produce less cluttered output in cases where the URLs are not particularly
  important.
  
  =item quotes
  
  Sets the quote marks used to surround CE<lt>> text.  If the value is a
  single character, it is used as both the left and right quote.  Otherwise,
  it is split in half, and the first half of the string is used as the left
  quote and the second is used as the right quote.
  
  This may also be set to the special value C<none>, in which case no quote
  marks are added around CE<lt>> text.
  
  =item sentence
  
  If set to a true value, Pod::Text will assume that each sentence ends in two
  spaces, and will try to preserve that spacing.  If set to false, all
  consecutive whitespace in non-verbatim paragraphs is compressed into a
  single space.  Defaults to false.
  
  =item stderr
  
  Send error messages about invalid POD to standard error instead of
  appending a POD ERRORS section to the generated output.  This is
  equivalent to setting C<errors> to C<stderr> if C<errors> is not already
  set.  It is supported for backward compatibility.
  
  =item utf8
  
  By default, Pod::Text uses the same output encoding as the input encoding
  of the POD source (provided that Perl was built with PerlIO; otherwise, it
  doesn't encode its output).  If this option is given, the output encoding
  is forced to UTF-8.
  
  Be aware that, when using this option, the input encoding of your POD
  source should be properly declared unless it's US-ASCII.  Pod::Simple will
  attempt to guess the encoding and may be successful if it's Latin-1 or
  UTF-8, but it will produce warnings.  Use the C<=encoding> command to
  declare the encoding.  See L<perlpod(1)> for more information.
  
  =item width
  
  The column at which to wrap text on the right-hand side.  Defaults to 76.
  
  =back
  
  The standard Pod::Simple method parse_file() takes one argument naming the
  POD file to read from.  By default, the output is sent to C<STDOUT>, but
  this can be changed with the output_fh() method.
  
  The standard Pod::Simple method parse_from_file() takes up to two
  arguments, the first being the input file to read POD from and the second
  being the file to write the formatted output to.
  
  You can also call parse_lines() to parse an array of lines or
  parse_string_document() to parse a document already in memory.  As with
  parse_file(), parse_lines() and parse_string_document() default to sending
  their output to C<STDOUT> unless changed with the output_fh() method.  Be
  aware that parse_lines() and parse_string_document() both expect raw bytes,
  not decoded characters.
  
  To put the output from any parse method into a string instead of a file
  handle, call the output_string() method instead of output_fh().
  
  See L<Pod::Simple> for more specific details on the methods available to
  all derived parsers.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bizarre space in item
  
  =item Item called without tag
  
  (W) Something has gone wrong in internal C<=item> processing.  These
  messages indicate a bug in Pod::Text; you should never see them.
  
  =item Can't open %s for reading: %s
  
  (F) Pod::Text was invoked via the compatibility mode pod2text() interface
  and the input file it was given could not be opened.
  
  =item Invalid errors setting "%s"
  
  (F) The C<errors> parameter to the constructor was set to an unknown value.
  
  =item Invalid quote specification "%s"
  
  (F) The quote specification given (the C<quotes> option to the
  constructor) was invalid.  A quote specification must be either one
  character long or an even number (greater than one) characters long.
  
  =item POD document had syntax errors
  
  (F) The POD document being formatted had syntax errors and the C<errors>
  option was set to C<die>.
  
  =back
  
  =head1 BUGS
  
  Encoding handling assumes that PerlIO is available and does not work
  properly if it isn't.  The C<utf8> option is therefore not supported
  unless Perl is built with PerlIO support.
  
  =head1 CAVEATS
  
  If Pod::Text is given the C<utf8> option, the encoding of its output file
  handle will be forced to UTF-8 if possible, overriding any existing
  encoding.  This will be done even if the file handle is not created by
  Pod::Text and was passed in from outside.  This maintains consistency
  regardless of PERL_UNICODE and other settings.
  
  If the C<utf8> option is not given, the encoding of its output file handle
  will be forced to the detected encoding of the input POD, which preserves
  whatever the input text is.  This ensures backward compatibility with
  earlier, pre-Unicode versions of this module, without large numbers of
  Perl warnings.
  
  This is not ideal, but it seems to be the best compromise.  If it doesn't
  work for you, please let me know the details of how it broke.
  
  =head1 NOTES
  
  This is a replacement for an earlier Pod::Text module written by Tom
  Christiansen.  It has a revamped interface, since it now uses Pod::Simple,
  but an interface roughly compatible with the old Pod::Text::pod2text()
  function is still available.  Please change to the new calling convention,
  though.
  
  The original Pod::Text contained code to do formatting via termcap
  sequences, although it wasn't turned on by default and it was problematic to
  get it to work at all.  This rewrite doesn't even try to do that, but a
  subclass of it does.  Look for L<Pod::Text::Termcap>.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>, based I<very> heavily on the original
  Pod::Text by Tom Christiansen <tchrist@mox.perl.com> and its conversion to
  Pod::Parser by Brad Appleton <bradapp@enteract.com>.  Sean Burke's initial
  conversion of Pod::Man to use Pod::Simple provided much-needed guidance on
  how to use Pod::Simple.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999-2002, 2004, 2006, 2008-2009, 2012-2016, 2018-2019 Russ Allbery
  <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Text::Termcap>, L<perlpod(1)>, L<pod2text(1)>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_TEXT

$fatpacked{"Pod/Text/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_COLOR';
  # Convert POD data to formatted color ASCII text
  #
  # This is just a basic proof of concept.  It should later be modified to make
  # better use of color, take options changing what colors are used for what
  # text, and the like.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Color;
  
  use 5.008;
  use strict;
  use warnings;
  
  use Pod::Text ();
  use Term::ANSIColor qw(color colored);
  
  use vars qw(@ISA $VERSION);
  
  @ISA = qw(Pod::Text);
  
  $VERSION = '4.14';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # Make level one headings bold.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      local $Term::ANSIColor::EACHLINE = "\n";
      $self->SUPER::cmd_head1 ($attrs, colored ($text, 'bold'));
  }
  
  # Make level two headings bold.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head2 ($attrs, colored ($text, 'bold'));
  }
  
  # Fix the various formatting codes.
  sub cmd_b { return colored ($_[2], 'bold')   }
  sub cmd_f { return colored ($_[2], 'cyan')   }
  sub cmd_i { return colored ($_[2], 'yellow') }
  
  # Analyze a single line and return any formatting codes in effect at the end
  # of that line.
  sub end_format {
      my ($self, $line) = @_;
      my $reset = color ('reset');
      my $current;
      while ($line =~ /(\e\[[\d;]+m)/g) {
          my $code = $1;
          if ($code eq $reset) {
              undef $current;
          } else {
              $current .= $code;
          }
      }
      return $current;
  }
  
  # Output any included code in green.
  sub output_code {
      my ($self, $code) = @_;
      local $Term::ANSIColor::EACHLINE = "\n";
      $code = colored ($code, 'green');
      $self->output ($code);
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.  We will eventually want to use colorstrip() from Term::ANSIColor,
  # but it's fairly new so avoid the tight dependency.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/\e\[[\d;]*m//g;
      return $text;
  }
  
  # We unfortunately have to override the wrapping code here, since the normal
  # wrapping code gets really confused by all the escape sequences.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
  
      # $codes matches a single special sequence.  $char matches any number of
      # special sequences preceding a single character other than a newline.
      # $shortchar matches some sequence of $char ending in codes followed by
      # whitespace or the end of the string.  $longchar matches exactly $width
      # $chars, used when we have to truncate and hard wrap.
      my $code = '(?:\e\[[\d;]+m)';
      my $char = "(?>$code*[^\\n])";
      my $shortchar = '^(' . $char . "{0,$width}(?>$code*)" . ')(?:\s+|\z)';
      my $longchar = '^(' . $char . "{$width})";
      while (length > $width) {
          if (s/$shortchar// || s/$longchar//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
  
      # less -R always resets terminal attributes at the end of each line, so we
      # need to clear attributes at the end of lines and then set them again at
      # the start of the next line.  This requires a second pass through the
      # wrapped string, accumulating any attributes we see, remembering them,
      # and then inserting the appropriate sequences at the newline.
      if ($output =~ /\n/) {
          my @lines = split (/\n/, $output);
          my $start_format;
          for my $line (@lines) {
              if ($start_format && $line =~ /\S/) {
                  $line =~ s/^(\s*)(\S)/$1$start_format$2/;
              }
              $start_format = $self->end_format ($line);
              if ($start_format) {
                  $line .= color ('reset');
              }
          }
          $output = join ("\n", @lines);
      }
  
      # Fix up trailing whitespace and return the results.
      $output =~ s/\s+$/\n\n/;
      $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  Allbery
  
  =head1 NAME
  
  Pod::Text::Color - Convert POD data to formatted color ASCII text
  
  =head1 SYNOPSIS
  
      use Pod::Text::Color;
      my $parser = Pod::Text::Color->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Color is a simple subclass of Pod::Text that highlights output
  text using ANSI color escape sequences.  Apart from the color, it in all
  ways functions like Pod::Text.  See L<Pod::Text> for details and available
  options.
  
  Term::ANSIColor is used to get colors and therefore must be installed to use
  this module.
  
  =head1 BUGS
  
  This is just a basic proof of concept.  It should be seriously expanded to
  support configurable coloration via options passed to the constructor, and
  B<pod2text> should be taught about those.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999, 2001, 2004, 2006, 2008, 2009, 2018-2019 Russ Allbery
  <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_TEXT_COLOR

$fatpacked{"Pod/Text/Overstrike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_OVERSTRIKE';
  # Convert POD data to formatted overstrike text
  #
  # This was written because the output from:
  #
  #     pod2text Text.pm > plain.txt; less plain.txt
  #
  # is not as rich as the output from
  #
  #     pod2man Text.pm | nroff -man > fancy.txt; less fancy.txt
  #
  # and because both Pod::Text::Color and Pod::Text::Termcap are not device
  # independent.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Overstrike;
  
  use 5.008;
  use strict;
  use warnings;
  
  use vars qw(@ISA $VERSION);
  
  use Pod::Text ();
  
  @ISA = qw(Pod::Text);
  
  $VERSION = '4.14';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # Make level one headings bold, overriding any existing formatting.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/$1\b$1/g;
      return $self->SUPER::cmd_head1 ($attrs, $text);
  }
  
  # Make level two headings bold, overriding any existing formatting.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/$1\b$1/g;
      return $self->SUPER::cmd_head2 ($attrs, $text);
  }
  
  # Make level three headings underscored, overriding any existing formatting.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/_\b$1/g;
      return $self->SUPER::cmd_head3 ($attrs, $text);
  }
  
  # Level four headings look like level three headings.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/_\b$1/g;
      return $self->SUPER::cmd_head4 ($attrs, $text);
  }
  
  # The common code for handling all headers.  We have to override to avoid
  # interpolating twice and because we don't want to honor alt.
  sub heading {
      my ($self, $text, $indent, $marker) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $text .= "\n" if $$self{opt_loose};
      my $margin = ' ' x ($$self{opt_margin} + $indent);
      $self->output ($margin . $text . "\n");
      return '';
  }
  
  # Fix the various formatting codes.
  sub cmd_b { local $_ = $_[0]->strip_format ($_[2]); s/(.)/$1\b$1/g; $_ }
  sub cmd_f { local $_ = $_[0]->strip_format ($_[2]); s/(.)/_\b$1/g; $_ }
  sub cmd_i { local $_ = $_[0]->strip_format ($_[2]); s/(.)/_\b$1/g; $_ }
  
  # Output any included code in bold.
  sub output_code {
      my ($self, $code) = @_;
      $code =~ s/(.)/$1\b$1/g;
      $self->output ($code);
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/(.)[\b]\1/$1/g;
      $text =~ s/_[\b]//g;
      return $text;
  }
  
  # We unfortunately have to override the wrapping code here, since the normal
  # wrapping code gets really confused by all the backspaces.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
      while (length > $width) {
          # This regex represents a single character, that's possibly underlined
          # or in bold (in which case, it's three characters; the character, a
          # backspace, and a character).  Use [^\n] rather than . to protect
          # against odd settings of $*.
          my $char = '(?:[^\n][\b])?[^\n]';
          if (s/^((?>$char){0,$width})(?:\Z|\s+)//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  overstrike overstruck Overstruck Allbery terminal's
  
  =head1 NAME
  
  Pod::Text::Overstrike - Convert POD data to formatted overstrike text
  
  =head1 SYNOPSIS
  
      use Pod::Text::Overstrike;
      my $parser = Pod::Text::Overstrike->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights
  output text using overstrike sequences, in a manner similar to nroff.
  Characters in bold text are overstruck (character, backspace, character)
  and characters in underlined text are converted to overstruck underscores
  (underscore, backspace, character).  This format was originally designed
  for hard-copy terminals and/or line printers, yet is readable on soft-copy
  (CRT) terminals.
  
  Overstruck text is best viewed by page-at-a-time programs that take
  advantage of the terminal's B<stand-out> and I<underline> capabilities, such
  as the less program on Unix.
  
  Apart from the overstrike, it in all ways functions like Pod::Text.  See
  L<Pod::Text> for details and available options.
  
  =head1 BUGS
  
  Currently, the outermost formatting instruction wins, so for example
  underlined text inside a region of bold text is displayed as simply bold.
  There may be some better approach possible.
  
  =head1 AUTHOR
  
  Originally written by Joe Smith <Joe.Smith@inwap.com>, using the framework
  created by Russ Allbery <rra@cpan.org>.  Subsequently updated by Russ Allbery.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2000 by Joe Smith <Joe.Smith@inwap.com>
  
  Copyright 2001, 2004, 2008, 2014, 2018-2019 by Russ Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_TEXT_OVERSTRIKE

$fatpacked{"Pod/Text/Termcap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_TERMCAP';
  # Convert POD data to ASCII text with format escapes.
  #
  # This is a simple subclass of Pod::Text that overrides a few key methods to
  # output the right termcap escape sequences for formatted text on the current
  # terminal type.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Termcap;
  
  use 5.008;
  use strict;
  use warnings;
  
  use Pod::Text ();
  use POSIX ();
  use Term::Cap;
  
  use vars qw(@ISA $VERSION);
  
  @ISA = qw(Pod::Text);
  
  $VERSION = '4.14';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # In the initialization method, grab our terminal characteristics as well as
  # do all the stuff we normally do.
  sub new {
      my ($self, %args) = @_;
      my ($ospeed, $term, $termios);
  
      # Fall back on a hard-coded terminal speed if POSIX::Termios isn't
      # available (such as on VMS).
      eval { $termios = POSIX::Termios->new };
      if ($@) {
          $ospeed = 9600;
      } else {
          $termios->getattr;
          $ospeed = $termios->getospeed || 9600;
      }
  
      # Get data from Term::Cap if possible.
      my ($bold, $undl, $norm, $width);
      eval {
          my $term = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
          $bold = $term->Tputs('md');
          $undl = $term->Tputs('us');
          $norm = $term->Tputs('me');
          if (defined $$term{_co}) {
              $width = $$term{_co};
              $width =~ s/^\#//;
          }
      };
  
      # Figure out the terminal width before calling the Pod::Text constructor,
      # since it will otherwise force 76 characters.  Pod::Text::Termcap has
      # historically used 2 characters less than the width of the screen, while
      # the other Pod::Text classes have used 76.  This is weirdly inconsistent,
      # but there's probably no good reason to change it now.
      unless (defined $args{width}) {
          $args{width} = $ENV{COLUMNS} || $width || 80;
          $args{width} -= 2;
      }
  
      # Initialize Pod::Text.
      $self = $self->SUPER::new (%args);
  
      # If we were unable to get any of the formatting sequences, don't attempt
      # that type of formatting.  This will do weird things if bold or underline
      # were available but normal wasn't, but hopefully that will never happen.
      $$self{BOLD} = $bold || q{};
      $$self{UNDL} = $undl || q{};
      $$self{NORM} = $norm || q{};
  
      return $self;
  }
  
  # Make level one headings bold.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head1 ($attrs, "$$self{BOLD}$text$$self{NORM}");
  }
  
  # Make level two headings bold.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head2 ($attrs, "$$self{BOLD}$text$$self{NORM}");
  }
  
  # Fix up B<> and I<>.  Note that we intentionally don't do F<>.
  sub cmd_b { my $self = shift; return "$$self{BOLD}$_[1]$$self{NORM}" }
  sub cmd_i { my $self = shift; return "$$self{UNDL}$_[1]$$self{NORM}" }
  
  # Return a regex that matches a formatting sequence.  This will only be valid
  # if we were able to get at least some termcap information.
  sub format_regex {
      my ($self) = @_;
      my @codes = ($self->{BOLD}, $self->{UNDL}, $self->{NORM});
      return join(q{|}, map { $_ eq q{} ? () : "\Q$_\E" } @codes);
  }
  
  # Analyze a single line and return any formatting codes in effect at the end
  # of that line.
  sub end_format {
      my ($self, $line) = @_;
      my $pattern = "(" . $self->format_regex() . ")";
      my $current;
      while ($line =~ /$pattern/g) {
          my $code = $1;
          if ($code eq $$self{NORM}) {
              undef $current;
          } else {
              $current .= $code;
          }
      }
      return $current;
  }
  
  # Output any included code in bold.
  sub output_code {
      my ($self, $code) = @_;
      $self->output ($$self{BOLD} . $code . $$self{NORM});
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/\Q$$self{BOLD}//g;
      $text =~ s/\Q$$self{UNDL}//g;
      $text =~ s/\Q$$self{NORM}//g;
      return $text;
  }
  
  # Override the wrapping code to ignore the special sequences.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
  
      # If we were unable to find any termcap sequences, use Pod::Text wrapping.
      if ($self->{BOLD} eq q{} && $self->{UNDL} eq q{} && $self->{NORM} eq q{}) {
          return $self->SUPER::wrap($_);
      }
  
      # $code matches a single special sequence.  $char matches any number of
      # special sequences preceding a single character other than a newline.
      # $shortchar matches some sequence of $char ending in codes followed by
      # whitespace or the end of the string.  $longchar matches exactly $width
      # $chars, used when we have to truncate and hard wrap.
      my $code = "(?:" . $self->format_regex() . ")";
      my $char = "(?>$code*[^\\n])";
      my $shortchar = '^(' . $char . "{0,$width}(?>$code*)" . ')(?:\s+|\z)';
      my $longchar = '^(' . $char . "{$width})";
      while (length > $width) {
          if (s/$shortchar// || s/$longchar//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
  
      # less -R always resets terminal attributes at the end of each line, so we
      # need to clear attributes at the end of lines and then set them again at
      # the start of the next line.  This requires a second pass through the
      # wrapped string, accumulating any attributes we see, remembering them,
      # and then inserting the appropriate sequences at the newline.
      if ($output =~ /\n/) {
          my @lines = split (/\n/, $output);
          my $start_format;
          for my $line (@lines) {
              if ($start_format && $line =~ /\S/) {
                  $line =~ s/^(\s*)(\S)/$1$start_format$2/;
              }
              $start_format = $self->end_format ($line);
              if ($start_format) {
                  $line .= $$self{NORM};
              }
          }
          $output = join ("\n", @lines);
      }
  
      # Fix up trailing whitespace and return the results.
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =head1 NAME
  
  Pod::Text::Termcap - Convert POD data to ASCII text with format escapes
  
  =for stopwords
  ECMA-48 VT100 Allbery Solaris TERMPATH
  
  =head1 SYNOPSIS
  
      use Pod::Text::Termcap;
      my $parser = Pod::Text::Termcap->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output
  text using the correct termcap escape sequences for the current terminal.
  Apart from the format codes, it in all ways functions like Pod::Text.  See
  L<Pod::Text> for details and available options.
  
  This module uses L<Term::Cap> to find the correct terminal settings.  See the
  documentation of that module for how it finds terminal database information
  and how to override that behavior if necessary.  If unable to find control
  strings for bold and underscore formatting, that formatting is skipped,
  resulting in the same output as Pod::Text.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999, 2001-2002, 2004, 2006, 2008-2009, 2014-2015, 2018-2019 Russ
  Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>, L<Term::Cap>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_TEXT_TERMCAP

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  #############################################################################
  # Pod/Usage.pm -- print usage messages for the running script.
  #
  # Copyright (c) 1996-2000 by Bradford Appleton. All rights reserved.
  # Copyright (c) 2001-2016 by Marek Rouchal.
  # This file is part of "Pod-Usage". Pod-Usage is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Usage;
  
  use strict;
  require  5.006;    ## requires this Perl version or later
  
  use Carp;
  use Config;
  use Exporter;
  use File::Spec;
  
  our $VERSION = '2.03';
  
  our @EXPORT = qw(&pod2usage);
  our @ISA;
  BEGIN {
      $Pod::Usage::Formatter ||= 'Pod::Text';
      eval "require $Pod::Usage::Formatter";
      die $@ if $@;
      @ISA = ( $Pod::Usage::Formatter );
  }
  
  our $MAX_HEADING_LEVEL = 3;
  
  ##---------------------------------------------------------------------------
  
  ##---------------------------------
  ## Function definitions begin here
  ##---------------------------------
  
  sub pod2usage {
      local($_) = shift;
      my %opts;
      ## Collect arguments
      if (@_ > 0) {
          ## Too many arguments - assume that this is a hash and
          ## the user forgot to pass a reference to it.
          %opts = ($_, @_);
      }
      elsif (!defined $_) {
        $_ = '';
      }
      elsif (ref $_) {
          ## User passed a ref to a hash
          %opts = %{$_}  if (ref($_) eq 'HASH');
      }
      elsif (/^[-+]?\d+$/) {
          ## User passed in the exit value to use
          $opts{'-exitval'} =  $_;
      }
      else {
          ## User passed in a message to print before issuing usage.
          $_  and  $opts{'-message'} = $_;
      }
  
      ## Need this for backward compatibility since we formerly used
      ## options that were all uppercase words rather than ones that
      ## looked like Unix command-line options.
      ## to be uppercase keywords)
      %opts = map {
          my ($key, $val) = ($_, $opts{$_});
          $key =~ s/^(?=\w)/-/;
          $key =~ /^-msg/i   and  $key = '-message';
          $key =~ /^-exit/i  and  $key = '-exitval';
          lc($key) => $val;
      } (keys %opts);
  
      ## Now determine default -exitval and -verbose values to use
      if ((! defined $opts{'-exitval'}) && (! defined $opts{'-verbose'})) {
          $opts{'-exitval'} = 2;
          $opts{'-verbose'} = 0;
      }
      elsif (! defined $opts{'-exitval'}) {
          $opts{'-exitval'} = ($opts{'-verbose'} > 0) ? 1 : 2;
      }
      elsif (! defined $opts{'-verbose'}) {
          $opts{'-verbose'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                               $opts{'-exitval'} < 2);
      }
  
      ## Default the output file
      $opts{'-output'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                          $opts{'-exitval'} < 2) ? \*STDOUT : \*STDERR
              unless (defined $opts{'-output'});
      ## Default the input file
      $opts{'-input'} = $0  unless (defined $opts{'-input'});
  
      ## Look up input file in path if it doesn't exist.
      unless ((ref $opts{'-input'}) || (-e $opts{'-input'})) {
          my $basename = $opts{'-input'};
          my $pathsep = ($^O =~ /^(?:dos|os2|MSWin32)$/i) ? ';'
                              : (($^O eq 'MacOS' || $^O eq 'VMS') ? ',' :  ':');
          my $pathspec = $opts{'-pathlist'} || $ENV{PATH} || $ENV{PERL5LIB};
  
          my @paths = (ref $pathspec) ? @$pathspec : split($pathsep, $pathspec);
          for my $dirname (@paths) {
              $_ = length($dirname) ? File::Spec->catfile($dirname, $basename) : $basename;
              last if (-e $_) && ($opts{'-input'} = $_);
          }
      }
  
      ## Now create a pod reader and constrain it to the desired sections.
      my $parser = Pod::Usage->new(USAGE_OPTIONS => \%opts);
      if ($opts{'-verbose'} == 0) {
          $parser->select('(?:SYNOPSIS|USAGE)\s*');
      }
      elsif ($opts{'-verbose'} == 1) {
          my $opt_re = '(?i)' .
                       '(?:OPTIONS|ARGUMENTS)' .
                       '(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';
          $parser->select( '(?:SYNOPSIS|USAGE)\s*', $opt_re, "DESCRIPTION/$opt_re" );
      }
      elsif ($opts{'-verbose'} >= 2 && $opts{'-verbose'} != 99) {
          $parser->select('.*');
      }
      elsif ($opts{'-verbose'} == 99) {
          my $sections = $opts{'-sections'};
          $parser->select( (ref $sections) ? @$sections : $sections );
          $opts{'-verbose'} = 1;
      }
  
      ## Check for perldoc
      my $progpath = $opts{'-perldoc'} ? $opts{'-perldoc'} :
          File::Spec->catfile($Config{scriptdirexp} || $Config{scriptdir},
              'perldoc');
  
      my $version = sprintf("%vd",$^V);
      if ($Config{versiononly} and $Config{startperl} =~ /\Q$version\E$/ ) {
        $progpath .= $version;
      }
      $opts{'-noperldoc'} = 1 unless -e $progpath;
  
      ## Now translate the pod document and then exit with the desired status
      if (      !$opts{'-noperldoc'}
           and  $opts{'-verbose'} >= 2
           and  !ref($opts{'-input'})
           and  $opts{'-output'} == \*STDOUT )
      {
         ## spit out the entire PODs. Might as well invoke perldoc
         print { $opts{'-output'} } ($opts{'-message'}, "\n") if($opts{'-message'});
         if(defined $opts{-input} && $opts{-input} =~ /^\s*(\S.*?)\s*$/) {
           # the perldocs back to 5.005 should all have -F
  	 # without -F there are warnings in -T scripts
  	 my $f = $1;
           my @perldoc_cmd = ($progpath);
  	 if ($opts{'-perldocopt'}) {
             $opts{'-perldocopt'} =~ s/^\s+|\s+$//g;
  	   push @perldoc_cmd, split(/\s+/, $opts{'-perldocopt'});
  	 }
  	 push @perldoc_cmd, ('-F', $f);
           unshift @perldoc_cmd, $opts{'-perlcmd'} if $opts{'-perlcmd'};
           system(@perldoc_cmd);
           # RT16091: fall back to more if perldoc failed
           if($?) {
             # RT131844: prefer PAGER env
             my $pager = $ENV{PAGER} || $Config{pager};
             if(defined($pager) && length($pager)) {
               my $cmd = $pager . ' ' . ($^O =~ /win/i ? qq("$f") : quotemeta($f));
               system($cmd);
             } else {
               # the most humble fallback; should work (at least) on *nix and Win
               system('more', $f);
             }
           }
         } else {
           croak "Unspecified input file or insecure argument.\n";
         }
      }
      else {
         $parser->parse_from_file($opts{'-input'}, $opts{'-output'});
      }
  
      exit($opts{'-exitval'})  unless (lc($opts{'-exitval'}) eq 'noexit');
  }
  
  ##---------------------------------------------------------------------------
  
  ##-------------------------------
  ## Method definitions begin here
  ##-------------------------------
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my %params = @_;
      my $self = {%params};
      bless $self, $class;
      if ($self->can('initialize')) {
          $self->initialize();
      } else {
          # pass through options to Pod::Text
          my %opts;
         	for (qw(alt code indent loose margin quotes sentence stderr utf8 width)) {
              my $val = $params{USAGE_OPTIONS}{"-$_"};
              $opts{$_} = $val if defined $val;
          }
          $self = $self->SUPER::new(%opts);
          %$self = (%$self, %params);
      }
      return $self;
  }
  
  # This subroutine was copied in whole-cloth from Pod::Select 1.60 in order to
  # allow the ejection of Pod::Select from the core without breaking Pod::Usage.
  # -- rjbs, 2013-03-18
  sub _compile_section_spec {
      my ($section_spec) = @_;
      my (@regexs, $negated);
  
      ## Compile the spec into a list of regexs
      local $_ = $section_spec;
      s{\\\\}{\001}g;  ## handle escaped backward slashes
      s{\\/}{\002}g;   ## handle escaped forward slashes
  
      ## Parse the regexs for the heading titles
      @regexs = split(/\//, $_, $MAX_HEADING_LEVEL);
  
      ## Set default regex for ommitted levels
      for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
          $regexs[$i]  = '.*'  unless ((defined $regexs[$i])
                                       && (length $regexs[$i]));
      }
      ## Modify the regexs as needed and validate their syntax
      my $bad_regexs = 0;
      for (@regexs) {
          $_ .= '.+'  if ($_ eq '!');
          s{\001}{\\\\}g;       ## restore escaped backward slashes
          s{\002}{\\/}g;        ## restore escaped forward slashes
          $negated = s/^\!//;   ## check for negation
          eval "m{$_}";         ## check regex syntax
          if ($@) {
              ++$bad_regexs;
              carp qq{Bad regular expression /$_/ in "$section_spec": $@\n};
          }
          else {
              ## Add the forward and rear anchors (and put the negator back)
              $_ = '^' . $_  unless (/^\^/);
              $_ = $_ . '$'  unless (/\$$/);
              $_ = '!' . $_  if ($negated);
          }
      }
      return  (! $bad_regexs) ? [ @regexs ] : undef;
  }
  
  sub select {
      my ($self, @sections) = @_;
      if ($ISA[0]->can('select')) {
          $self->SUPER::select(@sections);
      } else {
          # we're using Pod::Simple - need to mimic the behavior of Pod::Select
          my $add = ($sections[0] eq '+') ? shift(@sections) : '';
          ## Reset the set of sections to use
          unless (@sections) {
            delete $self->{USAGE_SELECT} unless ($add);
            return;
          }
          $self->{USAGE_SELECT} = []
            unless ($add && $self->{USAGE_SELECT});
          my $sref = $self->{USAGE_SELECT};
          ## Compile each spec
          for my $spec (@sections) {
            my $cs = _compile_section_spec($spec);
            if ( defined $cs ) {
              ## Store them in our sections array
              push(@$sref, $cs);
            } else {
              carp qq{Ignoring section spec "$spec"!\n};
            }
          }
      }
  }
  
  # Override Pod::Text->seq_i to return just "arg", not "*arg*".
  sub seq_i { return $_[1] }
  # Override Pod::Text->cmd_i to return just "arg", not "*arg*".
  # newer version based on Pod::Simple
  sub cmd_i {
   my $self = shift;
   # RT121489: highlighting should be there with Termcap
   return $self->SUPER::cmd_i(@_) if $self->isa('Pod::Text::Termcap');
   return $_[1];
  }
  
  # This overrides the Pod::Text method to do something very akin to what
  # Pod::Select did as well as the work done below by preprocess_paragraph.
  # Note that the below is very, very specific to Pod::Text and Pod::Simple.
  sub _handle_element_end {
      my ($self, $element) = @_;
      if ($element eq 'head1') {
          $self->{USAGE_HEADINGS} = [ $$self{PENDING}[-1][1] ];
          if ($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              $$self{PENDING}[-1][1] =~ s/^\s*SYNOPSIS\s*$/USAGE/;
          }
      } elsif ($element =~ /^head(\d+)$/ && $1) { # avoid 0
          my $idx = $1 - 1;
          $self->{USAGE_HEADINGS} = [] unless($self->{USAGE_HEADINGS});
          $self->{USAGE_HEADINGS}->[$idx] = $$self{PENDING}[-1][1];
          # we have to get rid of the lower headings
          splice(@{$self->{USAGE_HEADINGS}},$idx+1);
      }
      if ($element =~ /^head\d+$/) {
          $$self{USAGE_SKIPPING} = 1;
          if (!$$self{USAGE_SELECT} || !@{ $$self{USAGE_SELECT} }) {
              $$self{USAGE_SKIPPING} = 0;
          } else {
              my @headings = @{$$self{USAGE_HEADINGS}};
              for my $section_spec ( @{$$self{USAGE_SELECT}} ) {
                  my $match = 1;
                  for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
                      $headings[$i] = '' unless defined $headings[$i];
                      my $regex   = $section_spec->[$i];
                      my $negated = ($regex =~ s/^\!//);
                      $match  &= ($negated ? ($headings[$i] !~ /${regex}/)
                                           : ($headings[$i] =~ /${regex}/));
                      last unless ($match);
                  } # end heading levels
                  if ($match) {
                    $$self{USAGE_SKIPPING} = 0;
                    last;
                  }
              } # end sections
          }
  
          # Try to do some lowercasing instead of all-caps in headings, and use
          # a colon to end all headings.
          if($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              local $_ = $$self{PENDING}[-1][1];
              s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
              s/\s*$/:/  unless (/:\s*$/);
              $_ .= "\n";
              $$self{PENDING}[-1][1] = $_;
          }
      }
      if ($$self{USAGE_SKIPPING} && $element !~ m/^over-|^[BCFILSZ]$/) {
          pop @{ $$self{PENDING} };
      } else {
          $self->SUPER::_handle_element_end($element);
      }
  }
  
  # required for Pod::Simple API
  sub start_document {
      my $self = shift;
      $self->SUPER::start_document();
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_fh();
      print $out_fh "$msg\n";
  }
  
  # required for old Pod::Parser API
  sub begin_pod {
      my $self = shift;
      $self->SUPER::begin_pod();  ## Have to call superclass
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_handle();
      print $out_fh "$msg\n";
  }
  
  sub preprocess_paragraph {
      my $self = shift;
      local $_ = shift;
      my $line = shift;
      ## See if this is a heading and we aren't printing the entire manpage.
      if (($self->{USAGE_OPTIONS}->{-verbose} < 2) && /^=head/) {
          ## Change the title of the SYNOPSIS section to USAGE
          s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;
          ## Try to do some lowercasing instead of all-caps in headings
          s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
          ## Use a colon to end all headings
          s/\s*$/:/  unless (/:\s*$/);
          $_ .= "\n";
      }
      return  $self->SUPER::preprocess_paragraph($_);
  }
  
  1; # keep require happy
  
  __END__
  
  =for stopwords pod2usage verboseness downcased MSWin32 Marek Rouchal Christiansen ATOOMIC rjbs McDougall
  
  =head1 NAME
  
  Pod::Usage - extracts POD documentation and shows usage information
  
  =head1 SYNOPSIS
  
    use Pod::Usage;
  
    my $message_text  = "This text precedes the usage message.";
    my $exit_status   = 2;          ## The exit status to use
    my $verbose_level = 0;          ## The verbose level to use
    my $filehandle    = \*STDERR;   ## The filehandle to write to
  
    pod2usage($message_text);
  
    pod2usage($exit_status);
  
    pod2usage( { -message => $message_text ,
                 -exitval => $exit_status  ,
                 -verbose => $verbose_level,
                 -output  => $filehandle } );
  
    pod2usage(   -msg     => $message_text ,
                 -exitval => $exit_status  ,
                 -verbose => $verbose_level,
                 -output  => $filehandle );
  
    pod2usage(   -verbose => 2,
                 -noperldoc => 1  );
  
    pod2usage(   -verbose => 2,
                 -perlcmd => $path_to_perl,
                 -perldoc => $path_to_perldoc,
                 -perldocopt => $perldoc_options );
  
  =head1 ARGUMENTS
  
  B<pod2usage> should be given either a single argument, or a list of
  arguments corresponding to an associative array (a "hash"). When a single
  argument is given, it should correspond to exactly one of the following:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the usage message
  
  =item *
  
  A numeric value corresponding to the desired exit status
  
  =item *
  
  A reference to a hash
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message> I<string>
  
  =item C<-msg> I<string>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval> I<value>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string C<NOEXIT> to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-verbose> I<value>
  
  The desired level of "verboseness" to use when printing the usage message.
  If the value is 0, then only the "SYNOPSIS" and/or "USAGE" sections of the
  pod documentation are printed. If the value is 1, then the "SYNOPSIS" and/or
  "USAGE" sections, along with any section entitled "OPTIONS", "ARGUMENTS", or
  "OPTIONS AND ARGUMENTS" is printed. If the corresponding value is 2 or more
  then the entire manpage is printed, using L<perldoc> if available; otherwise
  L<Pod::Text> is used for the formatting. For better readability, the
  all-capital headings are downcased, e.g. C<SYNOPSIS> =E<gt> C<Synopsis>.
  
  The special verbosity level 99 requires to also specify the -sections
  parameter; then these sections are extracted and printed.
  
  =item C<-sections> I<spec>
  
  There are two ways to specify the selection. Either a string (scalar)
  representing a selection regexp for sections to be printed when -verbose
  is set to 99, e.g.
  
    "NAME|SYNOPSIS|DESCRIPTION|VERSION"
  
  With the above regexp all content following (and including) any of the
  given C<=head1> headings will be shown. It is possible to restrict the
  output to particular subsections only, e.g.:
  
    "DESCRIPTION/Algorithm"
  
  This will output only the C<=head2 Algorithm> heading and content within
  the C<=head1 DESCRIPTION> section. The regexp binding is stronger than the
  section separator, such that e.g.:
  
    "DESCRIPTION|OPTIONS|ENVIRONMENT/Caveats"
  
  will print any C<=head2 Caveats> section (only) within any of the three
  C<=head1> sections.
  
  Alternatively, an array reference of section specifications can be used:
  
    pod2usage(-verbose => 99, -sections => [
      qw(DESCRIPTION DESCRIPTION/Introduction) ] );
  
  This will print only the content of C<=head1 DESCRIPTION> and the
  C<=head2 Introduction> sections, but no other C<=head2>, and no other
  C<=head1> either.
  
  =item C<-output> I<handle>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =item C<-input> I<handle>
  
  A reference to a filehandle, or the pathname of a file from which the
  invoking script's pod documentation should be read.  It defaults to the
  file indicated by C<$0> (C<$PROGRAM_NAME> for users of F<English.pm>).
  
  If you are calling B<pod2usage()> from a module and want to display
  that module's POD, you can use this:
  
    use Pod::Find qw(pod_where);
    pod2usage( -input => pod_where({-inc => 1}, __PACKAGE__) );
  
  =item C<-pathlist> I<string>
  
  A list of directory paths. If the input file does not exist, then it
  will be searched for in the given directory list (in the order the
  directories appear in the list). It defaults to the list of directories
  implied by C<$ENV{PATH}>. The list may be specified either by a reference
  to an array, or by a string of directory paths which use the same path
  separator as C<$ENV{PATH}> on your system (e.g., C<:> for Unix, C<;> for
  MSWin32 and DOS).
  
  =item C<-noperldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is specified.
  This does not work well e.g. if the script was packed with L<PAR>. This option
  suppresses the external call to L<perldoc> and uses the simple text formatter
  (L<Pod::Text>) to output the POD.
  
  =item C<-perlcmd>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. In case of special or unusual Perl installations,
  this option may be used to supply the path to a L<perl> executable
  which should run L<perldoc>.
  
  =item C<-perldoc> I<path-to-perldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. In case L<perldoc> is not installed where the L<perl> interpreter
  thinks it is (see L<Config>), the -perldoc option may be used to supply
  the correct path to L<perldoc>.
  
  =item C<-perldocopt> I<string>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is specified.
  This option may be used to supply options to L<perldoc>. The
  string may contain several, space-separated options.
  
  =back
  
  =head2 Formatting base class
  
  The default text formatter is L<Pod::Text>. The base class for Pod::Usage can
  be defined by pre-setting C<$Pod::Usage::Formatter> I<before>
  loading Pod::Usage, e.g.:
  
      BEGIN { $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }
      use Pod::Usage qw(pod2usage);
  
  Pod::Usage uses L<Pod::Simple>'s _handle_element_end() method to implement
  the section selection, and in case of verbosity < 2 it down-cases the
  all-caps headings to first capital letter and rest lowercase, and adds
  a colon/newline at the end of the headings, for better readability. Same for
  verbosity = 99.
  
  =head2 Pass-through options
  
  The following options are passed through to the underlying text formatter.
  See the manual pages of these modules for more information.
  
    alt code indent loose margin quotes sentence stderr utf8 width
  
  =head1 DESCRIPTION
  
  B<pod2usage> will print a usage message for the invoking script (using
  its embedded pod documentation) and then exit the script with the
  desired exit status. The usage message printed may have any one of three
  levels of "verboseness": If the verbose level is 0, then only a synopsis
  is printed. If the verbose level is 1, then the synopsis is printed
  along with a description (if present) of the command line options and
  arguments. If the verbose level is 2, then the entire manual page is
  printed.
  
  Unless they are explicitly specified, the default values for the exit
  status, verbose level, and output stream to use are determined as
  follows:
  
  =over 4
  
  =item *
  
  If neither the exit status nor the verbose level is specified, then the
  default is to use an exit status of 2 with a verbose level of 0.
  
  =item *
  
  If an exit status I<is> specified but the verbose level is I<not>, then the
  verbose level will default to 1 if the exit status is less than 2 and
  will default to 0 otherwise.
  
  =item *
  
  If an exit status is I<not> specified but verbose level I<is> given, then
  the exit status will default to 2 if the verbose level is 0 and will
  default to 1 otherwise.
  
  =item *
  
  If the exit status used is less than 2, then output is printed on
  C<STDOUT>.  Otherwise output is printed on C<STDERR>.
  
  =back
  
  Although the above may seem a bit confusing at first, it generally does
  "the right thing" in most situations.  This determination of the default
  values to use is based upon the following typical Unix conventions:
  
  =over 4
  
  =item *
  
  An exit status of 0 implies "success". For example, B<diff(1)> exits
  with a status of 0 if the two files have the same contents.
  
  =item *
  
  An exit status of 1 implies possibly abnormal, but non-defective, program
  termination.  For example, B<grep(1)> exits with a status of 1 if
  it did I<not> find a matching line for the given regular expression.
  
  =item *
  
  An exit status of 2 or more implies a fatal error. For example, B<ls(1)>
  exits with a status of 2 if you specify an illegal (unknown) option on
  the command line.
  
  =item *
  
  Usage messages issued as a result of bad command-line syntax should go
  to C<STDERR>.  However, usage messages issued due to an explicit request
  to print usage (like specifying B<-help> on the command line) should go
  to C<STDOUT>, just in case the user wants to pipe the output to a pager
  (such as B<more(1)>).
  
  =item *
  
  If program usage has been explicitly requested by the user, it is often
  desirable to exit with a status of 1 (as opposed to 0) after issuing
  the user-requested usage message.  It is also desirable to give a
  more verbose description of program usage in this case.
  
  =back
  
  B<pod2usage> does not force the above conventions upon you, but it will
  use them by default if you don't expressly tell it to do otherwise.  The
  ability of B<pod2usage()> to accept a single number or a string makes it
  convenient to use as an innocent looking error message handling function:
  
      use strict;
      use Pod::Usage;
      use Getopt::Long;
  
      ## Parse options
      my %opt;
      GetOptions(\%opt, "help|?", "man", "flag1")  ||  pod2usage(2);
      pod2usage(1)  if ($opt{help});
      pod2usage(-exitval => 0, -verbose => 2)  if ($opt{man});
  
      ## Check for too many filenames
      pod2usage("$0: Too many files given.\n")  if (@ARGV > 1);
  
  Some user's however may feel that the above "economy of expression" is
  not particularly readable nor consistent and may instead choose to do
  something more like the following:
  
      use strict;
      use Pod::Usage qw(pod2usage);
      use Getopt::Long qw(GetOptions);
  
      ## Parse options
      my %opt;
      GetOptions(\%opt, "help|?", "man", "flag1")  ||
        pod2usage(-verbose => 0);
  
      pod2usage(-verbose => 1)  if ($opt{help});
      pod2usage(-verbose => 2)  if ($opt{man});
  
      ## Check for too many filenames
      pod2usage(-verbose => 2, -message => "$0: Too many files given.\n")
        if (@ARGV > 1);
  
  
  As with all things in Perl, I<there's more than one way to do it>, and
  B<pod2usage()> adheres to this philosophy.  If you are interested in
  seeing a number of different ways to invoke B<pod2usage> (although by no
  means exhaustive), please refer to L<"EXAMPLES">.
  
  =head2 Scripts
  
  The Pod::Usage distribution comes with a script pod2usage which offers
  a command line interface to the functionality of Pod::Usage. See
  L<pod2usage>.
  
  
  =head1 EXAMPLES
  
  Each of the following invocations of C<pod2usage()> will print just the
  "SYNOPSIS" section to C<STDERR> and will exit with a status of 2:
  
      pod2usage();
  
      pod2usage(2);
  
      pod2usage(-verbose => 0);
  
      pod2usage(-exitval => 2);
  
      pod2usage({-exitval => 2, -output => \*STDERR});
  
      pod2usage({-verbose => 0, -output  => \*STDERR});
  
      pod2usage(-exitval => 2, -verbose => 0);
  
      pod2usage(-exitval => 2, -verbose => 0, -output => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print a message
  of "Syntax error." (followed by a newline) to C<STDERR>, immediately
  followed by just the "SYNOPSIS" section (also printed to C<STDERR>) and
  will exit with a status of 2:
  
      pod2usage("Syntax error.");
  
      pod2usage(-message => "Syntax error.", -verbose => 0);
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2);
  
      pod2usage({-msg => "Syntax error.", -exitval => 2, -output => \*STDERR});
  
      pod2usage({-msg => "Syntax error.", -verbose => 0, -output => \*STDERR});
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2, -verbose => 0);
  
      pod2usage(-message => "Syntax error.",
                -exitval => 2,
                -verbose => 0,
                -output  => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print the
  "SYNOPSIS" section and any "OPTIONS" and/or "ARGUMENTS" sections to
  C<STDOUT> and will exit with a status of 1:
  
      pod2usage(1);
  
      pod2usage(-verbose => 1);
  
      pod2usage(-exitval => 1);
  
      pod2usage({-exitval => 1, -output => \*STDOUT});
  
      pod2usage({-verbose => 1, -output => \*STDOUT});
  
      pod2usage(-exitval => 1, -verbose => 1);
  
      pod2usage(-exitval => 1, -verbose => 1, -output => \*STDOUT});
  
  Each of the following invocations of C<pod2usage()> will print the
  entire manual page to C<STDOUT> and will exit with a status of 1:
  
      pod2usage(-verbose  => 2);
  
      pod2usage({-verbose => 2, -output => \*STDOUT});
  
      pod2usage(-exitval  => 1, -verbose => 2);
  
      pod2usage({-exitval => 1, -verbose => 2, -output => \*STDOUT});
  
  =head2 Recommended Use
  
  Most scripts should print some type of usage message to C<STDERR> when a
  command line syntax error is detected. They should also provide an
  option (usually C<-H> or C<-help>) to print a (possibly more verbose)
  usage message to C<STDOUT>. Some scripts may even wish to go so far as to
  provide a means of printing their complete documentation to C<STDOUT>
  (perhaps by allowing a C<-man> option). The following complete example
  uses B<Pod::Usage> in combination with B<Getopt::Long> to do all of these
  things:
  
      use strict;
      use Getopt::Long qw(GetOptions);
      use Pod::Usage qw(pod2usage);
  
      my $man = 0;
      my $help = 0;
      ## Parse options and print usage if there is a syntax error,
      ## or if usage was explicitly requested.
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-verbose => 2) if $man;
  
      ## If no arguments were given, then allow STDIN to be used only
      ## if it's not connected to a terminal (otherwise print usage)
      pod2usage("$0: No files given.")  if ((@ARGV == 0) && (-t STDIN));
  
      __END__
  
      =head1 NAME
  
      sample - Using GetOpt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 4
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  =head1 CAVEATS
  
  By default, B<pod2usage()> will use C<$0> as the path to the pod input
  file.  Unfortunately, not all systems on which Perl runs will set C<$0>
  properly (although if C<$0> is not found, B<pod2usage()> will search
  C<$ENV{PATH}> or else the list specified by the C<-pathlist> option).
  If this is the case for your system, you may need to explicitly specify
  the path to the pod docs for the invoking script using something
  similar to the following:
  
      pod2usage(-exitval => 2, -input => "/path/to/your/pod/docs");
  
  In the pathological case that a script is called via a relative path
  I<and> the script itself changes the current working directory
  (see L<perlfunc/chdir>) I<before> calling pod2usage, Pod::Usage will
  fail even on robust platforms. Don't do that. Or use L<FindBin> to locate
  the script:
  
      use FindBin;
      pod2usage(-input => $FindBin::Bin . "/" . $FindBin::Script);
  
  =head1 SUPPORT
  
  This module is managed in a GitHub repository,
  L<https://github.com/Dual-Life/Pod-Usage> Feel free to fork and contribute, or
  to clone and send patches!
  
  Please use L<https://github.com/Dual-Life/Pod-Usage/issues/new> to file a bug
  report.  The previous ticketing system,
  L<https://rt.cpan.org/Dist/Display.html?Queue=Pod-Usage>, is deprecated for
  this package.
  
  More general questions or discussion about POD should be sent to the
  C<pod-people@perl.org> mail list. Send an empty email to
  C<pod-people-subscribe@perl.org> to subscribe.
  
  =head1 AUTHOR
  
  Marek Rouchal E<lt>marekr@cpan.orgE<gt>
  
  Nicolas R E<lt>nicolas@atoomic.orgE<gt>
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt>
  
  Based on code for B<Pod::Text::pod2text()> written by
  Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>
  
  =head1 LICENSE
  
  Pod::Usage (the distribution) is licensed under the same terms as Perl.
  
  =head1 ACKNOWLEDGMENTS
  
  Nicolas R (ATOOMIC) for setting up the Github repo and modernizing this
  package.
  
  rjbs for refactoring Pod::Usage to not use Pod::Parser any more.
  
  Steven McDougall E<lt>swmcd@world.std.comE<gt> for his help and patience with
  re-writing this manpage.
  
  =head1 SEE ALSO
  
  B<Pod::Usage> is now a standalone distribution, depending on
  L<Pod::Text> which in turn depends on L<Pod::Simple>.
  
  L<Pod::Perldoc>, L<Getopt::Long>, L<Pod::Find>, L<FindBin>,
  L<Pod::Text>, L<Pod::Text::Termcap>, L<Pod::Simple>
  
  =cut
  
POD_USAGE

$fatpacked{"Whatpm/CSS/SelectorsParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_CSS_SELECTORSPARSER';
  package Whatpm::CSS::SelectorsParser;
  use strict;
  use warnings;
  our $VERSION = '1.13';
  
  require Exporter;
  push our @ISA, 'Exporter';
  
  use Whatpm::CSS::Tokenizer qw(:token);
  
  sub new ($) {
    my $self = bless {
      onerror => sub { },
  
      ## See |Whatpm::CSS::Parser| for usage.
      lookup_namespace_uri => sub {
        return undef;
      },
  
      level => {
        must => 'm',
        should => 's',
        warning => 'w',
        uncertain => 'u',
      },
  
      #href => \(URL in which the selectors appear),
      #pseudo_class => {supported_class_name => 1, ...},
      #pseudo_element => {supported_class_name => 1, ...},
    }, shift;
    return $self;
  } # new
  
  sub BEFORE_TYPE_SELECTOR_STATE () { 1 }
  sub AFTER_NAME_STATE () { 2 }
  sub BEFORE_LOCAL_NAME_STATE () { 3 }
  sub BEFORE_SIMPLE_SELECTOR_STATE () { 4 }
  sub BEFORE_CLASS_NAME_STATE () { 5 }
  sub AFTER_COLON_STATE () { 6 }
  sub AFTER_DOUBLE_COLON_STATE () { 7 }
  sub AFTER_LBRACKET_STATE () { 8 }
  sub AFTER_ATTR_NAME_STATE () { 9 }
  sub BEFORE_ATTR_LOCAL_NAME_STATE () { 10 }
  sub BEFORE_MATCH_STATE () { 11 }
  sub BEFORE_VALUE_STATE () { 12 }
  sub AFTER_VALUE_STATE () { 13 }
  sub BEFORE_COMBINATOR_STATE () { 14 }
  sub COMBINATOR_STATE () { 15 }
  sub BEFORE_LANG_TAG_STATE () { 16 }
  sub AFTER_LANG_TAG_STATE () { 17 }
  sub BEFORE_AN_STATE () { 18 }
  sub AFTER_AN_STATE () { 19 }
  sub BEFORE_B_STATE () { 20 }
  sub AFTER_B_STATE () { 21 }
  sub AFTER_NEGATION_SIMPLE_SELECTOR_STATE () { 22 }
  sub BEFORE_CONTAINS_STRING_STATE () { 23 }
  
  sub NAMESPACE_SELECTOR () { 1 }
  sub LOCAL_NAME_SELECTOR () { 2 }
  sub ID_SELECTOR () { 3 }
  sub CLASS_SELECTOR () { 4 }
  sub PSEUDO_CLASS_SELECTOR () { 5 }
  sub PSEUDO_ELEMENT_SELECTOR () { 6 }
  sub ATTRIBUTE_SELECTOR () { 7 }
  
  sub DESCENDANT_COMBINATOR () { S_TOKEN }
  sub CHILD_COMBINATOR () { GREATER_TOKEN }
  sub ADJACENT_SIBLING_COMBINATOR () { PLUS_TOKEN }
  sub GENERAL_SIBLING_COMBINATOR () { TILDE_TOKEN }
  
  sub EXISTS_MATCH () { 0 }
  sub EQUALS_MATCH () { MATCH_TOKEN }
  sub INCLUDES_MATCH () { INCLUDES_TOKEN }
  sub DASH_MATCH () { DASHMATCH_TOKEN }
  sub PREFIX_MATCH () { PREFIXMATCH_TOKEN }
  sub SUFFIX_MATCH () { SUFFIXMATCH_TOKEN }
  sub SUBSTRING_MATCH () { SUBSTRINGMATCH_TOKEN }
  
  our @EXPORT_OK = qw(NAMESPACE_SELECTOR LOCAL_NAME_SELECTOR ID_SELECTOR
      CLASS_SELECTOR PSEUDO_CLASS_SELECTOR PSEUDO_ELEMENT_SELECTOR
      ATTRIBUTE_SELECTOR
      DESCENDANT_COMBINATOR CHILD_COMBINATOR
      ADJACENT_SIBLING_COMBINATOR GENERAL_SIBLING_COMBINATOR
      EXISTS_MATCH EQUALS_MATCH INCLUDES_MATCH DASH_MATCH PREFIX_MATCH
      SUFFIX_MATCH SUBSTRING_MATCH);
  
  our %EXPORT_TAGS = (
    selector => [qw(NAMESPACE_SELECTOR LOCAL_NAME_SELECTOR ID_SELECTOR
        CLASS_SELECTOR PSEUDO_CLASS_SELECTOR PSEUDO_ELEMENT_SELECTOR
        ATTRIBUTE_SELECTOR)],
    combinator => [qw(DESCENDANT_COMBINATOR CHILD_COMBINATOR
        ADJACENT_SIBLING_COMBINATOR GENERAL_SIBLING_COMBINATOR)],
    match => [qw(EXISTS_MATCH EQUALS_MATCH INCLUDES_MATCH DASH_MATCH
        PREFIX_MATCH SUFFIX_MATCH SUBSTRING_MATCH)],
  );
  
  sub parse_string ($$) {
    my $self = $_[0];
    
    my $s = $_[1];
    pos ($s) = 0;
    my $line = 1;
    my $column = 0;
  
    my $tt = Whatpm::CSS::Tokenizer->new;
    $tt->{onerror} = $self->{onerror};
    $tt->{href} = $self->{href};
    $tt->{level} = $self->{level};
    $tt->{get_char} = sub ($) {
      if (pos $s < length $s) {
        my $c = ord substr $s, pos ($s)++, 1;
        if ($c == 0x000A) {
          $line++;
          $column = 0;
        } elsif ($c == 0x000D) {
          unless (substr ($s, pos ($s), 1) eq "\x0A") {
            $line++;
            $column = 0;
          } else {
            $column++;
          }
        } else {
          $column++;
        }
        $_[0]->{line_prev} = $_[0]->{line};
        $_[0]->{column_prev} = $_[0]->{column};
        $_[0]->{line} = $line;
        $_[0]->{column} = $column;
        return $c;
      } else {
        $_[0]->{line_prev} = $_[0]->{line};
        $_[0]->{column_prev} = $_[0]->{column};
        $_[0]->{line} = $line;
        $_[0]->{column} = $column + 1; ## Set the same number always.
        return -1;
      }
    }; # $tt->{get_char}
    $tt->{line} = $line;
    $tt->{column} = $column;
    $tt->init;
  
    my ($next_token, $selectors)
        = $self->_parse_selectors_with_tokenizer ($tt, EOF_TOKEN);
    return $selectors; # or undef
  } # parse_string
  
  our $IdentOnlyPseudoClasses = {
    active => 1,
    checked => 1,
    '-manakai-current' => 1,
    disabled => 1,
    empty => 1,
    enabled => 1,
    'first-child' => 1,
    'first-of-type' => 1,
    focus => 1,
    future => 1,
    hover => 1,
    indeterminate => 1,
    'last-child' => 1,
    'last-of-type' => 1,
    link => 1,
    'only-child' => 1,
    'only-of-type' => 1,
    past => 1,
    root => 1,
    target => 1,
    visited => 1,
  }; # $IdentOnlyPseudoClasses
  
  our $IdentOnlyPseudoElements = {
    'first-letter' => 1,
    'first-line' => 1,
    after => 1,
    before => 1,
    cue => 1,
  }; # $IdentOnlyPseudoElements
  
  sub _parse_selectors_with_tokenizer ($$$;$) {
    my $self = $_[0];
    my $tt = $_[1];
    # $_[2] : End token (other than EOF_TOKEN - may be EOF_TOKEN if no other).
    # $_[3] : The first token, or undef
  
    my $default_namespace = $self->{lookup_namespace_uri}->('');
  
    my $selectors = [];
    my $selector = [DESCENDANT_COMBINATOR];
    my $sss = [];
    my $simple_selector;
    my $has_pseudo_element;
    my $in_negation;
  
    my $state = BEFORE_TYPE_SELECTOR_STATE;
    my $t = $_[3] || $tt->get_next_token;
    my $name;
    my $name_t;
    S: {
      if ($state == BEFORE_TYPE_SELECTOR_STATE) {
        $in_negation = 2 if $in_negation;
  
        if ($t->{type} == IDENT_TOKEN) { ## element type or namespace prefix
          $name = $t->{value};
          $name_t = $t;
          $state = AFTER_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == STAR_TOKEN) { ## universal selector or prefix
          undef $name;
          $state = AFTER_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == VBAR_TOKEN) { ## null namespace
          undef $name;
          push @$sss, [NAMESPACE_SELECTOR, undef];
  
          $state = BEFORE_LOCAL_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } elsif ({
                  DOT_TOKEN, 1,
                  COLON_TOKEN, 1,
                  HASH_TOKEN, 1,
                  LBRACKET_TOKEN, 1,
                  RPAREN_TOKEN, $in_negation, # :not(a ->> ) <<-
                 }->{$t->{type}}) {
          $in_negation = 1 if $in_negation;
          if (defined $default_namespace and not $in_negation) {
            if (length $default_namespace) {
              push @$sss, [NAMESPACE_SELECTOR, $default_namespace];
            } else {
              push @$sss, [NAMESPACE_SELECTOR, undef];
            }
          }
  
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          # Reprocess.
          redo S;
        } else {
          if ($t->{type} == DELIM_TOKEN and
              $t->{value} eq '#') {
            $self->{onerror}->(type => 'selectors:id:empty',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
          } else {
            $self->{onerror}->(type => 'no sss',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
          }
          return ($t, undef);
        }
      } elsif ($state == BEFORE_SIMPLE_SELECTOR_STATE) {
        if ($in_negation and $in_negation++ == 2) {
          $state = AFTER_NEGATION_SIMPLE_SELECTOR_STATE;
          ## Reprocess.
          redo S;
        }
  
        if ($t->{type} == DOT_TOKEN) { ## class selector
          if ($has_pseudo_element) {
            $self->{onerror}->(type => 'ss after pseudo-element',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
          $state = BEFORE_CLASS_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == HASH_TOKEN) { ## ID selector
          if ($has_pseudo_element) {
            $self->{onerror}->(type => 'ss after pseudo-element',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
          if ($t->{not_ident}) {
            $self->{onerror}->(type => 'selectors:id:not ident',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
          push @$sss, [ID_SELECTOR, $t->{value}];
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == COLON_TOKEN) { ## pseudo-class or pseudo-element
          if ($has_pseudo_element) {
            $self->{onerror}->(type => 'ss after pseudo-element',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
          $state = AFTER_COLON_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == LBRACKET_TOKEN) { ## attribute selector
          if ($has_pseudo_element) {
            $self->{onerror}->(type => 'ss after pseudo-element',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
          $state = AFTER_LBRACKET_STATE;
          $t = $tt->get_next_token;
          redo S;
        } else {
          $state = BEFORE_COMBINATOR_STATE;
          ## Reprocess.
          redo S;
        }
      } elsif ($state == AFTER_NAME_STATE) {
        if ($t->{type} == VBAR_TOKEN) {
          $state = BEFORE_LOCAL_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } else { ## Type or universal selector w/o namespace prefix
          if (defined $default_namespace) {
            if (length $default_namespace) {
              push @$sss, [NAMESPACE_SELECTOR, $default_namespace];
            } else {
              push @$sss, [NAMESPACE_SELECTOR, undef];
            }
          }
          push @$sss, [LOCAL_NAME_SELECTOR, $name] if defined $name;
  
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          ## reprocess.
          redo S;
        }
      } elsif ($state == BEFORE_LOCAL_NAME_STATE) {
        if ($t->{type} == IDENT_TOKEN) {
          if (defined $name) { ## Prefix is neither empty nor "*"
            my $uri = $self->{lookup_namespace_uri}->($name);
            unless (defined $uri) {
              $self->{onerror}->(type => 'namespace prefix:not declared',
                                 level => $self->{level}->{must},
                                 uri => \$self->{href},
                                 token => $name_t || $t,
                                 value => $name);
              return ($t, undef);
            }
            undef $uri unless length $uri;
            push @$sss, [NAMESPACE_SELECTOR, $uri];
          }
          push @$sss, [LOCAL_NAME_SELECTOR, $t->{value}];
  
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == STAR_TOKEN) {
          if (defined $name) { ## Prefix is neither empty nor "*"
            my $uri = $self->{lookup_namespace_uri}->($name);
            unless (defined $uri) {
              $self->{onerror}->(type => 'namespace prefix:not declared',
                                 level => $self->{level}->{must},
                                 uri => \$self->{href},
                                 token => $name_t || $t,
                                 value => $name);
              return ($t, undef);
            }
            undef $uri unless length $uri;
            push @$sss, [NAMESPACE_SELECTOR, $uri];
          }
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } else { ## "|" not followed by type or universal selector
          $self->{onerror}->(type => 'no local name selector',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == BEFORE_CLASS_NAME_STATE) {
        if ($t->{type} == IDENT_TOKEN) {
          push @$sss, [CLASS_SELECTOR, $t->{value}];
  
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'no class name',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == BEFORE_COMBINATOR_STATE) {
        push @$selector, $sss;
        $sss = [];
  
        if ($t->{type} == S_TOKEN) {
          $state = COMBINATOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ({
                  GREATER_TOKEN, 1,
                  PLUS_TOKEN, 1,
                  TILDE_TOKEN, 1,
                  COMMA_TOKEN, 1,
                  EOF_TOKEN, 1,
                  $_[2], 1,
                 }->{$t->{type}}) {
          $state = COMBINATOR_STATE;
          ## Reprocess.
          redo S;
        } else {
          $self->{onerror}->(type => 'no combinator',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == COMBINATOR_STATE) {
        if ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } elsif ({
                  GREATER_TOKEN, 1,
                  PLUS_TOKEN, 1,
                  TILDE_TOKEN, 1,
                 }->{$t->{type}}) {
          if ($has_pseudo_element) {
            $self->{onerror}->(type => 'combinator after pseudo-element',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
  
          push @$selector, $t->{type};
  
          $state = BEFORE_TYPE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == EOF_TOKEN or $t->{type} == $_[2]) {
          push @$selectors, $selector;
          return ($t, $selectors);
        } elsif ($t->{type} == COMMA_TOKEN) {
          push @$selectors, $selector;
          $selector = [DESCENDANT_COMBINATOR];
          undef $has_pseudo_element;
  
          $state = BEFORE_TYPE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } else {
          if ($has_pseudo_element) {
            $self->{onerror}->(type => 'ss after pseudo-element',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
  
          push @$selector, S_TOKEN;
  
          $state = BEFORE_TYPE_SELECTOR_STATE;
          ## Reprocess.
          redo S;
        }
      } elsif ($state == AFTER_COLON_STATE) {
        if ($t->{type} == IDENT_TOKEN) {
          my $class = $t->{value};
          $class =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          if ($IdentOnlyPseudoClasses->{$class}) {
            if ($self->{pseudo_class}->{$class}) {
              push @$sss, [PSEUDO_CLASS_SELECTOR, $class];
            } else {
              $self->{onerror}->(type => 'selectors:pseudo-class:ident:not supported',
                                 level => $self->{level}->{warning},
                                 uri => \$self->{href},
                                 token => $t, value => $class);
              return ($t, undef);
            }
          } elsif ({'first-letter' => 1, 'first-line' => 1,
                    before => 1, after => 1}->{$class} and
                   not $in_negation) {
            if ($self->{pseudo_element}->{$class}) {
              $self->{onerror}->(type => 'selectors:pseudo-element:one colon',
                                 level => $self->{level}->{warning},
                                 uri => \$self->{href},
                                 token => $t, value => $class);
              push @$sss, [PSEUDO_ELEMENT_SELECTOR, $class];
              $has_pseudo_element = 1;
            } else {
              $self->{onerror}->(type => 'selectors:pseudo-element:ident:not supported',
                                 level => $self->{level}->{warning},
                                 uri => \$self->{href},
                                 token => $t, value => $class);
              return ($t, undef);
            }
          } else {
            $self->{onerror}->(type => 'selectors:pseudo-class:ident:unknown',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t, value => $class);
            return ($t, undef);
          }
  
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == FUNCTION_TOKEN) {
          my $class = $t->{value};
          $class =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          
          my $known;
          if ($class eq 'lang') {
            if ($self->{pseudo_class}->{$class}) {
              $state = BEFORE_LANG_TAG_STATE;
              $t = $tt->get_next_token;
              redo S;
            } else {
              $known = 1;
            }
          } elsif ($class eq 'not' and not $in_negation) {
            if ($self->{pseudo_class}->{$class}) {
              $in_negation = 1;
              
              push @$sss, '';
              $state = BEFORE_TYPE_SELECTOR_STATE;
              $t = $tt->get_next_token;
              redo S;
            } else {
              $known = 1;
            }
          } elsif ({
                    'nth-child' => 1,
                    'nth-last-child' => 1,
                    'nth-of-type' => 1,
                    'nth-last-of-type' => 1,
                   }->{$class}) {
            if ($self->{pseudo_class}->{$class}) {
              $name = $class;
              
              $state = BEFORE_AN_STATE;
              $t = $tt->get_next_token;
              redo S;
            } else {
              $known = 1;
            }
          } elsif ($class eq '-manakai-contains') {
            if ($self->{pseudo_class}->{$class}) {
              $state = BEFORE_CONTAINS_STRING_STATE;
              $t = $tt->get_next_token;
              redo S;
            } else {
              $known = 1;
            }
          }
  
          if ($known) {
            $self->{onerror}->(type => 'selectors:pseudo-class:function:not supported',
                               level => $self->{level}->{warning},
                               uri => \$self->{href},
                               token => $t, value => $class);
            return ($t, undef);
          } else {
            $self->{onerror}->(type => 'selectors:pseudo-class:function:unknown',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t, value => $class);
            return ($t, undef);
          }
        } elsif ($t->{type} == COLON_TOKEN and
                 not $in_negation) { ## Pseudo-element
          $state = AFTER_DOUBLE_COLON_STATE;
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'no pseudo-class name',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == AFTER_LBRACKET_STATE) { ## Attribute selector
        $simple_selector = [ATTRIBUTE_SELECTOR];
        if ($t->{type} == IDENT_TOKEN) {
          $name = $t->{value};
          $name_t = $t;
  
          $state = AFTER_ATTR_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == VBAR_TOKEN) {
          $simple_selector->[1] = ''; # null namespace
          
          $state = BEFORE_ATTR_LOCAL_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == STAR_TOKEN) {
          $name = undef;
          $name_t = undef;
  
          $state = AFTER_ATTR_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'no attr name',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == AFTER_ATTR_NAME_STATE) {
        if ($t->{type} == VBAR_TOKEN) {
          if (defined $name) {
            my $uri = $self->{lookup_namespace_uri}->($name);
            unless (defined $uri) {
              $self->{onerror}->(type => 'namespace prefix:not declared',
                                 level => $self->{level}->{must},
                                 uri => \$self->{href},
                                 token => $name_t || $t,
                                 value => $name);
              return ($t, undef);
            }
            $simple_selector->[1] = $uri; # null namespace if $uri is empty
          }
  
          $state = BEFORE_ATTR_LOCAL_NAME_STATE;
          $t = $tt->get_next_token;
          redo S;
        } else {
          unless (defined $name) { ## [*]
            $self->{onerror}->(type => 'no attr namespace separator',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
          $simple_selector->[1] = ''; # null namespace
          $simple_selector->[2] = $name;
  
          $state = BEFORE_MATCH_STATE;
          ## Reprocess.
          redo S;
        }
      } elsif ($state == BEFORE_ATTR_LOCAL_NAME_STATE) {
        if ($t->{type} == IDENT_TOKEN) {
          $simple_selector->[2] = $t->{value};
          
          $state = BEFORE_MATCH_STATE;
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'no attr local name',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == BEFORE_MATCH_STATE) {
        if ({
             MATCH_TOKEN, 1,
             INCLUDES_TOKEN, 1,
             DASHMATCH_TOKEN, 1,
             PREFIXMATCH_TOKEN, 1,
             SUFFIXMATCH_TOKEN, 1,
             SUBSTRINGMATCH_TOKEN, 1,
            }->{$t->{type}}) {
          $simple_selector->[3] = $t->{type};
  
          $state = BEFORE_VALUE_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == RBRACKET_TOKEN) {
          push @$sss, $simple_selector;
          
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'no attr match',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == BEFORE_VALUE_STATE) {
        if ($t->{type} == IDENT_TOKEN or
            $t->{type} == STRING_TOKEN or
            ($t->{type} == INVALID_TOKEN and $t->{eos})) {
          $simple_selector->[4] = $t->{value};
          push @$sss, $simple_selector;
  
          $state = AFTER_VALUE_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'no attr value',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == AFTER_VALUE_STATE) {
        if ($t->{type} == RBRACKET_TOKEN) {
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'attr selector not closed',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == AFTER_DOUBLE_COLON_STATE) {
        if ($t->{type} == IDENT_TOKEN) {
          my $pe = $t->{value};
          $pe =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          if ($self->{pseudo_element}->{$pe} and 
              $IdentOnlyPseudoElements->{$pe}) {
            push @$sss, [PSEUDO_ELEMENT_SELECTOR, $pe];
            $has_pseudo_element = 1;
  
            $state = BEFORE_SIMPLE_SELECTOR_STATE;
            $t = $tt->get_next_token;
            redo S;
          } else {
            if ($IdentOnlyPseudoElements->{$pe}) {
              $self->{onerror}
                  ->(type => 'selectors:pseudo-element:ident:not supported',
                     level => $self->{level}->{warning},
                     uri => \$self->{href},
                     token => $t, value => $pe);
            } else {
              $self->{onerror}
                  ->(type => 'selectors:pseudo-element:ident:unknown',
                     level => $self->{level}->{must},
                     uri => \$self->{href},
                     token => $t, value => $pe);
            }
            return ($t, undef);
          }
        } elsif ($t->{type} == FUNCTION_TOKEN) {
          my $pe = $t->{value};
          $pe =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          if ($self->{pseudo_element}->{$pe} and
              $pe eq 'cue') {
            my $sub_selectors;
            ($t, $sub_selectors)
                = $self->_parse_selectors_with_tokenizer ($tt, RPAREN_TOKEN);
            if ($sub_selectors and @$sub_selectors) {
              unless ($t->{type} == RPAREN_TOKEN) {
                $self->{onerror}->(type => 'function not closed',
                                   level => $self->{level}->{must},
                                   uri => \$self->{href},
                                   token => $t);
                return ($t, undef);
              }
  
              push @$sss, [PSEUDO_ELEMENT_SELECTOR, $pe, $sub_selectors];
              $has_pseudo_element = 1;
              
              $state = BEFORE_SIMPLE_SELECTOR_STATE;
              $t = $tt->get_next_token;
              redo S;
            } else {
              return ($t, undef);
            }
          } else {
            if ($pe eq 'cue') {
              $self->{onerror}
                  ->(type => 'selectors:pseudo-element:function:not supported',
                     level => $self->{level}->{warning},
                     uri => \$self->{href},
                     token => $t, value => $pe);
            } else {
              $self->{onerror}
                  ->(type => 'selectors:pseudo-element:function:unknown',
                     level => $self->{level}->{must},
                     uri => \$self->{href},
                     token => $t, value => $pe);
            }
            return ($t, undef);
          }
        } else {
          $self->{onerror}->(type => 'no pseudo-element name',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == BEFORE_LANG_TAG_STATE) {
        if ($t->{type} == IDENT_TOKEN) {
          push @$sss, [PSEUDO_CLASS_SELECTOR, 'lang', $t->{value}];
          
          $state = AFTER_LANG_TAG_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'no lang tag',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == AFTER_LANG_TAG_STATE) {
        if ($t->{type} == RPAREN_TOKEN) {
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'selectors:pseudo:argument not closed',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == BEFORE_AN_STATE) {
        if ($t->{type} == DIMENSION_TOKEN) {
          if ($t->{number} =~ /\A[0-9]+\z/) {
            my $n = $t->{value};
            $n =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($n eq 'n') {
              $simple_selector = [PSEUDO_CLASS_SELECTOR, $name,
                                  0+$t->{number}, 0];
              
              $state = AFTER_AN_STATE;
              $t = $tt->get_next_token;
              redo S;
            } elsif ($n =~ /\An-([0-9]+)\z/) {
              push @$sss, [PSEUDO_CLASS_SELECTOR, $name, 0+$t->{number}, 0-$1];
  
              $state = AFTER_B_STATE;
              $t = $tt->get_next_token;
              redo S;
            } elsif ($n =~ /\An-\z/) {
              push @$sss, [PSEUDO_CLASS_SELECTOR, $name, 0+$t->{number}, 0];
  
              $t = $tt->get_next_token;
              $t = $tt->get_next_token while $t->{type} == S_TOKEN;
              if ($t->{type} == NUMBER_TOKEN and
                  $t->{number} =~ /\A[0-9]+\z/) {
                $sss->[-1]->[-1] -= $t->{number};
                $state = AFTER_B_STATE;
                $t = $tt->get_next_token;
                redo S;
              }
            }
            $self->{onerror}->(type => 'an+b syntax error',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          } else {
            $self->{onerror}->(type => 'an+b syntax error',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
        } elsif ($t->{type} == NUMBER_TOKEN) {
          if ($t->{number} =~ /\A[0-9]+\z/) {
            push @$sss, [PSEUDO_CLASS_SELECTOR, $name, 0, 0+$t->{number}];
  
            $state = AFTER_B_STATE;
            $t = $tt->get_next_token;
            redo S;
          } else {
            $self->{onerror}->(type => 'an+b not integer',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t, value => $t->{number});
            return ($t, undef);
          }
        } elsif ($t->{type} == IDENT_TOKEN) {
          my $value = $t->{value};
          $value =~ tr/A-Z/a-z/; ## ASCII case-insensitive
          if ($value eq 'odd') {
            push @$sss, [PSEUDO_CLASS_SELECTOR, $name, 2, 1];
  
            $state = AFTER_B_STATE;
            $t = $tt->get_next_token;
            redo S;
          } elsif ($value eq 'even') {
            push @$sss, [PSEUDO_CLASS_SELECTOR, $name, 2, 0];
  
            $state = AFTER_B_STATE;
            $t = $tt->get_next_token;
            redo S;
          } elsif ($value eq 'n' or $value eq '-n') {
            $simple_selector = [PSEUDO_CLASS_SELECTOR, $name,
                                $value eq 'n' ? 1 : -1, 0];
  
            $state = AFTER_AN_STATE;
            $t = $tt->get_next_token;
            redo S;
          } elsif ($value =~ /\A(-?)n-([0-9]+)\z/) {
            push @$sss, [PSEUDO_CLASS_SELECTOR, $name, 0+($1.'1'), -$2];
  
            $state = AFTER_B_STATE;
            $t = $tt->get_next_token;
            redo S;
          } else {
            $self->{onerror}->(type => 'an+b syntax error',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
        } elsif ($t->{type} == MINUS_TOKEN or
                 $t->{type} == PLUS_TOKEN) {
          my $sign = $t->{type} == MINUS_TOKEN ? -1 : +1;
          $t = $tt->get_next_token;
          if ($t->{type} == DIMENSION_TOKEN || $t->{type} == IDENT_TOKEN) {
            my $num = $t->{type} == IDENT_TOKEN ? 1 : $t->{number};
            if ($num =~ /\A[0-9]+\z/) {
              my $n = $t->{value};
              $n =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($n eq 'n') {
                $simple_selector = [PSEUDO_CLASS_SELECTOR, $name,
                                    $sign * $num, 0];
                
                $state = AFTER_AN_STATE;
                $t = $tt->get_next_token;
                redo S;
              } elsif ($n =~ /\An-([0-9]+)\z/) {
                $simple_selector = [PSEUDO_CLASS_SELECTOR, $name,
                                    $sign * $num, -$1];
  
                $state = AFTER_AN_STATE;
                $t = $tt->get_next_token;
                redo S;
              } else {
                $self->{onerror}->(type => 'an+b syntax error',
                                   level => $self->{level}->{must},
                                   uri => \$self->{href},
                                   token => $t);
                return ($t, undef);
              }
            } else {
              $self->{onerror}->(type => 'an+b syntax error',
                                 level => $self->{level}->{must},
                                 uri => \$self->{href},
                                 token => $t);
              return ($t, undef);
            }
          } elsif ($t->{type} == NUMBER_TOKEN) {
            if ($t->{number} =~ /\A[0-9]+\z/) {
              push @$sss, [PSEUDO_CLASS_SELECTOR, $name,
                           0, $sign * $t->{number}];
  
              $state = AFTER_B_STATE;
              $t = $tt->get_next_token;
              redo S;
            } else {
              $self->{onerror}->(type => 'an+b syntax error',
                                 level => $self->{level}->{must},
                                 uri => \$self->{href},
                                 token => $t);
              return ($t, undef);
            }
          } else {
            $self->{onerror}->(type => 'an+b syntax error',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'an+b syntax error',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == AFTER_AN_STATE) {
        if ($t->{type} == PLUS_TOKEN) {
          $simple_selector->[3] = +1;
  
          $state = BEFORE_B_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == MINUS_TOKEN) {
          $simple_selector->[3] = -1;
  
          $state = BEFORE_B_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == RPAREN_TOKEN) {
          push @$sss, $simple_selector;
  
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'an+b syntax error',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == BEFORE_B_STATE) {
        if ($t->{type} == NUMBER_TOKEN) {
          if ($t->{number} =~ /\A[0-9]+\z/) {
            $simple_selector->[3] *= $t->{number};
            push @$sss, $simple_selector;
            
            $state = AFTER_B_STATE;
            $t = $tt->get_next_token;
            redo S;
          } else {
            $self->{onerror}->(type => 'an+b syntax error',
                               level => $self->{level}->{must},
                               uri => \$self->{href},
                               token => $t);
            return ($t, undef);
          }
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'an+b syntax error',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == AFTER_B_STATE) {
        if ($t->{type} == RPAREN_TOKEN) {
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'an+b not closed',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == AFTER_NEGATION_SIMPLE_SELECTOR_STATE) {
        if ($t->{type} == RPAREN_TOKEN) {
          undef $in_negation;
          my $simple_selector = [];
          unshift @$simple_selector, pop @$sss while ref $sss->[-1];
          pop @$sss; # dummy
          unshift @$simple_selector, 'not';
          unshift @$simple_selector, PSEUDO_CLASS_SELECTOR;
          push @$sss, $simple_selector;
          
          $state = BEFORE_SIMPLE_SELECTOR_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'not not closed',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } elsif ($state == BEFORE_CONTAINS_STRING_STATE) {
        if ($t->{type} == STRING_TOKEN or
            $t->{type} == IDENT_TOKEN or
            ($t->{type} == INVALID_TOKEN and $t->{eos})) {
          push @$sss, [PSEUDO_CLASS_SELECTOR, '-manakai-contains', $t->{value}];
          
          $state = AFTER_LANG_TAG_STATE;
          $t = $tt->get_next_token;
          redo S;
        } elsif ($t->{type} == S_TOKEN) {
          ## Stay in the state.
          $t = $tt->get_next_token;
          redo S;
        } else {
          $self->{onerror}->(type => 'no contains string',
                             level => $self->{level}->{must},
                             uri => \$self->{href},
                             token => $t);
          return ($t, undef);
        }
      } else {
        die "$0: Selectors Parser: $state: Unknown state";
      }
    } # S
  } # _parse_selectors_with_tokenizer
  
  sub get_selector_specificity ($$) {
    my (undef, $selector) = @_;
  
    my $r = [0, 0, 0, 0]; # s, a, b, c
  
    ## s  = 1 iff style="" attribute
    ## a += 1 for ID attribute selectors
    ## b += 1 for attribute, class, and pseudo-class selectors
    ## c += 1 for type selectors and pseudo-elements
  
    for my $sss (@$selector) {
      next unless ref $sss; # combinator
      my @sss = @$sss;
      while (@sss) {
        my $ss = shift @sss;
        if ($ss->[0] == LOCAL_NAME_SELECTOR or
            $ss->[0] == PSEUDO_ELEMENT_SELECTOR) {
          $r->[3]++;
        } elsif ($ss->[0] == ATTRIBUTE_SELECTOR or
                 $ss->[0] == CLASS_SELECTOR) {
          $r->[2]++;
        } elsif ($ss->[0] == PSEUDO_CLASS_SELECTOR) {
          if ($ss->[1] eq 'not') {
            push @sss, @$ss[2..$#$ss];
          } else {
            $r->[2]++;
          }
        } elsif ($ss->[0] == ID_SELECTOR) {
          $r->[1]++;
        }
      }
    }
  
    return $r;
  } # get_selector_specificity
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
WHATPM_CSS_SELECTORSPARSER

$fatpacked{"Whatpm/CSS/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_CSS_TOKENIZER';
  package Whatpm::CSS::Tokenizer;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '1.21';
  
  require Exporter;
  push our @ISA, 'Exporter';
  
  sub BEFORE_TOKEN_STATE () { 0 }
  sub BEFORE_NMSTART_STATE () { 1 }
  sub NAME_STATE () { 2 }
  sub ESCAPE_OPEN_STATE () { 3 }
  sub STRING_STATE () { 4 }
  sub HASH_OPEN_STATE () { 5 }
  sub NUMBER_STATE () { 6 }
  sub NUMBER_FRACTION_STATE () { 7 }
  sub AFTER_NUMBER_STATE () { 8 }
  sub URI_BEFORE_WSP_STATE () { 9 }
  sub ESCAPE_STATE () { 10 }
  sub ESCAPE_BEFORE_LF_STATE () { 11 }
  sub ESCAPE_BEFORE_NL_STATE () { 12 }
  sub NUMBER_DOT_STATE () { 13 }
  sub NUMBER_DOT_NUMBER_STATE () { 14 }
  sub DELIM_STATE () { 15 }
  sub URI_UNQUOTED_STATE () { 16 }
  sub URI_AFTER_WSP_STATE () { 17 }
  sub AFTER_AT_STATE () { 18 }
  sub AFTER_AT_HYPHEN_STATE () { 19 }
  
  sub IDENT_TOKEN () { 1 }
  sub ATKEYWORD_TOKEN () { 2 }
  sub HASH_TOKEN () { 3 }
  sub FUNCTION_TOKEN () { 4 }
  sub URI_TOKEN () { 5 }
  sub URI_INVALID_TOKEN () { 6 }
  sub URI_PREFIX_TOKEN () { 7 }
  sub URI_PREFIX_INVALID_TOKEN () { 8 }
  sub STRING_TOKEN () { 9 }
  sub INVALID_TOKEN () { 10 }
  sub NUMBER_TOKEN () { 11 }
  sub DIMENSION_TOKEN () { 12 }
  sub PERCENTAGE_TOKEN () { 13 }
  sub UNICODE_RANGE_TOKEN () { 14 }
  sub DELIM_TOKEN () { 16 }
  sub PLUS_TOKEN () { 17 }
  sub GREATER_TOKEN () { 18 }
  sub COMMA_TOKEN () { 19 }
  sub TILDE_TOKEN () { 20 }
  sub DASHMATCH_TOKEN () { 21 }
  sub PREFIXMATCH_TOKEN () { 22 }
  sub SUFFIXMATCH_TOKEN () { 23 }
  sub SUBSTRINGMATCH_TOKEN () { 24 }
  sub INCLUDES_TOKEN () { 25 }
  sub SEMICOLON_TOKEN () { 26 }
  sub LBRACE_TOKEN () { 27 }
  sub RBRACE_TOKEN () { 28 }
  sub LPAREN_TOKEN () { 29 }
  sub RPAREN_TOKEN () { 30 }
  sub LBRACKET_TOKEN () { 31 }
  sub RBRACKET_TOKEN () { 32 }
  sub S_TOKEN () { 33 }
  sub CDO_TOKEN () { 34 }
  sub CDC_TOKEN () { 35 }
  sub COMMENT_TOKEN () { 36 }
  sub COMMENT_INVALID_TOKEN () { 37 }
  sub EOF_TOKEN () { 38 }
  sub MINUS_TOKEN () { 39 }
  sub STAR_TOKEN () { 40 }
  sub VBAR_TOKEN () { 41 }
  sub DOT_TOKEN () { 42 }
  sub COLON_TOKEN () { 43 }
  sub MATCH_TOKEN () { 44 }
  sub EXCLAMATION_TOKEN () { 45 }
  
  our @TokenName = qw(
    0 IDENT ATKEYWORD HASH FUNCTION URI URI_INVALID URI_PREFIX URI_PREFIX_INVALID
    STRING INVALID NUMBER DIMENSION PERCENTAGE UNICODE_RANGE
    0 DELIM PLUS GREATER COMMA TILDE DASHMATCH
    PREFIXMATCH SUFFIXMATCH SUBSTRINGMATCH INCLUDES SEMICOLON
    LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET S CDO CDC COMMENT
    COMMENT_INVALID EOF MINUS STAR VBAR DOT COLON MATCH EXCLAMATION
  );
  
  our @EXPORT_OK = qw(
    IDENT_TOKEN ATKEYWORD_TOKEN HASH_TOKEN FUNCTION_TOKEN URI_TOKEN
    URI_INVALID_TOKEN URI_PREFIX_TOKEN URI_PREFIX_INVALID_TOKEN
    STRING_TOKEN INVALID_TOKEN NUMBER_TOKEN DIMENSION_TOKEN PERCENTAGE_TOKEN
    UNICODE_RANGE_TOKEN DELIM_TOKEN PLUS_TOKEN GREATER_TOKEN COMMA_TOKEN
    TILDE_TOKEN DASHMATCH_TOKEN PREFIXMATCH_TOKEN SUFFIXMATCH_TOKEN
    SUBSTRINGMATCH_TOKEN INCLUDES_TOKEN SEMICOLON_TOKEN LBRACE_TOKEN
    RBRACE_TOKEN LPAREN_TOKEN RPAREN_TOKEN LBRACKET_TOKEN RBRACKET_TOKEN
    S_TOKEN CDO_TOKEN CDC_TOKEN COMMENT_TOKEN COMMENT_INVALID_TOKEN EOF_TOKEN
    MINUS_TOKEN STAR_TOKEN VBAR_TOKEN DOT_TOKEN COLON_TOKEN MATCH_TOKEN
    EXCLAMATION_TOKEN
  );
  
  our %EXPORT_TAGS = ('token' => [@EXPORT_OK]);
  
  sub new ($) {
    my $self = bless {token => [], get_char => sub { -1 }}, shift;
    return $self;
  } # new
  
  sub init ($) {
    my $self = shift;
    $self->{state} = BEFORE_TOKEN_STATE;
    $self->{c} = $self->{get_char}->($self);
    #$self->{t} = {type => token-type,
    #              value => value,
    #              number => number,
    #              line => ..., column => ...,
    #              hyphen => bool,
    #              not_ident => bool, # HASH_TOKEN does not contain an identifier
    #              eos => bool};
  } # init
  
  sub get_next_token ($) {
    my $self = shift;
    if (@{$self->{token}}) {
      return shift @{$self->{token}};
    }
  
    my $char;
    my $num; # |{num}|, if any.
    my $i; # |$i + 1|th character in |unicode| in |escape|.
    my $q;
        ## NOTE:
        ##   0: in |ident|.
        ##   1: in |URI| outside of |string|.
        ##   0x0022: in |string1| or |invalid1|.
        ##   0x0027: in |string2| or |invalid2|.
  
    A: {
      if ($self->{state} == BEFORE_TOKEN_STATE) {
        if ($self->{c} == 0x002D) { # -
          ## NOTE: |-| in |ident| in |IDENT|
          $self->{t} = {type => IDENT_TOKEN, value => '-', hyphen => 1,
                        line => $self->{line}, column => $self->{column}};
          $self->{state} = BEFORE_NMSTART_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0055 or $self->{c} == 0x0075) { # U or u
          $self->{t} = {type => IDENT_TOKEN, value => chr $self->{c},
                        line => $self->{line}, column => $self->{column}};
          $self->{c} = $self->{get_char}->($self);
          if ($self->{c} == 0x002B) { # +
            my ($l, $c) = ($self->{line}, $self->{column});
            $self->{c} = $self->{get_char}->($self);
            if ((0x0030 <= $self->{c} and $self->{c} <= 0x0039) or # 0..9
                (0x0041 <= $self->{c} and $self->{c} <= 0x0046) or # A..F
                (0x0061 <= $self->{c} and $self->{c} <= 0x0066) or # a..f
                $self->{c} == 0x003F) { # ?
              $self->{t}->{value} = chr $self->{c};
              $self->{t}->{type} = UNICODE_RANGE_TOKEN;
              $self->{c} = $self->{get_char}->($self);
              C: for (2..6) {
                if ((0x0030 <= $self->{c} and $self->{c} <= 0x0039) or # 0..9
                    (0x0041 <= $self->{c} and $self->{c} <= 0x0046) or # A..F
                    (0x0061 <= $self->{c} and $self->{c} <= 0x0066) or # a..f
                    $self->{c} == 0x003F) { # ?
                  $self->{t}->{value} .= chr $self->{c};
                  $self->{c} = $self->{get_char}->($self);
                } else {
                  last C;
                }
              } # C
  
              if ($self->{c} == 0x002D) { # -
                $self->{c} = $self->{get_char}->($self);
                if ((0x0030 <= $self->{c} and $self->{c} <= 0x0039) or # 0..9
                    (0x0041 <= $self->{c} and $self->{c} <= 0x0046) or # A..F
                    (0x0061 <= $self->{c} and $self->{c} <= 0x0066)) { # a..f
                  $self->{t}->{value} .= '-' . chr $self->{c};
                  $self->{c} = $self->{get_char}->($self);
                  C: for (2..6) {
                    if ((0x0030 <= $self->{c} and $self->{c} <= 0x0039) or # 0..9
                        (0x0041 <= $self->{c} and $self->{c} <= 0x0046) or # A..F
                        (0x0061 <= $self->{c} and $self->{c} <= 0x0066)) { # a..f
                      $self->{t}->{value} .= chr $self->{c};
                      $self->{c} = $self->{get_char}->($self);
                    } else {
                      last C;
                    }
                  } # C
                  
                  #
                } else {
                  my $token = $self->{t};
                  $self->{t} = {type => IDENT_TOKEN, value => '-',
                                line => $self->{line},
                                column => $self->{column}};
                  $self->{state} = BEFORE_NMSTART_STATE;
                  # reprocess
                  return $token;
                  #redo A;
                }
              }
  
              $self->{state} = BEFORE_TOKEN_STATE;
              # reprocess
              return $self->{t};
              #redo A;
            } else {
              unshift @{$self->{token}},
                  {type => PLUS_TOKEN, line => $l, column => $c};
              $self->{state} = BEFORE_TOKEN_STATE;
              # reprocess
              return $self->{t};
              #redo A;
            }
          } else {
            $self->{state} = NAME_STATE;
            # reprocess
            redo A;
          }
        } elsif ((0x0041 <= $self->{c} and $self->{c} <= 0x005A) or # A..Z
                 (0x0061 <= $self->{c} and $self->{c} <= 0x007A) or # a..z
                 $self->{c} == 0x005F or # _
                 $self->{c} > 0x007F) { # nonascii
          ## NOTE: |nmstart| in |ident| in |IDENT|
          $self->{t} = {type => IDENT_TOKEN, value => chr $self->{c},
                        line => $self->{line}, column => $self->{column}};
          $self->{state} = NAME_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x005C) { # \
          ## NOTE: |nmstart| in |ident| in |IDENT|
          $self->{t} = {type => IDENT_TOKEN, value => '',
                        line => $self->{line}, column => $self->{column}};
          $self->{state} = ESCAPE_OPEN_STATE; $q = 0;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0040) { # @
          ## NOTE: |@| in |ATKEYWORD|
          $self->{t} = {type => ATKEYWORD_TOKEN, value => '',
                        line => $self->{line}, column => $self->{column}};
          $self->{state} = AFTER_AT_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0022 or $self->{c} == 0x0027) { # " or '
          $self->{t} = {type => STRING_TOKEN, value => '',
                        line => $self->{line}, column => $self->{column}};
          $self->{state} = STRING_STATE; $q = $self->{c};
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0023) { # #
          ## NOTE: |#| in |HASH|.
          $self->{t} = {type => HASH_TOKEN, value => '',
                        line => $self->{line}, column => $self->{column}};
          $self->{state} = HASH_OPEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif (0x0030 <= $self->{c} and $self->{c} <= 0x0039) { # 0..9
          ## NOTE: |num|.
          $self->{t} = {type => NUMBER_TOKEN, value => chr $self->{c},
                        line => $self->{line}, column => $self->{column}};
          ## NOTE: 'value' is renamed as 'number' later.
          $self->{state} = NUMBER_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x002E) { # .
          ## NOTE: |num|.
          $self->{t} = {type => NUMBER_TOKEN, value => '0',
                        line => $self->{line}, column => $self->{column}};
          ## NOTE: 'value' is renamed as 'number' later.
          $self->{state} = NUMBER_FRACTION_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x002F) { # /
          my ($l, $c) = ($self->{line}, $self->{column});
          $self->{c} = $self->{get_char}->($self);
          if ($self->{c} == 0x002A) { # *
            C: {
              $self->{c} = $self->{get_char}->($self);
              if ($self->{c} == 0x002A) { # *
                D: {
                  $self->{c} = $self->{get_char}->($self);
                  if ($self->{c} == 0x002F) { # /
                    #
                  } elsif ($self->{c} == 0x002A) { # *
                    redo D;
                  } else {
                    redo C;
                  }
                } # D
              } elsif ($self->{c} == -1) {
                # stay in the state
                # reprocess
                return {type => COMMENT_INVALID_TOKEN};
                #redo A;
              } else {
                redo C;
              }
            } # C
  
            # stay in the state.
            $self->{c} = $self->{get_char}->($self);
            redo A;
          } else {
            # stay in the state.
            # reprocess
            return {type => DELIM_TOKEN, value => '/', line => $l, column => $c};
            #redo A;
          }         
        } elsif ($self->{c} == 0x003C) { # <
          my ($l, $c) = ($self->{line}, $self->{column});
          ## NOTE: |CDO|
          $self->{c} = $self->{get_char}->($self);
          if ($self->{c} == 0x0021) { # !
            $self->{c} = $self->{get_char}->($self);
            if ($self->{c} == 0x002D) { # -
              $self->{c} = $self->{get_char}->($self);
              if ($self->{c} == 0x002D) { # -
                $self->{state} = BEFORE_TOKEN_STATE;
                $self->{c} = $self->{get_char}->($self);
                return {type => CDO_TOKEN, line => $l, column => $c};
                #redo A;
              } else {
                unshift @{$self->{token}},
                    {type => EXCLAMATION_TOKEN, line => $l, column => $c + 1};
                ## NOTE: |-| in |ident| in |IDENT|
                $self->{t} = {type => IDENT_TOKEN, value => '-',
                              line => $l, column => $c + 2};
                $self->{state} = BEFORE_NMSTART_STATE;
                #reprocess
                return {type => DELIM_TOKEN, value => '<',
                        line => $l, column => $c};
                #redo A;
              }
            } else {
              unshift @{$self->{token}}, {type => EXCLAMATION_TOKEN,
                                          line => $l, column => $c + 1};
              $self->{state} = BEFORE_TOKEN_STATE;
              #reprocess
              return {type => DELIM_TOKEN, value => '<',
                      line => $l, column => $c};
              #redo A;
            }
          } else {
            $self->{state} = BEFORE_TOKEN_STATE;
            #reprocess
            return {type => DELIM_TOKEN, value => '<',
                    line => $l, column => $c};
            #redo A;
          }
        } elsif (my $t = {
                          0x0021 => EXCLAMATION_TOKEN, # !
                          0x002D => MINUS_TOKEN, # -
                          0x002E => DOT_TOKEN, # .
                          0x003A => COLON_TOKEN, # :
                          0x003B => SEMICOLON_TOKEN, # ;
                          0x003D => MATCH_TOKEN, # =
                          0x007B => LBRACE_TOKEN, # {
                          0x007D => RBRACE_TOKEN, # }
                          0x0028 => LPAREN_TOKEN, # (
                          0x0029 => RPAREN_TOKEN, # )
                          0x005B => LBRACKET_TOKEN, # [
                          0x005D => RBRACKET_TOKEN, # ]
                 }->{$self->{c}}) {
          my ($l, $c) = ($self->{line}, $self->{column});
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          return {type => $t, line => $l, column => $c};
          # redo A;
        } elsif ({
                  0x0020 => 1, # SP
                  0x0009 => 1, # \t
                  0x000D => 1, # \r
                  0x000A => 1, # \n
                  0x000C => 1, # \f
                 }->{$self->{c}}) {
          my ($l, $c) = ($self->{line}, $self->{column});
          W: {
            $self->{c} = $self->{get_char}->($self);
            if ({
                  0x0020 => 1, # SP
                  0x0009 => 1, # \t
                  0x000D => 1, # \r
                  0x000A => 1, # \n
                  0x000C => 1, # \f
                }->{$self->{c}}) {
              redo W;
            } elsif (my $v = {
                              0x002B => PLUS_TOKEN, # +
                              0x003E => GREATER_TOKEN, # >
                              0x002C => COMMA_TOKEN, # ,
                              0x007E => TILDE_TOKEN, # ~
                             }->{$self->{c}}) {
              my ($l, $c) = ($self->{line}, $self->{column});
              # stay in the state
              $self->{c} = $self->{get_char}->($self);
              return {type => $v, line => $l, column => $c};
              #redo A;
            } else {
              # stay in the state
              # reprocess
              return {type => S_TOKEN, line => $l, column => $c};
              #redo A;
            }
          } # W
        } elsif (my $v = {
                          0x007C => DASHMATCH_TOKEN, # |
                          0x005E => PREFIXMATCH_TOKEN, # ^
                          0x0024 => SUFFIXMATCH_TOKEN, # $
                          0x002A => SUBSTRINGMATCH_TOKEN, # *
                         }->{$self->{c}}) {
          my ($line, $column) = ($self->{line}, $self->{column});
          my $c = $self->{c};
          $self->{c} = $self->{get_char}->($self);
          if ($self->{c} == 0x003D) { # =
            # stay in the state
            $self->{c} = $self->{get_char}->($self);
            return {type => $v, line => $line, column => $column};
            #redo A;
          } elsif ($v = {
                         0x002A => STAR_TOKEN, # *
                         0x007C => VBAR_TOKEN, # |
                        }->{$c}) {
            # stay in the state.
            # reprocess
            return {type => $v, line => $line, column => $column};
            #redo A;
          } else {
            # stay in the state
            # reprocess
            return {type => DELIM_TOKEN, value => chr $c,
                    line => $line, column => $column};
            #redo A;
          }
        } elsif ($self->{c} == 0x002B) { # +
          my ($l, $c) = ($self->{line}, $self->{column});
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          return {type => PLUS_TOKEN, line => $l, column => $c};
          #redo A;
        } elsif ($self->{c} == 0x003E) { # >
          my ($l, $c) = ($self->{line}, $self->{column});
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          return {type => GREATER_TOKEN, line => $l, column => $c};
          #redo A;
        } elsif ($self->{c} == 0x002C) { # ,
          my ($l, $c) = ($self->{line}, $self->{column});
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          return {type => COMMA_TOKEN, line => $l, column => $c};
          #redo A;
        } elsif ($self->{c} == 0x007E) { # ~
          my ($l, $c) = ($self->{line}, $self->{column});
          $self->{c} = $self->{get_char}->($self);
          if ($self->{c} == 0x003D) { # =
            # stay in the state
            $self->{c} = $self->{get_char}->($self);
            return {type => INCLUDES_TOKEN, line => $l, column => $c};
            #redo A;
          } else {
            # stay in the state
            # reprocess
            return {type => TILDE_TOKEN, line => $l, column => $c};
            #redo A;
          }
        } elsif ($self->{c} == -1) {
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          return {type => EOF_TOKEN,
                  line => $self->{line}, column => $self->{column}};
          #redo A;
        } else {
          # stay in the state
          $self->{t} = {type => DELIM_TOKEN, value => chr $self->{c},
                        line => $self->{line}, column => $self->{column}};
          $self->{c} = $self->{get_char}->($self);
          return $self->{t};
          #redo A;
        }
      } elsif ($self->{state} == BEFORE_NMSTART_STATE) {
        ## NOTE: |nmstart| in |ident| in (|IDENT|, |DIMENSION|, or
        ## |FUNCTION|)
        if ((0x0041 <= $self->{c} and $self->{c} <= 0x005A) or # A..Z
            (0x0061 <= $self->{c} and $self->{c} <= 0x007A) or # a..z
            $self->{c} == 0x005F or # _
            $self->{c} > 0x007F) { # nonascii
          $self->{t}->{value} .= chr $self->{c};
          $self->{t}->{type} = DIMENSION_TOKEN
              if $self->{t}->{type} == NUMBER_TOKEN;
          $self->{state} = NAME_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x005C) { # \
          $self->{state} = ESCAPE_OPEN_STATE; $q = 0;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x002D) { # -
          if ($self->{t}->{type} == IDENT_TOKEN) {
            #$self->normalize_surrogate ($self->{t}->{value});
            $self->{c} = $self->{get_char}->($self);
            if ($self->{c} == 0x003E) { # >
              $self->{state} = BEFORE_TOKEN_STATE;
              $self->{c} = $self->{get_char}->($self);
              return {type => CDC_TOKEN,
                      line => $self->{t}->{line},
                      column => $self->{t}->{column}};
              #redo A;
            } else {
              ## NOTE: |-|, |-|, $self->{c}
              #$self->{t} = {type => IDENT_TOKEN, value => '-'};
              $self->{t}->{column}++;
              # stay in the state
              # reconsume
              return {type => MINUS_TOKEN,
                      line => $self->{t}->{line},
                      column => $self->{t}->{column} - 1};
              #redo A;
            }
          } elsif ($self->{t}->{type} == DIMENSION_TOKEN) {
            my ($l, $c) = ($self->{line}, $self->{column}); # second '-'
            $self->{c} = $self->{get_char}->($self);
            if ($self->{c} == 0x003E) { # >
              unshift @{$self->{token}}, {type => CDC_TOKEN};
              $self->{t}->{type} = NUMBER_TOKEN;
              $self->{t}->{value} = '';
              $self->{state} = BEFORE_TOKEN_STATE;
              $self->{c} = $self->{get_char}->($self);
              return $self->{t};
              #redo A;
            } else {
              ## NOTE: NUMBER, |-|, |-|, $self->{c}
              my $t = $self->{t};
              $t->{type} = NUMBER_TOKEN;
              $t->{value} = '';
              $self->{t} = {type => IDENT_TOKEN, value => '-', hyphen => 1,
                            line => $l, column => $c};
              unshift @{$self->{token}}, {type => MINUS_TOKEN,
                                          line => $l, column => $c - 1};
              # stay in the state
              # reconsume
              return $t;
              #redo A;
            }
          } else {
            #
          }
        } else {
          #
        }
        
        if ($self->{t}->{type} == DIMENSION_TOKEN) {
          ## NOTE: |-| after |NUMBER|.
          unshift @{$self->{token}}, {type => MINUS_TOKEN,
                                      line => $self->{line},
                                      column => $self->{column} - 1};
          ## BUG: column might be wrong if on the line boundary.
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          $self->{t}->{type} = NUMBER_TOKEN;
          $self->{t}->{value} = '';
          return $self->{t};
        } else {
          ## NOTE: |-| not followed by |nmstart|.
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          return {type => MINUS_TOKEN,
                  line => $self->{line}, column => $self->{column} - 1};
          ## BUG: column might be wrong if on the line boundary.
        }
      } elsif ($self->{state} == AFTER_AT_STATE) {
        if ((0x0041 <= $self->{c} and $self->{c} <= 0x005A) or # A..Z
            (0x0061 <= $self->{c} and $self->{c} <= 0x007A) or # a..z
            $self->{c} == 0x005F or # _
            $self->{c} > 0x007F) { # nonascii
          $self->{t}->{value} .= chr $self->{c};
          $self->{state} = NAME_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x002D) { # -
          $self->{t}->{value} .= '-';
          $self->{state} = AFTER_AT_HYPHEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x005C) { # \
          $self->{state} = ESCAPE_OPEN_STATE; $q = 0;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          return {type => DELIM_TOKEN, value => '@',
                  line => $self->{t}->{line},
                  column => $self->{t}->{column}};
        }
      } elsif ($self->{state} == AFTER_AT_HYPHEN_STATE) {
        if ((0x0041 <= $self->{c} and $self->{c} <= 0x005A) or # A..Z
            (0x0061 <= $self->{c} and $self->{c} <= 0x007A) or # a..z
            $self->{c} == 0x005F or # _
            $self->{c} > 0x007F) { # nonascii
          $self->{t}->{value} .= chr $self->{c};
          $self->{state} = NAME_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x002D) { # -
          $self->{c} = $self->{get_char}->($self);
          if ($self->{c} == 0x003E) { # >
            unshift @{$self->{token}}, {type => CDC_TOKEN};
            $self->{state} = BEFORE_TOKEN_STATE;
            $self->{c} = $self->{get_char}->($self);
            return {type => DELIM_TOKEN, value => '@'};
            #redo A;
          } else {
            unshift @{$self->{token}}, {type => MINUS_TOKEN};
            $self->{t} = {type => IDENT_TOKEN, value => '-'};
            $self->{state} = BEFORE_NMSTART_STATE;
            # reprocess
            return {type => DELIM_TOKEN, value => '@'};
            #redo A;
          }
        } elsif ($self->{c} == 0x005C) { # \
          ## TODO: @-\{nl}
          $self->{state} = ESCAPE_OPEN_STATE; $q = 0;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          unshift @{$self->{token}}, {type => MINUS_TOKEN};
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          return {type => DELIM_TOKEN, value => '@'};
        }
      } elsif ($self->{state} == AFTER_NUMBER_STATE) {
        if ($self->{c} == 0x002D) { # -
          ## NOTE: |-| in |ident|.
          $self->{t}->{hyphen} = 1;
          $self->{t}->{value} = '-';
          $self->{t}->{type} = DIMENSION_TOKEN;
          $self->{state} = BEFORE_NMSTART_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ((0x0041 <= $self->{c} and $self->{c} <= 0x005A) or # A..Z
                 (0x0061 <= $self->{c} and $self->{c} <= 0x007A) or # a..z
                 $self->{c} == 0x005F or # _
                 $self->{c} > 0x007F) { # nonascii
          ## NOTE: |nmstart| in |ident|.
          $self->{t}->{value} = chr $self->{c};
          $self->{t}->{type} = DIMENSION_TOKEN;
          $self->{state} = NAME_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x005C) { # \
          ## NOTE: |nmstart| in |ident| in |IDENT|
          $self->{t}->{value} = '';
          $self->{t}->{type} = DIMENSION_TOKEN;
          $self->{state} = ESCAPE_OPEN_STATE; $q = 0;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0025) { # %
          $self->{t}->{type} = PERCENTAGE_TOKEN;
          $self->{state} = BEFORE_TOKEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          return $self->{t};
          #redo A;
        } else {
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          return $self->{t};
          #redo A;
        }
      } elsif ($self->{state} == HASH_OPEN_STATE) {
        ## NOTE: The first |nmchar| in |name| in |HASH|.
        if ((0x0041 <= $self->{c} and $self->{c} <= 0x005A) or # A..Z
            (0x0061 <= $self->{c} and $self->{c} <= 0x007A) or # a..z
            (0x0030 <= $self->{c} and $self->{c} <= 0x0039) or # 0..9
            $self->{c} == 0x002D or # -
            $self->{c} == 0x005F or # _
            $self->{c} > 0x007F) { # nonascii
          $self->{t}->{not_ident} = 1 if
              (0x0030 <= $self->{c} and $self->{c} <= 0x0039); # 0..9
          $self->{t}->{hyphen} = 1 if $self->{c} == 0x002D; # -
          $self->{t}->{value} .= chr $self->{c};
          $self->{state} = NAME_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x005C) { # \
          $self->{state} = ESCAPE_OPEN_STATE; $q = 0;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          return {type => DELIM_TOKEN, value => '#',
                  line => $self->{t}->{line},
                  column => $self->{t}->{column}};
          #redo A;
        }
      } elsif ($self->{state} == NAME_STATE) {
        ## NOTE: |nmchar| in (|ident| or |name|).
        if ((0x0041 <= $self->{c} and $self->{c} <= 0x005A) or # A..Z
            (0x0061 <= $self->{c} and $self->{c} <= 0x007A) or # a..z
            (0x0030 <= $self->{c} and $self->{c} <= 0x0039) or # 0..9
            $self->{c} == 0x005F or # _
            $self->{c} == 0x002D or # -
            $self->{c} > 0x007F) { # nonascii
          $self->{t}->{not_ident} = 1 if
              $self->{t}->{hyphen} and
              $self->{t}->{value} eq '-' and
              ((0x0030 <= $self->{c} and $self->{c} <= 0x0039) or # 0..9
               $self->{c} == 0x002D); # -
          $self->{t}->{value} .= chr $self->{c};
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x005C) { # \
          $self->{state} = ESCAPE_OPEN_STATE; $q = 0;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0028 and # (
                 $self->{t}->{type} == IDENT_TOKEN) { # (
          my $func_name = $self->{t}->{value};
          $func_name =~ tr/A-Z/a-z/; ## TODO: Unicode or ASCII case-insensitive?
          if ($func_name eq 'url' or $func_name eq 'url-prefix') {
            if ($self->{t}->{has_escape}) {
              ## TODO: warn
            }
            $self->{t}->{type}
                = $func_name eq 'url' ? URI_TOKEN : URI_PREFIX_TOKEN;
            $self->{t}->{value} = '';
            $self->{state} = URI_BEFORE_WSP_STATE;
            $self->{c} = $self->{get_char}->($self);
            redo A;
          } else {
            $self->{t}->{type} = FUNCTION_TOKEN;
            $self->{state} = BEFORE_TOKEN_STATE;
            $self->{c} = $self->{get_char}->($self);
            return $self->{t};
            #redo A;
          }
        } else {
          $self->{t}->{not_ident} = 1
              if $self->{t}->{value} eq '-' and $self->{t}->{hyphen};
          $self->normalize_surrogate ($self->{t}->{value});
          $self->{state} = BEFORE_TOKEN_STATE;
          # reconsume
          return $self->{t};
          #redo A;
        }
      } elsif ($self->{state} == URI_BEFORE_WSP_STATE) {
        while ({
                  0x0020 => 1, # SP
                  0x0009 => 1, # \t
                  0x000D => 1, # \r
                  0x000A => 1, # \n
                  0x000C => 1, # \f
               }->{$self->{c}}) {
          $self->{c} = $self->{get_char}->($self);
        }
        if ($self->{c} == -1) {
          $self->{t}->{type} = {
              URI_TOKEN, URI_INVALID_TOKEN,
              URI_INVALID_TOKEN, URI_INVALID_TOKEN,
              URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
              URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
          }->{$self->{t}->{type}};        
          $self->{state} = BEFORE_TOKEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          return $self->{t};
          #redo A;
        } elsif ($self->{c} < 0x0020 or $self->{c} == 0x0028) { # C0 or (
          ## TODO: Should we consider matches of "(" and ")"?
          $self->{t}->{type} = {
              URI_TOKEN, URI_INVALID_TOKEN,
              URI_INVALID_TOKEN, URI_INVALID_TOKEN,
              URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
              URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
          }->{$self->{t}->{type}};
          $self->{state} = URI_UNQUOTED_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0022 or $self->{c} == 0x0027) { # " or '
          $self->{state} = STRING_STATE; $q = $self->{c};
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0029) { # )
          $self->{state} = BEFORE_TOKEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          return $self->{t};
          #redo A;
        } elsif ($self->{c} == 0x005C) { # \
          $self->{state} = ESCAPE_OPEN_STATE; $q = 1;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{t}->{value} .= chr $self->{c};
          $self->{state} = URI_UNQUOTED_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        }
      } elsif ($self->{state} == URI_UNQUOTED_STATE) {
        if ({
             0x0020 => 1, # SP
             0x0009 => 1, # \t
             0x000D => 1, # \r
             0x000A => 1, # \n
             0x000C => 1, # \f
            }->{$self->{c}}) {
          $self->{state} = URI_AFTER_WSP_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == -1) {
          $self->{t}->{type} = {
              URI_TOKEN, URI_INVALID_TOKEN,
              URI_INVALID_TOKEN, URI_INVALID_TOKEN,
              URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
              URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
          }->{$self->{t}->{type}};        
          $self->{state} = BEFORE_TOKEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          return $self->{t};
          #redo A;
        } elsif ($self->{c} < 0x0020 or {
            0x0022 => 1, # "
            0x0027 => 1, # '
            0x0028 => 1, # (
        }->{$self->{c}}) { # C0 or (
          ## TODO: Should we consider matches of "(" and ")", '"', or "'"?
          $self->{t}->{type} = {
              URI_TOKEN, URI_INVALID_TOKEN,
              URI_INVALID_TOKEN, URI_INVALID_TOKEN,
              URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
              URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
          }->{$self->{t}->{type}};
          # stay in the state.
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0029) { # )
          $self->{state} = BEFORE_TOKEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          return $self->{t};
          #redo A;
        } elsif ($self->{c} == 0x005C) { # \
          $self->{state} = ESCAPE_OPEN_STATE; $q = 1;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{t}->{value} .= chr $self->{c};
          # stay in the state.
          $self->{c} = $self->{get_char}->($self);
          redo A;
        }
      } elsif ($self->{state} == URI_AFTER_WSP_STATE) {
        if ({
             0x0020 => 1, # SP
             0x0009 => 1, # \t
             0x000D => 1, # \r
             0x000A => 1, # \n
             0x000C => 1, # \f
            }->{$self->{c}}) {
          # stay in the state.
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == -1) {
          $self->{t}->{type} = {
              URI_TOKEN, URI_INVALID_TOKEN,
              URI_INVALID_TOKEN, URI_INVALID_TOKEN,
              URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
              URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
          }->{$self->{t}->{type}};        
          $self->{state} = BEFORE_TOKEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          return $self->{t};
          #redo A;
        } elsif ($self->{c} == 0x0029) { # )
          $self->{state} = BEFORE_TOKEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          return $self->{t};
          #redo A;
        } elsif ($self->{c} == 0x005C) { # \
          $self->{state} = ESCAPE_OPEN_STATE; $q = 1;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          ## TODO: Should we consider matches of "(" and ")", '"', or "'"?
          $self->{t}->{type} = {
              URI_TOKEN, URI_INVALID_TOKEN,
              URI_INVALID_TOKEN, URI_INVALID_TOKEN,
              URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
              URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
          }->{$self->{t}->{type}};
          # stay in the state.
          $self->{c} = $self->{get_char}->($self);
          redo A;
        }
      } elsif ($self->{state} == ESCAPE_OPEN_STATE) {
        $self->{t}->{has_escape} = 1;
        if (0x0030 <= $self->{c} and $self->{c} <= 0x0039) { # 0..9
          ## NOTE: second character of |unicode| in |escape|.
          $char = $self->{c} - 0x0030;
          $self->{state} = ESCAPE_STATE; $i = 2;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif (0x0041 <= $self->{c} and $self->{c} <= 0x0046) { # A..F
          ## NOTE: second character of |unicode| in |escape|.
          $char = $self->{c} - 0x0041 + 0xA;
          $self->{state} = ESCAPE_STATE; $i = 2;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif (0x0061 <= $self->{c} and $self->{c} <= 0x0066) { # a..f
          ## NOTE: second character of |unicode| in |escape|.
          $char = $self->{c} - 0x0061 + 0xA;
          $self->{state} = ESCAPE_STATE; $i = 2;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x000A or # \n
                 $self->{c} == 0x000C) { # \f
          if ($q == 0) {
            #
          } elsif ($q == 1) {
            ## NOTE: In |escape| in |URI|.
            $self->{t}->{type} = {
                URI_TOKEN, URI_INVALID_TOKEN,
                URI_INVALID_TOKEN, URI_INVALID_TOKEN,
                URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
                URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
            }->{$self->{t}->{type}};
            $self->{t}->{value} .= chr $self->{c};
            $self->{state} = URI_UNQUOTED_STATE;
            $self->{c} = $self->{get_char}->($self);
            redo A;
          } else {
            ## Note: In |nl| in ... in |string| or |ident|.
            $self->{state} = STRING_STATE;
            $self->{c} = $self->{get_char}->($self);
            redo A;
          }
        } elsif ($self->{c} == 0x000D) { # \r
          if ($q == 0) {
            #
          } elsif ($q == 1) {
            ## NOTE: In |escape| in |URI|.
            $self->{t}->{type} = {
                URI_TOKEN, URI_INVALID_TOKEN,
                URI_INVALID_TOKEN, URI_INVALID_TOKEN,
                URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
                URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
            }->{$self->{t}->{type}};
            $self->{state} = ESCAPE_BEFORE_LF_STATE;
            $self->{c} = $self->{get_char}->($self);
            redo A;
          } else {
            ## Note: In |nl| in ... in |string| or |ident|.
            $self->{state} = ESCAPE_BEFORE_LF_STATE;
            $self->{c} = $self->{get_char}->($self);
            redo A;
          }
        } elsif ($self->{c} == -1) {
          #
        } else {
          ## NOTE: second character of |escape|.
          $self->{t}->{value} .= chr $self->{c};
          $self->{state} = $q == 0 ? NAME_STATE :
              $q == 1 ? URI_UNQUOTED_STATE : STRING_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        }
  
        if ($q == 0) {
          if ($self->{t}->{type} == DIMENSION_TOKEN) {
            if ($self->{t}->{hyphen} and $self->{t}->{value} eq '-') {
              $self->{state} = BEFORE_TOKEN_STATE;
              # reprocess
              unshift @{$self->{token}}, {type => DELIM_TOKEN, value => '\\',
                                          line => $self->{line_prev},
                                          column => $self->{column_prev} - 1};
              unshift @{$self->{token}}, {type => MINUS_TOKEN,
                                          line => $self->{line_prev},
                                          column => $self->{column_prev}};
              $self->{t}->{type} = NUMBER_TOKEN;
              $self->{t}->{value} = '';
              return $self->{t};
              #redo A;
            } elsif (length $self->{t}->{value}) {
              $self->{state} = BEFORE_TOKEN_STATE;
              # reprocess
              unshift @{$self->{token}}, {type => DELIM_TOKEN, value => '\\',
                                          line => $self->{line_prev},
                                          column => $self->{column_prev}};
              return $self->{t};
              #redo A;
            } else {
              $self->{state} = BEFORE_TOKEN_STATE;
              # reprocess
              unshift @{$self->{token}}, {type => DELIM_TOKEN, value => '\\',
                                          line => $self->{line_prev},
                                          column => $self->{column_prev}};
              $self->{t}->{type} = NUMBER_TOKEN;
              $self->{t}->{value} = '';
              return $self->{t};
              #redo A;
            }
          } else {
            ## \ -> [DELIM \]
            ## #\ -> [DELIM #][DELIM \]
            ## -\ -> [MINUS][DELIM \]
            ## #-\ -> [HASH -][DELIM \]
            ## a\ -> [IDENT a][DELIM \]
            ## #a\ -> [HASH a][DELIM \]
  
            unshift @{$self->{token}},
                {type => DELIM_TOKEN, value => '\\',
                 line => $self->{line_prev}, column => $self->{column_prev}};
  
            if ($self->{t}->{hyphen} and $self->{t}->{value} eq '-') {
              unshift @{$self->{token}},
                  {type => MINUS_TOKEN,
                   line => $self->{line_prev},
                   column => $self->{column_prev} - 1};
              $self->{t}->{value} = '';
            }
  
            if (length $self->{t}->{value}) {
              $self->normalize_surrogate ($self->{t}->{value});
              $self->{state} = BEFORE_TOKEN_STATE;
              # reprocess
              return $self->{t};
              #redo A;
            }
  
            if ($self->{t}->{type} == HASH_TOKEN) {
              $self->{state} = BEFORE_TOKEN_STATE;
              # reprocess
              return {type => DELIM_TOKEN, value => '#',
                      line => $self->{t}->{line},
                      column => $self->{t}->{column}};
              #redo A;
            }
  
            $self->{state} = BEFORE_TOKEN_STATE;
            # reprocess
            return shift @{$self->{token}};
            #redo A;
          }
        } elsif ($q == 1) {
          $self->{state} = URI_UNQUOTED_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          unshift @{$self->{token}}, {type => DELIM_TOKEN, value => '\\',
                                      line => $self->{line_prev},
                                      column => $self->{column_prev}};
          $self->{t}->{type} = {
            STRING_TOKEN, INVALID_TOKEN,
            URI_TOKEN, URI_INVALID_TOKEN,
            URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
          }->{$self->{t}->{type}} || $self->{t}->{type};
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          return $self->{t};
          #redo A;
        }
      } elsif ($self->{state} == ESCAPE_STATE) {
        ## NOTE: third..seventh character of |unicode| in |escape|.
        if (0x0030 <= $self->{c} and $self->{c} <= 0x0039) { # 0..9
          $char = $char * 0x10 + $self->{c} - 0x0030;
          $self->{state} = ++$i == 7 ? ESCAPE_BEFORE_NL_STATE : ESCAPE_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif (0x0041 <= $self->{c} and $self->{c} <= 0x0046) { # A..F
          $char = $char * 0x10 + $self->{c} - 0x0041 + 0xA;
          $self->{state} = ++$i == 7 ? ESCAPE_BEFORE_NL_STATE : ESCAPE_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif (0x0061 <= $self->{c} and $self->{c} <= 0x0066) { # a..f
          $char = $char * 0x10 + $self->{c} - 0x0061 + 0xA;
          $self->{state} = ++$i == 7 ? ESCAPE_BEFORE_NL_STATE : ESCAPE_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x0020 or # SP
                 $self->{c} == 0x000A or # \n
                 $self->{c} == 0x0009 or # \t
                 $self->{c} == 0x000C) { # \f
          $self->{t}->{value} .= $self->_escaped_char ($char);
          $self->{state} = $q == 0 ? NAME_STATE :
              $q == 1 ? URI_UNQUOTED_STATE : STRING_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x000D) { # \r
          $self->{t}->{value} .= $self->_escaped_char ($char);
          $self->{state} = ESCAPE_BEFORE_LF_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{t}->{value} .= $self->_escaped_char ($char);
          $self->{state} = $q == 0 ? NAME_STATE :
              $q == 1 ? URI_UNQUOTED_STATE : STRING_STATE;
          # reconsume
          redo A;
        }
      } elsif ($self->{state} == ESCAPE_BEFORE_NL_STATE) {
        ## NOTE: eightth character of |unicode| in |escape|.
        if ($self->{c} == 0x0020 or # SP
            $self->{c} == 0x000A or # \n
            $self->{c} == 0x0009 or # \t
            $self->{c} == 0x000C) { # \f
          $self->{t}->{value} .= $self->_escaped_char ($char);
          $self->{state} = $q == 0 ? NAME_STATE :
              $q == 1 ? URI_UNQUOTED_STATE : STRING_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x000D) { # \r
          $self->{t}->{value} .= $self->_escaped_char ($char);
          $self->{state} = ESCAPE_BEFORE_LF_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{t}->{value} .= $self->_escaped_char ($char);
          $self->{state} = $q == 0 ? NAME_STATE :
              $q == 1 ? URI_UNQUOTED_STATE : STRING_STATE;
          # reconsume
          redo A;
        }
      } elsif ($self->{state} == ESCAPE_BEFORE_LF_STATE) {
        ## NOTE: |\n| in |\r\n| in |nl| in |escape|.
        if ($self->{c} == 0x000A) { # \n
          $self->{state} = $q == 0 ? NAME_STATE :
              $q == 1 ? URI_UNQUOTED_STATE : STRING_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{state} = $q == 0 ? NAME_STATE :
              $q == 1 ? URI_UNQUOTED_STATE : STRING_STATE;
          # reprocess
          redo A;
        }
      } elsif ($self->{state} == STRING_STATE) {
        ## NOTE: A character in |string$Q| in |string| in |STRING|, or
        ## a character in |invalid$Q| in |invalid| in |INVALID|,
        ## where |$Q = $q == 0x0022 ? 1 : 2|.
        ## Or, in |URI|.
        if ($self->{c} == 0x005C) { # \
          $self->{state} = ESCAPE_OPEN_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == $q) { # " | '
          if ($self->{t}->{type} == STRING_TOKEN) {
            $self->normalize_surrogate ($self->{t}->{value});
            $self->{state} = BEFORE_TOKEN_STATE;
            $self->{c} = $self->{get_char}->($self);
            return $self->{t};
            #redo A;
          } else {
            $self->{state} = URI_AFTER_WSP_STATE;
            $self->{c} = $self->{get_char}->($self);
            redo A;
          }
        } elsif ($self->{c} == 0x000A or # \n
                 $self->{c} == 0x000D or # \r
                 $self->{c} == 0x000C or # \f
                 $self->{c} == -1) {
          $self->{t}->{type} = {
            STRING_TOKEN, INVALID_TOKEN,
            INVALID_TOKEN, INVALID_TOKEN,
            URI_TOKEN, URI_INVALID_TOKEN,
            URI_INVALID_TOKEN, URI_INVALID_TOKEN,
            URI_PREFIX_TOKEN, URI_PREFIX_INVALID_TOKEN,
            URI_PREFIX_INVALID_TOKEN, URI_PREFIX_INVALID_TOKEN,
          }->{$self->{t}->{type}};
          $self->{t}->{eos} = 1 if $self->{c} == -1;
          $self->{state} = BEFORE_TOKEN_STATE;
          # reconsume
          return $self->{t};
          #redo A;
        } else {
          $self->{t}->{value} .= chr $self->{c};
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          redo A;
        }
      } elsif ($self->{state} == NUMBER_STATE) {
        ## NOTE: 2nd, 3rd, or ... character in |num| before |.|.
        if (0x0030 <= $self->{c} and $self->{c} <= 0x0039) {
          $self->{t}->{value} .= chr $self->{c};
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } elsif ($self->{c} == 0x002E) { # .
          $self->{state} = NUMBER_DOT_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{t}->{number} = $self->{t}->{value};
          $self->{t}->{value} = '';
          $self->{state} = AFTER_NUMBER_STATE;
          # reprocess
          redo A;
        }
      } elsif ($self->{state} == NUMBER_DOT_STATE) {
        ## NOTE: The character immediately following |.| in |num|.
        if (0x0030 <= $self->{c} and $self->{c} <= 0x0039) {
          $self->{t}->{value} .= '.' . chr $self->{c};
          $self->{state} = NUMBER_DOT_NUMBER_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          unshift @{$self->{token}}, {type => DOT_TOKEN};
          $self->{t}->{number} = $self->{t}->{value};
          $self->{t}->{value} = '';
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          return $self->{t};
          #redo A;
        }
      } elsif ($self->{state} == NUMBER_FRACTION_STATE) {
        ## NOTE: The character immediately following |.| at the beginning of |num|.
        if (0x0030 <= $self->{c} and $self->{c} <= 0x0039) {
          $self->{t}->{value} .= '.' . chr $self->{c};
          $self->{state} = NUMBER_DOT_NUMBER_STATE;
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{state} = BEFORE_TOKEN_STATE;
          # reprocess
          return {type => DOT_TOKEN,
                  line => $self->{line}, column => $self->{column} - 1};
          ## BUG: line and column might be wrong if they are on the
          ## line boundary.
          #redo A;
        }
      } elsif ($self->{state} == NUMBER_DOT_NUMBER_STATE) {
        ## NOTE: |[0-9]| in |num| after |.|.
        if (0x0030 <= $self->{c} and $self->{c} <= 0x0039) {
          $self->{t}->{value} .= chr $self->{c};
          # stay in the state
          $self->{c} = $self->{get_char}->($self);
          redo A;
        } else {
          $self->{t}->{number} = $self->{t}->{value};
          $self->{t}->{value} = '';
          $self->{state} = AFTER_NUMBER_STATE;
          # reprocess
          redo A;
        }
      } else {
        die "$0: Unknown state |$self->{state}|";
      }
    } # A
  } # get_next_token
  
  sub serialize_token ($$) {
    shift;
    my $t = shift;
  
    ## NOTE: This function is not intended for roundtrip-able serialization.
  
    if ($t->{type} == IDENT_TOKEN) {
      return $t->{value};
    } elsif ($t->{type} == ATKEYWORD_TOKEN) {
      return '@' . $t->{value};
    } elsif ($t->{type} == HASH_TOKEN) {
      return '#' . $t->{value};
    } elsif ($t->{type} == FUNCTION_TOKEN) {
      return $t->{value} . '(';
    } elsif ($t->{type} == URI_TOKEN) {
      return 'url(' . $t->{value} . ')';
    } elsif ($t->{type} == URI_INVALID_TOKEN) {
      return 'url(' . $t->{value};
    } elsif ($t->{type} == URI_PREFIX_TOKEN) {
      return 'url-prefix(' . $t->{value} . ')';
    } elsif ($t->{type} == URI_PREFIX_INVALID_TOKEN) {
      return 'url-prefix(' . $t->{value};
    } elsif ($t->{type} == STRING_TOKEN) {
      return '"' . $t->{value} . '"';
    } elsif ($t->{type} == INVALID_TOKEN) {
      return '"' . $t->{value};
    } elsif ($t->{type} == NUMBER_TOKEN) {
      return $t->{number};
    } elsif ($t->{type} == DIMENSION_TOKEN) {
      return $t->{number} . $t->{value};
    } elsif ($t->{type} == PERCENTAGE_TOKEN) {
      return $t->{number} . '%';
    } elsif ($t->{type} == UNICODE_RANGE_TOKEN) {
      return 'U+' . $t->{value};
    } elsif ($t->{type} == DELIM_TOKEN) {
      return $t->{value};
    } elsif ($t->{type} == PLUS_TOKEN) {
      return '+';
    } elsif ($t->{type} == GREATER_TOKEN) {
      return '>';
    } elsif ($t->{type} == COMMA_TOKEN) {
      return ',';
    } elsif ($t->{type} == TILDE_TOKEN) {
      return '~';
    } elsif ($t->{type} == DASHMATCH_TOKEN) {
      return '|=';
    } elsif ($t->{type} == PREFIXMATCH_TOKEN) {
      return '^=';
    } elsif ($t->{type} == SUFFIXMATCH_TOKEN) {
      return '$=';
    } elsif ($t->{type} == SUBSTRINGMATCH_TOKEN) {
      return '*=';
    } elsif ($t->{type} == INCLUDES_TOKEN) {
      return '~=';
    } elsif ($t->{type} == SEMICOLON_TOKEN) {
      return ';';
    } elsif ($t->{type} == LBRACE_TOKEN) {
      return '{';
    } elsif ($t->{type} == RBRACE_TOKEN) {
      return '}';
    } elsif ($t->{type} == LPAREN_TOKEN) {
      return '(';
    } elsif ($t->{type} == RPAREN_TOKEN) {
      return ')';
    } elsif ($t->{type} == LBRACKET_TOKEN) {
      return '[';
    } elsif ($t->{type} == RBRACKET_TOKEN) {
      return ']';
    } elsif ($t->{type} == S_TOKEN) {
      return ' ';
    } elsif ($t->{type} == CDO_TOKEN) {
      return '<!--';
    } elsif ($t->{type} == CDC_TOKEN) {
      return '-->';
    } elsif ($t->{type} == COMMENT_TOKEN) {
      return '/**/';
    } elsif ($t->{type} == COMMENT_INVALID_TOKEN) {
      return '/*';
    } elsif ($t->{type} == EOF_TOKEN) {
      return '{EOF}';
    } elsif ($t->{type} == MINUS_TOKEN) {
      return '-';
    } elsif ($t->{type} == STAR_TOKEN) {
      return '*';
    } elsif ($t->{type} == VBAR_TOKEN) {
      return '|';
    } elsif ($t->{type} == COLON_TOKEN) {
      return ':';
    } elsif ($t->{type} == MATCH_TOKEN) {
      return '=';
    } elsif ($t->{type} == EXCLAMATION_TOKEN) {
      return '!';
    } else {
      return '{'.$t->{type}.'}';
    }
  } # serialize_token
  
  sub _escaped_char {
    if ($_[1] == 0x0000) {
      $_[0]->{onerror}->(type => 'css:escape:null',
                         level => $_[0]->{level}->{must},
                         uri => \$_[0]->{href},
                         line => $_[0]->{line_prev},
                         column => $_[0]->{column_prev});
      return chr $_[1];
    } elsif ($_[1] > 0x10FFFF) {
      $_[0]->{onerror}->(type => 'css:escape:not unicode',
                         level => $_[0]->{level}->{should},
                         uri => \$_[0]->{href},
                         line => $_[0]->{line_prev},
                         column => $_[0]->{column_prev});
      return "\x{FFFD}";
    } else {
      return chr $_[1];
    }
  } # _escaped_char
  
  use Encode;
  sub normalize_surrogate {
    ## XXX bad impl...
    $_[1] =~ s{((?:[\x{D800}-\x{DBFF}][\x{DC00}-\x{DF00}])+)}{
      decode 'utf-16be', join '', map { pack 'CC', int ((ord $_) / 0x100), ((ord $_) % 0x100) } split //, $1;
    }ge if defined $_[1];
  } # _normalize_surrogate
  
  =head1 LICENSE
  
  Copyright 2007-2011 Wakaba <w@suika.fam.cx>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
WHATPM_CSS_TOKENIZER

$fatpacked{"Whatpm/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_HTML';
  package Whatpm::HTML; # -*- Perl -*-
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '3.0';
  use Encode;
  use Whatpm::HTML::Defs;
  use Whatpm::HTML::Parser;
  push our @ISA, qw(Whatpm::HTML::Parser);
  
  ## DEPRECATED - Use Whatpm::HTML::Parser.
  
  ## DEPRECATED
  sub parse_byte_stream ($$$$;$$) {
    #my ($self, $charset_name, $stream, $doc, $onerror, $get_wrapper) = @_;
    my $self = ref $_[0] ? $_[0] : $_[0]->new;
    my $doc = $self->{document} = $_[3];
  
    my $handle = $_[2];
    my $embedded_encoding_name;
    $self->{chars} = [];
    $self->{chars_pos} = 0;
    my $bytes = '';
    my $orig_bytes = '';
    {
      my $i = 0;
      while ($handle->read ($bytes, 1, length $bytes)) {
        $orig_bytes .= substr ($bytes, -1);
        last if $i++ == 1024;
      }
    }
    $self->{chars_pull_next} = sub {
      $self->{chars} = [];
      $self->{chars_pos} = 0;
      my $i = 0;
      while ($handle->read ($bytes, 1, length $bytes)) {
        $orig_bytes .= substr ($bytes, -1) unless $embedded_encoding_name;
        last if $i++ == 1024;
      }
      my @added = split //,
          decode $self->{input_encoding}, $bytes, Encode::FB_QUIET;
      if (6 < length $bytes or (length $bytes and $i <= 1024)) { # shit!
        push @added, "\x{FFFD}";
        substr ($bytes, 0, 1) = '';
      }
      push @{$self->{chars}}, @added;
      return @added > 0;
    };
    delete $self->{chars_was_cr};
  
    PARSER: {
      @{$self->{document}->child_nodes} = ();
  
      $self->_encoding_sniffing
          (transport_encoding_name => $_[1],
           embedded_encoding_name => $embedded_encoding_name,
           read_head => sub {
             return \$bytes;
           });
      $self->{document}->input_encoding ($self->{input_encoding});
  
      $self->{line_prev} = $self->{line} = 1;
      $self->{column_prev} = -1;
      $self->{column} = 0;
      
      $self->{restart_parser} = sub {
        $embedded_encoding_name = $_[0];
        $bytes = $orig_bytes;
        $self->{chars} = [];
        $self->{chars_pos} = 0;
        die bless {}, 'Whatpm::HTML::InputStream::RestartParser';
      };
  
      my $onerror = $_[4] || $self->onerror;
      $self->{parse_error} = sub {
        $onerror->(line => $self->{line}, column => $self->{column}, @_);
      };
  
      $self->_initialize_tokenizer;
      $self->_initialize_tree_constructor;
      $self->{t} = $self->_get_next_token;
      {
        my $error;
        {
          local $@;
          eval { $self->_construct_tree; 1 } or $error = $@;
        }
        if ($error) {
          if (ref $error eq 'Whatpm::HTML::InputStream::RestartParser') {
            redo PARSER;
          }
          die $error;
        }
        redo if $self->{nc} != EOF_CHAR;
      }
      $self->_terminate_tree_constructor;
      $self->_clear_refs;
    } # PARSER
  
    return $doc;
  } # parse_byte_stream
  
  ## DEPRECATED - for backward compatibility
  sub parse_string {
    return shift->parse_char_string (@_);
  } # parse_string
  
  ## DEPRECATED
  sub parse_char_stream ($$$;$$) {
    #my ($self, $handle, $document, $onerror, $get_wrapper) = @_;
    my $self = ref $_[0] ? $_[0] : $_[0]->new;
    my $doc = $self->{document} = $_[2];
    @{$self->{document}->child_nodes} = ();
  
    ## Confidence: irrelevant.
    $self->{confident} = 1 unless exists $self->{confident};
  
    $self->{line_prev} = $self->{line} = 1;
    $self->{column_prev} = -1;
    $self->{column} = 0;
  
    my $handle = $_[1];
    $self->{chars} = [];
    $self->{chars_pos} = 0;
    $self->{chars_pull_next} = sub {
      $self->{chars} = [];
      $self->{chars_pos} = 0;
      my $i = 0;
      my $char = '';
      while ($handle->read ($char, 1, 0)) {
        push @{$self->{chars}}, $char;
        last if $i++ == 1024;
      }
      return $i > 0;
    };
    delete $self->{chars_was_cr};
  
    my $onerror = $_[3] || $self->onerror;
    $self->{parse_error} = sub {
      $onerror->(line => $self->{line}, column => $self->{column}, @_);
    };
  
    $self->_initialize_tokenizer;
    $self->_initialize_tree_constructor;
    $self->{t} = $self->_get_next_token;
    {
      $self->_construct_tree;
      redo if $self->{nc} != EOF_CHAR;
    }
    $self->_terminate_tree_constructor;
    $self->_clear_refs;
  
    return $doc;
  } # parse_char_stream
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WHATPM_HTML

$fatpacked{"Whatpm/HTML/Defs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_HTML_DEFS';
  package Whatpm::HTML::Defs;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Exporter::Lite;
  
  our @EXPORT;
  
  ## ------ Special character-like constants ------
  
  push @EXPORT, qw(EOF_CHAR NEVER_CHAR ABORT_CHAR);
  
  ## The "EOF" pseudo-character in the HTML parsing algorithm.
  sub EOF_CHAR () { -1 }
  
  ## A pseudo-character code that can never appear in the input stream.
  sub NEVER_CHAR () { -2 }
  
  ## Pause tokenization (and parsing) because of the end of the
  ## currently available characters (that could be different from EOF).
  sub ABORT_CHAR () { -3 }
  
  ## ------ HTML/XML Tokens ------
  
  push @EXPORT, qw(
    DOCTYPE_TOKEN COMMENT_TOKEN START_TAG_TOKEN END_TAG_TOKEN
    END_OF_FILE_TOKEN CHARACTER_TOKEN PI_TOKEN ABORT_TOKEN
    END_OF_DOCTYPE_TOKEN ATTLIST_TOKEN ELEMENT_TOKEN 
    GENERAL_ENTITY_TOKEN PARAMETER_ENTITY_TOKEN NOTATION_TOKEN
  );
  
  sub DOCTYPE_TOKEN () { 1 } ## XML5: No DOCTYPE token.
  sub COMMENT_TOKEN () { 2 }
  sub START_TAG_TOKEN () { 3 }
  sub END_TAG_TOKEN () { 4 }
  sub END_OF_FILE_TOKEN () { 5 }
  sub CHARACTER_TOKEN () { 6 }
  sub PI_TOKEN () { 7 } ## NOTE: XML only.
  sub ABORT_TOKEN () { 8 } ## NOTE: For internal processing.
  sub END_OF_DOCTYPE_TOKEN () { 9 } ## NOTE: XML only.
  sub ATTLIST_TOKEN () { 10 } ## NOTE: XML only.
  sub ELEMENT_TOKEN () { 11 } ## NOTE: XML only.
  sub GENERAL_ENTITY_TOKEN () { 12 } ## NOTE: XML only.
  sub PARAMETER_ENTITY_TOKEN () { 13 } ## NOTE: XML only.
  sub NOTATION_TOKEN () { 14 } ## NOTE: XML only.
  
  ## ------ Tokenizer states ------
  
  sub DATA_STATE () { 0 }
  sub RCDATA_STATE () { 107 }
  sub RAWTEXT_STATE () { 108 }
  sub SCRIPT_DATA_STATE () { 109 }
  sub PLAINTEXT_STATE () { 110 }
  sub TAG_OPEN_STATE () { 2 }
  sub RCDATA_LT_STATE () { 111 }
  sub RAWTEXT_LT_STATE () { 112 }
  sub SCRIPT_DATA_LT_STATE () { 113 }
  sub CLOSE_TAG_OPEN_STATE () { 3 }
  sub RCDATA_END_TAG_OPEN_STATE () { 114 }
  sub RAWTEXT_END_TAG_OPEN_STATE () { 115 }
  sub SCRIPT_DATA_END_TAG_OPEN_STATE () { 116 }
  sub SCRIPT_DATA_ESCAPE_START_STATE () { 1 }
  sub SCRIPT_DATA_ESCAPE_START_DASH_STATE () { 12 }
  sub SCRIPT_DATA_ESCAPED_STATE () { 117 }
  sub SCRIPT_DATA_ESCAPED_DASH_STATE () { 118 }
  sub SCRIPT_DATA_ESCAPED_DASH_DASH_STATE () { 119 }
  sub SCRIPT_DATA_ESCAPED_LT_STATE () { 120 }
  sub SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE () { 121 }
  sub SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE () { 122 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_STATE () { 123 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE () { 124 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE () { 125 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_LT_STATE () { 126 }
  sub SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE () { 127 }
  sub TAG_NAME_STATE () { 4 }
  sub BEFORE_ATTRIBUTE_NAME_STATE () { 5 }
  sub ATTRIBUTE_NAME_STATE () { 6 }
  sub AFTER_ATTRIBUTE_NAME_STATE () { 7 }
  sub BEFORE_ATTRIBUTE_VALUE_STATE () { 8 }
  sub ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE () { 9 }
  sub ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE () { 10 }
  sub ATTRIBUTE_VALUE_UNQUOTED_STATE () { 11 }
  sub MARKUP_DECLARATION_OPEN_STATE () { 13 }
  sub COMMENT_START_STATE () { 14 }
  sub COMMENT_START_DASH_STATE () { 15 }
  sub COMMENT_STATE () { 16 }
  sub COMMENT_END_STATE () { 17 }
  sub COMMENT_END_BANG_STATE () { 102 }
  #sub COMMENT_END_SPACE_STATE () { 103 } ## REMOVED
  sub COMMENT_END_DASH_STATE () { 18 }
  sub BOGUS_COMMENT_STATE () { 19 }
  sub DOCTYPE_STATE () { 20 }
  sub BEFORE_DOCTYPE_NAME_STATE () { 21 }
  sub DOCTYPE_NAME_STATE () { 22 }
  sub AFTER_DOCTYPE_NAME_STATE () { 23 }
  sub AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE () { 104 }
  sub BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE () { 24 }
  sub DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE () { 25 }
  sub DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE () { 26 }
  sub AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE () { 27 }
  sub BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE () { 28 }
  sub DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE () { 29 }
  sub DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE () { 30 }
  sub BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE () { 105 }
  sub AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE () { 106 }
  sub AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE () { 31 }
  sub BOGUS_DOCTYPE_STATE () { 32 }
  sub AFTER_ATTRIBUTE_VALUE_QUOTED_STATE () { 33 }
  sub SELF_CLOSING_START_TAG_STATE () { 34 }
  sub CDATA_SECTION_STATE () { 35 }
  sub MD_HYPHEN_STATE () { 36 } # "markup declaration open state" in the spec
  sub MD_DOCTYPE_STATE () { 37 } # "markup declaration open state" in the spec
  sub MD_CDATA_STATE () { 38 } # "markup declaration open state" in the spec
  #sub CDATA_RCDATA_CLOSE_TAG_STATE () { 39 } # "close tag open state" in the spec
  sub CDATA_SECTION_MSE1_STATE () { 40 } # "CDATA section state" in the spec
  sub CDATA_SECTION_MSE2_STATE () { 41 } # "CDATA section state" in the spec
  sub PUBLIC_STATE () { 42 } # "after DOCTYPE name state" in the spec
  sub SYSTEM_STATE () { 43 } # "after DOCTYPE name state" in the spec
  ##
  ## NOTE: "Character reference in data state", "Character reference in
  ## RCDATA state", "Character reference in attribute value state", and
  ## the "consume a character referece" algoritm are implemented as the
  ## following six tokenizer states:
  sub ENTITY_STATE () { 44 }
  sub ENTITY_HASH_STATE () { 45 }
  sub NCR_NUM_STATE () { 46 }
  sub HEXREF_X_STATE () { 47 }
  sub HEXREF_HEX_STATE () { 48 }
  sub ENTITY_NAME_STATE () { 49 }
  ##
  ## XML-only states
  sub DATA_MSE1_STATE () { 50 }
  sub DATA_MSE2_STATE () { 128 } # last
  sub PI_STATE () { 51 }
  sub PI_TARGET_STATE () { 52 }
  sub PI_TARGET_AFTER_STATE () { 53 }
  sub PI_DATA_STATE () { 54 }
  sub PI_AFTER_STATE () { 55 }
  sub PI_DATA_AFTER_STATE () { 56 }
  sub DOCTYPE_INTERNAL_SUBSET_STATE () { 57 }
  sub DOCTYPE_INTERNAL_SUBSET_AFTER_STATE () { 58 }
  sub BOGUS_DOCTYPE_INTERNAL_SUBSET_AFTER_STATE () { 59 }
  sub DOCTYPE_TAG_STATE () { 60 }
  sub DOCTYPE_MARKUP_DECLARATION_OPEN_STATE () { 61 }
  sub MD_ATTLIST_STATE () { 62 }
  sub MD_E_STATE () { 63 }
  sub MD_ELEMENT_STATE () { 64 }
  sub MD_ENTITY_STATE () { 65 }
  sub MD_NOTATION_STATE () { 66 }
  sub DOCTYPE_MD_STATE () { 67 }
  sub BEFORE_MD_NAME_STATE () { 68 }
  sub MD_NAME_STATE () { 69 }
  sub DOCTYPE_ENTITY_PARAMETER_BEFORE_STATE () { 70 }
  sub DOCTYPE_ATTLIST_NAME_AFTER_STATE () { 71 }
  sub DOCTYPE_ATTLIST_ATTRIBUTE_NAME_STATE () { 72 }
  sub DOCTYPE_ATTLIST_ATTRIBUTE_NAME_AFTER_STATE () { 73 }
  sub DOCTYPE_ATTLIST_ATTRIBUTE_TYPE_STATE () { 74 }
  sub DOCTYPE_ATTLIST_ATTRIBUTE_TYPE_AFTER_STATE () { 75 }
  sub BEFORE_ALLOWED_TOKEN_STATE () { 76 }
  sub ALLOWED_TOKEN_STATE () { 77 }
  sub AFTER_ALLOWED_TOKEN_STATE () { 78 }
  sub AFTER_ALLOWED_TOKENS_STATE () { 79 }
  sub BEFORE_ATTR_DEFAULT_STATE () { 80 }
  sub DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_BEFORE_STATE () { 81 }
  sub DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_STATE () { 82 }
  sub DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_AFTER_STATE () { 83 }
  sub AFTER_ATTLIST_ATTR_VALUE_QUOTED_STATE () { 84 }
  sub BEFORE_NDATA_STATE () { 85 }
  sub NDATA_STATE () { 86 }
  sub AFTER_NDATA_STATE () { 87 }
  sub BEFORE_NOTATION_NAME_STATE () { 88 }
  sub NOTATION_NAME_STATE () { 89 }
  sub DOCTYPE_ENTITY_VALUE_DOUBLE_QUOTED_STATE () { 90 }
  sub DOCTYPE_ENTITY_VALUE_SINGLE_QUOTED_STATE () { 91 }
  sub ENTITY_VALUE_ENTITY_STATE () { 92 }
  sub AFTER_ELEMENT_NAME_STATE () { 93 }
  sub BEFORE_ELEMENT_CONTENT_STATE () { 94 }
  sub CONTENT_KEYWORD_STATE () { 95 }
  sub AFTER_CM_GROUP_OPEN_STATE () { 96 }
  sub CM_ELEMENT_NAME_STATE () { 97 }
  sub AFTER_CM_ELEMENT_NAME_STATE () { 98 }
  sub AFTER_CM_GROUP_CLOSE_STATE () { 99 }
  sub AFTER_MD_DEF_STATE () { 100 }
  sub BOGUS_MD_STATE () { 101 }
  
  push @EXPORT, qw(
  
    DATA_STATE RCDATA_STATE RAWTEXT_STATE SCRIPT_DATA_STATE
    PLAINTEXT_STATE TAG_OPEN_STATE RCDATA_LT_STATE RAWTEXT_LT_STATE
    SCRIPT_DATA_LT_STATE CLOSE_TAG_OPEN_STATE RCDATA_END_TAG_OPEN_STATE
    RAWTEXT_END_TAG_OPEN_STATE SCRIPT_DATA_END_TAG_OPEN_STATE
    SCRIPT_DATA_ESCAPE_START_STATE SCRIPT_DATA_ESCAPE_START_DASH_STATE
    SCRIPT_DATA_ESCAPED_STATE SCRIPT_DATA_ESCAPED_DASH_STATE
    SCRIPT_DATA_ESCAPED_DASH_DASH_STATE SCRIPT_DATA_ESCAPED_LT_STATE
    SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE
    SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE
    SCRIPT_DATA_DOUBLE_ESCAPED_STATE SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE
    SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE
    SCRIPT_DATA_DOUBLE_ESCAPED_LT_STATE
    SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE TAG_NAME_STATE
    BEFORE_ATTRIBUTE_NAME_STATE ATTRIBUTE_NAME_STATE
    AFTER_ATTRIBUTE_NAME_STATE BEFORE_ATTRIBUTE_VALUE_STATE
    ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE
    ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE ATTRIBUTE_VALUE_UNQUOTED_STATE
    MARKUP_DECLARATION_OPEN_STATE COMMENT_START_STATE
    COMMENT_START_DASH_STATE COMMENT_STATE COMMENT_END_STATE
    COMMENT_END_BANG_STATE COMMENT_END_DASH_STATE BOGUS_COMMENT_STATE
    DOCTYPE_STATE BEFORE_DOCTYPE_NAME_STATE DOCTYPE_NAME_STATE
    AFTER_DOCTYPE_NAME_STATE AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE
    BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE
    DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE
    DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE
    AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE
    BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE
    DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE
    DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE
    BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE
    AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE
    AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE BOGUS_DOCTYPE_STATE
    AFTER_ATTRIBUTE_VALUE_QUOTED_STATE SELF_CLOSING_START_TAG_STATE
    CDATA_SECTION_STATE MD_HYPHEN_STATE MD_DOCTYPE_STATE MD_CDATA_STATE
    CDATA_SECTION_MSE1_STATE CDATA_SECTION_MSE2_STATE PUBLIC_STATE
    SYSTEM_STATE ENTITY_STATE ENTITY_HASH_STATE NCR_NUM_STATE
    HEXREF_X_STATE HEXREF_HEX_STATE ENTITY_NAME_STATE DATA_MSE1_STATE
    DATA_MSE2_STATE PI_STATE PI_TARGET_STATE PI_TARGET_AFTER_STATE
    PI_DATA_STATE PI_AFTER_STATE PI_DATA_AFTER_STATE
    DOCTYPE_INTERNAL_SUBSET_STATE DOCTYPE_INTERNAL_SUBSET_AFTER_STATE
    BOGUS_DOCTYPE_INTERNAL_SUBSET_AFTER_STATE DOCTYPE_TAG_STATE
    DOCTYPE_MARKUP_DECLARATION_OPEN_STATE MD_ATTLIST_STATE MD_E_STATE
    MD_ELEMENT_STATE MD_ENTITY_STATE MD_NOTATION_STATE DOCTYPE_MD_STATE
    BEFORE_MD_NAME_STATE MD_NAME_STATE
    DOCTYPE_ENTITY_PARAMETER_BEFORE_STATE DOCTYPE_ATTLIST_NAME_AFTER_STATE
    DOCTYPE_ATTLIST_ATTRIBUTE_NAME_STATE
    DOCTYPE_ATTLIST_ATTRIBUTE_NAME_AFTER_STATE
    DOCTYPE_ATTLIST_ATTRIBUTE_TYPE_STATE
    DOCTYPE_ATTLIST_ATTRIBUTE_TYPE_AFTER_STATE BEFORE_ALLOWED_TOKEN_STATE
    ALLOWED_TOKEN_STATE AFTER_ALLOWED_TOKEN_STATE
    AFTER_ALLOWED_TOKENS_STATE BEFORE_ATTR_DEFAULT_STATE
    DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_BEFORE_STATE
    DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_STATE
    DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_AFTER_STATE
    AFTER_ATTLIST_ATTR_VALUE_QUOTED_STATE BEFORE_NDATA_STATE NDATA_STATE
    AFTER_NDATA_STATE BEFORE_NOTATION_NAME_STATE NOTATION_NAME_STATE
    DOCTYPE_ENTITY_VALUE_DOUBLE_QUOTED_STATE
    DOCTYPE_ENTITY_VALUE_SINGLE_QUOTED_STATE ENTITY_VALUE_ENTITY_STATE
    AFTER_ELEMENT_NAME_STATE BEFORE_ELEMENT_CONTENT_STATE
    CONTENT_KEYWORD_STATE AFTER_CM_GROUP_OPEN_STATE CM_ELEMENT_NAME_STATE
    AFTER_CM_ELEMENT_NAME_STATE AFTER_CM_GROUP_CLOSE_STATE
    AFTER_MD_DEF_STATE BOGUS_MD_STATE
  
  );
  
  ## ------ Tree constructor state constants ------
  
  ## Whether the parsed string is in the foreign island or not affect
  ## how tokenization is done, unfortunately.  These are a copy of some
  ## of tokenization state constants.  See Whatpm::HTML for the full
  ## list and the descriptions for constants.
  
  push @EXPORT, qw(FOREIGN_EL);
  
  sub FOREIGN_EL () { 0b1_00000000000 }
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WHATPM_HTML_DEFS

$fatpacked{"Whatpm/HTML/InputStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_HTML_INPUTSTREAM';
  package Whatpm::HTML::InputStream;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '1.0';
  use Whatpm::HTML::Defs;
  
  ## ------ Constructor ------
  
  sub new ($) {
    my $class = shift;
    my $self = bless {
      level => {
        must => 'm',
        should => 's',
        obsconforming => 's',
        warn => 'w',
        info => 'i',
        uncertain => 'u',
      },
    }, $class;
    $self->{application_cache_selection} = sub {
      #
    };
    
    return $self;
  } # new
  
  ## ------ Parser common operations ------
  
  sub _clear_refs ($) {
    my $self = $_[0];
    ## Remove self references.
    delete $self->{set_nc};
    delete $self->{read_until};
    delete $self->{parse_error};
    delete $self->{document};
    delete $self->{chars};
    delete $self->{chars_pull_next};
    delete $self->{restart_parser};
    delete $self->{t};
    delete $self->{embedded_encoding_name};
    delete $self->{byte_buffer};
  } # _clear_refs
  
  ## ------ Error handling ------
  
  our $DefaultErrorHandler = sub {
    my (%opt) = @_;
    my $line = $opt{token} ? $opt{token}->{line} : $opt{line};
    my $column = $opt{token} ? $opt{token}->{column} : $opt{column};
    warn "Parse error ($opt{type}) at line $line column $column\n";
  }; # $DefaultErrorHandler
  
  sub onerror ($;$) {
    if (@_ > 1) {
      $_[0]->{onerror} = $_[1];
    }
    return $_[0]->{onerror} || $DefaultErrorHandler;
  } # onerror
  
  ## ------ Character encoding processing ------
  
  ## XXX Encoding Standard support
  
  ## <http://dvcs.w3.org/hg/encoding/raw-file/tip/Overview.html#encodings>
  
  # $ curl http://dvcs.w3.org/hg/encoding/raw-file/tip/encodings.json | perl -MJSON::XS -MData::Dumper -e 'local $/ = undef; $json = JSON::XS->new->decode(<>); $Data::Dumper::Sortkeys = 1; print Dumper {map { my $name = $_->{name}; map { $_ => $name } @{$_->{labels}} } map { @{$_->{encodings}} } @$json}'
  my $CharsetMap = {
            '866' => 'ibm866',
            'ansi_x3.4-1968' => 'windows-1252',
            'arabic' => 'iso-8859-6',
            'ascii' => 'windows-1252',
            'asmo-708' => 'iso-8859-6',
            'big5' => 'big5',
            'big5-hkscs' => 'big5',
            'chinese' => 'gbk',
            'cn-big5' => 'big5',
            'cp1250' => 'windows-1250',
            'cp1251' => 'windows-1251',
            'cp1252' => 'windows-1252',
            'cp1253' => 'windows-1253',
            'cp1254' => 'windows-1254',
            'cp1255' => 'windows-1255',
            'cp1256' => 'windows-1256',
            'cp1257' => 'windows-1257',
            'cp1258' => 'windows-1258',
            'cp819' => 'windows-1252',
            'cp864' => 'ibm864',
            'cp866' => 'ibm866',
            'csbig5' => 'big5',
            'cseuckr' => 'euc-kr',
            'cseucpkdfmtjapanese' => 'euc-jp',
            'csgb2312' => 'gbk',
            'csibm864' => 'ibm864',
            'csibm866' => 'ibm866',
            'csiso2022jp' => 'iso-2022-jp',
            'csiso2022kr' => 'iso-2022-kr',
            'csiso58gb231280' => 'gbk',
            'csiso88596e' => 'iso-8859-6',
            'csiso88596i' => 'iso-8859-6',
            'csiso88598e' => 'iso-8859-8',
            'csiso88598i' => 'iso-8859-8',
            'csisolatin1' => 'windows-1252',
            'csisolatin2' => 'iso-8859-2',
            'csisolatin3' => 'iso-8859-3',
            'csisolatin4' => 'iso-8859-4',
            'csisolatin5' => 'windows-1254',
            'csisolatin6' => 'iso-8859-10',
            'csisolatin9' => 'iso-8859-15',
            'csisolatinarabic' => 'iso-8859-6',
            'csisolatincyrillic' => 'iso-8859-5',
            'csisolatingreek' => 'iso-8859-7',
            'csisolatinhebrew' => 'iso-8859-8',
            'cskoi8r' => 'koi8-r',
            'csksc56011987' => 'euc-kr',
            'csmacintosh' => 'macintosh',
            'csshiftjis' => 'shift_jis',
            'cyrillic' => 'iso-8859-5',
            'dos-874' => 'windows-874',
            'ecma-114' => 'iso-8859-6',
            'ecma-118' => 'iso-8859-7',
            'elot_928' => 'iso-8859-7',
            'euc-jp' => 'euc-jp',
            'euc-kr' => 'euc-kr',
            'gb18030' => 'gb18030',
            'gb2312' => 'gbk',
            'gb_2312' => 'gbk',
            'gb_2312-80' => 'gbk',
            'gbk' => 'gbk',
            'greek' => 'iso-8859-7',
            'greek8' => 'iso-8859-7',
            'hebrew' => 'iso-8859-8',
            'hz-gb-2312' => 'hz-gb-2312',
            'ibm-864' => 'ibm864',
            'ibm819' => 'windows-1252',
            'ibm864' => 'ibm864',
            'ibm866' => 'ibm866',
            'iso-2022-jp' => 'iso-2022-jp',
            'iso-2022-kr' => 'iso-2022-kr',
            'iso-8859-1' => 'windows-1252',
            'iso-8859-10' => 'iso-8859-10',
            'iso-8859-11' => 'windows-874',
            'iso-8859-13' => 'iso-8859-13',
            'iso-8859-14' => 'iso-8859-14',
            'iso-8859-15' => 'iso-8859-15',
            'iso-8859-16' => 'iso-8859-16',
            'iso-8859-2' => 'iso-8859-2',
            'iso-8859-3' => 'iso-8859-3',
            'iso-8859-4' => 'iso-8859-4',
            'iso-8859-5' => 'iso-8859-5',
            'iso-8859-6' => 'iso-8859-6',
            'iso-8859-6-e' => 'iso-8859-6',
            'iso-8859-6-i' => 'iso-8859-6',
            'iso-8859-7' => 'iso-8859-7',
            'iso-8859-8' => 'iso-8859-8',
            'iso-8859-8-e' => 'iso-8859-8',
            'iso-8859-8-i' => 'iso-8859-8',
            'iso-8859-9' => 'windows-1254',
            'iso-ir-100' => 'windows-1252',
            'iso-ir-101' => 'iso-8859-2',
            'iso-ir-109' => 'iso-8859-3',
            'iso-ir-110' => 'iso-8859-4',
            'iso-ir-126' => 'iso-8859-7',
            'iso-ir-127' => 'iso-8859-6',
            'iso-ir-138' => 'iso-8859-8',
            'iso-ir-144' => 'iso-8859-5',
            'iso-ir-148' => 'windows-1254',
            'iso-ir-149' => 'euc-kr',
            'iso-ir-157' => 'iso-8859-10',
            'iso-ir-58' => 'gbk',
            'iso8859-1' => 'windows-1252',
            'iso8859-10' => 'iso-8859-10',
            'iso8859-11' => 'windows-874',
            'iso8859-13' => 'iso-8859-13',
            'iso8859-14' => 'iso-8859-14',
            'iso8859-15' => 'iso-8859-15',
            'iso8859-2' => 'iso-8859-2',
            'iso8859-3' => 'iso-8859-3',
            'iso8859-4' => 'iso-8859-4',
            'iso8859-5' => 'iso-8859-5',
            'iso8859-6' => 'iso-8859-6',
            'iso8859-7' => 'iso-8859-7',
            'iso8859-8' => 'iso-8859-8',
            'iso8859-9' => 'windows-1254',
            'iso88591' => 'windows-1252',
            'iso885910' => 'iso-8859-10',
            'iso885911' => 'windows-874',
            'iso885913' => 'iso-8859-13',
            'iso885914' => 'iso-8859-14',
            'iso885915' => 'iso-8859-15',
            'iso88592' => 'iso-8859-2',
            'iso88593' => 'iso-8859-3',
            'iso88594' => 'iso-8859-4',
            'iso88595' => 'iso-8859-5',
            'iso88596' => 'iso-8859-6',
            'iso88597' => 'iso-8859-7',
            'iso88598' => 'iso-8859-8',
            'iso88599' => 'windows-1254',
            'iso_8859-1' => 'windows-1252',
            'iso_8859-15' => 'iso-8859-15',
            'iso_8859-1:1987' => 'windows-1252',
            'iso_8859-2' => 'iso-8859-2',
            'iso_8859-2:1987' => 'iso-8859-2',
            'iso_8859-3' => 'iso-8859-3',
            'iso_8859-3:1988' => 'iso-8859-3',
            'iso_8859-4' => 'iso-8859-4',
            'iso_8859-4:1988' => 'iso-8859-4',
            'iso_8859-5' => 'iso-8859-5',
            'iso_8859-5:1988' => 'iso-8859-5',
            'iso_8859-6' => 'iso-8859-6',
            'iso_8859-6:1987' => 'iso-8859-6',
            'iso_8859-7' => 'iso-8859-7',
            'iso_8859-7:1987' => 'iso-8859-7',
            'iso_8859-8' => 'iso-8859-8',
            'iso_8859-8:1988' => 'iso-8859-8',
            'iso_8859-9' => 'windows-1254',
            'iso_8859-9:1989' => 'windows-1254',
            'koi' => 'koi8-r',
            'koi8' => 'koi8-r',
            'koi8-r' => 'koi8-r',
            'koi8-u' => 'koi8-u',
            'koi8_r' => 'koi8-r',
            'korean' => 'euc-kr',
            'ks_c_5601-1987' => 'euc-kr',
            'ks_c_5601-1989' => 'euc-kr',
            'ksc5601' => 'euc-kr',
            'ksc_5601' => 'euc-kr',
            'l1' => 'windows-1252',
            'l2' => 'iso-8859-2',
            'l3' => 'iso-8859-3',
            'l4' => 'iso-8859-4',
            'l5' => 'windows-1254',
            'l6' => 'iso-8859-10',
            'l9' => 'iso-8859-15',
            'latin1' => 'windows-1252',
            'latin2' => 'iso-8859-2',
            'latin3' => 'iso-8859-3',
            'latin4' => 'iso-8859-4',
            'latin5' => 'windows-1254',
            'latin6' => 'iso-8859-10',
            'logical' => 'iso-8859-8',
            'mac' => 'macintosh',
            'macintosh' => 'macintosh',
            'ms_kanji' => 'shift_jis',
            'shift-jis' => 'shift_jis',
            'shift_jis' => 'shift_jis',
            'sjis' => 'shift_jis',
            'sun_eu_greek' => 'iso-8859-7',
            'tis-620' => 'windows-874',
            'unicode-1-1-utf-8' => 'utf-8',
            'us-ascii' => 'windows-1252',
            'utf-16' => 'utf-16',
            'utf-16be' => 'utf-16be',
            'utf-16le' => 'utf-16',
            'utf-8' => 'utf-8',
            'utf8' => 'utf-8',
            'visual' => 'iso-8859-8',
            'windows-1250' => 'windows-1250',
            'windows-1251' => 'windows-1251',
            'windows-1252' => 'windows-1252',
            'windows-1253' => 'windows-1253',
            'windows-1254' => 'windows-1254',
            'windows-1255' => 'windows-1255',
            'windows-1256' => 'windows-1256',
            'windows-1257' => 'windows-1257',
            'windows-1258' => 'windows-1258',
            'windows-31j' => 'shift_jis',
            'windows-874' => 'windows-874',
            'windows-949' => 'euc-kr',
            'x-cp1250' => 'windows-1250',
            'x-cp1251' => 'windows-1251',
            'x-cp1252' => 'windows-1252',
            'x-cp1253' => 'windows-1253',
            'x-cp1254' => 'windows-1254',
            'x-cp1255' => 'windows-1255',
            'x-cp1256' => 'windows-1256',
            'x-cp1257' => 'windows-1257',
            'x-cp1258' => 'windows-1258',
            'x-euc-jp' => 'euc-jp',
            'x-gbk' => 'gbk',
            'x-mac-cyrillic' => 'x-mac-cyrillic',
            'x-mac-roman' => 'macintosh',
            'x-mac-ukrainian' => 'x-mac-cyrillic',
            'x-sjis' => 'shift_jis',
            'x-x-big5' => 'big5'
  }; # $CharsetMap
  
  my $LocaleDefaultCharset = {
    ar => 'utf-8',
    be => 'iso-8859-5',
    bg => 'windows-1251',
    cs => 'iso-8859-2',
    cy => 'utf-8',
    fa => 'utf-8',
    he => 'windows-1255',
    hr => 'utf-8',
    hu => 'iso-8859-2',
    ja => 'shift_jis',
    kk => 'utf-8',
    ko => 'euc-kr',
    ku => 'windows-1254',
    lt => 'windows-1257',
    lv => 'iso-8859-13',
    mk => 'utf-8',
    or => 'utf-8',
    pl => 'iso-8859-2',
    ro => 'utf-8',
    ru => 'windows-1251',
    sk => 'windows-1250',
    sl => 'iso-8859-2',
    sr => 'utf-8',
    th => 'windows-874',
    tr => 'windows-1254',
    uk => 'windows-1251',
    vi => 'utf-8',
    'zh-cn' => 'gb18030',
    'zh-tw' => 'big5',
  };
  
  # XXX
  sub _get_encoding_name ($) {
    my $input = shift || '';
    $input =~ s/\A[\x09\x0A\x0C\x0D\x20]+//;
    $input =~ s/[\x09\x0A\x0C\x0D\x20]+\z//;
    $input =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
    return $CharsetMap->{$input}; # or undef
  } # _get_encoding_name
  
  ## Encoding sniffing algorithm
  ## <http://www.whatwg.org/specs/web-apps/current-work/#determining-the-character-encoding>.
  sub _encoding_sniffing ($;%) {
    my ($self, %args) = @_;
  
    ## Change the encoding
    ## <http://www.whatwg.org/specs/web-apps/current-work/#change-the-encoding>
    ## Step 5. Encoding from <meta charset>
    if ($args{embedded_encoding_name}) {
      my $name = _get_encoding_name $args{embedded_encoding_name};
      if ($name) {
        $self->{input_encoding} = $name;
        $self->{confident} = 1; # certain
        return;
      }
    }
  
    ## Step 1. User-specified encoding
    if ($args{user_encoding_name}) {
      my $name = _get_encoding_name $args{user_encoding_name};
      if ($name) {
        $self->{input_encoding} = $name;
        $self->{confident} = 1; # certain
        return;
      }
    }
  
    ## Step 2. Transport-layer encoding
    if ($args{transport_encoding_name}) {
      my $name = _get_encoding_name $args{transport_encoding_name};
      if ($name) {
        $self->{input_encoding} = $name;
        $self->{confident} = 1; # certain
        return;
      }
    }
  
    return if $args{no_body_data_yet};
  
    ## Step 3. Sniffing
    if ($args{read_head}) {
      my $head = $args{read_head}->();
      if (defined $head) {
        ## Step 4. BOM
        if ($$head =~ /^\xFE\xFF/) {
          $self->{input_encoding} = 'utf-16be';
          $self->{confident} = 1; # certain
          return;
        } elsif ($$head =~ /^\xFF\xFE/) {
          $self->{input_encoding} = 'utf-16le';
          $self->{confident} = 1; # certain
          return;
        } elsif ($$head =~ /^\xEF\xBB\xBF/) {
          $self->{input_encoding} = 'utf-8';
          $self->{confident} = 1; # certain
          return;
        }
  
        ## Step 5. <meta charset>
        # XXX
  
        ## Step 6. History
        if ($args{get_history_encoding_name}) {
          my $name = _get_encoding_name $args{get_history_encoding_name}->();
          if ($name) {
            $self->{input_encoding} = $name;
            $self->{confident} = 0; # tentative
            return;
          }
        }
  
        ## Step 7. UniversalCharDet
        require Whatpm::Charset::UniversalCharDet;
        my $name = _get_encoding_name
            +Whatpm::Charset::UniversalCharDet->detect_byte_string ($$head);
        if ($name) {
          $self->{input_encoding} = $name;
          $self->{confident} = 0; # tentative
          return;
        }
      } # $head
    }
  
    ## Step 8. Locale-dependent default
    if ($args{locale}) {
      my $name = _get_encoding_name $LocaleDefaultCharset->{$args{locale}};
      if ($name) {
        $self->{input_encoding} = $name;
        $self->{confident} = 0; # tentative
        return;
      }
    }
  
    ## Step 8. Default of default
    $self->{input_encoding} = 'windows-1252';
    $self->{confident} = 0; # tentative
    return;
  
    # XXX expose sniffing info for validator
  } # _encoding_sniffing
  
  sub _change_encoding {
    my ($self, $name, $token) = @_;
  
    ## "meta" start tag
    ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inhead>.
  
    ## "meta". Confidence is /tentative/
    return 0 if $self->{confident}; # tentative
  
    $name = _get_encoding_name $name;
    unless ($name) {
      ## "meta". Supported encoding
      return 0;
    }
  
    ## "meta". ASCII-compatible or UTF-16
    ## All encodings in Encoding Standard are ASCII-compatible or UTF-16.
  
    ## Change the encoding
    ## <http://www.whatwg.org/specs/web-apps/current-work/#change-the-encoding>.
  
    ## Step 1. UTF-16
    if ($self->{input_encoding} eq 'utf-16' or
        $self->{input_encoding} eq 'utf-16be') {
      $self->{confident} = 1; # certain
      return 0;
    }
  
    ## Step 2. UTF-16
    $name = 'utf-8' if $name eq 'utf-16' or $name eq 'utf-16be';
    
    ## Step 3. Same
    if ($name eq $self->{input_encoding}) {
      $self->{confident} = 1; # certain
      return 0;
    }
  
    $self->{parse_error}->(type => 'charset label detected',
                           text => $self->{input_encoding},
                           value => $name,
                           level => $self->{level}->{warn},
                           token => $token);
  
    ## Step 4. Change the encoding on the fly
    ## Not implemented.
  
    ## Step 5. Navigate with replace.
    if ($self->{restart_parser}) {
      return $self->{restart_parser}->($name);
    }
  
    ## Step 5. Can't restart
    $self->{confident} = 1; # certain
    return 0;
  
    # XXX expose info for validator
  } # _change_encoding
  
  ## ------ Feed characters from input stream to tokenizer ------
  
  my $CommonStoppers = {
    ## Newlines
    "\x{000D}" => 1, "\x{000A}" => 1,
    "\x{0085}" => 1, "\x{2028}" => 1,
  
    ## Parse errors
    "\x{000B}" => 1, "\x{FFFE}" => 1, "\x{FFFF}" => 1,
    "\x{1FFFE}" => 1, "\x{1FFFF}" => 1, "\x{2FFFE}" => 1, "\x{2FFFF}" => 1,
    "\x{3FFFE}" => 1, "\x{3FFFF}" => 1, "\x{4FFFE}" => 1, "\x{4FFFF}" => 1,
    "\x{5FFFE}" => 1, "\x{5FFFF}" => 1, "\x{6FFFE}" => 1, "\x{6FFFF}" => 1,
    "\x{7FFFE}" => 1, "\x{7FFFF}" => 1, "\x{8FFFE}" => 1, "\x{8FFFF}" => 1,
    "\x{9FFFE}" => 1, "\x{9FFFF}" => 1, "\x{AFFFE}" => 1, "\x{AFFFF}" => 1,
    "\x{BFFFE}" => 1, "\x{BFFFF}" => 1, "\x{CFFFE}" => 1, "\x{CFFFF}" => 1,
    "\x{DFFFE}" => 1, "\x{DFFFF}" => 1, "\x{EFFFE}" => 1, "\x{EFFFF}" => 1,
    "\x{FFFFE}" => 1, "\x{FFFFF}" => 1,
    "\x{10FFFE}" => 1, "\x{10FFFF}" => 1,
    "\x{000C}" => 1,
  };
  $CommonStoppers->{chr $_} = 1
      for 0x0001..0x0008, 0x000E..0x001F, 0x007F..0x009F, 0xFDD0..0xFDEF,
          0xD800..0xDFFF;
  
  ## U+0000 error will be detected by tokenizer or tree constructor.
  my $ParseErrorControlCodePosition = {
    html => {0x000B => 'must', 0x0085 => 'must'},
    1 => {0x000B => 'must', 0x000C => 'must', 0x0085 => 'warn'},
    1.1 => {0x000B => 'must', 0x000C => 'must'},
  };
  $ParseErrorControlCodePosition->{html}->{$_} = 'must',
  $ParseErrorControlCodePosition->{1}->{$_} = 'must',
  $ParseErrorControlCodePosition->{1.1}->{$_} = 'must'
      for 0x0001..0x0008, 0x000E..0x001F;
  $ParseErrorControlCodePosition->{html}->{$_} = 'must',
  $ParseErrorControlCodePosition->{1}->{$_} = 'warn',
  $ParseErrorControlCodePosition->{1.1}->{$_} = 'must'
      for 0x007F..0x0084, 0x0086..0x009F;
  
  my $ParseErrorNoncharCodePosition = {};
  $ParseErrorNoncharCodePosition->{html}->{$_} = 'must',
  $ParseErrorNoncharCodePosition->{1}->{$_} = 'warn',
  $ParseErrorNoncharCodePosition->{1.1}->{$_} = 'warn'
      for 0xFDD0..0xFDEF;
  $ParseErrorNoncharCodePosition->{html}->{$_} = 'must',
  $ParseErrorNoncharCodePosition->{1}->{$_} = 'must',
  $ParseErrorNoncharCodePosition->{1.1}->{$_} = 'must'
      for 0xFFFE, 0xFFFF;
  $ParseErrorNoncharCodePosition->{1}->{$_} = 'must',
  $ParseErrorNoncharCodePosition->{1.1}->{$_} = 'must'
      for 0xD800..0xDFFF;
  $ParseErrorNoncharCodePosition->{html}->{$_} = 'must',
  $ParseErrorNoncharCodePosition->{1}->{$_} = 'warn',
  $ParseErrorNoncharCodePosition->{1.1}->{$_} = 'warn'
      for 0x1FFFE, 0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE, 0x3FFFF, 0x4FFFE,
          0x4FFFF, 0x5FFFE, 0x5FFFF, 0x6FFFE, 0x6FFFF, 0x7FFFE, 0x7FFFF,
          0x8FFFE, 0x8FFFF, 0x9FFFE, 0x9FFFF, 0xAFFFE, 0xAFFFF, 0xBFFFE,
          0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE, 0xDFFFF, 0xEFFFE, 0xEFFFF,
          0xFFFFE, 0xFFFFF, 0x10FFFE, 0x10FFFF;
  
  sub _set_nc ($) {
    my $self = $_[0];
    {
      if ($self->{chars_pos} < @{$self->{chars}}) {
        $self->{line_prev} = $self->{line};
        $self->{column_prev} = $self->{column};
        my $lang = $self->{is_xml} || 'html';
        my $c = ord $self->{chars}->[$self->{chars_pos}++];
        if ($c == 0x000A or
            ($c == 0x0085 and $lang eq 1.1)) {
          if ($self->{chars_was_cr}) {
            delete $self->{chars_was_cr};
            redo;
          } else {
            delete $self->{chars_was_cr};
            $self->{line}++;
            $self->{column} = 0;
            $c = 0x000A;
          }
        } elsif ($c == 0x000D) {
          $self->{chars_was_cr} = 1;
          $self->{line}++;
          $self->{column} = 0;
          $c = 0x000A;
        } elsif ($c == 0x2028 and $lang eq 1.1) {
          delete $self->{chars_was_cr};
          $self->{line}++;
          $self->{column} = 0;
          $c = 0x000A;
        } else {
          if (my $level = $ParseErrorControlCodePosition->{$lang}->{$c}) {
            $self->{parse_error}
                ->(type => 'control char', # XXXtype
                   value => (sprintf 'U+%04X', $c),
                   level => $self->{level}->{$level},
                   line => $self->{line},
                   column => $self->{column} + 1);
          } elsif ($level = $ParseErrorNoncharCodePosition->{$lang}->{$c}) {
            $self->{parse_error}
                ->(type => 'nonchar', # XXXtype
                   value => (sprintf 'U+%04X', $c),
                   level => $self->{level}->{$level},
                   line => $self->{line},
                   column => $self->{column} + 1);
          }
          
          delete $self->{chars_was_cr};
          $self->{column}++;
        }
        $self->{nc} = $c;
      } else {
        if ($self->{chars_pull_next}->()) {
          $self->{nc} = ABORT_CHAR;
        } else {
          delete $self->{chars_was_cr};
          $self->{nc} = EOF_CHAR;
        }
      }
    } # block
  } # _set_nc
  
  sub _read_chars ($$) {
    my ($self, $stoppers) = @_;
    
    my $start = $self->{chars_pos};
    {
      my $char = $self->{chars}->[$self->{chars_pos}];
      last if not defined $char;
      if ($stoppers->{$char} or $CommonStoppers->{$char}) {
        last;
      } else {
        $self->{chars_pos}++;
      }
      redo;
    }
    return '' if $start == $self->{chars_pos};
  
    $self->{column} += $self->{chars_pos} - $start;
    return join '', @{$self->{chars}}[$start..($self->{chars_pos}-1)];
  } # _read_chars
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WHATPM_HTML_INPUTSTREAM

$fatpacked{"Whatpm/HTML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_HTML_PARSER';
  package Whatpm::HTML::Parser; # -*- Perl -*-
  use strict;
  #use warnings;
  no warnings 'utf8';
  our $VERSION = '1.0';
  use Encode;
  use Whatpm::HTML::Defs;
  use Whatpm::HTML::Tokenizer;
  push our @ISA, qw(Whatpm::HTML::Tokenizer);
  
  
  
  use Whatpm::HTML::Tokenizer;
  
  ## Namespace URLs
  
  sub HTML_NS () { q<http://www.w3.org/1999/xhtml> }
  sub MML_NS () { q<http://www.w3.org/1998/Math/MathML> }
  sub SVG_NS () { q<http://www.w3.org/2000/svg> }
  
  ## Element categories
  
  ## Bits 14-18
  sub BUTTON_SCOPING_EL () { 0b1_000000000000000000 } ## Special
  sub SPECIAL_EL () { 0b1_00000000000000000 }         ## Special
  sub SCOPING_EL () { 0b1_0000000000000000 }          ## Special
  sub FORMATTING_EL () { 0b1_000000000000000 }        ## Formatting
  sub PHRASING_EL () { 0b1_00000000000000 }           ## Ordinary
  
  ## Bits 10-13
  sub SVG_EL () { 0b1_0000000000000 }
  sub MML_EL () { 0b1_000000000000 }
  #sub FOREIGN_EL () { 0b1_00000000000 } # see Whatpm::HTML::Tokenizer
  sub FOREIGN_FLOW_CONTENT_EL () { 0b1_0000000000 }
  
  ## Bits 6-9
  sub TABLE_SCOPING_EL () { 0b1_000000000 }
  sub TABLE_ROWS_SCOPING_EL () { 0b1_00000000 }
  sub TABLE_ROW_SCOPING_EL () { 0b1_0000000 }
  sub TABLE_ROWS_EL () { 0b1_000000 }
  
  ## Bit 5
  sub ADDRESS_DIV_P_EL () { 0b1_00000 }
  
  ## NOTE: Used in </body> and EOF algorithms.
  ## Bit 4
  sub ALL_END_TAG_OPTIONAL_EL () { 0b1_0000 }
  
  ## NOTE: Used in "generate implied end tags" algorithm.
  ## NOTE: There is a code where a modified version of
  ## END_TAG_OPTIONAL_EL is used in "generate implied end tags"
  ## implementation (search for the algorithm name).
  ## Bit 3
  sub END_TAG_OPTIONAL_EL () { 0b1_000 }
  
  ## Bits 0-2
  
  sub MISC_SPECIAL_EL () { SPECIAL_EL | 0b000 }
  sub FORM_EL () { SPECIAL_EL | 0b001 }
  sub FRAMESET_EL () { SPECIAL_EL | 0b010 }
  sub HEADING_EL () { SPECIAL_EL | 0b011 }
  sub SELECT_EL () { SPECIAL_EL | 0b100 }
  sub SCRIPT_EL () { SPECIAL_EL | 0b101 }
  sub BUTTON_EL () { SPECIAL_EL | BUTTON_SCOPING_EL | 0b110 }
  
  sub ADDRESS_DIV_EL () { SPECIAL_EL | ADDRESS_DIV_P_EL | 0b001 }
  sub BODY_EL () { SPECIAL_EL | ALL_END_TAG_OPTIONAL_EL | 0b001 }
  
  sub DTDD_EL () {
    SPECIAL_EL |
    END_TAG_OPTIONAL_EL |
    ALL_END_TAG_OPTIONAL_EL |
    0b010
  }
  sub LI_EL () {
    SPECIAL_EL |
    END_TAG_OPTIONAL_EL |
    ALL_END_TAG_OPTIONAL_EL |
    0b100
  }
  sub P_EL () {
    SPECIAL_EL |
    ADDRESS_DIV_P_EL |
    END_TAG_OPTIONAL_EL |
    ALL_END_TAG_OPTIONAL_EL |
    0b001
  }
  
  sub TABLE_ROW_EL () {
    SPECIAL_EL |
    TABLE_ROWS_EL |
    TABLE_ROW_SCOPING_EL |
    ALL_END_TAG_OPTIONAL_EL |
    0b001
  }
  sub TABLE_ROW_GROUP_EL () {
    SPECIAL_EL |
    TABLE_ROWS_EL |
    TABLE_ROWS_SCOPING_EL |
    ALL_END_TAG_OPTIONAL_EL |
    0b001
  }
  
  sub MISC_SCOPING_EL () { SCOPING_EL | BUTTON_SCOPING_EL | 0b000 }
  sub CAPTION_EL () { SCOPING_EL | BUTTON_SCOPING_EL | 0b010 }
  sub HTML_EL () {
    SCOPING_EL |
    BUTTON_SCOPING_EL |
    TABLE_SCOPING_EL |
    TABLE_ROWS_SCOPING_EL |
    TABLE_ROW_SCOPING_EL |
    ALL_END_TAG_OPTIONAL_EL |
    0b001
  }
  sub TABLE_EL () {
    SCOPING_EL |
    BUTTON_SCOPING_EL |
    TABLE_ROWS_EL |
    TABLE_SCOPING_EL |
    0b001
  }
  sub TABLE_CELL_EL () {
    SCOPING_EL |
    BUTTON_SCOPING_EL |
    ALL_END_TAG_OPTIONAL_EL |
    0b001
  }
  
  sub MISC_FORMATTING_EL () { FORMATTING_EL | 0b000 }
  sub A_EL () { FORMATTING_EL | 0b001 }
  sub NOBR_EL () { FORMATTING_EL | 0b010 }
  
  sub RUBY_EL () { PHRASING_EL | 0b001 }
  
  ## NOTE: These elements are not included in |ALL_END_TAG_OPTIONAL_EL|.
  sub OPTGROUP_EL () { PHRASING_EL | END_TAG_OPTIONAL_EL | 0b001 }
  sub OPTION_EL () { PHRASING_EL | END_TAG_OPTIONAL_EL | 0b010 }
  sub RUBY_COMPONENT_EL () { PHRASING_EL | END_TAG_OPTIONAL_EL | 0b100 }
  
  ## "MathML text integration point" elements.
  sub MML_TEXT_INTEGRATION_EL () {
    MML_EL |
    SCOPING_EL |
    BUTTON_SCOPING_EL |
    FOREIGN_EL |
    FOREIGN_FLOW_CONTENT_EL
  } # MML_TEXT_INTEGRATION_EL
  
  sub MML_AXML_EL () {
    MML_EL |
    SCOPING_EL |
    BUTTON_SCOPING_EL |
    FOREIGN_EL |
    0b001
  } # MML_AXML_EL
  
  ## "HTML integration point" elements in SVG namespace.
  sub SVG_INTEGRATION_EL () {
    SVG_EL |
    SCOPING_EL |
    BUTTON_SCOPING_EL |
    FOREIGN_EL |
    FOREIGN_FLOW_CONTENT_EL
  } # SVG_INTEGRATION_EL
  
  sub SVG_SCRIPT_EL () {
    SVG_EL |
    FOREIGN_EL |
    0b101
  } # SVG_SCRIPT_EL
  
  my $el_category = {
    a => A_EL,
    address => ADDRESS_DIV_EL,
    applet => MISC_SCOPING_EL,
    area => MISC_SPECIAL_EL,
    article => MISC_SPECIAL_EL,
    aside => MISC_SPECIAL_EL,
    b => FORMATTING_EL,
    base => MISC_SPECIAL_EL,
    basefont => MISC_SPECIAL_EL,
    bgsound => MISC_SPECIAL_EL,
    big => FORMATTING_EL,
    blockquote => MISC_SPECIAL_EL,
    body => BODY_EL,
    br => MISC_SPECIAL_EL,
    button => BUTTON_EL,
    caption => CAPTION_EL,
    center => MISC_SPECIAL_EL,
    code => FORMATTING_EL,
    col => MISC_SPECIAL_EL,
    colgroup => MISC_SPECIAL_EL,
    command => MISC_SPECIAL_EL,
    #datagrid => MISC_SPECIAL_EL,
    dd => DTDD_EL,
    details => MISC_SPECIAL_EL,
    dir => MISC_SPECIAL_EL,
    div => ADDRESS_DIV_EL,
    dl => MISC_SPECIAL_EL,
    dt => DTDD_EL,
    em => FORMATTING_EL,
    embed => MISC_SPECIAL_EL,
    fieldset => MISC_SPECIAL_EL,
    figcaption => MISC_SPECIAL_EL,
    figure => MISC_SPECIAL_EL,
    font => FORMATTING_EL,
    footer => MISC_SPECIAL_EL,
    form => FORM_EL,
    frame => MISC_SPECIAL_EL,
    frameset => FRAMESET_EL,
    h1 => HEADING_EL,
    h2 => HEADING_EL,
    h3 => HEADING_EL,
    h4 => HEADING_EL,
    h5 => HEADING_EL,
    h6 => HEADING_EL,
    head => MISC_SPECIAL_EL,
    header => MISC_SPECIAL_EL,
    hgroup => MISC_SPECIAL_EL,
    hr => MISC_SPECIAL_EL,
    html => HTML_EL,
    i => FORMATTING_EL,
    iframe => MISC_SPECIAL_EL,
    img => MISC_SPECIAL_EL,
    #image => MISC_SPECIAL_EL, ## NOTE: Commented out in the spec.
    input => MISC_SPECIAL_EL,
    isindex => MISC_SPECIAL_EL,
    ## XXX keygen? (Whether a void element is in Special or not does not
    ## affect to the processing, however.)
    li => LI_EL,
    link => MISC_SPECIAL_EL,
    listing => MISC_SPECIAL_EL,
    marquee => MISC_SCOPING_EL,
    menu => MISC_SPECIAL_EL,
    meta => MISC_SPECIAL_EL,
    nav => MISC_SPECIAL_EL,
    nobr => NOBR_EL,
    noembed => MISC_SPECIAL_EL,
    noframes => MISC_SPECIAL_EL,
    noscript => MISC_SPECIAL_EL,
    object => MISC_SCOPING_EL,
    ol => MISC_SPECIAL_EL,
    optgroup => OPTGROUP_EL,
    option => OPTION_EL,
    p => P_EL,
    param => MISC_SPECIAL_EL,
    plaintext => MISC_SPECIAL_EL,
    pre => MISC_SPECIAL_EL,
    rp => RUBY_COMPONENT_EL,
    rt => RUBY_COMPONENT_EL,
    ruby => RUBY_EL,
    s => FORMATTING_EL,
    script => MISC_SPECIAL_EL,
    select => SELECT_EL,
    section => MISC_SPECIAL_EL,
    small => FORMATTING_EL,
    strike => FORMATTING_EL,
    strong => FORMATTING_EL,
    style => MISC_SPECIAL_EL,
    summary => MISC_SPECIAL_EL,
    table => TABLE_EL,
    tbody => TABLE_ROW_GROUP_EL,
    td => TABLE_CELL_EL,
    textarea => MISC_SPECIAL_EL,
    tfoot => TABLE_ROW_GROUP_EL,
    th => TABLE_CELL_EL,
    thead => TABLE_ROW_GROUP_EL,
    title => MISC_SPECIAL_EL,
    tr => TABLE_ROW_EL,
    tt => FORMATTING_EL,
    u => FORMATTING_EL,
    ul => MISC_SPECIAL_EL,
    wbr => MISC_SPECIAL_EL,
    xmp => MISC_SPECIAL_EL,
  };
  
  my $el_category_f = {
    (MML_NS) => {
      'annotation-xml' => MML_AXML_EL,
      mi => MML_TEXT_INTEGRATION_EL,
      mo => MML_TEXT_INTEGRATION_EL,
      mn => MML_TEXT_INTEGRATION_EL,
      ms => MML_TEXT_INTEGRATION_EL,
      mtext => MML_TEXT_INTEGRATION_EL,
    },
    (SVG_NS) => {
      foreignObject => SVG_INTEGRATION_EL,
      desc => SVG_INTEGRATION_EL,
      title => SVG_INTEGRATION_EL,
      script => SVG_SCRIPT_EL,
    },
    ## NOTE: In addition, FOREIGN_EL is set to non-HTML elements, MML_EL
    ## is set to MathML elements, and SVG_EL is set to SVG elements.
  };
  
  require Whatpm::HTML::ParserData;
  
  my $svg_attr_name = $Whatpm::HTML::ParserData::SVGAttrNameFixup;
  my $mml_attr_name = $Whatpm::HTML::ParserData::MathMLAttrNameFixup;
  my $foreign_attr_xname = $Whatpm::HTML::ParserData::ForeignAttrNamespaceFixup;
  
  ## TODO: Invoke the reset algorithm when a resettable element is
  ## created (cf. HTML5 revision 2259).
  
  ## ------ String parse API ------
  
  sub parse_byte_string ($$$$;$$) {
    #my ($self, $charset_name, $string, $doc, $onerror, $get_wrapper) = @_;
    my $self = ref $_[0] ? $_[0] : $_[0]->new;
    my $doc = $self->{document} = $_[3];
  
    my $embedded_encoding_name;
    PARSER: {
      @{$self->{document}->child_nodes} = ();
      
      my $inputref = \($_[2]);
      $self->_encoding_sniffing
          (transport_encoding_name => $_[1],
           embedded_encoding_name => $embedded_encoding_name,
           read_head => sub {
             return $inputref;
           });
      $self->{document}->input_encoding ($self->{input_encoding});
  
      $self->{line_prev} = $self->{line} = 1;
      $self->{column_prev} = -1;
      $self->{column} = 0;
  
      $self->{chars} = [split //, decode $self->{input_encoding}, $$inputref];
      $self->{chars_pos} = 0;
      $self->{chars_pull_next} = sub { 0 };
      delete $self->{chars_was_cr};
  
      $self->{restart_parser} = sub {
        $embedded_encoding_name = $_[0];
        die bless {}, 'Whatpm::HTML::InputStream::RestartParser';
        return 0;
      };
  
      my $onerror = $_[4] || $self->onerror;
      $self->{parse_error} = sub {
        $onerror->(line => $self->{line}, column => $self->{column}, @_);
      };
  
      $self->_initialize_tokenizer;
      $self->_initialize_tree_constructor;
      $self->{t} = $self->_get_next_token;
      my $error;
      {
        local $@;
        eval { $self->_construct_tree; 1 } or $error = $@;
      }
      if ($error) {
        if (ref $error eq 'Whatpm::HTML::InputStream::RestartParser') {
          redo PARSER;
        }
        die $error;
      }
      $self->_terminate_tree_constructor;
      $self->_clear_refs;
    } # PARSER
  
    return $doc;
  } # parse_byte_string
  
  ## NOTE: HTML5 spec says that the encoding layer MUST NOT strip BOM
  ## and the HTML layer MUST ignore it.  However, we does strip BOM in
  ## the encoding layer and the HTML layer does not ignore any U+FEFF,
  ## because the core part of our HTML parser expects a string of
  ## character, not a string of bytes or code units or anything which
  ## might contain a BOM.  Therefore, any parser interface that accepts
  ## a string of bytes, such as |parse_byte_string| in this module, must
  ## ensure that it does strip the BOM and never strip any ZWNBSP.
  
  ## XXX The policy mentioned above might change when we implement
  ## Encoding Standard spec.
  
  sub parse_char_string ($$$;$$) {
    #my ($self, $string, $document, $onerror, $get_wrapper) = @_;
    my $self = ref $_[0] ? $_[0] : $_[0]->new;
    my $doc = $self->{document} = $_[2];
    @{$self->{document}->child_nodes} = ();
  
    ## Confidence: irrelevant.
    $self->{confident} = 1 unless exists $self->{confident};
  
    $self->{line_prev} = $self->{line} = 1;
    $self->{column_prev} = -1;
    $self->{column} = 0;
  
    $self->{chars} = [split //, $_[1]];
    $self->{chars_pos} = 0;
    $self->{chars_pull_next} = sub { 0 };
    delete $self->{chars_was_cr};
  
    my $onerror = $_[3] || $self->onerror;
    $self->{parse_error} = sub {
      $onerror->(line => $self->{line}, column => $self->{column}, @_);
    };
  
    $self->_initialize_tokenizer;
    $self->_initialize_tree_constructor;
    $self->{t} = $self->_get_next_token;
    $self->_construct_tree;
    $self->_terminate_tree_constructor;
    $self->_clear_refs;
  
    return $doc;
  } # parse_char_string
  
  ## ------ Stream parse API (experimental) ------
  
  ## XXX tests
  
  sub parse_bytes_start ($$$) {
    #my ($self, $charset_name, $doc) = @_;
    my $self = ref $_[0] ? $_[0] : $_[0]->new;
    my $doc = $self->{document} = $_[2];
    
    $self->{chars_pull_next} = sub { 1 };
    $self->{restart_parser} = sub {
      $self->{embedded_encoding_name} = $_[0];
      return 1;
    };
    
    my $onerror = $self->onerror;
    $self->{parse_error} = sub {
      $onerror->(line => $self->{line}, column => $self->{column}, @_);
    };
  
    $self->{byte_buffer} = '';
    $self->{byte_buffer_orig} = '';
  
    $self->_parse_bytes_start_parsing
        (transport_encoding_name => $_[1],
         no_body_data_yet => 1);
  } # parse_bytes_start
  
  sub _parse_bytes_start_parsing ($;%) {
    my ($self, %args) = @_;
    @{$self->{document}->child_nodes} = ();
    $self->{line_prev} = $self->{line} = 1;
    $self->{column_prev} = -1;
    $self->{column} = 0;
    $self->{chars} = [];
    $self->{chars_pos} = 0;
    delete $self->{chars_was_cr};
    
    $self->_encoding_sniffing
        (embedded_encoding_name => delete $self->{embedded_encoding_name},
         transport_encoding_name => $args{transport_encoding_name},
         no_body_data_yet => $args{no_body_data_yet},
         read_head => sub {
           return \($self->{byte_buffer});
       });
    if (not $self->{input_encoding} and $args{no_body_data_yet}) {
      delete $self->{parse_bytes_started};
      return;
    }
  
    $self->{parse_bytes_started} = 1;
    
    $self->{document}->input_encoding ($self->{input_encoding});
    
    $self->_initialize_tokenizer;
    $self->_initialize_tree_constructor;
  
    push @{$self->{chars}}, split //,
        decode $self->{input_encoding}, $self->{byte_buffer},
            Encode::FB_QUIET;
    $self->{t} = $self->_get_next_token;
    $self->_construct_tree;
    if ($self->{embedded_encoding_name}) {
      ## Restarting
      $self->_parse_bytes_start_parsing;
    }
  } # _parse_bytes_start_parsing
  
  ## The $args{start_parsing} flag should be set true if it has taken
  ## more than 500ms from the start of overall parsing process.
  sub parse_bytes_feed ($$;%) {
    my ($self, undef, %args) = @_;
  
    if ($self->{parse_bytes_started}) {
      $self->{byte_buffer} .= $_[1];
      $self->{byte_buffer_orig} .= $_[1];
      $self->{chars}
          = [split //, decode $self->{input_encoding}, $self->{byte_buffer},
                           Encode::FB_QUIET];
      $self->{chars_pos} = 0;
      my $i = 0;
      if (length $self->{byte_buffer} and @{$self->{chars}} == $i) {
        substr ($self->{byte_buffer}, 0, 1) = '';
        push @{$self->{chars}}, "\x{FFFD}", split //,
            decode $self->{input_encoding}, $self->{byte_buffer},
                Encode::FB_QUIET;
        $i++;
      }
      
      $self->{t} = $self->_get_next_token;
      $self->_construct_tree;
      if ($self->{embedded_encoding_name}) {
        ## Restarting the parser
        $self->_parse_bytes_start_parsing;
      }
    } else {
      $self->{byte_buffer} .= $_[1];
      $self->{byte_buffer_orig} .= $_[1];
      if ($args{start_parsing} or 1024 <= length $self->{byte_buffer}) {
        $self->_parse_bytes_start_parsing;
      }
    }
  } # parse_bytes_feed
  
  sub parse_bytes_end {
    my $self = $_[0];
    unless ($self->{parse_bytes_started}) {
      $self->_parse_bytes_start_parsing;
    }
  
    if (length $self->{byte_buffer}) {
      push @{$self->{chars}},
          split //, decode $self->{input_encoding}, $self->{byte_buffer};
      $self->{byte_buffer} = '';
    }
    $self->{chars_pull_next} = sub { 0 };
    $self->{t} = $self->_get_next_token;
    $self->_construct_tree;
    if ($self->{embedded_encoding_name}) {
      ## Restarting the parser
      $self->_parse_bytes_start_parsing;
    }
  
    $self->_terminate_tree_constructor;
    $self->_clear_refs;
  } # parse_bytes_end
  
  ## ------ Insertion modes ------
  
  sub AFTER_HTML_IMS () { 0b100 }
  sub HEAD_IMS ()       { 0b1000 }
  sub BODY_IMS ()       { 0b10000 }
  sub BODY_TABLE_IMS () { 0b100000 }
  sub TABLE_IMS ()      { 0b1000000 }
  sub ROW_IMS ()        { 0b10000000 }
  sub BODY_AFTER_IMS () { 0b100000000 }
  sub FRAME_IMS ()      { 0b1000000000 }
  sub SELECT_IMS ()     { 0b10000000000 }
  sub IN_CDATA_RCDATA_IM () { 0b1000000000000 }
      ## NOTE: "in CDATA/RCDATA" insertion mode is also special; it is
      ## combined with the original insertion mode.  In thie parser,
      ## they are stored together in the bit-or'ed form.
  
  sub IM_MASK () { 0b11111111111 }
  
  ## NOTE: These insertion modes are special.
  sub INITIAL_IM () { -1 }
  sub BEFORE_HTML_IM () { -2 }
  
  ## NOTE: "after after body" insertion mode.
  sub AFTER_HTML_BODY_IM () { AFTER_HTML_IMS | BODY_AFTER_IMS }
  
  ## NOTE: "after after frameset" insertion mode.
  sub AFTER_HTML_FRAMESET_IM () { AFTER_HTML_IMS | FRAME_IMS }
  
  sub IN_HEAD_IM () { HEAD_IMS | 0b00 }
  sub IN_HEAD_NOSCRIPT_IM () { HEAD_IMS | 0b01 }
  sub AFTER_HEAD_IM () { HEAD_IMS | 0b10 }
  sub BEFORE_HEAD_IM () { HEAD_IMS | 0b11 }
  sub IN_BODY_IM () { BODY_IMS }
  sub IN_CELL_IM () { BODY_IMS | BODY_TABLE_IMS | 0b01 }
  sub IN_CAPTION_IM () { BODY_IMS | BODY_TABLE_IMS | 0b10 }
  sub IN_ROW_IM () { TABLE_IMS | ROW_IMS | 0b01 }
  sub IN_TABLE_BODY_IM () { TABLE_IMS | ROW_IMS | 0b10 }
  sub IN_TABLE_IM () { TABLE_IMS }
  sub AFTER_BODY_IM () { BODY_AFTER_IMS }
  sub IN_FRAMESET_IM () { FRAME_IMS | 0b01 }
  sub AFTER_FRAMESET_IM () { FRAME_IMS | 0b10 }
  sub IN_SELECT_IM () { SELECT_IMS | 0b01 }
  sub IN_SELECT_IN_TABLE_IM () { SELECT_IMS | 0b10 }
  sub IN_COLUMN_GROUP_IM () { 0b10 }
  
  
  
  sub _initialize_tree_constructor ($) {
    my $self = shift;
    ## NOTE: $self->{document} MUST be specified before this method is called
    $self->{document}->strict_error_checking (0);
    ## TODO: Turn mutation events off # MUST
    ## TODO: Turn loose Document option (manakai extension) on
    $self->{document}->manakai_is_html (1); # MUST
    $self->{document}->set_user_data (manakai_source_line => 1);
    $self->{document}->set_user_data (manakai_source_column => 1);
  
    $self->{frameset_ok} = 1;
    delete $self->{active_formatting_elements};
    delete $self->{insert};
    delete $self->{open_tables};
  
    $self->{insertion_mode} = INITIAL_IM;
    undef $self->{form_element};
    undef $self->{head_element};
    $self->{open_elements} = [];
    undef $self->{inner_html_node};
    undef $self->{ignore_newline};
  } # _initialize_tree_constructor
  
  sub _terminate_tree_constructor ($) {
    my $self = shift;
    $self->{document}->strict_error_checking (1);
    delete $self->{active_formatting_elements};
    delete $self->{insert};
    delete $self->{open_tables};
    ## TODO: Turn mutation events on
  } # _terminate_tree_constructor
  
  ## ISSUE: Should append_child (for example) in script executed in tree construction stage fire mutation events?
  
  ## When an interactive UA render the $self->{document} available to
  ## the user, or when it begin accepting user input, are not defined.
  
  sub _reset_insertion_mode ($) {
    my $self = shift;
  
    ## Step 1
    my $last;
    
    ## Step 2
    my $i = -1;
    my $node = $self->{open_elements}->[$i];
      
    ## LOOP: Step 3
    LOOP: {
      if ($self->{open_elements}->[0]->[0] eq $node->[0]) {
        $last = 1;
        if (defined $self->{inner_html_node}) {
          
          $node = $self->{inner_html_node};
        } else {
          die "_reset_insertion_mode: t27";
        }
      }
      
      ## Step 4..13
      my $new_mode;
      if ($node->[1] == TABLE_CELL_EL) {
        if ($last) {
          
          #
        } else {
          
          $new_mode = IN_CELL_IM;
        } 
      } elsif ($node->[1] & FOREIGN_EL) {
        #
      } else {
        
        $new_mode = {
          select => IN_SELECT_IM,
          ## NOTE: |option| and |optgroup| do not set insertion mode to
          ## "in select" by themselves.
          tr => IN_ROW_IM,
          tbody => IN_TABLE_BODY_IM,
          thead => IN_TABLE_BODY_IM,
          tfoot => IN_TABLE_BODY_IM,
          caption => IN_CAPTION_IM,
          colgroup => IN_COLUMN_GROUP_IM,
          table => IN_TABLE_IM,
          head => IN_BODY_IM, # not in head!
          body => IN_BODY_IM,
          frameset => IN_FRAMESET_IM,
        }->{$node->[0]->manakai_local_name};
      }
      $self->{insertion_mode} = $new_mode and last LOOP if defined $new_mode;
      
      ## Step 14
      if ($node->[1] == HTML_EL) {
        ## NOTE: Commented out in the spec (HTML5 revision 3894).
        #unless (defined $self->{head_element}) {
          
          $self->{insertion_mode} = BEFORE_HEAD_IM;
        #} else {
          
        #  $self->{insertion_mode} = AFTER_HEAD_IM;
        #}
        last LOOP;
      } else {
        
      }
      
      ## Step 15
      $self->{insertion_mode} = IN_BODY_IM and last LOOP if $last;
      
      ## Step 16
      $i--;
      $node = $self->{open_elements}->[$i];
      
      ## Step 17
      redo LOOP;
    } # LOOP
    
    ## END
  } # _reset_insertion_mode
  
    my $parse_rcdata = sub ($$$$) {
      my ($self, $insert, $open_tables, $parse_refs) = @_;
  
      ## Step 1
      my $start_tag_name = $self->{t}->{tag_name};
      
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
  
      ## Step 2
      if ($parse_refs) {
        $self->{state} = RCDATA_STATE;
      } else {
        $self->{state} = RAWTEXT_STATE;
      }
      delete $self->{escape}; # MUST
  
      ## Step 3, 4
      $self->{insertion_mode} |= IN_CDATA_RCDATA_IM;
  
      
      $self->{t} = $self->_get_next_token;
    }; # $parse_rcdata
  
    my $script_start_tag = sub ($$$) {
      my ($self, $insert, $open_tables) = @_;
  
      ## Step 1
      my $script_el;
      
        $script_el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'script']);
      
          for my $attr_name (keys %{ $self->{t}->{attributes}}) {
            my $attr_t =  $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $script_el->set_attribute_node_ns ($attr);
          }
        
          $script_el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $script_el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
  
      ## Step 2
      ## TODO: mark as "parser-inserted"
  
      ## Step 3
      ## TODO: Mark as "already executed", if ...
  
      ## Step 4 (HTML5 revision 2702)
      $insert->($self, $script_el, $open_tables);
      push @{$self->{open_elements}}, [$script_el, $el_category->{script}];
  
      ## Step 5
      $self->{state} = SCRIPT_DATA_STATE;
      delete $self->{escape}; # MUST
  
      ## Step 6-7
      $self->{insertion_mode} |= IN_CDATA_RCDATA_IM;
  
      
      $self->{t} = $self->_get_next_token;
    }; # $script_start_tag
  
  sub push_afe ($$) {
    my ($item => $afes) = @_;
    my $item_token = $item->[2];
  
    my $depth = 0;
    OUTER: for my $i (reverse 0..$#$afes) {
      my $afe = $afes->[$i];
      if ($afe->[0] eq '#marker') {
        last OUTER;
      } else {
        my $afe_token = $afe->[2];
        ## Both |$afe_token| and |$item_token| should be start tag tokens.
        if ($afe_token->{tag_name} eq $item_token->{tag_name}) {
          if ((keys %{$afe_token->{attributes}}) !=
              (keys %{$item_token->{attributes}})) {
            next OUTER;
          }
          for my $attr_name (keys %{$item_token->{attributes}}) {
            next OUTER unless $afe_token->{attributes}->{$attr_name};
            next OUTER unless
                $afe_token->{attributes}->{$attr_name}->{value} eq 
                $item_token->{attributes}->{$attr_name}->{value};
          }
  
          $depth++;
          if ($depth == 3) {
            splice @$afes, $i, 1 => ();
            last OUTER;
          }
        }
  
        ## We don't have to check namespaces of elements and attributes,
        ##  nevertheless the spec requires it, because |$afes| could
        ##  never contain a non-HTML element at the time of writing.  In
        ##  addition, scripted changes would never change the original
        ##  start tag token.
      }
    } # OUTER
  
    push @$afes, $item;
  } # push_afe
  
    my $formatting_end_tag = sub {
      my ($self, $active_formatting_elements, $open_tables, $end_tag_token) = @_;
      my $tag_name = $end_tag_token->{tag_name};
  
      ## NOTE: The adoption agency algorithm (AAA).
  
      ## Step 1
      my $outer_loop_counter = 0;
  
      ## Step 2
      OUTER: {
        if ($outer_loop_counter >= 8) {
          $self->{t} = $self->_get_next_token;
          last OUTER;
        }
  
        ## Step 3
        $outer_loop_counter++;
        
        ## Step 4
        my $formatting_element;
        my $formatting_element_i_in_active;
        AFE: for (reverse 0..$#$active_formatting_elements) {
          if ($active_formatting_elements->[$_]->[0] eq '#marker') {
            
            last AFE;
          } elsif ($active_formatting_elements->[$_]->[0]->manakai_local_name
                       eq $tag_name) {
            ## NOTE: Non-HTML elements can't be in the list of active
            ## formatting elements.
            
            $formatting_element = $active_formatting_elements->[$_];
            $formatting_element_i_in_active = $_;
            last AFE;
          }
        } # AFE
        unless (defined $formatting_element) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag', text => $tag_name, token => $end_tag_token);
          ## Ignore the token
          $self->{t} = $self->_get_next_token;
          return;
        }
        ## has an element in scope
        my $in_scope = 1;
        my $formatting_element_i_in_open;  
        INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[0] eq $formatting_element->[0]) {
            if ($in_scope) {
              
              $formatting_element_i_in_open = $_;
              last INSCOPE;
            } else { # in open elements but not in scope
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => $self->{t}->{tag_name},
                              token => $end_tag_token);
              ## Ignore the token
              $self->{t} = $self->_get_next_token;
              return;
            }
          } elsif ($node->[1] & SCOPING_EL) {
            
            $in_scope = 0;
          }
        } # INSCOPE
        unless (defined $formatting_element_i_in_open) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                          text => $self->{t}->{tag_name},
                          token => $end_tag_token);
          pop @$active_formatting_elements; # $formatting_element
          $self->{t} = $self->_get_next_token; ## TODO: ok?
          return;
        }
        if (not $self->{open_elements}->[-1]->[0] eq $formatting_element->[0]) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                          text => $self->{open_elements}->[-1]->[0]
                              ->manakai_local_name,
                          token => $end_tag_token);
        }
        
        ## Step 5
        my $furthest_block;
        my $furthest_block_i_in_open;
        OE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[1] & SPECIAL_EL or $node->[1] & SCOPING_EL) { ## "Special"
            
            $furthest_block = $node;
            $furthest_block_i_in_open = $_;
  	  ## NOTE: The topmost (eldest) node.
          } elsif ($node->[0] eq $formatting_element->[0]) {
            
            last OE;
          }
        } # OE
        
        ## Step 6
        unless (defined $furthest_block) { # MUST
          
          splice @{$self->{open_elements}}, $formatting_element_i_in_open;
          splice @$active_formatting_elements, $formatting_element_i_in_active, 1;
          $self->{t} = $self->_get_next_token;
          return;
        }
        
        ## Step 7
        my $common_ancestor_node = $self->{open_elements}->[$formatting_element_i_in_open - 1];
        
        ## Step 8
        my $bookmark_prev_el
          = $active_formatting_elements->[$formatting_element_i_in_active - 1]
            ->[0];
        
        ## Step 9
        my $node = $furthest_block;
        my $node_i_in_open = $furthest_block_i_in_open;
        my $last_node = $furthest_block;
  
        ## Step 9.1
        my $inner_loop_counter = 0;
  
        INNER: {
          ## Step 9.2
          if ($inner_loop_counter >= 3) {
            $self->{t} = $self->_get_next_token;
            last OUTER;
          }
  
          ## Step 9.3
          $inner_loop_counter++;
  
          ## Step 9.4
          $node_i_in_open--;
          $node = $self->{open_elements}->[$node_i_in_open];
          
          ## Step 9.5
          my $node_i_in_active;
          my $node_token;
          S7S2: {
            for (reverse 0..$#$active_formatting_elements) {
              if ($active_formatting_elements->[$_]->[0] eq $node->[0]) {
                
                $node_i_in_active = $_;
                $node_token = $active_formatting_elements->[$_]->[2];
                last S7S2;
              }
            }
            splice @{$self->{open_elements}}, $node_i_in_open, 1;
            redo INNER;
          } # S7S2
          
          ## Step 9.6
          last INNER if $node->[0] eq $formatting_element->[0];
          
          ## Step 9.7
          my $new_element = [];
          
        $new_element->[0] = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $node_token->{tag_name}]);
      
          for my $attr_name (keys %{ $node_token->{attributes}}) {
            my $attr_t =  $node_token->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $new_element->[0]->set_attribute_node_ns ($attr);
          }
        
          $new_element->[0]->set_user_data (manakai_source_line => $node_token->{line})
              if defined $node_token->{line};
          $new_element->[0]->set_user_data (manakai_source_column => $node_token->{column})
              if defined $node_token->{column};
        
          $new_element->[1] = $node->[1];
          $new_element->[2] = $node_token;
          $active_formatting_elements->[$node_i_in_active] = $new_element;
          $self->{open_elements}->[$node_i_in_open] = $new_element;
          $node = $new_element;
          
          ## Step 9.8
          if ($last_node->[0] eq $furthest_block->[0]) {
            
            $bookmark_prev_el = $node->[0];
          }
          
          ## Step 9.9
          $node->[0]->append_child ($last_node->[0]);
          
          ## Step 9.10
          $last_node = $node;
          
          ## Step 9.11
          redo INNER;
        } # INNER
        
        ## Step 10
        if ($common_ancestor_node->[1] & TABLE_ROWS_EL) {
          ## Foster parenting.
          my $foster_parent_element;
          my $next_sibling;
          OE: for (reverse 0..$#{$self->{open_elements}}) {
            if ($self->{open_elements}->[$_]->[1] == TABLE_EL) {
              
              $foster_parent_element = $self->{open_elements}->[$_ - 1]->[0];
              $next_sibling = $self->{open_elements}->[$_]->[0];
              undef $next_sibling
                  unless $next_sibling->parent_node eq $foster_parent_element;
              last OE;
            }
          } # OE
          $foster_parent_element ||= $self->{open_elements}->[0]->[0];
  
          $foster_parent_element->insert_before ($last_node->[0], $next_sibling);
          $open_tables->[-1]->[1] = 1; # tainted
        } else {
          
          $common_ancestor_node->[0]->append_child ($last_node->[0]);
        }
        
        ## Step 11
        my $new_element = [];
        
        $new_element->[0] = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $formatting_element->[2]->{tag_name}]);
      
          for my $attr_name (keys %{ $formatting_element->[2]->{attributes}}) {
            my $attr_t =  $formatting_element->[2]->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $new_element->[0]->set_attribute_node_ns ($attr);
          }
        
          $new_element->[0]->set_user_data (manakai_source_line => $formatting_element->[2]->{line})
              if defined $formatting_element->[2]->{line};
          $new_element->[0]->set_user_data (manakai_source_column => $formatting_element->[2]->{column})
              if defined $formatting_element->[2]->{column};
        
        $new_element->[1] = $formatting_element->[1];
        $new_element->[2] = $formatting_element->[2];
        
        ## Step 12
        $new_element->[0]->append_child ($_)
            for $furthest_block->[0]->child_nodes->to_list;
        
        ## Step 13
        $furthest_block->[0]->append_child ($new_element->[0]);
        
        ## Step 14
        my $i;
        AFE: for (reverse 0..$#$active_formatting_elements) {
          if ($active_formatting_elements->[$_]->[0] eq $formatting_element->[0]) {
            
            splice @$active_formatting_elements, $_, 1;
            $i-- and last AFE if defined $i;
          } elsif ($active_formatting_elements->[$_]->[0] eq $bookmark_prev_el) {
            
            $i = $_;
          }
        } # AFE
        splice @$active_formatting_elements, $i + 1, 0 => $new_element;
        
        ## Step 15
        undef $i;
        OE: for (reverse 0..$#{$self->{open_elements}}) {
          if ($self->{open_elements}->[$_]->[0] eq $formatting_element->[0]) {
            
            splice @{$self->{open_elements}}, $_, 1;
            $i-- and last OE if defined $i;
          } elsif ($self->{open_elements}->[$_]->[0] eq $furthest_block->[0]) {
            
            $i = $_;
          }
        } # OE
        splice @{$self->{open_elements}}, $i + 1, 0, $new_element;
        
        ## Step 16
        redo OUTER;
      } # OUTER
    }; # $formatting_end_tag
  
    my $reconstruct_active_formatting_elements = sub ($$$$) {
      my ($self, $insert, $active_formatting_elements, $open_tables) = @_;
  
      ## Step 1
      return unless @$active_formatting_elements;
  
      ## Step 3
      my $i = -1;
      my $entry = $active_formatting_elements->[$i];
  
      ## Step 2
      return if $entry->[0] eq '#marker';
      for (@{$self->{open_elements}}) {
        if ($entry->[0] eq $_->[0]) {
          
          return;
        }
      }
      
      S4: {
        ## Step 4
        last S4 if $active_formatting_elements->[0]->[0] eq $entry->[0];
  
        ## Step 5
        $i--;
        $entry = $active_formatting_elements->[$i];
  
        ## Step 6
        if ($entry->[0] eq '#marker') {
          
          #
        } else {
          my $in_open_elements;
          OE: for (@{$self->{open_elements}}) {
            if ($entry->[0] eq $_->[0]) {
              
              $in_open_elements = 1;
              last OE;
            }
          }
          if ($in_open_elements) {
            
            #
          } else {
            ## NOTE: <!DOCTYPE HTML><p><b><i><u></p> <p>X
            
            redo S4;
          }
        }
  
        ## Step 7
        $i++;
        $entry = $active_formatting_elements->[$i];
      } # S4
  
      S7: {
        ## Step 8
        my $clone = [$entry->[0]->clone_node (0), $entry->[1], $entry->[2]];
      
        ## Step 9
        $insert->($self, $clone->[0], $open_tables);
        push @{$self->{open_elements}}, $clone;
        
        ## Step 10
        $active_formatting_elements->[$i] = $self->{open_elements}->[-1];
  
        ## Step 11
        unless ($clone->[0] eq $active_formatting_elements->[-1]->[0]) {
          
          ## Step 7'
          $i++;
          $entry = $active_formatting_elements->[$i];
          
          redo S7;
        }
  
        
      } # S7
    }; # $reconstruct_active_formatting_elements
  
    my $clear_up_to_marker = sub ($) {
      my $active_formatting_elements = $_[0];
      for (reverse 0..$#$active_formatting_elements) {
        if ($active_formatting_elements->[$_]->[0] eq '#marker') {
          
          splice @$active_formatting_elements, $_;
          return;
        }
      }
  
      
    }; # $clear_up_to_marker
    my $insert_to_current = sub {
      #my ($self, $child, $open_tables) = @_;
      $_[0]->{open_elements}->[-1]->[0]->append_child ($_[1]);
    }; # $insert_to_current
  
    ## Foster parenting.  Note that there are three "foster parenting"
    ## code in the parser: for elements (this one), for texts, and for
    ## elements in the AAA code.
    my $insert_to_foster = sub {
      my ($self, $child, $open_tables) = @_;
      if ($self->{open_elements}->[-1]->[1] & TABLE_ROWS_EL) {
        # MUST
        my $foster_parent_element;
        my $next_sibling;
        OE: for (reverse 0..$#{$self->{open_elements}}) {
          if ($self->{open_elements}->[$_]->[1] == TABLE_EL) {
            
            $foster_parent_element = $self->{open_elements}->[$_ - 1]->[0];
            $next_sibling = $self->{open_elements}->[$_]->[0];
            undef $next_sibling
                unless $next_sibling->parent_node eq $foster_parent_element;
            last OE;
          }
        } # OE
        $foster_parent_element ||= $self->{open_elements}->[0]->[0];
  
        $foster_parent_element->insert_before ($child, $next_sibling);
        $open_tables->[-1]->[1] = 1; # tainted
      } else {
        
        $self->{open_elements}->[-1]->[0]->append_child ($child);
      }
    }; # $insert_to_foster
  
  sub _construct_tree ($) {
    my $self = $_[0];
  
    ## "List of active formatting elements".  Each item in this array is
    ## an array reference, which contains: [0] - the element node; [1] -
    ## the local name of the element; [2] - the token that is used to
    ## create [0].
    my $active_formatting_elements = $self->{active_formatting_elements} ||= [];
  
    my $insert = $self->{insert} ||= $insert_to_current;
  
    ## NOTE: $open_tables->[-1]->[0] is the "current table" element node.
    ## NOTE: $open_tables->[-1]->[1] is the "tainted" flag (OBSOLETE; unused).
    ## NOTE: $open_tables->[-1]->[2] is set false when non-Text node inserted.
    my $open_tables = $self->{open_tables} ||= [];
  
    B: while (1) {
      
  
      if ($self->{t}->{type} == ABORT_TOKEN) {
        return;
      }
  
      if ($self->{t}->{n}++ == 100) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'parser impl error', # XXXtest
                        token => $self->{t});
        require Data::Dumper;
        warn "====== HTML Parser Error ======\n";
        warn join (' ', map { $_->[0]->manakai_local_name } @{$self->{open_elements}}) . ' #' . $self->{insertion_mode} . "\n";
        warn Data::Dumper::Dumper ($self->{t});
        $self->{t} = $self->_get_next_token;
        next B;
      }
  
      if ($self->{insertion_mode} == INITIAL_IM) {
        if ($self->{t}->{type} == DOCTYPE_TOKEN) {
          ## NOTE: Conformance checkers MAY, instead of reporting "not
          ## HTML5" error, switch to a conformance checking mode for
          ## another language.  (We don't support such mode switchings;
          ## it is nonsense to do anything different from what browsers
          ## do.)
          my $doctype_name = $self->{t}->{name};
          $doctype_name = '' unless defined $doctype_name;
          my $doctype = $self->{document}->create_document_type_definition
              ($doctype_name);
          
          if ($doctype_name ne 'html') {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'not HTML5', token => $self->{t});
          } elsif (defined $self->{t}->{pubid}) {
            ## Obsolete permitted DOCTYPEs (case-sensitive)
            my $xsysid = $Whatpm::HTML::ParserData::ObsoletePermittedDoctypes
                ->{$self->{t}->{pubid}};
            if (defined $xsysid and
                ((not defined $self->{t}->{sysid} and
                  $self->{t}->{pubid} =~ /HTML 4/) or
                 (defined $self->{t}->{sysid} and
                  $self->{t}->{sysid} eq $xsysid))) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'obs DOCTYPE', token => $self->{t},
                              level => $self->{level}->{obsconforming});
            } else {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'not HTML5', token => $self->{t});
            }
          } elsif (defined $self->{t}->{sysid}) {
            if ($self->{t}->{sysid} eq 'about:legacy-compat') {
              ## <!DOCTYPE HTML SYSTEM "about:legacy-compat">
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'XSLT-compat', token => $self->{t},
                              level => $self->{level}->{should});
            } else {
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'not HTML5', token => $self->{t});
            }
          } else { ## <!DOCTYPE HTML>
            
            #
          }
          
          ## NOTE: Default value for both |public_id| and |system_id|
          ## attributes are empty strings, so that we don't set any
          ## value in missing cases.
          $doctype->public_id ($self->{t}->{pubid})
              if defined $self->{t}->{pubid};
          $doctype->system_id ($self->{t}->{sysid})
              if defined $self->{t}->{sysid};
          
          ## NOTE: Other DocumentType attributes are null or empty
          ## lists.  In Firefox3, |internalSubset| attribute is set to
          ## the empty string, while |null| is an allowed value for the
          ## attribute according to DOM3 Core.
  
          $self->{document}->append_child ($doctype);
          
          ## Resetting the quirksness.  Not in the spec, but this has to
          ## be done for reusing Document object (or for
          ## |document.open|).
          $self->{document}->manakai_compat_mode ('no quirks');
          
          if ($self->{t}->{quirks} or $doctype_name ne 'html') {
            
            $self->{document}->manakai_compat_mode ('quirks');
          } elsif (defined $self->{t}->{pubid}) {
            my $pubid = $self->{t}->{pubid};
            $pubid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
            my $prefix = $Whatpm::HTML::ParserData::QuirkyPublicIDPrefixes;
            my $match;
            for (@$prefix) {
              if (substr ($pubid, 0, length $_) eq $_) {
                $match = 1;
                last;
              }
            }
            if ($match or
                $Whatpm::HTML::ParserData::QuirkyPublicIDs->{$pubid}) {
              
              $self->{document}->manakai_compat_mode ('quirks');
            } elsif ($pubid =~ m[^-//W3C//DTD HTML 4.01 FRAMESET//] or
                     $pubid =~ m[^-//W3C//DTD HTML 4.01 TRANSITIONAL//]) {
              if (not defined $self->{t}->{sysid}) {
                
                $self->{document}->manakai_compat_mode ('quirks');
              } else {
                
                $self->{document}->manakai_compat_mode ('limited quirks');
              }
            } elsif ($pubid =~ m[^-//W3C//DTD XHTML 1.0 FRAMESET//] or
                     $pubid =~ m[^-//W3C//DTD XHTML 1.0 TRANSITIONAL//]) {
              
              $self->{document}->manakai_compat_mode ('limited quirks');
            } else {
              
            }
          } else {
            
          }
          if (defined $self->{t}->{sysid}) {
            my $sysid = $self->{t}->{sysid};
            $sysid =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($sysid eq "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd") {
              ## NOTE: Ensure that |PUBLIC "(limited quirks)"
              ## "(quirks)"| is signaled as in quirks mode!
              $self->{document}->manakai_compat_mode ('quirks');
              
            } else {
              
            }
          } else {
            
          }
          
          $self->{insertion_mode} = BEFORE_HTML_IM;
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ({
                  START_TAG_TOKEN, 1,
                  END_TAG_TOKEN, 1,
                  END_OF_FILE_TOKEN, 1,
                 }->{$self->{t}->{type}}) {
          unless ($self->{document}->manakai_is_srcdoc) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no DOCTYPE', token => $self->{t});
            $self->{document}->manakai_compat_mode ('quirks');
          } else {
            
          }
          $self->{insertion_mode} = BEFORE_HTML_IM;
          ## Reprocess the token.
          
          redo B;
        } elsif ($self->{t}->{type} == CHARACTER_TOKEN) {
          if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            ## Ignore the token
            
            unless (length $self->{t}->{data}) {
              
              ## Stay in the insertion mode.
              $self->{t} = $self->_get_next_token;
              redo B;
            } else {
              
            }
          } else {
            
          }
          
          unless ($self->{document}->manakai_is_srcdoc) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no DOCTYPE', token => $self->{t});
            $self->{document}->manakai_compat_mode ('quirks');
          } else {
            
          }
          $self->{insertion_mode} = BEFORE_HTML_IM;
          ## Reprocess the token.
          redo B;
        } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
          
          my $comment = $self->{document}->create_comment
              ($self->{t}->{data});
          $self->{document}->append_child ($comment);
          
          ## Stay in the insertion mode.
          $self->{t} = $self->_get_next_token;
          next B;
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
      } elsif ($self->{insertion_mode} == BEFORE_HTML_IM) {
        if ($self->{t}->{type} == DOCTYPE_TOKEN) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'in html:#DOCTYPE', token => $self->{t});
          ## Ignore the token.
          $self->{t} = $self->_get_next_token;
          redo B;
        } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
          
          my $comment = $self->{document}->create_comment
              ($self->{t}->{data});
          $self->{document}->append_child ($comment);
          $self->{t} = $self->_get_next_token;
          redo B;
        } elsif ($self->{t}->{type} == CHARACTER_TOKEN) {
          if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            ## Ignore the token.
            
            unless (length $self->{t}->{data}) {
              
              $self->{t} = $self->_get_next_token;
              redo B;
            } else {
              
            }
          } else {
            
          }
          
          $self->{application_cache_selection}->(undef);
          
          #
        } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
          if ($self->{t}->{tag_name} eq 'html') {
            my $root_element;
            
        $root_element = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{ $self->{t}->{attributes}}) {
            my $attr_t =  $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $root_element->set_attribute_node_ns ($attr);
          }
        
          $root_element->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $root_element->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
            $self->{document}->append_child ($root_element);
            push @{$self->{open_elements}},
                [$root_element, $el_category->{html}];
            
            if ($self->{t}->{attributes}->{manifest}) {
              
              ## XXX resolve URL and drop fragment
              ## <http://html5.org/tools/web-apps-tracker?from=3479&to=3480>
              ## <http://manakai.g.hatena.ne.jp/task/2/95>
              $self->{application_cache_selection}
                   ->($self->{t}->{attributes}->{manifest}->{value});
            } else {
              
              $self->{application_cache_selection}->(undef);
            }
            
            
            
            $self->{t} = $self->_get_next_token;
            $self->{insertion_mode} = BEFORE_HEAD_IM;
            next B;
          } else {
            
            #
          }
        } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
          if ({
               head => 1, body => 1, html => 1, br => 1,
              }->{$self->{t}->{tag_name}}) {
            
            #
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name},
                            token => $self->{t});
            ## Ignore the token.
            $self->{t} = $self->_get_next_token;
            redo B;
          }
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          
          #
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
        
        my $root_element;
        
        $root_element = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'html']);
      
          $root_element->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $root_element->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{document}->append_child ($root_element);
        push @{$self->{open_elements}},
            [$root_element, $el_category->{html}];
        push @$open_tables, [[$root_element]];
        
        $self->{application_cache_selection}->(undef);
        
        ## Reprocess the token.
        
        $self->{insertion_mode} = BEFORE_HEAD_IM;
        redo B;
      } # insertion mode
  
      if (
        (not @{$self->{open_elements}}) or
        (not $self->{open_elements}->[-1]->[1] & FOREIGN_EL) or ## HTML element
        ($self->{open_elements}->[-1]->[1] == MML_TEXT_INTEGRATION_EL and
         (($self->{t}->{type} == START_TAG_TOKEN and
           $self->{t}->{tag_name} ne 'mglyph' and
           $self->{t}->{tag_name} ne 'malignmark') or
          $self->{t}->{type} == CHARACTER_TOKEN)) or
        ($self->{open_elements}->[-1]->[1] & MML_AXML_EL and
         $self->{t}->{type} == START_TAG_TOKEN and
         $self->{t}->{tag_name} eq 'svg') or
        ( ## If the current node is an HTML integration point (other
          ## than |annotation-xml|).
         $self->{open_elements}->[-1]->[1] == SVG_INTEGRATION_EL and
         ($self->{t}->{type} == START_TAG_TOKEN or
          $self->{t}->{type} == CHARACTER_TOKEN)) or
        ( ## If the current node is an |annotation-xml| whose |encoding|
          ## is |text/html| or |application/xhtml+xml| (HTML integration
          ## point).
         $self->{open_elements}->[-1]->[1] == MML_AXML_EL and
         ($self->{t}->{type} == START_TAG_TOKEN or
          $self->{t}->{type} == CHARACTER_TOKEN) and
         do {
           my $encoding = $self->{open_elements}->[-1]->[0]->get_attribute_ns (undef, 'encoding') || '';
           $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
           if ($encoding eq 'text/html' or 
               $encoding eq 'application/xhtml+xml') {
             1;
           } else {
             0;
           }
         }) or
        ($self->{t}->{type} == END_OF_FILE_TOKEN)) {
        
        ## Use the rules for the current insertion mode in HTML content.
        #
      } else {
        ## Use the rules for the foreign content.
  
        if ($self->{t}->{type} == CHARACTER_TOKEN) {
          ## "In foreign content", character tokens.
          my $data = $self->{t}->{data};
          while ($data =~ s/\x00/\x{FFFD}/) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL', token => $self->{t});
          }
          $self->{open_elements}->[-1]->[0]->manakai_append_text ($data);
          if ($data =~ /[^\x09\x0A\x0C\x0D\x20]/) {
            delete $self->{frameset_ok};
          }
          
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
          ## "In foreign content", start tag token.
  
          if (
            $Whatpm::HTML::ParserData::ForeignContentBreakers->{$self->{t}->{tag_name}} or
            ($self->{t}->{tag_name} eq 'font' and
             ($self->{t}->{attributes}->{color} or
              $self->{t}->{attributes}->{face} or
              $self->{t}->{attributes}->{size}))
          ) {
            ## "In foreign content", HTML-only start tag.
            
  
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                            text => $self->{open_elements}->[-1]->[0]
                                ->manakai_local_name,
                            token => $self->{t});
  
            pop @{$self->{open_elements}};
            V: {
              my $current_node = $self->{open_elements}->[-1];
              if (
                ## An HTML element.
                not $current_node->[1] & FOREIGN_EL or
  
                ## An MathML text integration point.
                $current_node->[1] == MML_TEXT_INTEGRATION_EL or
                
                ## An HTML integration point.
                $current_node->[1] == SVG_INTEGRATION_EL or
                ($current_node->[1] == MML_AXML_EL and
                 do {
                   my $encoding = $current_node->[0]->get_attribute_ns (undef, 'encoding') || '';
                   $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
                   ($encoding eq 'text/html' or
                    $encoding eq 'application/xhtml+xml');
                 })
              ) {
                last V;
              }
              
              pop @{$self->{open_elements}};
              redo V;
            }
            
            ## Reprocess the token.
            next B;
  
          } else {
            ## "In foreign content", foreign start tag.
  
            my $nsuri = $self->{open_elements}->[-1]->[0]->namespace_uri;
            my $tag_name = $self->{t}->{tag_name};
            if ($nsuri eq SVG_NS) {
              $tag_name = $Whatpm::HTML::ParserData::SVGElementNameFixup
                  ->{$tag_name} || $tag_name;
            }
  
            ## "adjust SVG attributes" (SVG only) - done in insert-element-f
  
            ## "adjust foreign attributes" - done in insert-element-f
  
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          ($nsuri, [undef,   $tag_name]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (
            @{
              $foreign_attr_xname->{$attr_name} ||
              [undef, [undef,
                       ($nsuri) eq SVG_NS ?
                           ($svg_attr_name->{$attr_name} || $attr_name) :
                       ($nsuri) eq MML_NS ?
                           ($mml_attr_name->{$attr_name} || $attr_name) :
                           $attr_name]]
            }
          );
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, ($el_category_f->{$nsuri}->{ $tag_name} || 0) | FOREIGN_EL | (($nsuri) eq SVG_NS ? SVG_EL : ($nsuri) eq MML_NS ? MML_EL : 0)];
  
        if ( $self->{t}->{attributes}->{xmlns} and  $self->{t}->{attributes}->{xmlns}->{value} ne ($nsuri)) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bad namespace', token =>  $self->{t});
  ## TODO: Error type documentation
        }
        if ( $self->{t}->{attributes}->{'xmlns:xlink'} and
             $self->{t}->{attributes}->{'xmlns:xlink'}->{value} ne q<http://www.w3.org/1999/xlink>) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bad namespace', token =>  $self->{t});
        }
      }
    
  
            if ($self->{self_closing}) {
              pop @{$self->{open_elements}};
              delete $self->{self_closing};
            } else {
              
            }
  
            $self->{t} = $self->_get_next_token;
            next B;
          }
  
        } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
          ## "In foreign content", end tag.
  
          if ($self->{t}->{tag_name} eq 'script' and
              $self->{open_elements}->[-1]->[1] == SVG_SCRIPT_EL) {
            ## "In foreign content", "script" end tag, if the current
            ## node is an SVG |script| element.
            
            pop @{$self->{open_elements}};
  
            ## XXXscript: Execute script here.
            $self->{t} = $self->_get_next_token;
            next B;
  
          } else {
            ## "In foreign content", end tag.
            
            
            ## 1.
            my $i = -1;
            my $node = $self->{open_elements}->[$i];
            
            ## 2.
            my $tag_name = $node->[0]->manakai_local_name;
            $tag_name =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($tag_name ne $self->{t}->{tag_name}) {
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => $self->{t}->{tag_name},
                              level => $self->{level}->{must});
            }
  
            ## 3.
            LOOP: {
              my $tag_name = $node->[0]->manakai_local_name;
              $tag_name =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($tag_name eq $self->{t}->{tag_name}) {
                splice @{$self->{open_elements}}, $i, -$i, ();
                $self->{t} = $self->_get_next_token;
                next B;
              }
              
              ## 4.
              $i--;
              $node = $self->{open_elements}->[$i];
  
              ## 5.
              if ($node->[1] & FOREIGN_EL) {
                redo LOOP;
              }
            } # LOOP
  
            ## Step 6 (Use the current insertion mode in HTML content)
            #
          }
  
        } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
          ## "In foreign content", comment token.
          my $comment = $self->{document}->create_comment ($self->{t}->{data});
          $self->{open_elements}->[-1]->[0]->append_child ($comment);
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{type} == DOCTYPE_TOKEN) {
          
          ## "In foreign content", DOCTYPE token.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'in html:#DOCTYPE', token => $self->{t});
          ## Ignore the token.
          $self->{t} = $self->_get_next_token;
          next B;
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";        
        }
      } # foreign
  
      ## The "in table text" insertion mode.
      if ($self->{insertion_mode} & TABLE_IMS and
          not $self->{insertion_mode} & IN_CDATA_RCDATA_IM) {
        C: {
          my $s;
          if ($self->{t}->{type} == CHARACTER_TOKEN) {
            
            $self->{pending_chars} ||= [];
            push @{$self->{pending_chars}}, $self->{t};
            $self->{t} = $self->_get_next_token;
            next B;
          } else {
            ## There is an "insert pending chars" code clone.
            if ($self->{pending_chars}) {
              $s = join '', map { $_->{data} } @{$self->{pending_chars}};
              delete $self->{pending_chars};
              while ($s =~ s/\x00//) {
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL', token => $self->{t});
              }
              if ($s eq '') {
                last C;
              } elsif ($s =~ /[^\x09\x0A\x0C\x0D\x20]/) {
                
                #
              } else {
                
                $self->{open_elements}->[-1]->[0]->manakai_append_text ($s);
                last C;
              }
            } else {
              
              last C;
            }
          }
  
          ## "in table" insertion mode, "Anything else".
  
          ## Foster parenting.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'in table:#text', token => $self->{t});
  
          ## NOTE: As if in body, but insert into the foster parent element.
          $reconstruct_active_formatting_elements
              ->($self, $insert_to_foster, $active_formatting_elements,
                 $open_tables);
              
          if ($self->{open_elements}->[-1]->[1] & TABLE_ROWS_EL) {
            # MUST
            my $foster_parent_element;
            my $next_sibling;
            OE: for (reverse 0..$#{$self->{open_elements}}) {
              if ($self->{open_elements}->[$_]->[1] == TABLE_EL) {
                
                $foster_parent_element = $self->{open_elements}->[$_ - 1]->[0];
                $next_sibling = $self->{open_elements}->[$_]->[0];
                undef $next_sibling
                  unless $next_sibling->parent_node eq $foster_parent_element;
                last OE;
              }
            } # OE
            $foster_parent_element ||= $self->{open_elements}->[0]->[0];
  
            
            $foster_parent_element->insert_before
                ($self->{document}->create_text_node ($s), $next_sibling);
  
            $open_tables->[-1]->[1] = 1; # tainted
            $open_tables->[-1]->[2] = 1; # ~node inserted
          } else {
            ## NOTE: Fragment case or in a foster parent'ed element
            ## (e.g. |<table><span>a|).  In fragment case, whether the
            ## character is appended to existing node or a new node is
            ## created is irrelevant, since the foster parent'ed nodes
            ## are discarded and fragment parsing does not invoke any
            ## script.
            
            $self->{open_elements}->[-1]->[0]->manakai_append_text ($s);
          }
        } # C
      } # TABLE_IMS
  
      if ($self->{t}->{type} == DOCTYPE_TOKEN) {
        
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'in html:#DOCTYPE', token => $self->{t});
        ## Ignore the token
        ## Stay in the phase
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == START_TAG_TOKEN and
               $self->{t}->{tag_name} eq 'html') {
        if ($self->{insertion_mode} == AFTER_HTML_BODY_IM) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'after html', text => 'html', token => $self->{t});
          $self->{insertion_mode} = AFTER_BODY_IM;
        } elsif ($self->{insertion_mode} == AFTER_HTML_FRAMESET_IM) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'after html', text => 'html', token => $self->{t});
          $self->{insertion_mode} = AFTER_FRAMESET_IM;
        } else {
          
        }
  
        
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'not first start tag', token => $self->{t});
        my $top_el = $self->{open_elements}->[0]->[0];
        for my $attr_name (keys %{$self->{t}->{attributes}}) {
          unless ($top_el->has_attribute_ns (undef, $attr_name)) {
            
            $top_el->set_attribute_ns
              (undef, [undef, $attr_name], 
               $self->{t}->{attributes}->{$attr_name}->{value});
          }
        }
        
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
        my $comment = $self->{document}->create_comment ($self->{t}->{data});
        if ($self->{insertion_mode} & AFTER_HTML_IMS) {
          
          $self->{document}->append_child ($comment);
        } elsif ($self->{insertion_mode} == AFTER_BODY_IM) {
          
          $self->{open_elements}->[0]->[0]->append_child ($comment);
        } else {
          
          $self->{open_elements}->[-1]->[0]->append_child ($comment);
          $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
        }
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{insertion_mode} & IN_CDATA_RCDATA_IM) {
        if ($self->{t}->{type} == CHARACTER_TOKEN) {
          $self->{t}->{data} =~ s/^\x0A// if $self->{ignore_newline};
          delete $self->{ignore_newline};
  
          if (length $self->{t}->{data}) {
            
            ## NOTE: NULLs are replaced into U+FFFDs in tokenizer.
            $self->{open_elements}->[-1]->[0]->manakai_append_text
                ($self->{t}->{data});
          } else {
            
          }
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
          delete $self->{ignore_newline};
  
          if ($self->{t}->{tag_name} eq 'script') {
            
            
            ## Para 1-2
            my $script = pop @{$self->{open_elements}};
            
            ## Para 3
            $self->{insertion_mode} &= ~ IN_CDATA_RCDATA_IM;
  
            ## Para 4
            ## TODO: $old_insertion_point = $current_insertion_point;
            ## TODO: $current_insertion_point = just before $self->{nc};
  
            ## Para 5
            ## TODO: Run the $script->[0].
  
            ## Para 6
            ## TODO: $current_insertion_point = $old_insertion_point;
  
            ## Para 7
            ## TODO: if ($pending_external_script) {
              ## TODO: ...
            ## TODO: }
  
            $self->{t} = $self->_get_next_token;
            next B;
          } else {
            
   
            pop @{$self->{open_elements}};
  
            $self->{insertion_mode} &= ~ IN_CDATA_RCDATA_IM;
            $self->{t} = $self->_get_next_token;
            next B;
          }
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          delete $self->{ignore_newline};
  
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                          text => $self->{open_elements}->[-1]->[0]
                              ->manakai_local_name,
                          token => $self->{t});
  
          #if ($self->{open_elements}->[-1]->[1] == SCRIPT_EL) {
          #  ## TODO: Mark as "already executed"
          #}
  
          pop @{$self->{open_elements}};
  
          $self->{insertion_mode} &= ~ IN_CDATA_RCDATA_IM;
          ## Reprocess.
          next B;
        } else {
          die "$0: $self->{t}->{type}: In CDATA/RCDATA: Unknown token type";        
        }
      } # insertion_mode
  
      if ($self->{insertion_mode} & HEAD_IMS) {
        if ($self->{t}->{type} == CHARACTER_TOKEN) {
          if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            unless ($self->{insertion_mode} == BEFORE_HEAD_IM) {
              
              $self->{open_elements}->[-1]->[0]->manakai_append_text ($1);
            } else {
              
              ## Ignore the token.
              #
            }
            unless (length $self->{t}->{data}) {
              
              $self->{t} = $self->_get_next_token;
              next B;
            }
  ## TODO: set $self->{t}->{column} appropriately
          }
  
          if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
            
            ## As if <head>
            
        $self->{head_element} = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'head']);
      
          $self->{head_element}->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $self->{head_element}->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
            $self->{open_elements}->[-1]->[0]->append_child ($self->{head_element});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
  
            ## Reprocess in the "in head" insertion mode...
            pop @{$self->{open_elements}};
  
            ## Reprocess in the "after head" insertion mode...
          } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            
            ## As if </noscript>
            pop @{$self->{open_elements}};
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in noscript:#text', token => $self->{t});
            
            ## Reprocess in the "in head" insertion mode...
            ## As if </head>
            pop @{$self->{open_elements}};
  
            ## Reprocess in the "after head" insertion mode...
          } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
            
            pop @{$self->{open_elements}};
  
            ## Reprocess in the "after head" insertion mode...
          } else {
            
          }
  
          ## "after head" insertion mode
          ## As if <body>
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'body']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{'body'} || 0];
      }
    
          $self->{insertion_mode} = IN_BODY_IM;
          ## The "frameset-ok" flag is left unchanged in this case.
          ## Reporcess the token.
          next B;
        } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
          if ($self->{t}->{tag_name} eq 'head') {
            if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
              
              
        $self->{head_element} = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{ $self->{t}->{attributes}}) {
            my $attr_t =  $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $self->{head_element}->set_attribute_node_ns ($attr);
          }
        
          $self->{head_element}->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $self->{head_element}->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
              $self->{open_elements}->[-1]->[0]->append_child
                  ($self->{head_element});
              push @{$self->{open_elements}},
                  [$self->{head_element}, $el_category->{head}];
              $self->{insertion_mode} = IN_HEAD_IM;
              
              $self->{t} = $self->_get_next_token;
              next B;
            } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after head', text => 'head',
                              token => $self->{t});
              ## Ignore the token
              
              $self->{t} = $self->_get_next_token;
              next B;
            } else {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in head:head',
                              token => $self->{t}); # or in head noscript
              ## Ignore the token
              
              $self->{t} = $self->_get_next_token;
              next B;
            }
          } elsif ($self->{insertion_mode} == BEFORE_HEAD_IM) {
            
            ## As if <head>
            
        $self->{head_element} = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'head']);
      
          $self->{head_element}->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $self->{head_element}->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
            $self->{open_elements}->[-1]->[0]->append_child ($self->{head_element});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
  
            $self->{insertion_mode} = IN_HEAD_IM;
            ## Reprocess in the "in head" insertion mode...
          } else {
            
          }
  
          if ($self->{t}->{tag_name} eq 'base') {
            if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
              
              ## As if </noscript>
              pop @{$self->{open_elements}};
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in noscript', text => 'base',
                              token => $self->{t});
            
              $self->{insertion_mode} = IN_HEAD_IM;
              ## Reprocess in the "in head" insertion mode...
            } else {
              
            }
  
            ## NOTE: There is a "as if in head" code clone.
            if ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after head',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              push @{$self->{open_elements}},
                  [$self->{head_element}, $el_category->{head}];
            } else {
              
            }
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            pop @{$self->{open_elements}};
            pop @{$self->{open_elements}} # <head>
                if $self->{insertion_mode} == AFTER_HEAD_IM;
            
            $self->{t} = $self->_get_next_token;
            next B;
          } elsif ({
            link => 1, basefont => 1, bgsound => 1,
          }->{$self->{t}->{tag_name}}) {
            ## NOTE: There is a "as if in head" code clone.
            if ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after head',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              push @{$self->{open_elements}},
                  [$self->{head_element}, $el_category->{head}];
            } else {
              
            }
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            pop @{$self->{open_elements}};
            pop @{$self->{open_elements}} # <head>
                if $self->{insertion_mode} == AFTER_HEAD_IM;
            delete $self->{self_closing};
            $self->{t} = $self->_get_next_token;
            next B;
          } elsif ($self->{t}->{tag_name} eq 'command') {
            if ($self->{insertion_mode} == IN_HEAD_IM) {
              ## NOTE: If the insertion mode at the time of the emission
              ## of the token was "before head", $self->{insertion_mode}
              ## is already changed to |IN_HEAD_IM|.
  
              ## NOTE: There is a "as if in head" code clone.
              
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
              pop @{$self->{open_elements}};
              pop @{$self->{open_elements}} # <head>
                  if $self->{insertion_mode} == AFTER_HEAD_IM;
              delete $self->{self_closing};
              $self->{t} = $self->_get_next_token;
              next B;
            } else {
              ## NOTE: "in head noscript" or "after head" insertion mode
              ## - in these cases, these tags are treated as same as
              ## normal in-body tags.
              
              #
            }
          } elsif ($self->{t}->{tag_name} eq 'meta') {
            ## NOTE: There is a "as if in head" code clone.
            if ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after head',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              push @{$self->{open_elements}},
                  [$self->{head_element}, $el_category->{head}];
            } else {
              
            }
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            my $meta_el = pop @{$self->{open_elements}};
  
                unless ($self->{confident}) {
                  if ($self->{t}->{attributes}->{charset}) {
                    
                    ## NOTE: Whether the encoding is supported or not,
                    ## an ASCII-compatible charset is not, is handled in
                    ## the |_change_encoding| method.
                    if ($self->_change_encoding
                            ($self->{t}->{attributes}->{charset}->{value},
                             $self->{t})) {
                      return {type => ABORT_TOKEN};
                    }
                    
                    $meta_el->[0]->get_attribute_node_ns (undef, 'charset')
                        ->set_user_data (manakai_has_reference =>
                                             $self->{t}->{attributes}->{charset}
                                                 ->{has_reference});
                  } elsif ($self->{t}->{attributes}->{content} and
                           $self->{t}->{attributes}->{'http-equiv'}) {
                    if ($self->{t}->{attributes}->{'http-equiv'}->{value}
                        =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
                        $self->{t}->{attributes}->{content}->{value}
                        =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                            [\x09\x0A\x0C\x0D\x20]*=
                            [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                            ([^"'\x09\x0A\x0C\x0D\x20]
                             [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
                      
                      ## NOTE: Whether the encoding is supported or not,
                      ## an ASCII-compatible charset is not, is handled
                      ## in the |_change_encoding| method.
                      if ($self->_change_encoding
                              (defined $1 ? $1 : defined $2 ? $2 : $3,
                               $self->{t})) {
                        return {type => ABORT_TOKEN};
                      }
                      $meta_el->[0]->get_attribute_node_ns (undef, 'content')
                          ->set_user_data (manakai_has_reference =>
                                               $self->{t}->{attributes}->{content}
                                                     ->{has_reference});
                    } else {
                      
                    }
                  }
                } else {
                  if ($self->{t}->{attributes}->{charset}) {
                    
                    $meta_el->[0]->get_attribute_node_ns (undef, 'charset')
                        ->set_user_data (manakai_has_reference =>
                                             $self->{t}->{attributes}->{charset}
                                                 ->{has_reference});
                  }
                  if ($self->{t}->{attributes}->{content}) {
                    
                    $meta_el->[0]->get_attribute_node_ns (undef, 'content')
                        ->set_user_data (manakai_has_reference =>
                                             $self->{t}->{attributes}->{content}
                                                 ->{has_reference});
                  }
                }
  
                pop @{$self->{open_elements}} # <head>
                    if $self->{insertion_mode} == AFTER_HEAD_IM;
                delete $self->{self_closing};
                $self->{t} = $self->_get_next_token;
                next B;
          } elsif ($self->{t}->{tag_name} eq 'title') {
            if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
              
              ## As if </noscript>
              pop @{$self->{open_elements}};
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in noscript', text => 'title',
                              token => $self->{t});
            
              $self->{insertion_mode} = IN_HEAD_IM;
              ## Reprocess in the "in head" insertion mode...
            } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after head',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              push @{$self->{open_elements}},
                  [$self->{head_element}, $el_category->{head}];
            } else {
              
            }
  
            ## NOTE: There is a "as if in head" code clone.
            $parse_rcdata->($self, $insert, $open_tables, 1); # RCDATA
  
            ## NOTE: At this point the stack of open elements contain
            ## the |head| element (index == -2) and the |script| element
            ## (index == -1).  In the "after head" insertion mode the
            ## |head| element is inserted only for the purpose of
            ## providing the context for the |script| element, and
            ## therefore we can now and have to remove the element from
            ## the stack.
            splice @{$self->{open_elements}}, -2, 1, () # <head>
                if ($self->{insertion_mode} & IM_MASK) == AFTER_HEAD_IM;
            next B;
          } elsif ($self->{t}->{tag_name} eq 'style' or
                   $self->{t}->{tag_name} eq 'noframes') {
            ## NOTE: Or (scripting is enabled and tag_name eq 'noscript' and
            ## insertion mode IN_HEAD_IM)
            ## NOTE: There is a "as if in head" code clone.
            if ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after head',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              push @{$self->{open_elements}},
                  [$self->{head_element}, $el_category->{head}];
            } else {
              
            }
            $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
            splice @{$self->{open_elements}}, -2, 1, () # <head>
                if ($self->{insertion_mode} & IM_MASK) == AFTER_HEAD_IM;
            next B;
          } elsif ($self->{t}->{tag_name} eq 'noscript') {
                if ($self->{insertion_mode} == IN_HEAD_IM) {
                  
                  ## NOTE: and scripting is disalbed
                  
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
                  $self->{insertion_mode} = IN_HEAD_NOSCRIPT_IM;
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'in noscript', text => 'noscript',
                                  token => $self->{t});
                  ## Ignore the token
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                } else {
                  
                  #
                }
          } elsif ($self->{t}->{tag_name} eq 'script') {
            if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
              
              ## As if </noscript>
              pop @{$self->{open_elements}};
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in noscript', text => 'script',
                              token => $self->{t});
            
              $self->{insertion_mode} = IN_HEAD_IM;
              ## Reprocess in the "in head" insertion mode...
            } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after head',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              push @{$self->{open_elements}},
                  [$self->{head_element}, $el_category->{head}];
            } else {
              
            }
  
            ## NOTE: There is a "as if in head" code clone.
            $script_start_tag->($self, $insert, $open_tables);
            ## ISSUE: A spec bug  [Bug 6038]
            splice @{$self->{open_elements}}, -2, 1 # <head>
                if ($self->{insertion_mode} & IM_MASK) == AFTER_HEAD_IM;
            next B;
          } elsif ($self->{t}->{tag_name} eq 'body' or
                   $self->{t}->{tag_name} eq 'frameset') {
            if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
              
              ## As if </noscript>
              pop @{$self->{open_elements}};
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in noscript',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              
              ## Reprocess in the "in head" insertion mode...
              ## As if </head>
              pop @{$self->{open_elements}};
              
              ## Reprocess in the "after head" insertion mode...
            } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
              
              pop @{$self->{open_elements}};
              
              ## Reprocess in the "after head" insertion mode...
            } else {
              
            }
  
            ## "after head" insertion mode
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            if ($self->{t}->{tag_name} eq 'body') {
              
              delete $self->{frameset_ok};
              $self->{insertion_mode} = IN_BODY_IM;
            } elsif ($self->{t}->{tag_name} eq 'frameset') {
              
              $self->{insertion_mode} = IN_FRAMESET_IM;
            } else {
              die "$0: tag name: $self->{tag_name}";
            }
            
            $self->{t} = $self->_get_next_token;
            next B;
          } else {
            
            #
          }
  
              if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
                
                ## As if </noscript>
                pop @{$self->{open_elements}};
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'in noscript:/',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                
                ## Reprocess in the "in head" insertion mode...
                ## As if </head>
                pop @{$self->{open_elements}};
  
                ## Reprocess in the "after head" insertion mode...
              } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
                
                ## As if </head>
                pop @{$self->{open_elements}};
  
                ## Reprocess in the "after head" insertion mode...
              } else {
                
              }
  
          ## "after head" insertion mode
          ## As if <body>
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'body']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{'body'} || 0];
      }
    
          $self->{insertion_mode} = IN_BODY_IM;
          ## The "frameset-ok" flag is not changed in this case.
          ## Reprocess the token.
          
          next B;
        } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
          ## "Before head", "in head", and "after head" insertion modes
          ## ignore most of end tags.  Exceptions are "body", "html",
          ## and "br" end tags.  "Before head" and "in head" insertion
          ## modes also recognize "head" end tag.  "In head noscript"
          ## insertion modes ignore end tags except for "noscript" and
          ## "br".
  
          if ($self->{t}->{tag_name} eq 'head') {
            if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
              
              ## As if <head>
              
        $self->{head_element} = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'head']);
      
          $self->{head_element}->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $self->{head_element}->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
              $self->{open_elements}->[-1]->[0]->append_child ($self->{head_element});
              push @{$self->{open_elements}},
                  [$self->{head_element}, $el_category->{head}];
  
              ## Reprocess in the "in head" insertion mode...
              pop @{$self->{open_elements}};
              $self->{insertion_mode} = AFTER_HEAD_IM;
              $self->{t} = $self->_get_next_token;
              next B;
            } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
              
              #
            } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
              
              pop @{$self->{open_elements}};
              $self->{insertion_mode} = AFTER_HEAD_IM;
              $self->{t} = $self->_get_next_token;
              next B;
            } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              #
            } else {
              die "$0: $self->{insertion_mode}: Unknown insertion mode";
            }
          } elsif ($self->{t}->{tag_name} eq 'noscript') {
            if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
              
              pop @{$self->{open_elements}};
              $self->{insertion_mode} = IN_HEAD_IM;
              $self->{t} = $self->_get_next_token;
              next B;
            } else {
              
              #
            }
          } elsif ({
              body => ($self->{insertion_mode} != IN_HEAD_NOSCRIPT_IM),
              html => ($self->{insertion_mode} != IN_HEAD_NOSCRIPT_IM),
              br => 1,
          }->{$self->{t}->{tag_name}}) {
            if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
              
              ## (before head) as if <head>, (in head) as if </head>
              
        $self->{head_element} = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'head']);
      
          $self->{head_element}->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $self->{head_element}->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
              $self->{open_elements}->[-1]->[0]->append_child ($self->{head_element});
              $self->{insertion_mode} = AFTER_HEAD_IM;
    
              ## Reprocess in the "after head" insertion mode...
            } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
              
              ## As if </head>
              pop @{$self->{open_elements}};
              $self->{insertion_mode} = AFTER_HEAD_IM;
    
              ## Reprocess in the "after head" insertion mode...
            } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
              
              ## NOTE: Two parse errors for <head><noscript></br>
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              ## As if </noscript>
              pop @{$self->{open_elements}};
              $self->{insertion_mode} = IN_HEAD_IM;
  
              ## Reprocess in the "in head" insertion mode...
              ## As if </head>
              pop @{$self->{open_elements}};
              $self->{insertion_mode} = AFTER_HEAD_IM;
  
              ## Reprocess in the "after head" insertion mode...
            } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
              
              #
            } else {
              die "$0: $self->{insertion_mode}: Unknown insertion mode";
            }
  
            ## "after head" insertion mode
            ## As if <body>
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'body']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{'body'} || 0];
      }
    
            $self->{insertion_mode} = IN_BODY_IM;
            ## The "frameset-ok" flag is left unchanged in this case.
            ## Reprocess the token.
            next B;
          }
  
          ## End tags are ignored by default.
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## Ignore the token.
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
            
  
            ## NOTE: As if <head>
            
        $self->{head_element} = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'head']);
      
          $self->{head_element}->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $self->{head_element}->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
            $self->{open_elements}->[-1]->[0]->append_child
                ($self->{head_element});
            #push @{$self->{open_elements}},
            #    [$self->{head_element}, $el_category->{head}];
            #$self->{insertion_mode} = IN_HEAD_IM;
            ## NOTE: Reprocess.
  
            ## NOTE: As if </head>
            #pop @{$self->{open_elements}};
            #$self->{insertion_mode} = IN_AFTER_HEAD_IM;
            ## NOTE: Reprocess.
            
            #
          } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
            
  
            ## NOTE: As if </head>
            pop @{$self->{open_elements}};
            #$self->{insertion_mode} = IN_AFTER_HEAD_IM;
            ## NOTE: Reprocess.
  
            #
          } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            
  
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in noscript:#eof', token => $self->{t});
  
            ## As if </noscript>
            pop @{$self->{open_elements}};
            #$self->{insertion_mode} = IN_HEAD_IM;
            ## NOTE: Reprocess.
  
            ## NOTE: As if </head>
            pop @{$self->{open_elements}};
            #$self->{insertion_mode} = IN_AFTER_HEAD_IM;
            ## NOTE: Reprocess.
  
            #
          } else {
            
            #
          }
  
          ## NOTE: As if <body>
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'body']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{'body'} || 0];
      }
    
          $self->{insertion_mode} = IN_BODY_IM;
          ## The "frameset-ok" flag is left unchanged in this case.
          ## Reprocess the token.
          next B;
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
  
      } elsif ($self->{insertion_mode} & BODY_IMS) {
        if ($self->{t}->{type} == CHARACTER_TOKEN) {
          ## "In body" insertion mode, character token.  It is also used
          ## for character tokens "in foreign content" for certain
          ## cases.
  
          while ($self->{t}->{data} =~ s/\x00//g) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL', token => $self->{t});
          }
          if ($self->{t}->{data} eq '') {
            $self->{t} = $self->_get_next_token;
            next B;
          }
  
          
          $reconstruct_active_formatting_elements
              ->($self, $insert_to_current, $active_formatting_elements,
                 $open_tables);
          
          $self->{open_elements}->[-1]->[0]->manakai_append_text ($self->{t}->{data});
  
          if ($self->{frameset_ok} and
              $self->{t}->{data} =~ /[^\x09\x0A\x0C\x0D\x20]/) {
            delete $self->{frameset_ok};
          }
  
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
              if ({
                   caption => 1, col => 1, colgroup => 1, tbody => 1,
                   td => 1, tfoot => 1, th => 1, thead => 1, tr => 1,
                  }->{$self->{t}->{tag_name}}) {
                if (($self->{insertion_mode} & IM_MASK) == IN_CELL_IM) {
                  ## have an element in table scope
                  for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[1] == TABLE_CELL_EL) {
                      
  
                      ## Close the cell
                      
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <x>
                      $self->{t} = {type => END_TAG_TOKEN,
                                tag_name => $node->[0]->manakai_local_name,
                                line => $self->{t}->{line},
                                column => $self->{t}->{column}};
                      next B;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      
                      ## ISSUE: This case can never be reached, maybe.
                      last;
                    }
                  }
  
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'start tag not allowed',
                      text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                } elsif (($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed', text => 'caption',
                                  token => $self->{t});
                  
                  ## NOTE: As if </caption>.
                  ## have a table element in table scope
                  my $i;
                  INSCOPE: {
                    for (reverse 0..$#{$self->{open_elements}}) {
                      my $node = $self->{open_elements}->[$_];
                      if ($node->[1] == CAPTION_EL) {
                        
                        $i = $_;
                        last INSCOPE;
                      } elsif ($node->[1] & TABLE_SCOPING_EL) {
                        
                        last;
                      }
                    }
  
                    
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'start tag not allowed',
                                    text => $self->{t}->{tag_name}, token => $self->{t});
                    ## Ignore the token
                    
                    $self->{t} = $self->_get_next_token;
                    next B;
                  } # INSCOPE
                  
                  ## generate implied end tags
                  while ($self->{open_elements}->[-1]->[1]
                             & END_TAG_OPTIONAL_EL) {
                    
                    pop @{$self->{open_elements}};
                  }
  
                  unless ($self->{open_elements}->[-1]->[1] == CAPTION_EL) {
                    
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                    text => $self->{open_elements}->[-1]->[0]
                                        ->manakai_local_name,
                                    token => $self->{t});
                  } else {
                    
                  }
                  
                  splice @{$self->{open_elements}}, $i;
                  
                  $clear_up_to_marker->($active_formatting_elements);
                  
                  $self->{insertion_mode} = IN_TABLE_IM;
                  
                  ## reprocess
                  
                  next B;
                } else {
                  
                  #
                }
              } else {
                
                #
              }
            } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
              if ($self->{t}->{tag_name} eq 'td' or $self->{t}->{tag_name} eq 'th') {
                if (($self->{insertion_mode} & IM_MASK) == IN_CELL_IM) {
                  ## have an element in table scope
                  my $i;
                  INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                      
                      $i = $_;
                      last INSCOPE;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      
                      last INSCOPE;
                    }
                  } # INSCOPE
                    unless (defined $i) {
                      
                      $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                      text => $self->{t}->{tag_name},
                                      token => $self->{t});
                      ## Ignore the token
                      $self->{t} = $self->_get_next_token;
                      next B;
                    }
                  
                  ## generate implied end tags
                  while ($self->{open_elements}->[-1]->[1]
                             & END_TAG_OPTIONAL_EL) {
                    
                    pop @{$self->{open_elements}};
                  }
  
                  if ($self->{open_elements}->[-1]->[0]->manakai_local_name
                          ne $self->{t}->{tag_name}) {
                    
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                    text => $self->{open_elements}->[-1]->[0]
                                        ->manakai_local_name,
                                    token => $self->{t});
                  } else {
                    
                  }
                  
                  splice @{$self->{open_elements}}, $i;
                  
                  $clear_up_to_marker->($active_formatting_elements);
                  
                  $self->{insertion_mode} = IN_ROW_IM;
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                } elsif (($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  $self->{t} = $self->_get_next_token;
                  next B;
                } else {
                  
                  #
                }
              } elsif ($self->{t}->{tag_name} eq 'caption') {
                if (($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
                  ## have a table element in table scope
                  my $i;
                  INSCOPE: {
                    for (reverse 0..$#{$self->{open_elements}}) {
                      my $node = $self->{open_elements}->[$_];
                      if ($node->[1] == CAPTION_EL) {
                        
                        $i = $_;
                        last INSCOPE;
                      } elsif ($node->[1] & TABLE_SCOPING_EL) {
                        
                        last;
                      }
                    }
  
                    
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                    text => $self->{t}->{tag_name}, token => $self->{t});
                    ## Ignore the token
                    $self->{t} = $self->_get_next_token;
                    next B;
                  } # INSCOPE
                  
                  ## generate implied end tags
                  while ($self->{open_elements}->[-1]->[1]
                             & END_TAG_OPTIONAL_EL) {
                    
                    pop @{$self->{open_elements}};
                  }
                  
                  unless ($self->{open_elements}->[-1]->[1] == CAPTION_EL) {
                    
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                    text => $self->{open_elements}->[-1]->[0]
                                        ->manakai_local_name,
                                    token => $self->{t});
                  } else {
                    
                  }
                  
                  splice @{$self->{open_elements}}, $i;
                  
                  $clear_up_to_marker->($active_formatting_elements);
                  
                  $self->{insertion_mode} = IN_TABLE_IM;
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                } elsif (($self->{insertion_mode} & IM_MASK) == IN_CELL_IM) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  $self->{t} = $self->_get_next_token;
                  next B;
                } else {
                  
                  #
                }
              } elsif ({
                        table => 1, tbody => 1, tfoot => 1, 
                        thead => 1, tr => 1,
                       }->{$self->{t}->{tag_name}} and
                       ($self->{insertion_mode} & IM_MASK) == IN_CELL_IM) {
                ## have an element in table scope
                my $i;
                my $tn;
                INSCOPE: {
                  for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                      
                      $i = $_;
  
                      ## Close the cell
                      
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # </x>
                      $self->{t} = {type => END_TAG_TOKEN, tag_name => $tn,
                                line => $self->{t}->{line},
                                column => $self->{t}->{column}};
                      next B;
                    } elsif ($node->[1] == TABLE_CELL_EL) {
                      
                      $tn = $node->[0]->manakai_local_name;
                      ## NOTE: There is exactly one |td| or |th| element
                      ## in scope in the stack of open elements by definition.
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      ## ISSUE: Can this be reached?
                      
                      last;
                    }
                  }
  
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                      text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  $self->{t} = $self->_get_next_token;
                  next B;
                } # INSCOPE
              } elsif ($self->{t}->{tag_name} eq 'table' and
                       ($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed', text => 'caption',
                                token => $self->{t});
  
                ## As if </caption>
                ## have a table element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == CAPTION_EL) {
                    
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    
                    last INSCOPE;
                  }
                } # INSCOPE
                unless (defined $i) {
                  
  	## TODO: Wrong error type?
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                  text => 'caption', token => $self->{t});
                  ## Ignore the token
                  $self->{t} = $self->_get_next_token;
                  next B;
                }
                
                ## generate implied end tags
                while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
                  
                  pop @{$self->{open_elements}};
                }
  
                unless ($self->{open_elements}->[-1]->[1] == CAPTION_EL) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                  text => $self->{open_elements}->[-1]->[0]
                                      ->manakai_local_name,
                                  token => $self->{t});
                } else {
                  
                }
  
                splice @{$self->{open_elements}}, $i;
  
                $clear_up_to_marker->($active_formatting_elements);
  
                $self->{insertion_mode} = IN_TABLE_IM;
  
                ## reprocess
                next B;
              } elsif ({
                        body => 1, col => 1, colgroup => 1, html => 1,
                       }->{$self->{t}->{tag_name}}) {
                if ($self->{insertion_mode} & BODY_TABLE_IMS) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  $self->{t} = $self->_get_next_token;
                  next B;
                } else {
                  
                  #
                }
          } elsif ({
                    tbody => 1, tfoot => 1,
                    thead => 1, tr => 1,
                   }->{$self->{t}->{tag_name}} and
                   ($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token
            $self->{t} = $self->_get_next_token;
            next B;
          } else {
            
            #
          }
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          for my $entry (@{$self->{open_elements}}) {
            unless ($entry->[1] & ALL_END_TAG_OPTIONAL_EL) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in body:#eof', token => $self->{t});
              last;
            }
          }
  
          ## Stop parsing.
          last B;
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
  
        $self->{insert} = $insert = $insert_to_current;
        #
      } elsif ($self->{insertion_mode} & TABLE_IMS) {
        if ($self->{t}->{type} == START_TAG_TOKEN) {
          if ({
               tr => (($self->{insertion_mode} & IM_MASK) != IN_ROW_IM),
               th => 1, td => 1,
              }->{$self->{t}->{tag_name}}) {
            if (($self->{insertion_mode} & IM_MASK) == IN_TABLE_IM) {
              ## Clear back to table context
              while (not ($self->{open_elements}->[-1]->[1]
                              & TABLE_SCOPING_EL)) {
                
                pop @{$self->{open_elements}};
              }
              
              
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'tbody']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{'tbody'} || 0];
      }
    
              $self->{insertion_mode} = IN_TABLE_BODY_IM;
              ## reprocess in the "in table body" insertion mode...
            }
            
            if (($self->{insertion_mode} & IM_MASK) == IN_TABLE_BODY_IM) {
              unless ($self->{t}->{tag_name} eq 'tr') {
                
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'missing start tag:tr', token => $self->{t});
              }
                  
              ## Clear back to table body context
              while (not ($self->{open_elements}->[-1]->[1]
                              & TABLE_ROWS_SCOPING_EL)) {
                
                ## ISSUE: Can this case be reached?
                pop @{$self->{open_elements}};
              }
                  
              $self->{insertion_mode} = IN_ROW_IM;
              if ($self->{t}->{tag_name} eq 'tr') {
                
                
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
                $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
                
                $self->{t} = $self->_get_next_token;
                next B;
              } else {
                
                
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'tr']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{'tr'} || 0];
      }
    
                ## reprocess in the "in row" insertion mode
              }
            } else {
              
            }
  
                ## Clear back to table row context
                while (not ($self->{open_elements}->[-1]->[1]
                                & TABLE_ROW_SCOPING_EL)) {
                  
                  pop @{$self->{open_elements}};
                }
                
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
            $self->{insertion_mode} = IN_CELL_IM;
  
            push @$active_formatting_elements, ['#marker', '', undef];
            
            
            $self->{t} = $self->_get_next_token;
            next B;
          } elsif ({
                    caption => 1, col => 1, colgroup => 1,
                    tbody => 1, tfoot => 1, thead => 1,
                    tr => 1, # $self->{insertion_mode} == IN_ROW_IM
                   }->{$self->{t}->{tag_name}}) {
            if (($self->{insertion_mode} & IM_MASK) == IN_ROW_IM) {
              ## XXXgeneratetoken
              ## As if </tr>
              ## have an element in table scope
              my $i;
              INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                my $node = $self->{open_elements}->[$_];
                if ($node->[1] == TABLE_ROW_EL) {
                  
                  $i = $_;
                  last INSCOPE;
                } elsif ($node->[1] & TABLE_SCOPING_EL) {
                  
                  last INSCOPE;
                }
              } # INSCOPE
              unless (defined $i) { 
                
                ## TODO: This type is wrong.
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmacthed end tag',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                
                $self->{t} = $self->_get_next_token;
                next B;
              }
                  
                  ## Clear back to table row context
                  while (not ($self->{open_elements}->[-1]->[1]
                                  & TABLE_ROW_SCOPING_EL)) {
                    
                    ## ISSUE: Can this case be reached?
                    pop @{$self->{open_elements}};
                  }
                  
                  pop @{$self->{open_elements}}; # tr
                  $self->{insertion_mode} = IN_TABLE_BODY_IM;
                  if ($self->{t}->{tag_name} eq 'tr') {
                    
                    ## reprocess
                    
                    next B;
                  } else {
                    
                    ## reprocess in the "in table body" insertion mode...
                  }
                }
  
                if (($self->{insertion_mode} & IM_MASK) == IN_TABLE_BODY_IM) {
                  ## have an element in table scope
                  my $i;
                  INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[1] == TABLE_ROW_GROUP_EL) {
                      
                      $i = $_;
                      last INSCOPE;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      
                      last INSCOPE;
                    }
                  } # INSCOPE
                  unless (defined $i) {
                    
  ## TODO: This erorr type is wrong.
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                    text => $self->{t}->{tag_name}, token => $self->{t});
                    ## Ignore the token
                    
                    $self->{t} = $self->_get_next_token;
                    next B;
                  }
  
                  ## Clear back to table body context
                  while (not ($self->{open_elements}->[-1]->[1]
                                  & TABLE_ROWS_SCOPING_EL)) {
                    
                    ## ISSUE: Can this state be reached?
                    pop @{$self->{open_elements}};
                  }
                  
                  ## As if <{current node}>
                  ## have an element in table scope
                  ## true by definition
                  
                  ## Clear back to table body context
                  ## nop by definition
                  
                  pop @{$self->{open_elements}};
                  $self->{insertion_mode} = IN_TABLE_IM;
                  ## reprocess in "in table" insertion mode...
                } else {
                  
                }
  
            if ($self->{t}->{tag_name} eq 'col') {
              ## Clear back to table context
              while (not ($self->{open_elements}->[-1]->[1]
                              & TABLE_SCOPING_EL)) {
                
                ## ISSUE: Can this state be reached?
                pop @{$self->{open_elements}};
              }
              
              
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'colgroup']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{'colgroup'} || 0];
      }
    
              $self->{insertion_mode} = IN_COLUMN_GROUP_IM;
              ## reprocess
              $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
              
              next B;
            } elsif ({
                      caption => 1,
                      colgroup => 1,
                      tbody => 1, tfoot => 1, thead => 1,
                     }->{$self->{t}->{tag_name}}) {
              ## Clear back to table context
              while (not ($self->{open_elements}->[-1]->[1]
                          & TABLE_SCOPING_EL)) {
                
                ## ISSUE: Can this state be reached?
                pop @{$self->{open_elements}};
              }
              
              push @$active_formatting_elements, ['#marker', '', undef]
                  if $self->{t}->{tag_name} eq 'caption';
              
              
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
              $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
              $self->{insertion_mode} = {
                                         caption => IN_CAPTION_IM,
                                         colgroup => IN_COLUMN_GROUP_IM,
                                         tbody => IN_TABLE_BODY_IM,
                                         tfoot => IN_TABLE_BODY_IM,
                                         thead => IN_TABLE_BODY_IM,
                                        }->{$self->{t}->{tag_name}};
              $self->{t} = $self->_get_next_token;
              
              next B;
            } else {
              die "$0: in table: <>: $self->{t}->{tag_name}";
            }
              } elsif ($self->{t}->{tag_name} eq 'table') {
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                text => $self->{open_elements}->[-1]->[0]
                                    ->manakai_local_name,
                                token => $self->{t});
  
                ## XXXgeneratetoken
                ## As if </table>
                ## have a table element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == TABLE_EL) {
                    
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    
                    last INSCOPE;
                  }
                } # INSCOPE
                unless (defined $i) {
                  
  ## TODO: The following is wrong, maybe.
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag', text => 'table',
                                  token => $self->{t});
                  ## Ignore tokens </table><table>
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                }
                
  ## TODO: Followings are removed from the latest spec. 
                ## generate implied end tags
                while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
                  
                  pop @{$self->{open_elements}};
                }
  
                unless ($self->{open_elements}->[-1]->[1] == TABLE_EL) {
                  
                  ## NOTE: |<table><tr><table>|
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                  text => $self->{open_elements}->[-1]->[0]
                                      ->manakai_local_name,
                                  token => $self->{t});
                } else {
                  
                }
  
                splice @{$self->{open_elements}}, $i;
                pop @{$open_tables};
  
                $self->_reset_insertion_mode; 
  
            ## reprocess
            
            next B;
          } elsif ($self->{t}->{tag_name} eq 'style') {
            
            ## NOTE: This is a "as if in head" code clone.
            $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
            $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
            next B;
          } elsif ($self->{t}->{tag_name} eq 'script') {
            
            ## NOTE: This is a "as if in head" code clone.
            $script_start_tag->($self, $insert, $open_tables);
            $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
            next B;
          } elsif ($self->{t}->{tag_name} eq 'input') {
            if ($self->{t}->{attributes}->{type}) {
              my $type = $self->{t}->{attributes}->{type}->{value};
              $type =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($type eq 'hidden') {
                
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'in table',
                                text => $self->{t}->{tag_name}, token => $self->{t});
  
                
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
                $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
  
                ## TODO: form element pointer
  
                pop @{$self->{open_elements}};
  
                $self->{t} = $self->_get_next_token;
                delete $self->{self_closing};
                next B;
              } else {
                
                #
              }
            } else {
              
              #
            }
          } elsif ($self->{t}->{tag_name} eq 'form') {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'form in table', token => $self->{t}); # XXX documentation
            
            if ($self->{form_element}) {
              ## Ignore the token.
              $self->{t} = $self->_get_next_token;
              
              next B;
            } else {
              
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
              $self->{form_element} = $self->{open_elements}->[-1]->[0];
              
              pop @{$self->{open_elements}};
              
              $self->{t} = $self->_get_next_token;
              
              next B;
            }
          } else {
            
            #
          }
  
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'in table', text => $self->{t}->{tag_name},
                          token => $self->{t});
  
          $self->{insert} = $insert = $insert_to_foster;
          #
        } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
          if ($self->{t}->{tag_name} eq 'tr' and
              ($self->{insertion_mode} & IM_MASK) == IN_ROW_IM) {
            ## have an element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == TABLE_ROW_EL) {
                    
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    
                    last INSCOPE;
                  }
                } # INSCOPE
                unless (defined $i) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                } else {
                  
                }
  
                ## Clear back to table row context
                while (not ($self->{open_elements}->[-1]->[1]
                                & TABLE_ROW_SCOPING_EL)) {
                  
  ## ISSUE: Can this state be reached?
                  pop @{$self->{open_elements}};
                }
  
                pop @{$self->{open_elements}}; # tr
                $self->{insertion_mode} = IN_TABLE_BODY_IM;
                $self->{t} = $self->_get_next_token;
                
                next B;
              } elsif ($self->{t}->{tag_name} eq 'table') {
                if (($self->{insertion_mode} & IM_MASK) == IN_ROW_IM) {
                  ## XXXgeneratetoken
                  ## As if </tr>
                  ## have an element in table scope
                  my $i;
                  INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[1] == TABLE_ROW_EL) {
                      
                      $i = $_;
                      last INSCOPE;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      
                      last INSCOPE;
                    }
                  } # INSCOPE
                  unless (defined $i) {
                    
  ## TODO: The following is wrong.
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                    text => $self->{t}->{type}, token => $self->{t});
                    ## Ignore the token
                    
                    $self->{t} = $self->_get_next_token;
                    next B;
                  }
                  
                  ## Clear back to table row context
                  while (not ($self->{open_elements}->[-1]->[1]
                                  & TABLE_ROW_SCOPING_EL)) {
                    
  ## ISSUE: Can this state be reached?
                    pop @{$self->{open_elements}};
                  }
                  
                  pop @{$self->{open_elements}}; # tr
                  $self->{insertion_mode} = IN_TABLE_BODY_IM;
                  ## reprocess in the "in table body" insertion mode...
                }
  
                if (($self->{insertion_mode} & IM_MASK) == IN_TABLE_BODY_IM) {
                  ## have an element in table scope
                  my $i;
                  INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[1] == TABLE_ROW_GROUP_EL) {
                      
                      $i = $_;
                      last INSCOPE;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      
                      last INSCOPE;
                    }
                  } # INSCOPE
                  unless (defined $i) {
                    
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                    text => $self->{t}->{tag_name}, token => $self->{t});
                    ## Ignore the token
                    
                    $self->{t} = $self->_get_next_token;
                    next B;
                  }
                  
                  ## Clear back to table body context
                  while (not ($self->{open_elements}->[-1]->[1]
                                  & TABLE_ROWS_SCOPING_EL)) {
                    
                    pop @{$self->{open_elements}};
                  }
                  
                  ## As if <{current node}>
                  ## have an element in table scope
                  ## true by definition
                  
                  ## Clear back to table body context
                  ## nop by definition
                  
                  pop @{$self->{open_elements}};
                  $self->{insertion_mode} = IN_TABLE_IM;
                  ## reprocess in the "in table" insertion mode...
                }
  
                ## NOTE: </table> in the "in table" insertion mode.
                ## When you edit the code fragment below, please ensure that
                ## the code for <table> in the "in table" insertion mode
                ## is synced with it.
  
                ## have a table element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == TABLE_EL) {
                    
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    
                    last INSCOPE;
                  }
                } # INSCOPE
                unless (defined $i) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                }
                  
                splice @{$self->{open_elements}}, $i;
                pop @{$open_tables};
                
                $self->_reset_insertion_mode;
                
                $self->{t} = $self->_get_next_token;
                next B;
              } elsif ({
                        tbody => 1, tfoot => 1, thead => 1,
                       }->{$self->{t}->{tag_name}} and
                       $self->{insertion_mode} & ROW_IMS) {
                if (($self->{insertion_mode} & IM_MASK) == IN_ROW_IM) {
                  ## have an element in table scope
                  my $i;
                  INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                      
                      $i = $_;
                      last INSCOPE;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      
                      last INSCOPE;
                    }
                  } # INSCOPE
                    unless (defined $i) {
                      
                      $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                      text => $self->{t}->{tag_name}, token => $self->{t});
                      ## Ignore the token
                      
                      $self->{t} = $self->_get_next_token;
                      next B;
                    }
                  
                  ## XXXgeneratetoken
                  ## As if </tr>
                  ## have an element in table scope
                  my $i;
                  INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[1] == TABLE_ROW_EL) {
                      
                      $i = $_;
                      last INSCOPE;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      
                      last INSCOPE;
                    }
                  } # INSCOPE
                    unless (defined $i) {
                      
                      $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                      text => 'tr', token => $self->{t});
                      ## Ignore the token
                      
                      $self->{t} = $self->_get_next_token;
                      next B;
                    }
                  
                  ## Clear back to table row context
                  while (not ($self->{open_elements}->[-1]->[1]
                                  & TABLE_ROW_SCOPING_EL)) {
                    
  ## ISSUE: Can this case be reached?
                    pop @{$self->{open_elements}};
                  }
                  
                  pop @{$self->{open_elements}}; # tr
                  $self->{insertion_mode} = IN_TABLE_BODY_IM;
                  ## reprocess in the "in table body" insertion mode...
                }
  
                ## have an element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                    
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    
                    last INSCOPE;
                  }
                } # INSCOPE
                unless (defined $i) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                }
  
                ## Clear back to table body context
                while (not ($self->{open_elements}->[-1]->[1]
                                & TABLE_ROWS_SCOPING_EL)) {
                  
  ## ISSUE: Can this case be reached?
                  pop @{$self->{open_elements}};
                }
  
                pop @{$self->{open_elements}};
                $self->{insertion_mode} = IN_TABLE_IM;
                
                $self->{t} = $self->_get_next_token;
                next B;
              } elsif ({
                        body => 1, caption => 1, col => 1, colgroup => 1,
                        html => 1, td => 1, th => 1,
                        tr => 1, # $self->{insertion_mode} == IN_ROW_IM
                        tbody => 1, tfoot => 1, thead => 1, # $self->{insertion_mode} == IN_TABLE_IM
                       }->{$self->{t}->{tag_name}}) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token
            
             $self->{t} = $self->_get_next_token;
            next B;
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in table:/',
                            text => $self->{t}->{tag_name}, token => $self->{t});
  
            $self->{insert} = $insert = $insert_to_foster;
            #
          }
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          unless ($self->{open_elements}->[-1]->[1] == HTML_EL and
                  @{$self->{open_elements}} == 1) { # redundant, maybe
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in body:#eof', token => $self->{t});
            
            #
          } else {
            
            #
          }
  
          ## Stop parsing
          last B;
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
      } elsif (($self->{insertion_mode} & IM_MASK) == IN_COLUMN_GROUP_IM) {
            if ($self->{t}->{type} == CHARACTER_TOKEN) {
              if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
                $self->{open_elements}->[-1]->[0]->manakai_append_text ($1);
                unless (length $self->{t}->{data}) {
                  
                  $self->{t} = $self->_get_next_token;
                  next B;
                }
              }
              
              
              #
            } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
              if ($self->{t}->{tag_name} eq 'col') {
                
                
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
                pop @{$self->{open_elements}};
                delete $self->{self_closing};
                $self->{t} = $self->_get_next_token;
                next B;
              } else { 
                
                #
              }
            } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
              if ($self->{t}->{tag_name} eq 'colgroup') {
                if ($self->{open_elements}->[-1]->[1] == HTML_EL) {
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                  text => 'colgroup', token => $self->{t});
                  ## Ignore the token
                  $self->{t} = $self->_get_next_token;
                  next B;
                } else {
                  
                  pop @{$self->{open_elements}}; # colgroup
                  $self->{insertion_mode} = IN_TABLE_IM;
                  $self->{t} = $self->_get_next_token;
                  next B;             
                }
              } elsif ($self->{t}->{tag_name} eq 'col') {
                
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                text => 'col', token => $self->{t});
                ## Ignore the token
                $self->{t} = $self->_get_next_token;
                next B;
              } else {
                
                # 
              }
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          if ($self->{open_elements}->[-1]->[1] == HTML_EL and
              @{$self->{open_elements}} == 1) { # redundant, maybe
            
            ## Stop parsing.
            last B;
          } else {
            ## XXXgeneratetoken
            ## NOTE: As if </colgroup>.
            
            pop @{$self->{open_elements}}; # colgroup
            $self->{insertion_mode} = IN_TABLE_IM;
            ## Reprocess.
            next B;
          }
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
  
            ## XXXgeneratetoken
            ## As if </colgroup>
            if ($self->{open_elements}->[-1]->[1] == HTML_EL) {
              
  ## TODO: Wrong error type?
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => 'colgroup', token => $self->{t});
              ## Ignore the token
              
              $self->{t} = $self->_get_next_token;
              next B;
            } else {
              
              pop @{$self->{open_elements}}; # colgroup
              $self->{insertion_mode} = IN_TABLE_IM;
              
              ## reprocess
              next B;
            }
      } elsif ($self->{insertion_mode} & SELECT_IMS) {
        if ($self->{t}->{type} == CHARACTER_TOKEN) {
          
          my $data = $self->{t}->{data};
          while ($data =~ s/\x00//) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL', token => $self->{t});
          }
          $self->{open_elements}->[-1]->[0]->manakai_append_text ($data)
              if $data ne '';
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
          if ($self->{t}->{tag_name} eq 'option') {
            if ($self->{open_elements}->[-1]->[1] == OPTION_EL) {
              
              ## XXXgeneratetoken
              ## As if </option>
              pop @{$self->{open_elements}};
            } else {
              
            }
  
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            
            $self->{t} = $self->_get_next_token;
            next B;
          } elsif ($self->{t}->{tag_name} eq 'optgroup') {
            if ($self->{open_elements}->[-1]->[1] == OPTION_EL) {
              
              ## XXXgenereatetoken
              ## As if </option>
              pop @{$self->{open_elements}};
            } else {
              
            }
  
            if ($self->{open_elements}->[-1]->[1] == OPTGROUP_EL) {
              
              ## XXXgeneratetoken
              ## As if </optgroup>
              pop @{$self->{open_elements}};
            } else {
              
            }
  
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            
            $self->{t} = $self->_get_next_token;
            next B;
  
          } elsif ($self->{t}->{tag_name} eq 'select') {
            ## "In select" / "in select in table" insertion mode,
            ## "select" start tag.
            
  
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'select in select', ## XXX: documentation
                            token => $self->{t});
  
            ## XXXgenereatetoken
            ## Act as if the token were </select>.
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'select',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
  
          } elsif ({
            input => 1, textarea => 1, keygen => 1,
          }->{$self->{t}->{tag_name}}) {
            ## "In select" / "in select in table" insertion mode,
            ## "input", "keygen", "textarea" start tag.
  
            ## Parse error.
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed', text => 'select',
                            token => $self->{t});
  
            ## If there "have an element in select scope" where element
            ## is a |select| element.
            my $i;
            INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
              my $node = $self->{open_elements}->[$_];
              if ($node->[1] == SELECT_EL) {
                
                $i = $_;
                last INSCOPE;
              } elsif ($node->[1] == OPTGROUP_EL or
                       $node->[1] == OPTION_EL) {
                
                #
              } else {
                
                last INSCOPE;
              }
            } # INSCOPE
            unless (defined $i) {
              ## Ignore the token.
              
              $self->{t} = $self->_get_next_token;
              next B;
            }
  
            ## Otherwise, act as if there were </select>, then reprocess
            ## the token.
            
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
      
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'select',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
  
          } elsif (
            ($self->{insertion_mode} & IM_MASK) == IN_SELECT_IN_TABLE_IM and
            {
              caption => 1, table => 1, tbody => 1, tfoot => 1, thead => 1,
              tr => 1, td => 1, th => 1,
            }->{$self->{t}->{tag_name}}
          ) {
            ## "In select in table" insertion mode, table-related start
            ## tags.
  
            ## Parse error.
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed', text => 'select',
                            token => $self->{t});
  
            ## Act as if there were </select>, then reprocess the token.
            
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
      
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'select',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
  
          } elsif ($self->{t}->{tag_name} eq 'script') {
            
            ## NOTE: This is an "as if in head" code clone
            $script_start_tag->($self, $insert, $open_tables);
            next B;
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in select',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token
            
            $self->{t} = $self->_get_next_token;
            next B;
          }
  
        } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
          if ($self->{t}->{tag_name} eq 'optgroup') {
            if ($self->{open_elements}->[-1]->[1] == OPTION_EL and
                $self->{open_elements}->[-2]->[1] == OPTGROUP_EL) {
              
              ## XXXgeneratetoken
              ## As if </option>
              splice @{$self->{open_elements}}, -2;
            } elsif ($self->{open_elements}->[-1]->[1] == OPTGROUP_EL) {
              
              pop @{$self->{open_elements}};
            } else {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              ## Ignore the token
            }
            
            $self->{t} = $self->_get_next_token;
            next B;
          } elsif ($self->{t}->{tag_name} eq 'option') {
            if ($self->{open_elements}->[-1]->[1] == OPTION_EL) {
              
              pop @{$self->{open_elements}};
            } else {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              ## Ignore the token
            }
            
            $self->{t} = $self->_get_next_token;
            next B;
  
          } elsif ($self->{t}->{tag_name} eq 'select') {
            ## "In select" / "in select in table" insertion mode,
            ## "select" end tag.
  
            ## There "have an element in select scope" where the element
            ## is |select|.
            my $i;
            INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
              my $node = $self->{open_elements}->[$_];
              if ($node->[1] == SELECT_EL) {
                
                $i = $_;
                last INSCOPE;
              } elsif ($node->[1] == OPTION_EL or
                       $node->[1] == OPTGROUP_EL) {
                
                #
              } else {
                
                last INSCOPE;
              }
            } # INSCOPE
            unless (defined $i) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              ## Ignore the token.
              
              $self->{t} = $self->_get_next_token;
              next B;
            }
            
            ## Otherwise,
            
            splice @{$self->{open_elements}}, $i;
  
            $self->_reset_insertion_mode;
  
            
            $self->{t} = $self->_get_next_token;
            next B;
  
          } elsif (
            ($self->{insertion_mode} & IM_MASK) == IN_SELECT_IN_TABLE_IM and
            {
              caption => 1, table => 1, tbody => 1, tfoot => 1, thead => 1,
              tr => 1, td => 1, th => 1,
            }->{$self->{t}->{tag_name}}
          ) {
            ## "In select in table" insertion mode, table-related end
            ## tags.
  
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
  
            ## There "have an element in table scope" where the element
            ## is same tag name as |$self->{t}|.
            my $i;
            INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
              my $node = $self->{open_elements}->[$_];
              if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                
                $i = $_;
                last INSCOPE;
              } elsif ($node->[1] & TABLE_SCOPING_EL) {
                
                last INSCOPE;
              }
            } # INSCOPE
            unless (defined $i) {
              
              ## Ignore the token
              
              $self->{t} = $self->_get_next_token;
              next B;
            }
            
            ## Act as if there were </select>, then reprocess the token.
            
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
      
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'select',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
  
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in select:/',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token
            
            $self->{t} = $self->_get_next_token;
            next B;
          }
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          unless ($self->{open_elements}->[-1]->[1] == HTML_EL and
                  @{$self->{open_elements}} == 1) { # redundant, maybe
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in body:#eof', token => $self->{t});
          } else {
            
          }
  
          ## Stop parsing.
          last B;
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
      } elsif ($self->{insertion_mode} & BODY_AFTER_IMS) {
        if ($self->{t}->{type} == CHARACTER_TOKEN) {
          if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            my $data = $1;
            ## As if in body
            $reconstruct_active_formatting_elements
                ->($self, $insert_to_current, $active_formatting_elements,
                   $open_tables);
                
            $self->{open_elements}->[-1]->[0]->manakai_append_text ($1);
            
            unless (length $self->{t}->{data}) {
              
              $self->{t} = $self->_get_next_token;
              next B;
            }
          }
          
          if ($self->{insertion_mode} == AFTER_HTML_BODY_IM) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'after html:#text', token => $self->{t});
            #
          } else {
            
            ## "after body" insertion mode
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'after body:#text', token => $self->{t});
            #
          }
  
          $self->{insertion_mode} = IN_BODY_IM;
          ## reprocess
          next B;
        } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
          if ($self->{insertion_mode} == AFTER_HTML_BODY_IM) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'after html',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            #
          } else {
            
            ## "after body" insertion mode
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'after body',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            #
          }
  
          $self->{insertion_mode} = IN_BODY_IM;
          
          ## reprocess
          next B;
        } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
          if ($self->{insertion_mode} == AFTER_HTML_BODY_IM) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'after html:/',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            
            $self->{insertion_mode} = IN_BODY_IM;
            ## Reprocess.
            next B;
          } else {
            
          }
  
          ## "after body" insertion mode
          if ($self->{t}->{tag_name} eq 'html') {
            if (defined $self->{inner_html_node}) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => 'html', token => $self->{t});
              ## Ignore the token
              $self->{t} = $self->_get_next_token;
              next B;
            } else {
              
              $self->{insertion_mode} = AFTER_HTML_BODY_IM;
              $self->{t} = $self->_get_next_token;
              next B;
            }
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'after body:/',
                            text => $self->{t}->{tag_name}, token => $self->{t});
  
            $self->{insertion_mode} = IN_BODY_IM;
            ## reprocess
            next B;
          }
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          
          ## Stop parsing
          last B;
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
      } elsif ($self->{insertion_mode} & FRAME_IMS) {
        if ($self->{t}->{type} == CHARACTER_TOKEN) {
          if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            $self->{open_elements}->[-1]->[0]->manakai_append_text ($1);
            
            unless (length $self->{t}->{data}) {
              
              $self->{t} = $self->_get_next_token;
              next B;
            }
          }
          
          if ($self->{t}->{data} =~ s/^[^\x09\x0A\x0C\x20]+//) {
            if ($self->{insertion_mode} == IN_FRAMESET_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in frameset:#text', token => $self->{t});
            } elsif ($self->{insertion_mode} == AFTER_FRAMESET_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after frameset:#text', token => $self->{t});
            } else { # "after after frameset"
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after html:#text', token => $self->{t});
            }
            
            ## Ignore the token.
            if (length $self->{t}->{data}) {
              
              ## reprocess the rest of characters
            } else {
              
              $self->{t} = $self->_get_next_token;
            }
            next B;
          }
          
          die qq[$0: Character "$self->{t}->{data}"];
        } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
          if ($self->{t}->{tag_name} eq 'frameset' and
              $self->{insertion_mode} == IN_FRAMESET_IM) {
            
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            
            $self->{t} = $self->_get_next_token;
            next B;
          } elsif ($self->{t}->{tag_name} eq 'frame' and
                   $self->{insertion_mode} == IN_FRAMESET_IM) {
            
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $self->{open_elements}->[-1]->[0]->append_child ($el);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
            pop @{$self->{open_elements}};
            delete $self->{self_closing};
            $self->{t} = $self->_get_next_token;
            next B;
          } elsif ($self->{t}->{tag_name} eq 'noframes') {
            
            ## NOTE: As if in head.
            $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
            next B;
  
            ## NOTE: |<!DOCTYPE HTML><frameset></frameset></html><noframes></noframes>|
            ## has no parse error.
          } else {
            if ($self->{insertion_mode} == IN_FRAMESET_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in frameset',
                              text => $self->{t}->{tag_name}, token => $self->{t});
            } elsif ($self->{insertion_mode} == AFTER_FRAMESET_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after frameset',
                              text => $self->{t}->{tag_name}, token => $self->{t});
            } else { # "after after frameset"
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after after frameset',
                              text => $self->{t}->{tag_name}, token => $self->{t});
            }
            ## Ignore the token
            
            $self->{t} = $self->_get_next_token;
            next B;
          }
        } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
          if ($self->{t}->{tag_name} eq 'frameset' and
              $self->{insertion_mode} == IN_FRAMESET_IM) {
            if ($self->{open_elements}->[-1]->[1] == HTML_EL and
                @{$self->{open_elements}} == 1) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              ## Ignore the token
              $self->{t} = $self->_get_next_token;
            } else {
              
              pop @{$self->{open_elements}};
              $self->{t} = $self->_get_next_token;
            }
  
            if (not defined $self->{inner_html_node} and
                not ($self->{open_elements}->[-1]->[1] == FRAMESET_EL)) {
              
              $self->{insertion_mode} = AFTER_FRAMESET_IM;
            } else {
              
            }
            next B;
          } elsif ($self->{t}->{tag_name} eq 'html' and
                   $self->{insertion_mode} == AFTER_FRAMESET_IM) {
            
            $self->{insertion_mode} = AFTER_HTML_FRAMESET_IM;
            $self->{t} = $self->_get_next_token;
            next B;
          } else {
            if ($self->{insertion_mode} == IN_FRAMESET_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in frameset:/',
                              text => $self->{t}->{tag_name}, token => $self->{t});
            } elsif ($self->{insertion_mode} == AFTER_FRAMESET_IM) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after frameset:/',
                              text => $self->{t}->{tag_name}, token => $self->{t});
            } else { # "after after html"
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'after after frameset:/',
                              text => $self->{t}->{tag_name}, token => $self->{t});
            }
            ## Ignore the token
            $self->{t} = $self->_get_next_token;
            next B;
          }
        } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
          unless ($self->{open_elements}->[-1]->[1] == HTML_EL and
                  @{$self->{open_elements}} == 1) { # redundant, maybe
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in body:#eof', token => $self->{t});
          } else {
            
          }
          
          ## Stop parsing
          last B;
        } else {
          die "$0: $self->{t}->{type}: Unknown token type";
        }
      } else {
        die "$0: $self->{insertion_mode}: Unknown insertion mode";
      }
  
      ## "in body" insertion mode
      if ($self->{t}->{type} == START_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'script') {
          
          ## NOTE: This is an "as if in head" code clone
          $script_start_tag->($self, $insert, $open_tables);
          next B;
        } elsif ($self->{t}->{tag_name} eq 'style') {
          
          ## NOTE: This is an "as if in head" code clone
          $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
          next B;
        } elsif ({
          base => 1, command => 1, link => 1, basefont => 1, bgsound => 1,
        }->{$self->{t}->{tag_name}}) {
          
          ## NOTE: This is an "as if in head" code clone, only "-t" differs
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          pop @{$self->{open_elements}};
          delete $self->{self_closing};
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'meta') {
          ## NOTE: This is an "as if in head" code clone, only "-t" differs
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          my $meta_el = pop @{$self->{open_elements}};
  
          unless ($self->{confident}) {
            if ($self->{t}->{attributes}->{charset}) {
              
              ## NOTE: Whether the encoding is supported or not, an
              ## ASCII-compatible charset is not, is handled in the
              ## |_change_encoding| method.
              if ($self->_change_encoding
                      ($self->{t}->{attributes}->{charset}->{value},
                       $self->{t})) {
                return {type => ABORT_TOKEN};
              }
              
              $meta_el->[0]->get_attribute_node_ns (undef, 'charset')
                  ->set_user_data (manakai_has_reference =>
                                       $self->{t}->{attributes}->{charset}
                                           ->{has_reference});
            } elsif ($self->{t}->{attributes}->{content} and
                     $self->{t}->{attributes}->{'http-equiv'}) {
              if ($self->{t}->{attributes}->{'http-equiv'}->{value}
                  =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
                  $self->{t}->{attributes}->{content}->{value}
                  =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                      [\x09\x0A\x0C\x0D\x20]*=
                      [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                      ([^"'\x09\x0A\x0C\x0D\x20][^\x09\x0A\x0C\x0D\x20\x3B]*))
                     /x) {
                
                ## NOTE: Whether the encoding is supported or not, an
                ## ASCII-compatible charset is not, is handled in the
                ## |_change_encoding| method.
                if ($self->_change_encoding
                        (defined $1 ? $1 : defined $2 ? $2 : $3,
                         $self->{t})) {
                  return {type => ABORT_TOKEN};
                }
                $meta_el->[0]->get_attribute_node_ns (undef, 'content')
                    ->set_user_data (manakai_has_reference =>
                                         $self->{t}->{attributes}->{content}
                                               ->{has_reference});
              }
            }
          } else {
            if ($self->{t}->{attributes}->{charset}) {
              
              $meta_el->[0]->get_attribute_node_ns (undef, 'charset')
                  ->set_user_data (manakai_has_reference =>
                                       $self->{t}->{attributes}->{charset}
                                           ->{has_reference});
            }
            if ($self->{t}->{attributes}->{content}) {
              
              $meta_el->[0]->get_attribute_node_ns (undef, 'content')
                  ->set_user_data (manakai_has_reference =>
                                       $self->{t}->{attributes}->{content}
                                           ->{has_reference});
            }
          }
  
          delete $self->{self_closing};
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'title') {
          
          ## NOTE: This is an "as if in head" code clone
          $parse_rcdata->($self, $insert, $open_tables, 1); # RCDATA
          next B;
  
        } elsif ($self->{t}->{tag_name} eq 'body') {
          ## "In body" insertion mode, "body" start tag token.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'in body', text => 'body', token => $self->{t});
                
          if (@{$self->{open_elements}} == 1 or
              not ($self->{open_elements}->[1]->[1] == BODY_EL)) {
            
            ## Ignore the token
          } else {
            delete $self->{frameset_ok};
            my $body_el = $self->{open_elements}->[1]->[0];
            for my $attr_name (keys %{$self->{t}->{attributes}}) {
              unless ($body_el->has_attribute_ns (undef, $attr_name)) {
                
                $body_el->set_attribute_ns
                  (undef, [undef, $attr_name],
                   $self->{t}->{attributes}->{$attr_name}->{value});
              }
            }
          }
          
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'frameset') {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'in body', text => $self->{t}->{tag_name},
                          token => $self->{t});
  
          if (@{$self->{open_elements}} == 1 or
              not ($self->{open_elements}->[1]->[1] == BODY_EL)) {
            
            ## Ignore the token.
          } elsif (not $self->{frameset_ok}) {
            
            ## Ignore the token.
          } else {
            
            
            ## 1. Remove the second element.
            my $body = $self->{open_elements}->[1]->[0];
            my $body_parent = $body->parent_node;
            $body_parent->remove_child ($body) if $body_parent;
  
            ## 2. Pop nodes.
            splice @{$self->{open_elements}}, 1;
  
            ## 3. Insert.
            
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
  
            ## 4. Switch.
            $self->{insertion_mode} = IN_FRAMESET_IM;
          }
  
          
          $self->{t} = $self->_get_next_token;
          next B;
  
        } elsif ({
          ## "In body" insertion mode, non-phrasing flow-content
          ## elements start tags.
  
          address => 1, article => 1, aside => 1, blockquote => 1,
          center => 1, details => 1, dir => 1, div => 1, dl => 1,
          fieldset => 1, figcaption => 1, figure => 1, footer => 1,
          header => 1, hgroup => 1, menu => 1, nav => 1, ol => 1,
          p => 1, section => 1, ul => 1, summary => 1,
          # datagrid => 1,
  
          ## Closing any heading element
          h1 => 1, h2 => 1, h3 => 1, h4 => 1, h5 => 1, h6 => 1, 
  
          ## Ignoring any leading newline in content
          pre => 1, listing => 1,
  
          ## Form element pointer
          form => 1,
          
          ## A quirk & switching of insertion mode
          table => 1,
  
          ## Void element
          hr => 1,
        }->{$self->{t}->{tag_name}}) {
  
          ## 1. When there is an opening |form| element:
          if ($self->{t}->{tag_name} eq 'form' and defined $self->{form_element}) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'in form:form', token => $self->{t});
            ## Ignore the token
            
            $self->{t} = $self->_get_next_token;
            next B;
          }
  
          ## 2. Close the |p| element, if any.
          if ($self->{t}->{tag_name} ne 'table' or # The Hixie Quirk
              $self->{document}->manakai_compat_mode ne 'quirks') {
            ## "have a |p| element in button scope"
            INSCOPE: for (reverse @{$self->{open_elements}}) {
              if ($_->[1] == P_EL) {
                
                
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <form>
                $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                          line => $self->{t}->{line}, column => $self->{t}->{column}};
                next B;
              } elsif ($_->[1] & BUTTON_SCOPING_EL) {
                
                last INSCOPE;
              }
            } # INSCOPE
          }
  
          ## 3. Close the opening <hn> element, if any.
          if ({h1 => 1, h2 => 1, h3 => 1,
               h4 => 1, h5 => 1, h6 => 1}->{$self->{t}->{tag_name}}) {
            if ($self->{open_elements}->[-1]->[1] == HEADING_EL) {
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                              text => $self->{open_elements}->[-1]->[0]->manakai_local_name,
                              token => $self->{t});
              pop @{$self->{open_elements}};
            }
          }
  
          ## 4. Insertion.
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          if ($self->{t}->{tag_name} eq 'pre' or $self->{t}->{tag_name} eq 'listing') {
            
            $self->{t} = $self->_get_next_token;
            if ($self->{t}->{type} == CHARACTER_TOKEN) {
              $self->{t}->{data} =~ s/^\x0A//;
              unless (length $self->{t}->{data}) {
                
                $self->{t} = $self->_get_next_token;
              } else {
                
              }
            } else {
              
            }
  
            delete $self->{frameset_ok};
          } elsif ($self->{t}->{tag_name} eq 'form') {
            
            $self->{form_element} = $self->{open_elements}->[-1]->[0];
  
            
            $self->{t} = $self->_get_next_token;
          } elsif ($self->{t}->{tag_name} eq 'table') {
            
            push @{$open_tables}, [$self->{open_elements}->[-1]->[0]];
  
            delete $self->{frameset_ok};
            
            $self->{insertion_mode} = IN_TABLE_IM;
  
            
            $self->{t} = $self->_get_next_token;
          } elsif ($self->{t}->{tag_name} eq 'hr') {
            
            pop @{$self->{open_elements}};
            
            delete $self->{self_closing};
  
            delete $self->{frameset_ok};
  
            $self->{t} = $self->_get_next_token;
          } else {
            
            $self->{t} = $self->_get_next_token;
          }
          next B;
  
        } elsif ($self->{t}->{tag_name} eq 'li') {
          ## "In body" insertion mode, "li" start tag.  As normal, but
          ## imply </li> when there's another <li>.
  
          ## NOTE: Special, Scope (<li><foo><li> == <li><foo><li/></foo></li>)::
            ## Interpreted as <li><foo/></li><li/> (non-conforming):
            ## blockquote (O9.27), center (O), dd (Fx3, O, S3.1.2, IE7),
            ## dt (Fx, O, S, IE), dl (O), fieldset (O, S, IE), form (Fx, O, S),
            ## hn (O), pre (O), applet (O, S), button (O, S), marquee (Fx, O, S),
            ## object (Fx)
            ## Generate non-tree (non-conforming):
            ## basefont (IE7 (where basefont is non-void)), center (IE),
            ## form (IE), hn (IE)
          ## address, div, p (<li><foo><li> == <li><foo/></li><li/>)::
            ## Interpreted as <li><foo><li/></foo></li> (non-conforming):
            ## div (Fx, S)
  
          ## 1. Frameset-ng
          delete $self->{frameset_ok};
  
          my $non_optional;
          my $i = -1;
  
          ## 2.
          for my $node (reverse @{$self->{open_elements}}) {
            if ($node->[1] == LI_EL) {
              ## XXXgeneratetoken
              ## 3. (a) As if </li>
              {
                ## If no </li> - not applied
                #
  
                ## Otherwise
  
                ## 1. generate implied end tags, except for </li>
                #
  
                ## 2. If current node != "li", parse error
                if ($non_optional) {
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                  text => $non_optional->[0]->manakai_local_name,
                                  token => $self->{t});
                  
                } else {
                  
                }
  
                ## 3. Pop
                splice @{$self->{open_elements}}, $i;
              }
  
              last; ## 3. (b) goto 5.
            } elsif (
                     ## NOTE: "special" category
                     ($node->[1] & SPECIAL_EL or
                      $node->[1] & SCOPING_EL) and
                     ## NOTE: "li", "dt", and "dd" are in |SPECIAL_EL|.
                     (not $node->[1] & ADDRESS_DIV_P_EL)
                    ) {
              ## 4.
              
              last; ## goto 6.
            } elsif ($node->[1] & END_TAG_OPTIONAL_EL) {
              
              #
            } else {
              
              $non_optional ||= $node;
              #
            }
            ## 5.
            ## goto 3.
            $i--;
          }
  
          ## 6. (a) "have a |p| element in button scope".
          INSCOPE: for (reverse @{$self->{open_elements}}) {
            if ($_->[1] == P_EL) {
              
  
              ## NOTE: |<p><li>|, for example.
  
              
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <x>
              $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                        line => $self->{t}->{line}, column => $self->{t}->{column}};
              next B;
            } elsif ($_->[1] & BUTTON_SCOPING_EL) {
              
              last INSCOPE;
            }
          } # INSCOPE
  
          ## 6. (b) insert
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          
          $self->{t} = $self->_get_next_token;
          next B;
  
        } elsif ($self->{t}->{tag_name} eq 'dt' or $self->{t}->{tag_name} eq 'dd') {
          ## "In body" insertion mode, "dt" or "dd" start tag.  As
          ## normal, but imply </dt> or </dd> when there's antoher <dt>
          ## or <dd>.
  
          ## 1. Frameset-ng
          delete $self->{frameset_ok};
  
          my $non_optional;
          my $i = -1;
  
          ## 2.
          for my $node (reverse @{$self->{open_elements}}) {
            if ($node->[1] == DTDD_EL) {
              ## XXXgeneratetoken
              ## 3. (a) As if </li>
              {
                ## If no </li> - not applied
                #
  
                ## Otherwise
  
                ## 1. generate implied end tags, except for </dt> or </dd>
                #
  
                ## 2. If current node != "dt"|"dd", parse error
                if ($non_optional) {
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                  text => $non_optional->[0]->manakai_local_name,
                                  token => $self->{t});
                  
                } else {
                  
                }
  
                ## 3. Pop
                splice @{$self->{open_elements}}, $i;
              }
  
              last; ## 3. (b) goto 5.
            } elsif (
                     ## NOTE: "special" category
                     ($node->[1] & SPECIAL_EL or $node->[1] & SCOPING_EL) and
                     ## NOTE: "li", "dt", and "dd" are in |SPECIAL_EL|.
  
                     (not $node->[1] & ADDRESS_DIV_P_EL)
                    ) {
              ## 4.
              
              last; ## goto 5.
            } elsif ($node->[1] & END_TAG_OPTIONAL_EL) {
              
              #
            } else {
              
              $non_optional ||= $node;
              #
            }
            ## 5.
            ## goto 3.
            $i--;
          }
  
          ## 6. (a) "have a |p| element in button scope".
          INSCOPE: for (reverse @{$self->{open_elements}}) {
            if ($_->[1] == P_EL) {
              
              
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <x>
              $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                        line => $self->{t}->{line}, column => $self->{t}->{column}};
              next B;
            } elsif ($_->[1] & BUTTON_SCOPING_EL) {
              
              last INSCOPE;
            }
          } # INSCOPE
  
          ## 6. (b) insert
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          
          $self->{t} = $self->_get_next_token;
          next B;
  
        } elsif ($self->{t}->{tag_name} eq 'plaintext') {
          ## "In body" insertion mode, "plaintext" start tag.  As
          ## normal, but effectively ends parsing.
  
          ## "has a |p| element in scope".
          INSCOPE: for (reverse @{$self->{open_elements}}) {
            if ($_->[1] == P_EL) {
              
              
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <plaintext>
              $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                        line => $self->{t}->{line}, column => $self->{t}->{column}};
              next B;
            } elsif ($_->[1] & BUTTON_SCOPING_EL) {
              
              last INSCOPE;
            }
          } # INSCOPE
            
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          
          $self->{state} = PLAINTEXT_STATE;
            
          
          $self->{t} = $self->_get_next_token;
          next B;
  
        } elsif ($self->{t}->{tag_name} eq 'a') {
          AFE: for my $i (reverse 0..$#$active_formatting_elements) {
            my $node = $active_formatting_elements->[$i];
            if ($node->[1] == A_EL) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in a:a', token => $self->{t});
              
              
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <a>
              $self->{t} = {type => END_TAG_TOKEN, tag_name => 'a',
                        line => $self->{t}->{line}, column => $self->{t}->{column}};
              $formatting_end_tag->($self, $active_formatting_elements,
                                    $open_tables, $self->{t});
              
              AFE2: for (reverse 0..$#$active_formatting_elements) {
                if ($active_formatting_elements->[$_]->[0] eq $node->[0]) {
                  
                  splice @$active_formatting_elements, $_, 1;
                  last AFE2;
                }
              } # AFE2
              OE: for (reverse 0..$#{$self->{open_elements}}) {
                if ($self->{open_elements}->[$_]->[0] eq $node->[0]) {
                  
                  splice @{$self->{open_elements}}, $_, 1;
                  last OE;
                }
              } # OE
              last AFE;
            } elsif ($node->[0] eq '#marker') {
              
              last AFE;
            }
          } # AFE
          
          my $insert = $self->{insertion_mode} & TABLE_IMS
              ? $insert_to_foster : $insert_to_current;
          $reconstruct_active_formatting_elements
              ->($self, $insert, $active_formatting_elements, $open_tables);
  
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          push_afe [$self->{open_elements}->[-1]->[0],
                    $self->{open_elements}->[-1]->[1],
                    $self->{t}]
              => $active_formatting_elements;
  
          
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'nobr') {
          my $insert = $self->{insertion_mode} & TABLE_IMS
              ? $insert_to_foster : $insert_to_current;
          $reconstruct_active_formatting_elements
              ->($self, $insert, $active_formatting_elements, $open_tables);
  
          ## has a |nobr| element in scope
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[1] == NOBR_EL) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in nobr:nobr', token => $self->{t});
              
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <nobr>
              $self->{t} = {type => END_TAG_TOKEN, tag_name => 'nobr',
                        line => $self->{t}->{line}, column => $self->{t}->{column}};
              next B;
            } elsif ($node->[1] & SCOPING_EL) {
              
              last INSCOPE;
            }
          } # INSCOPE
          
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          push_afe [$self->{open_elements}->[-1]->[0],
                    $self->{open_elements}->[-1]->[1],
                    $self->{t}]
              => $active_formatting_elements;
          
          
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'button') {
          ## has a button element in scope
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[1] == BUTTON_EL) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'in button:button', token => $self->{t});
              
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <button>
              $self->{t} = {type => END_TAG_TOKEN, tag_name => 'button',
                        line => $self->{t}->{line}, column => $self->{t}->{column}};
              next B;
            } elsif ($node->[1] & SCOPING_EL) {
              
              last INSCOPE;
            }
          } # INSCOPE
            
          my $insert = $self->{insertion_mode} & TABLE_IMS
              ? $insert_to_foster : $insert_to_current;
          $reconstruct_active_formatting_elements
              ->($self, $insert, $active_formatting_elements, $open_tables);
            
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
  
          ## TODO: associate with $self->{form_element} if defined
  
          delete $self->{frameset_ok};
  
          
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ({
                  xmp => 1,
                  iframe => 1,
                  noembed => 1,
                  noframes => 1, ## NOTE: This is an "as if in head" code clone.
                  noscript => 0, ## TODO: 1 if scripting is enabled
                 }->{$self->{t}->{tag_name}}) {
          if ($self->{t}->{tag_name} eq 'xmp') {
            ## "In body" insertion mode, "xmp" start tag.  As normal
            ## flow-content element start tag, but CDATA parsing.
            
  
            ## "have a |p| element in button scope".
            INSCOPE: for (reverse @{$self->{open_elements}}) {
              if ($_->[1] == P_EL) {
                
                
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <xmp>
                $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                          line => $self->{t}->{line}, column => $self->{t}->{column}};
                next B;
              } elsif ($_->[1] & BUTTON_SCOPING_EL) {
                
                last INSCOPE;
              }
            } # INSCOPE
  
            my $insert = $self->{insertion_mode} & TABLE_IMS
                ? $insert_to_foster : $insert_to_current;
            $reconstruct_active_formatting_elements
                ->($self, $insert, $active_formatting_elements,
                   $open_tables);
  
            delete $self->{frameset_ok};
          } elsif ($self->{t}->{tag_name} eq 'iframe') {
            
            delete $self->{frameset_ok};
          } else {
            
          }
          ## NOTE: There is an "as if in body" code clone.
          $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
          next B;
        } elsif ($self->{t}->{tag_name} eq 'isindex') {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'isindex', token => $self->{t});
          
          if (defined $self->{form_element}) {
            
            ## Ignore the token
             ## NOTE: Not acknowledged.
            $self->{t} = $self->_get_next_token;
            next B;
          } else {
            delete $self->{self_closing};
  
            my $at = $self->{t}->{attributes};
            my $form_attrs;
            $form_attrs->{action} = $at->{action} if $at->{action};
            my $prompt_attr = $at->{prompt};
            $at->{name} = {name => 'name', value => 'isindex'};
            delete $at->{action};
            delete $at->{prompt};
            my @tokens = (
                          {type => START_TAG_TOKEN, tag_name => 'form',
                           attributes => $form_attrs,
                           line => $self->{t}->{line}, column => $self->{t}->{column}},
                          {type => START_TAG_TOKEN, tag_name => 'hr',
                           line => $self->{t}->{line}, column => $self->{t}->{column}},
                          {type => START_TAG_TOKEN, tag_name => 'label',
                           line => $self->{t}->{line}, column => $self->{t}->{column}},
                         );
            if ($prompt_attr) {
              
              push @tokens, {type => CHARACTER_TOKEN, data => $prompt_attr->{value},
                             #line => $self->{t}->{line}, column => $self->{t}->{column},
                            };
            } else {
              
              push @tokens, {type => CHARACTER_TOKEN,
                             data => 'This is a searchable index. Enter search keywords: ',
                             #line => $self->{t}->{line}, column => $self->{t}->{column},
                            }; # SHOULD
              ## TODO: make this configurable
            }
            push @tokens,
                          {type => START_TAG_TOKEN, tag_name => 'input', attributes => $at,
                           line => $self->{t}->{line}, column => $self->{t}->{column}},
                          #{type => CHARACTER_TOKEN, data => ''}, # SHOULD
                          {type => END_TAG_TOKEN, tag_name => 'label',
                           line => $self->{t}->{line}, column => $self->{t}->{column}},
                          {type => START_TAG_TOKEN, tag_name => 'hr',
                           line => $self->{t}->{line}, column => $self->{t}->{column}},
                          {type => END_TAG_TOKEN, tag_name => 'form',
                           line => $self->{t}->{line}, column => $self->{t}->{column}};
            unshift @{$self->{token}}, (@tokens);
            $self->{t} = $self->_get_next_token;
            next B;
          }
        } elsif ($self->{t}->{tag_name} eq 'textarea') {
          ## 1. Insert
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          
          ## Step 2 # XXX
          ## TODO: $self->{form_element} if defined
  
          ## 2. Drop U+000A LINE FEED
          $self->{ignore_newline} = 1;
  
          ## 3. RCDATA
          $self->{state} = RCDATA_STATE;
          delete $self->{escape}; # MUST
  
          ## 4., 6. Insertion mode
          $self->{insertion_mode} |= IN_CDATA_RCDATA_IM;
  
          ## 5. Frameset-ng.
          delete $self->{frameset_ok};
  
          
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'optgroup' or
                 $self->{t}->{tag_name} eq 'option') {
          if ($self->{open_elements}->[-1]->[1] == OPTION_EL) {
            
            ## XXXgeneratetoken
            ## NOTE: As if </option>
            
        $self->{t}->{self_closing} = $self->{self_closing};
        unshift @{$self->{token}}, $self->{t};
        delete $self->{self_closing};
       # <option> or <optgroup>
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'option',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
          }
  
          my $insert = $self->{insertion_mode} & TABLE_IMS
              ? $insert_to_foster : $insert_to_current;
          $reconstruct_active_formatting_elements
              ->($self, $insert, $active_formatting_elements, $open_tables);
  
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
  
          
          $self->{t} = $self->_get_next_token;
          redo B;
        } elsif ($self->{t}->{tag_name} eq 'rt' or
                 $self->{t}->{tag_name} eq 'rp') {
          ## has a |ruby| element in scope
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[1] == RUBY_EL) {
              
              ## generate implied end tags
              while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
                
                pop @{$self->{open_elements}};
              }
              unless ($self->{open_elements}->[-1]->[1] == RUBY_EL) {
                
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                text => $self->{open_elements}->[-1]->[0]
                                    ->manakai_local_name,
                                token => $self->{t});
              }
              last INSCOPE;
            } elsif ($node->[1] & SCOPING_EL) {
              
              last INSCOPE;
            }
          } # INSCOPE
  
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
  
          
          $self->{t} = $self->_get_next_token;
          redo B;
        } elsif ($self->{t}->{tag_name} eq 'math' or
                 $self->{t}->{tag_name} eq 'svg') {
          my $insert = $self->{insertion_mode} & TABLE_IMS
              ? $insert_to_foster : $insert_to_current;
          $reconstruct_active_formatting_elements
              ->($self, $insert, $active_formatting_elements, $open_tables);
  
          ## "Adjust MathML attributes" ('math' only) - done in insert-element-f
  
          ## "adjust SVG attributes" ('svg' only) - done in insert-element-f
  
          ## "adjust foreign attributes" - done in insert-element-f
          
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          ($self->{t}->{tag_name} eq 'math' ? MML_NS : SVG_NS, [undef,   $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (
            @{
              $foreign_attr_xname->{$attr_name} ||
              [undef, [undef,
                       ($self->{t}->{tag_name} eq 'math' ? MML_NS : SVG_NS) eq SVG_NS ?
                           ($svg_attr_name->{$attr_name} || $attr_name) :
                       ($self->{t}->{tag_name} eq 'math' ? MML_NS : SVG_NS) eq MML_NS ?
                           ($mml_attr_name->{$attr_name} || $attr_name) :
                           $attr_name]]
            }
          );
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, ($el_category_f->{$self->{t}->{tag_name} eq 'math' ? MML_NS : SVG_NS}->{ $self->{t}->{tag_name}} || 0) | FOREIGN_EL | (($self->{t}->{tag_name} eq 'math' ? MML_NS : SVG_NS) eq SVG_NS ? SVG_EL : ($self->{t}->{tag_name} eq 'math' ? MML_NS : SVG_NS) eq MML_NS ? MML_EL : 0)];
  
        if ( $self->{t}->{attributes}->{xmlns} and  $self->{t}->{attributes}->{xmlns}->{value} ne ($self->{t}->{tag_name} eq 'math' ? MML_NS : SVG_NS)) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bad namespace', token =>  $self->{t});
  ## TODO: Error type documentation
        }
        if ( $self->{t}->{attributes}->{'xmlns:xlink'} and
             $self->{t}->{attributes}->{'xmlns:xlink'}->{value} ne q<http://www.w3.org/1999/xlink>) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bad namespace', token =>  $self->{t});
        }
      }
    
          
          if ($self->{self_closing}) {
            pop @{$self->{open_elements}};
            delete $self->{self_closing};
          } else {
            
          }
  
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ({
                  caption => 1, col => 1, colgroup => 1, frame => 1,
                  head => 1,
                  tbody => 1, td => 1, tfoot => 1, th => 1,
                  thead => 1, tr => 1,
                 }->{$self->{t}->{tag_name}}) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'in body',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## Ignore the token
           ## NOTE: |<col/>| or |<frame/>| here is an error.
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'param' or
                 $self->{t}->{tag_name} eq 'source' or
                 $self->{t}->{tag_name} eq 'track') {
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
          pop @{$self->{open_elements}};
  
          delete $self->{self_closing};
          $self->{t} = $self->_get_next_token;
          redo B;
        } else {
          if ($self->{t}->{tag_name} eq 'image') {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'image', token => $self->{t});
            $self->{t}->{tag_name} = 'img';
          } else {
            
          }
  
          ## NOTE: There is an "as if <br>" code clone.
          my $insert = $self->{insertion_mode} & TABLE_IMS
              ? $insert_to_foster : $insert_to_current;
          $reconstruct_active_formatting_elements
              ->($self, $insert, $active_formatting_elements, $open_tables);
          
          
      {
        my $el;
        
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  $self->{t}->{tag_name}]);
      
          for my $attr_name (keys %{  $self->{t}->{attributes}}) {
            my $attr_t =   $self->{t}->{attributes}->{$attr_name};
            my $attr = $self->{document}->create_attribute_ns (undef, [undef, $attr_name]);
            $attr->value ($attr_t->{value});
            $attr->set_user_data (manakai_source_line => $attr_t->{line});
            $attr->set_user_data (manakai_source_column => $attr_t->{column});
            $el->set_attribute_node_ns ($attr);
          }
        
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
        $insert->($self, $el, $open_tables);
        push @{$self->{open_elements}}, [$el, $el_category->{$self->{t}->{tag_name}} || 0];
      }
    
  
          if ({
               applet => 1, marquee => 1, object => 1,
              }->{$self->{t}->{tag_name}}) {
            
  
            push @$active_formatting_elements, ['#marker', '', undef];
  
            delete $self->{frameset_ok};
  
            
          } elsif ({
                    b => 1, big => 1, code => 1, em => 1, font => 1, i => 1,
                    s => 1, small => 1, strike => 1,
                    strong => 1, tt => 1, u => 1,
                   }->{$self->{t}->{tag_name}}) {
            
            push_afe [$self->{open_elements}->[-1]->[0],
                 $self->{open_elements}->[-1]->[1],
                 $self->{t}]
                => $active_formatting_elements;
            
          } elsif ($self->{t}->{tag_name} eq 'input') {
            
            ## TODO: associate with $self->{form_element} if defined
  
            pop @{$self->{open_elements}};
  
            if ($self->{t}->{attributes}->{type}) {
              my $type = $self->{t}->{attributes}->{type}->{value};
              $type =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($type eq 'hidden') {
                #
              } else {
                delete $self->{frameset_ok};
              }
            } else {
              delete $self->{frameset_ok};
            }
  
            delete $self->{self_closing};
          } elsif ({
            area => 1, br => 1, embed => 1, img => 1, wbr => 1, keygen => 1,
          }->{$self->{t}->{tag_name}}) {
            
  
            pop @{$self->{open_elements}};
  
            delete $self->{frameset_ok};
  
            delete $self->{self_closing};
          } elsif ($self->{t}->{tag_name} eq 'select') {
            ## TODO: associate with $self->{form_element} if defined
  
            delete $self->{frameset_ok};
            
            if ($self->{insertion_mode} & TABLE_IMS or
                $self->{insertion_mode} & BODY_TABLE_IMS) {
              
              $self->{insertion_mode} = IN_SELECT_IN_TABLE_IM;
            } else {
              
              $self->{insertion_mode} = IN_SELECT_IM;
            }
            
          } else {
            
          }
          
          $self->{t} = $self->_get_next_token;
          next B;
        }
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'body' or $self->{t}->{tag_name} eq 'html') {
  
          ## 1. If not "have an element in scope":
          ## "has a |body| element in scope"
          my $i;
          INSCOPE: {
            for (reverse @{$self->{open_elements}}) {
              if ($_->[1] == BODY_EL) {
                
                $i = $_;
                last INSCOPE;
              } elsif ($_->[1] & SCOPING_EL) {
                
                last;
              }
            }
  
            ## NOTE: |<marquee></body>|, |<svg><foreignobject></body>|,
            ## and fragment cases.
  
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token.  (</body> or </html>)
            $self->{t} = $self->_get_next_token;
            next B;
          } # INSCOPE
  
          ## 2. If unclosed elements:
          for (@{$self->{open_elements}}) {
            unless ($_->[1] & ALL_END_TAG_OPTIONAL_EL ||
                    $_->[1] == OPTGROUP_EL ||
                    $_->[1] == OPTION_EL ||
                    $_->[1] == RUBY_COMPONENT_EL) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                              text => $_->[0]->manakai_local_name,
                              token => $self->{t});
              last;
            } else {
              
            }
          }
  
          ## 3. Switch the insertion mode.
          $self->{insertion_mode} = AFTER_BODY_IM;
          if ($self->{t}->{tag_name} eq 'body') {
            $self->{t} = $self->_get_next_token;
          } else { # html
            ## Reprocess.
          }
          next B;
  
        } elsif ({
          ## "In body" insertion mode, end tags for non-phrasing flow
          ## content elements.
  
                  address => 1, article => 1, aside => 1, blockquote => 1,
                  center => 1,
                  #datagrid => 1,
                  details => 1,
                  dir => 1, div => 1, dl => 1, fieldset => 1, figure => 1,
                  footer => 1, header => 1, hgroup => 1,
                  listing => 1, menu => 1, nav => 1,
                  ol => 1, pre => 1, section => 1, ul => 1,
                  figcaption => 1, summary => 1,
  
                  ## NOTE: As normal, but ... optional tags
                  dd => 1, dt => 1, li => 1,
  
                  applet => 1, button => 1, marquee => 1, object => 1,
                 }->{$self->{t}->{tag_name}}) {
          ## XXXgeneraetetoken
          ## NOTE: Code for <li> start tags includes "as if </li>" code.
          ## Code for <dt> or <dd> start tags includes "as if </dt> or
          ## </dd>" code.
  
          ## has an element in scope
          my $i;
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
              
              $i = $_;
              last INSCOPE;
            } elsif ($node->[1] & SCOPING_EL) {
              
              last INSCOPE;
            } elsif ($self->{t}->{tag_name} eq 'li' and
                     {ul => 1, ol => 1}->{$node->[0]->manakai_local_name}) {
              ## Has an element in list item scope
              
              last INSCOPE;
            }
          } # INSCOPE
  
          unless (defined $i) { # has an element in scope
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## NOTE: Ignore the token.
          } else {
            ## Step 1. generate implied end tags
            while ({
                    ## END_TAG_OPTIONAL_EL
                    dd => ($self->{t}->{tag_name} ne 'dd'),
                    dt => ($self->{t}->{tag_name} ne 'dt'),
                    li => ($self->{t}->{tag_name} ne 'li'),
                    option => 1,
                    optgroup => 1,
                    p => 1,
                    rt => 1,
                    rp => 1,
                   }->{$self->{open_elements}->[-1]->[0]->manakai_local_name}) {
              
              pop @{$self->{open_elements}};
            }
  
            ## Step 2.
            if ($self->{open_elements}->[-1]->[0]->manakai_local_name
                    ne $self->{t}->{tag_name}) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                              text => $self->{open_elements}->[-1]->[0]
                                  ->manakai_local_name,
                              token => $self->{t});
            } else {
              
            }
  
            ## Step 3.
            splice @{$self->{open_elements}}, $i;
  
            ## Step 4.
            $clear_up_to_marker->($active_formatting_elements)
                if {
                  applet => 1, marquee => 1, object => 1,
                }->{$self->{t}->{tag_name}};
          }
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'form') {
          ## NOTE: As normal, but interacts with the form element pointer
  
          undef $self->{form_element};
  
          ## has an element in scope
          my $i;
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[1] == FORM_EL) {
              
              $i = $_;
              last INSCOPE;
            } elsif ($node->[1] & SCOPING_EL) {
              
              last INSCOPE;
            }
          } # INSCOPE
  
          unless (defined $i) { # has an element in scope
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## NOTE: Ignore the token.
          } else {
            ## Step 1. generate implied end tags
            while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
              
              pop @{$self->{open_elements}};
            }
            
            ## Step 2. 
            if ($self->{open_elements}->[-1]->[0]->manakai_local_name
                    ne $self->{t}->{tag_name}) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                              text => $self->{open_elements}->[-1]->[0]
                                  ->manakai_local_name,
                              token => $self->{t});
            } else {
              
            }  
            
            ## Step 3.
            splice @{$self->{open_elements}}, $i;
          }
  
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ({
                  ## NOTE: As normal, except acts as a closer for any ...
                  h1 => 1, h2 => 1, h3 => 1, h4 => 1, h5 => 1, h6 => 1,
                 }->{$self->{t}->{tag_name}}) {
          ## has an element in scope
          my $i;
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[1] == HEADING_EL) {
              
              $i = $_;
              last INSCOPE;
            } elsif ($node->[1] & SCOPING_EL) {
              
              last INSCOPE;
            }
          } # INSCOPE
  
          unless (defined $i) { # has an element in scope
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## NOTE: Ignore the token.
          } else {
            ## Step 1. generate implied end tags
            while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
              
              pop @{$self->{open_elements}};
            }
            
            ## Step 2.
            if ($self->{open_elements}->[-1]->[0]->manakai_local_name
                    ne $self->{t}->{tag_name}) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                              text => $self->{t}->{tag_name}, token => $self->{t});
            } else {
              
            }
  
            ## Step 3.
            splice @{$self->{open_elements}}, $i;
          }
          
          $self->{t} = $self->_get_next_token;
          next B;
  
        } elsif ($self->{t}->{tag_name} eq 'p') {
          ## "In body" insertion mode, "p" start tag. As normal, except
          ## </p> implies <p> and ...
  
          ## "have an element in button scope".
          my $non_optional;
          my $i;
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[1] == P_EL) {
              
              $i = $_;
              last INSCOPE;
            } elsif ($node->[1] & BUTTON_SCOPING_EL) {
              
              last INSCOPE;
            } elsif ($node->[1] & END_TAG_OPTIONAL_EL) {
              ## NOTE: |END_TAG_OPTIONAL_EL| includes "p"
              
              #
            } else {
              
              $non_optional ||= $node;
              #
            }
          } # INSCOPE
  
          if (defined $i) {
            ## 1. Generate implied end tags
            #
  
            ## 2. If current node != "p", parse error
            if ($non_optional) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                              text => $non_optional->[0]->manakai_local_name,
                              token => $self->{t});
            } else {
              
            }
  
            ## 3. Pop
            splice @{$self->{open_elements}}, $i;
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
  
            
            ## As if <p>, then reprocess the current token
            my $el;
            
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'p']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
            $insert->($self, $el, $open_tables);
            ## NOTE: Not inserted into |$self->{open_elements}|.
          }
  
          $self->{t} = $self->_get_next_token;
          next B;
        } elsif ({
                  a => 1,
                  b => 1, big => 1, code => 1, em => 1, font => 1, i => 1,
                  nobr => 1, s => 1, small => 1, strike => 1,
                  strong => 1, tt => 1, u => 1,
                 }->{$self->{t}->{tag_name}}) {
          
          $formatting_end_tag->($self, $active_formatting_elements,
                                $open_tables, $self->{t});
          next B;
        } elsif ($self->{t}->{tag_name} eq 'br') {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                          text => 'br', token => $self->{t});
  
          ## As if <br>
          my $insert = $self->{insertion_mode} & TABLE_IMS
              ? $insert_to_foster : $insert_to_current;
          $reconstruct_active_formatting_elements
              ->($self, $insert, $active_formatting_elements, $open_tables);
          
          my $el;
          
        $el = $self->{document}->create_element_ns
          (HTML_NS, [undef,  'br']);
      
          $el->set_user_data (manakai_source_line => $self->{t}->{line})
              if defined $self->{t}->{line};
          $el->set_user_data (manakai_source_column => $self->{t}->{column})
              if defined $self->{t}->{column};
        
          $insert->($self, $el, $open_tables);
          
          ## Ignore the token.
          $self->{t} = $self->_get_next_token;
          next B;
        } else {
          if ($self->{t}->{tag_name} eq 'sarcasm') {
            sleep 0.001; # take a deep breath
          }
  
          ## Step 1
          my $node_i = -1;
          my $node = $self->{open_elements}->[$node_i];
  
          ## Step 2
          LOOP: {
            my $node_tag_name = $node->[0]->manakai_local_name;
            $node_tag_name =~ tr/A-Z/a-z/; # for SVG camelCase tag names
            if ($node_tag_name eq $self->{t}->{tag_name}) {
              ## Step 1
              ## generate implied end tags
              while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL and
                     $self->{open_elements}->[-1]->[0]->manakai_local_name
                         ne $self->{t}->{tag_name}) {
                
                ## NOTE: |<ruby><rt></ruby>|.
                pop @{$self->{open_elements}};
                $node_i++;
              }
          
              ## Step 2
              my $current_tag_name
                  = $self->{open_elements}->[-1]->[0]->manakai_local_name;
              $current_tag_name =~ tr/A-Z/a-z/;
              if ($current_tag_name ne $self->{t}->{tag_name}) {
                
                ## NOTE: <x><y></x>
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'not closed',
                                text => $self->{open_elements}->[-1]->[0]
                                    ->manakai_local_name,
                                token => $self->{t});
              } else {
                
              }
              
              ## Step 3
              splice @{$self->{open_elements}}, $node_i if $node_i < 0;
  
              $self->{t} = $self->_get_next_token;
              last LOOP;
            } else {
              ## Step 3
              if ($node->[1] & SPECIAL_EL or $node->[1] & SCOPING_EL) { ## "Special"
                
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                $self->{t} = $self->_get_next_token;
                last LOOP;
  
                ## NOTE: |<span><dd></span>a|: In Safari 3.1.2 and Opera
                ## 9.27, "a" is a child of <dd> (conforming).  In
                ## Firefox 3.0.2, "a" is a child of <body>.  In WinIE 7,
                ## "a" is a child of both <body> and <dd>.
              }
              
              
            }
            
            ## Step 4
            $node_i--;
            $node = $self->{open_elements}->[$node_i];
            
            ## Step 5;
            redo LOOP;
          } # LOOP
  	next B;
        }
      }
      next B;
    } # B
  
    ## Stop parsing # MUST
    
    ## TODO: script stuffs
  } # _tree_construct_main
  
  ## XXX: How this method is organized is somewhat out of date, although
  ## it still does what the current spec documents.
  sub set_inner_html ($$$$) {
    #my ($self, $string, $onerror, $get_wrapper) = @_;
    my ($class, $self);
    if (ref $_[0]) {
      $self = shift;
      $class = ref $self;
    } else {
      $class = shift;
      $self = $class->new;
    }
    my $node = shift; # /context/
    #my $s = \$_[0];
    my $onerror = $_[1];
    my $get_wrapper = $_[2] || sub ($) { return $_[0] };
  
    my $nt = $node->node_type;
    if ($nt == 9) { # Document (invoke the algorithm with no /context/ element)
      # MUST
      
      ## Step 1 # MUST
      ## TODO: If the document has an active parser, ...
      ## ISSUE: There is an issue in the spec.
      
      ## Step 2 # MUST
      for ($node->child_nodes->to_list) {
        $node->remove_child ($_);
      }
  
      ## Step 3, 4, 5 # MUST
      $self->parse_char_string ($_[0] => $node, $onerror, $get_wrapper);
    } elsif ($nt == 1) { # Element (invoke the algorithm with /context/ element)
      ## TODO: If non-html element
  
      ## NOTE: Most of this code is copied from |parse_string|
  
  ## TODO: Support for $get_wrapper
  
      ## F1. Create an HTML document.
      my $this_doc = $node->owner_document;
      my $doc = $this_doc->implementation->create_document;
      $doc->manakai_is_html (1);
  
      ## F2. Propagate quirkness flag
      my $node_doc = $node->owner_document;
      $doc->manakai_compat_mode ($node_doc->manakai_compat_mode);
  
      ## F3. Create an HTML parser
      my $p = $self;
      $p->{document} = $doc;
  
      ## Step 8 # MUST
      my $i = 0;
      $p->{line_prev} = $p->{line} = 1;
      $p->{column_prev} = -1;
      $p->{column} = 0;
  
      $self->{chars} = [split //, $_[0]];
      $self->{chars_pos} = 0;
      $self->{chars_pull_next} = sub { 0 };
      delete $self->{chars_was_cr};
  
      my $ponerror = $onerror || $self->onerror;
      $p->{parse_error} = sub {
        $ponerror->(line => $p->{line}, column => $p->{column}, @_);
      };
  
      $p->_initialize_tokenizer;
      $p->_initialize_tree_constructor;
  
      ## F4. If /context/ is not undef...
  
      ## F4.1. content model flag
      my $node_ns = $node->namespace_uri || '';
      my $node_ln = $node->manakai_local_name;
      if ($node_ns eq HTML_NS) {
        if ($node_ln eq 'title' or $node_ln eq 'textarea') {
          $p->{state} = RCDATA_STATE;
        } elsif ($node_ln eq 'script') {
          $p->{state} = SCRIPT_DATA_STATE;
        } elsif ({
          style => 1,
          script => 1,
          xmp => 1,
          iframe => 1,
          noembed => 1,
          noframes => 1,
          noscript => 1,
        }->{$node_ln}) {
          $p->{state} = RAWTEXT_STATE;
        } elsif ($node_ln eq 'plaintext') {
          $p->{state} = PLAINTEXT_STATE;
        }
        
        $p->{inner_html_node} = [$node, $el_category->{$node_ln}];
      } elsif ($node_ns eq SVG_NS) {
        $p->{inner_html_node} = [$node,
                                 $el_category_f->{$node_ns}->{$node_ln}
                                     || FOREIGN_EL | SVG_EL];
      } elsif ($node_ns eq MML_NS) {
        $p->{inner_html_node} = [$node,
                                 $el_category_f->{$node_ns}->{$node_ln}
                                     || FOREIGN_EL | MML_EL];
      } else {
        $p->{inner_html_node} = [$node, FOREIGN_EL];
      }
  
      ## F4.2. Root |html| element
      my $root = $doc->create_element_ns
        ('http://www.w3.org/1999/xhtml', [undef, 'html']);
  
      ## F4.3.
      $doc->append_child ($root);
  
      ## F4.4.
      push @{$p->{open_elements}}, [$root, $el_category->{html}];
      $p->{open_tables} = [[$root]];
  
      undef $p->{head_element};
  
      ## F4.5.
      $p->_reset_insertion_mode;
  
      ## F4.6.
      my $anode = $node;
      AN: while (defined $anode) {
        if ($anode->node_type == 1) {
          my $nsuri = $anode->namespace_uri;
          if (defined $nsuri and $nsuri eq HTML_NS) {
            if ($anode->manakai_local_name eq 'form') {
              
              $p->{form_element} = $anode;
              last AN;
            }
          }
        }
        $anode = $anode->parent_node;
      } # AN
  
      ## F.5. Set the input stream.
      $p->{confident} = 1; ## Confident: irrelevant.
  
      ## F.6. Start the parser.
      $p->{t} = $p->_get_next_token;
      $p->_construct_tree;
  
      ## F.7.
      for ($node->child_nodes->to_list) {
        $node->remove_child ($_);
      }
      ## ISSUE: mutation events? read-only?
  
      ## Step 11 # MUST
      for ($root->child_nodes->to_list) {
        $this_doc->adopt_node ($_);
        $node->append_child ($_);
      }
      ## ISSUE: mutation events?
  
      $p->_terminate_tree_constructor;
      $p->_clear_refs;
    } else {
      die "$0: |set_inner_html| is not defined for node of type $nt";
    }
  } # set_inner_html
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WHATPM_HTML_PARSER

$fatpacked{"Whatpm/HTML/ParserData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_HTML_PARSERDATA';
  package Whatpm::HTML::ParserData;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  
  ## ------ Namespace URLs ------
  
  sub HTML_NS () { q<http://www.w3.org/1999/xhtml> }
  sub MML_NS () { q<http://www.w3.org/1998/Math/MathML> }
  sub SVG_NS () { q<http://www.w3.org/2000/svg> }
  sub XLINK_NS () { q<http://www.w3.org/1999/xlink> }
  sub XML_NS () { q<http://www.w3.org/XML/1998/namespace> }
  sub XMLNS_NS () { q<http://www.w3.org/2000/xmlns/> }
  
  ## ------ Element categories ------
  
  our $AllVoidElements = {
    ## "Void elements" per syntax spec
    ## <http://www.whatwg.org/specs/web-apps/current-work/#void-elements>.
    area => 1, base => 1, br => 1, col => 1, command => 1, embed => 1,
    hr => 1, img => 1, input => 1, keygen => 1, link => 1, meta => 1,
    param => 1, source => 1, track => 1, wbr => 1,
  
    ## Obsolete void elements from serialization spec
    ## <http://www.whatwg.org/specs/web-apps/current-work/#serializing-html-fragments>.
    basefont => 1, bgsound => 1, frame => 1,
  
    ## "Macro" elements, from spec comment at
    ## <http://www.whatwg.org/specs/web-apps/current-work/#serializing-html-fragments>.
    #image => 1, isindex => 1,
  }; ## $AllVoidElements
  
  ## ------ Foreign element integration points ------
  
  ## MathML text integration point
  ## <http://www.whatwg.org/specs/web-apps/current-work/#mathml-text-integration-point>.
  our $MathMLTextIntegrationPoints = {
    mi => 1,
    mo => 1,
    mn => 1,
    ms => 1,
    mtext => 1,
  };
  
  ## <http://www.whatwg.org/specs/web-apps/current-work/#tree-construction>.
  our $MathMLTextIntegrationPointMathMLElements = {
    mglyph => 1,
    malignmark => 1,
  };
  
  ## HTML integration point (SVG elements)
  ## <http://www.whatwg.org/specs/web-apps/current-work/#html-integration-point>.
  our $SVGHTMLIntegrationPoints = {
    foreignObject => 1,
    desc => 1,
    title => 1,
  };
  
  ## HTML integration point (MathML elements)
  ## <http://www.whatwg.org/specs/web-apps/current-work/#html-integration-point>.
  our $MathMLHTMLIntegrationPoints = {
    #'annotation-xml' with encoding (ASCII case-insensitive) text/html
    #or application/xhtml+xml
  };
  
  ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inforeign>.
  our $ForeignContentBreakers = {
    b => 1, big => 1, blockquote => 1, body => 1, br => 1, center => 1,
    code => 1, dd => 1, div => 1, dl => 1, dt => 1, em => 1, embed => 1,
    h1 => 1, h2 => 1, h3 => 1, h4 => 1, h5 => 1, h6 => 1, head => 1,
    hr => 1, i => 1, img => 1, li => 1, listing => 1, menu => 1, meta => 1,
    nobr => 1, ol => 1, p => 1, pre => 1, ruby => 1, s => 1, small => 1,
    span => 1, strong => 1, strike => 1, sub => 1, sup => 1, table => 1,
    tt => 1, u => 1, ul => 1, var => 1,
    # font with "color"/"face"/"size"
  };
  
  ## ------ Attribute name mappings ------
  
  ## Adjust MathML attributes
  ## <http://www.whatwg.org/specs/web-apps/current-work/#adjust-mathml-attributes>.
  our $MathMLAttrNameFixup = {
    definitionurl => 'definitionURL',
  }; # $MathMLAttrNameFixup
  
  ## Adjust SVG attributes
  ## <http://www.whatwg.org/specs/web-apps/current-work/#adjust-svg-attributes>.
  our $SVGAttrNameFixup = {
    attributename => 'attributeName',
    attributetype => 'attributeType',
    basefrequency => 'baseFrequency',
    baseprofile => 'baseProfile',
    calcmode => 'calcMode',
    clippathunits => 'clipPathUnits',
    contentscripttype => 'contentScriptType',
    contentstyletype => 'contentStyleType',
    diffuseconstant => 'diffuseConstant',
    edgemode => 'edgeMode',
    externalresourcesrequired => 'externalResourcesRequired',
    filterres => 'filterRes',
    filterunits => 'filterUnits',
    glyphref => 'glyphRef',
    gradienttransform => 'gradientTransform',
    gradientunits => 'gradientUnits',
    kernelmatrix => 'kernelMatrix',
    kernelunitlength => 'kernelUnitLength',
    keypoints => 'keyPoints',
    keysplines => 'keySplines',
    keytimes => 'keyTimes',
    lengthadjust => 'lengthAdjust',
    limitingconeangle => 'limitingConeAngle',
    markerheight => 'markerHeight',
    markerunits => 'markerUnits',
    markerwidth => 'markerWidth',
    maskcontentunits => 'maskContentUnits',
    maskunits => 'maskUnits',
    numoctaves => 'numOctaves',
    pathlength => 'pathLength',
    patterncontentunits => 'patternContentUnits',
    patterntransform => 'patternTransform',
    patternunits => 'patternUnits',
    pointsatx => 'pointsAtX',
    pointsaty => 'pointsAtY',
    pointsatz => 'pointsAtZ',
    preservealpha => 'preserveAlpha',
    preserveaspectratio => 'preserveAspectRatio',
    primitiveunits => 'primitiveUnits',
    refx => 'refX',
    refy => 'refY',
    repeatcount => 'repeatCount',
    repeatdur => 'repeatDur',
    requiredextensions => 'requiredExtensions',
    requiredfeatures => 'requiredFeatures',
    specularconstant => 'specularConstant',
    specularexponent => 'specularExponent',
    spreadmethod => 'spreadMethod',
    startoffset => 'startOffset',
    stddeviation => 'stdDeviation',
    stitchtiles => 'stitchTiles',
    surfacescale => 'surfaceScale',
    systemlanguage => 'systemLanguage',
    tablevalues => 'tableValues',
    targetx => 'targetX',
    targety => 'targetY',
    textlength => 'textLength',
    viewbox => 'viewBox',
    viewtarget => 'viewTarget',
    xchannelselector => 'xChannelSelector',
    ychannelselector => 'yChannelSelector',
    zoomandpan => 'zoomAndPan',
  }; # $SVGAttrNameFixup
  
  ## Adjust foreign attributes
  ## <http://www.whatwg.org/specs/web-apps/current-work/#adjust-foreign-attributes>.
  our $ForeignAttrNamespaceFixup = {
    'xlink:actuate' => [XLINK_NS, ['xlink', 'actuate']],
    'xlink:arcrole' => [XLINK_NS, ['xlink', 'arcrole']],
    'xlink:href' => [XLINK_NS, ['xlink', 'href']],
    'xlink:role' => [XLINK_NS, ['xlink', 'role']],
    'xlink:show' => [XLINK_NS, ['xlink', 'show']],
    'xlink:title' => [XLINK_NS, ['xlink', 'title']],
    'xlink:type' => [XLINK_NS, ['xlink', 'type']],
    'xml:base' => [XML_NS, ['xml', 'base']],
    'xml:lang' => [XML_NS, ['xml', 'lang']],
    'xml:space' => [XML_NS, ['xml', 'space']],
    'xmlns' => [XMLNS_NS, [undef, 'xmlns']],
    'xmlns:xlink' => [XMLNS_NS, ['xmlns', 'xlink']],
  }; # $ForeignAttrNamespaceFixup
  
  ## The rules for parsing tokens in foreign content, Any other start
  ## tag, An element in the SVG namespace
  ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inforeign>.
  our $SVGElementNameFixup = {
    altglyph => 'altGlyph',
    altglyphdef => 'altGlyphDef',
    altglyphitem => 'altGlyphItem',
    animatecolor => 'animateColor',
    animatemotion => 'animateMotion',
    animatetransform => 'animateTransform',
    clippath => 'clipPath',
    feblend => 'feBlend',
    fecolormatrix => 'feColorMatrix',
    fecomponenttransfer => 'feComponentTransfer',
    fecomposite => 'feComposite',
    feconvolvematrix => 'feConvolveMatrix',
    fediffuselighting => 'feDiffuseLighting',
    fedisplacementmap => 'feDisplacementMap',
    fedistantlight => 'feDistantLight',
    feflood => 'feFlood',
    fefunca => 'feFuncA',
    fefuncb => 'feFuncB',
    fefuncg => 'feFuncG',
    fefuncr => 'feFuncR',
    fegaussianblur => 'feGaussianBlur',
    feimage => 'feImage',
    femerge => 'feMerge',
    femergenode => 'feMergeNode',
    femorphology => 'feMorphology',
    feoffset => 'feOffset',
    fepointlight => 'fePointLight',
    fespecularlighting => 'feSpecularLighting',
    fespotlight => 'feSpotLight',
    fetile => 'feTile',
    feturbulence => 'feTurbulence',
    foreignobject => 'foreignObject',
    glyphref => 'glyphRef',
    lineargradient => 'linearGradient',
    radialgradient => 'radialGradient',
    #solidcolor => 'solidColor', ## NOTE: Commented in spec (SVG1.2)
    textpath => 'textPath',  
  }; # $SVGElementNameFixup
  
  ## ------ Character references ------
  
  require Whatpm::_NamedEntityList;
  our $NamedCharRefs = $Whatpm::HTML::EntityChar;
  
  ## <http://www.whatwg.org/specs/web-apps/current-work/#tokenizing-character-references>.
  our $CharRefReplacements = {
    0x00 => 0xFFFD,
    0x0D => 0x000D,
    0x80 => 0x20AC,
    0x81 => 0x0081,
    0x82 => 0x201A,
    0x83 => 0x0192,
    0x84 => 0x201E,
    0x85 => 0x2026,
    0x86 => 0x2020,
    0x87 => 0x2021,
    0x88 => 0x02C6,
    0x89 => 0x2030,
    0x8A => 0x0160,
    0x8B => 0x2039,
    0x8C => 0x0152,
    0x8D => 0x008D,
    0x8E => 0x017D,
    0x8F => 0x008F,
    0x90 => 0x0090,
    0x91 => 0x2018,
    0x92 => 0x2019,
    0x93 => 0x201C,
    0x94 => 0x201D,
    0x95 => 0x2022,
    0x96 => 0x2013,
    0x97 => 0x2014,
    0x98 => 0x02DC,
    0x99 => 0x2122,
    0x9A => 0x0161,
    0x9B => 0x203A,
    0x9C => 0x0153,
    0x9D => 0x009D,
    0x9E => 0x017E,
    0x9F => 0x0178,
    #map { $_ => 0xFFFD } 0xD800..0xDFFF,
  }; # $CharRefReplacements
  
  our $NoncharacterCodePoints = {
    map { $_ => 1 }
      0xFDD0..0xFDEF,
      0xFFFE, 0xFFFF, 0x1FFFE, 0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE, 0x3FFFF,
      0x4FFFE, 0x4FFFF, 0x5FFFE, 0x5FFFF, 0x6FFFE, 0x6FFFF, 0x7FFFE,
      0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE, 0x9FFFF, 0xAFFFE, 0xAFFFF,
      0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE, 0xDFFFF, 0xEFFFE,
      0xEFFFF, 0xFFFFE, 0xFFFFF, 0x10FFFE, 0x10FFFF,
  }; # $NoncharacterCodePoints
  
  ## ------ DOCTYPEs ------
  
  ## Obsolete permitted DOCTYPE strings
  ## <http://www.whatwg.org/specs/web-apps/current-work/#obsolete-permitted-doctype-string>,
  ## <http://www.whatwg.org/specs/web-apps/current-work/#the-initial-insertion-mode>.
  
  ## Case-sensitive
  our $ObsoletePermittedDoctypes = {
    '-//W3C//DTD HTML 4.0//EN'
        => 'http://www.w3.org/TR/REC-html40/strict.dtd', # or missing
    '-//W3C//DTD HTML 4.01//EN'
        => 'http://www.w3.org/TR/html4/strict.dtd', # or missing
    '-//W3C//DTD XHTML 1.0 Strict//EN'
        => 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd', # required
    '-//W3C//DTD XHTML 1.1//EN'
        => 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd', # required
  };
  
  ## ASCII case-insensitive
  our $QuirkyPublicIDPrefixes = [
    "+//SILMARIL//DTD HTML PRO V0R11 19970101//",
    "-//ADVASOFT LTD//DTD HTML 3.0 ASWEDIT + EXTENSIONS//",
    "-//AS//DTD HTML 3.0 ASWEDIT + EXTENSIONS//",
    "-//IETF//DTD HTML 2.0 LEVEL 1//",
    "-//IETF//DTD HTML 2.0 LEVEL 2//",
    "-//IETF//DTD HTML 2.0 STRICT LEVEL 1//",
    "-//IETF//DTD HTML 2.0 STRICT LEVEL 2//",
    "-//IETF//DTD HTML 2.0 STRICT//",
    "-//IETF//DTD HTML 2.0//",
    "-//IETF//DTD HTML 2.1E//",
    "-//IETF//DTD HTML 3.0//",
    "-//IETF//DTD HTML 3.2 FINAL//",
    "-//IETF//DTD HTML 3.2//",
    "-//IETF//DTD HTML 3//",
    "-//IETF//DTD HTML LEVEL 0//",
    "-//IETF//DTD HTML LEVEL 1//",
    "-//IETF//DTD HTML LEVEL 2//",
    "-//IETF//DTD HTML LEVEL 3//",
    "-//IETF//DTD HTML STRICT LEVEL 0//",
    "-//IETF//DTD HTML STRICT LEVEL 1//",
    "-//IETF//DTD HTML STRICT LEVEL 2//",
    "-//IETF//DTD HTML STRICT LEVEL 3//",
    "-//IETF//DTD HTML STRICT//",
    "-//IETF//DTD HTML//",
    "-//METRIUS//DTD METRIUS PRESENTATIONAL//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 2.0 HTML STRICT//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 2.0 HTML//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 2.0 TABLES//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 3.0 HTML STRICT//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 3.0 HTML//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 3.0 TABLES//",
    "-//NETSCAPE COMM. CORP.//DTD HTML//",
    "-//NETSCAPE COMM. CORP.//DTD STRICT HTML//",
    "-//O'REILLY AND ASSOCIATES//DTD HTML 2.0//",
    "-//O'REILLY AND ASSOCIATES//DTD HTML EXTENDED 1.0//",
    "-//O'REILLY AND ASSOCIATES//DTD HTML EXTENDED RELAXED 1.0//",
    "-//SOFTQUAD SOFTWARE//DTD HOTMETAL PRO 6.0::19990601::EXTENSIONS TO HTML 4.0//",
    "-//SOFTQUAD//DTD HOTMETAL PRO 4.0::19971010::EXTENSIONS TO HTML 4.0//",
    "-//SPYGLASS//DTD HTML 2.0 EXTENDED//",
    "-//SQ//DTD HTML 2.0 HOTMETAL + EXTENSIONS//",
    "-//SUN MICROSYSTEMS CORP.//DTD HOTJAVA HTML//",
    "-//SUN MICROSYSTEMS CORP.//DTD HOTJAVA STRICT HTML//",
    "-//W3C//DTD HTML 3 1995-03-24//",
    "-//W3C//DTD HTML 3.2 DRAFT//",
    "-//W3C//DTD HTML 3.2 FINAL//",
    "-//W3C//DTD HTML 3.2//",
    "-//W3C//DTD HTML 3.2S DRAFT//",
    "-//W3C//DTD HTML 4.0 FRAMESET//",
    "-//W3C//DTD HTML 4.0 TRANSITIONAL//",
    "-//W3C//DTD HTML EXPERIMETNAL 19960712//",
    "-//W3C//DTD HTML EXPERIMENTAL 970421//",
    "-//W3C//DTD W3 HTML//",
    "-//W3O//DTD W3 HTML 3.0//",
    "-//WEBTECHS//DTD MOZILLA HTML 2.0//",
    "-//WEBTECHS//DTD MOZILLA HTML//",
  ]; # $QuirkyPublicIDPrefixes
  
  ## ASCII case-insensitive
  our $QuirkyPublicIDs = {
    "-//W3O//DTD W3 HTML STRICT 3.0//EN//" => 1,
    "-/W3C/DTD HTML 4.0 TRANSITIONAL/EN" => 1,
    "HTML" => 1,
  }; # $QuirkyPublicIDs
  
  ## ASCII case-insensitive
  ## Quirks or limited quirks, depending on existence of system id
  ## -//W3C//DTD HTML 4.01 FRAMESET// (prefix)
  ## -//W3C//DTD HTML 4.01 TRANSITIONAL// (prefix)
  
  ## ASCII case-insensitive
  ## Limited quirks
  ## -//W3C//DTD XHTML 1.0 FRAMESET// (prefix)
  ## -//W3C//DTD XHTML 1.0 TRANSITIONAL// (prefix)
  
  ## ASCII case-insensitive
  ## Quirks system id
  ## http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd
  
  =head1 NAME
  
  Whatpm::HTML::ParserData - Data for HTML parser
  
  =head1 DESCRIPTION
  
  The C<Whatpm::HTML::ParserData> module contains data for HTML parser,
  extracted from the HTML Living Standard.
  
  =head1 CONSTANTS
  
  Following constants for namespace URLs are defined (but not exported):
  C<HTML_NS> (HTML namespace), C<SVG_NS> (SVG namespace), C<MML_NS>
  (MathML namespace), C<XML_NS> (XML namespace), C<XMLNS_NS> (XML
  Namespace namespace), and C<XLINK_NS> (XLink namespace).
  
  =head1 VARIABLES
  
  Following data from the HTML specification are included:
  
  =over 4
  
  =item $AllVoidElements
  
  =item $MathMLTextIntegrationPoints
  
  =item $MathMLHTMLIntegrationPoints
  
  =item $SVGHTMLIntegrationPoints
  
  =item $ForeignContentBreakers
  
  =item $MathMLAttrNameFixup
  
  =item $SVGAttrNameFixup
  
  =item $ForeignAttrNamespaceFixup
  
  =item $SVGElementNameFixup
  
  =item $NamedCharRefs
  
  =item $CharRefReplacements
  
  =item $NoncharacterCodePoints
  
  =item $ObsoletePermittedDoctypes
  
  =item $QuirkyPublicIDPrefixes
  
  =item $QuirkyPublicIDs
  
  =back
  
  =head1 SEE ALSO
  
  HTML Living Standard
  <http://www.whatwg.org/specs/web-apps/current-work/>.
  
  =head1 LICENSE
  
  Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation, and
  Opera Software ASA.
  
  You are granted a license to use, reproduce and create derivative
  works of this document.
  
  =cut
  
  1;
  
WHATPM_HTML_PARSERDATA

$fatpacked{"Whatpm/HTML/Serializer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_HTML_SERIALIZER';
  package Whatpm::HTML::Serializer;
  use strict;
  use warnings;
  our $VERSION = '1.8';
  
  sub _in_cdata ($) {
    my $node = $_[0];
    
    my $ns = $node->namespace_uri;
    return 0 if not defined $ns; # in no namespace, or not an Element
    return 0 unless $ns eq q<http://www.w3.org/1999/xhtml>;
    
    my $ln = $node->manakai_local_name;
    return 1 if {
      style => 1,
      script => 1,
      xmp => 1,
      iframe => 1,
      noembed => 1,
      noframes => 1,
      plaintext => 1,
    }->{$ln};
    return $Whatpm::ScriptingEnabled if $ln eq 'noscript';
  
    return 0;
  } # _in_cdata
  
  sub get_inner_html ($$$) {
    my (undef, $node, $onerror) = @_;
  
    ## Step 1
    my $s = '';
    
    ## Step 2
    my $node_in_cdata = _in_cdata ($node);
    my @node = map { [$_, $node_in_cdata] } $node->child_nodes->to_list;
    C: while (@node) {
      ## Step 2.1
      my $c = shift @node;
      my $child = $c->[0];
  
      ## End tag
      if (not ref $child) {
        $s .= $child;
        next;
      }
  
      ## Step 2.2
      my $nt = $child->node_type;
      if ($nt == 1) { # Element
        my $tag_name;
        my $child_ns = $child->namespace_uri || '';
        if ($child_ns eq q<http://www.w3.org/1999/xhtml> or
            $child_ns eq q<http://www.w3.org/2000/svg> or
            $child_ns eq q<http://www.w3.org/1998/Math/MathML>) {
          $tag_name = $child->manakai_local_name;
        } else {
          $tag_name = $child->manakai_tag_name;
        }
        $s .= '<' . $tag_name;
  
        my @attrs = @{$child->attributes}; # sort order MUST be stable
        for my $attr (@attrs) { # order is implementation dependent
          my $attr_name;
          my $attr_ns = $attr->namespace_uri;
          if (not defined $attr_ns) {
            $attr_name = $attr->manakai_local_name;
          } elsif ($attr_ns eq q<http://www.w3.org/XML/1998/namespace>) {
            $attr_name = 'xml:' . $attr->manakai_local_name;
          } elsif ($attr_ns eq q<http://www.w3.org/2000/xmlns/>) {
            $attr_name = 'xmlns:' . $attr->manakai_local_name;
            $attr_name = 'xmlns' if $attr_name eq 'xmlns:xmlns';
          } elsif ($attr_ns eq q<http://www.w3.org/1999/xlink>) {
            $attr_name = 'xlink:' . $attr->manakai_local_name;
          } else {
            $attr_name = $attr->manakai_name;
          }
          $s .= ' ' . $attr_name . '="';
          my $attr_value = $attr->value;
          ## escape
          $attr_value =~ s/&/&amp;/g;
          $attr_value =~ s/\xA0/&nbsp;/g;
          $attr_value =~ s/"/&quot;/g;
          #$attr_value =~ s/</&lt;/g;
          #$attr_value =~ s/>/&gt;/g;
          $s .= $attr_value . '"';
        }
        $s .= '>';
        
        next C if {
          area => 1, base => 1, basefont => 1, bgsound => 1, br => 1,
          col => 1, command => 1, embed => 1, frame => 1, hr => 1,
          img => 1, input => 1, keygen => 1, link => 1, meta => 1,
          param => 1, source => 1, track => 1, wbr => 1,
          # image, isindex
        }->{$tag_name} and $child_ns eq q<http://www.w3.org/1999/xhtml>;
  
        $s .= "\x0A"
            if {pre => 1, textarea => 1, listing => 1}->{$tag_name} and
                $child_ns eq q<http://www.w3.org/1999/xhtml>;
  
        my $child_in_cdata = _in_cdata ($child);
        unshift @node,
            (map { [$_, $child_in_cdata] } $child->child_nodes->to_list),
            (['</' . $tag_name . '>', 0]);
      } elsif ($nt == 3 or $nt == 4) { # Text or CDATASection
        if ($c->[1]) { # in CDATA or RCDATA or PLAINTEXT element
          $s .= $child->data;
        } else {
          my $value = $child->data;
          $value =~ s/&/&amp;/g;
          $value =~ s/\xA0/&nbsp;/g;
          $value =~ s/</&lt;/g;
          $value =~ s/>/&gt;/g;
          #$value =~ s/"/&quot;/g;
          $s .= $value;
        }
      } elsif ($nt == 8) { # Comment
        $s .= '<!--' . $child->data . '-->';
      } elsif ($nt == 10) { # DocumentType
        $s .= '<!DOCTYPE ' . $child->name . '>';
      } elsif ($nt == 7) { # ProcessingInstruction
        $s .= '<?' . $child->target . ' ' . $child->data . '>';
      } elsif ($nt == 5) { # EntityReference
        push @node, map { [$_, $c->[1]] } $child->child_nodes->to_list;
      } else {
        # INVALID_STATE_ERROR
        $onerror->($child) if defined $onerror;
      }
    } # C
    
    ## Step 3
    return \$s;
  } # get_inner_html
  
  =head1 LICENSE
  
  Copyright 2007-2011 Wakaba <w@suika.fam.cx>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
WHATPM_HTML_SERIALIZER

$fatpacked{"Whatpm/HTML/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_HTML_TOKENIZER';
  package Whatpm::HTML::Tokenizer; # -*- Perl -*-
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '2.0';
  use Whatpm::HTML::Defs;
  use Whatpm::HTML::InputStream;
  use Whatpm::HTML::ParserData;
  push our @ISA, qw(Whatpm::HTML::InputStream);
  
  ## This module implements the tokenization phase of both HTML5 and
  ## XML5.  Notes like this are usually based on the latest HTML
  ## specification.  Since XML is different from HTML, and since XML5
  ## specification has not been maintained any more, there is a few
  ## differences from HTML's tokenization.  Such differences are marked
  ## by prefix "XML5:".
  
  ## ------ Token types (for compat) ------
  
  BEGIN {
    require Exporter;
    push our @ISA, 'Exporter';
  
    our @EXPORT_OK = qw(
      DOCTYPE_TOKEN COMMENT_TOKEN START_TAG_TOKEN END_TAG_TOKEN
      END_OF_FILE_TOKEN CHARACTER_TOKEN PI_TOKEN ABORT_TOKEN
      END_OF_DOCTYPE_TOKEN ATTLIST_TOKEN ELEMENT_TOKEN
      GENERAL_ENTITY_TOKEN PARAMETER_ENTITY_TOKEN NOTATION_TOKEN
    );
    
    our %EXPORT_TAGS = (token => [@EXPORT_OK]);
  }
  use Whatpm::HTML::Defs qw(
    DOCTYPE_TOKEN COMMENT_TOKEN START_TAG_TOKEN END_TAG_TOKEN
    END_OF_FILE_TOKEN CHARACTER_TOKEN PI_TOKEN ABORT_TOKEN
    END_OF_DOCTYPE_TOKEN ATTLIST_TOKEN ELEMENT_TOKEN 
    GENERAL_ENTITY_TOKEN PARAMETER_ENTITY_TOKEN NOTATION_TOKEN
  );
  
  ## XML5: XML5 has "empty tag token".  In this implementation, it is
  ## represented as a start tag token with $self->{self_closing} flag
  ## set to true.
  
  ## XML5: XML5 has "short end tag token".  In this implementation, it
  ## is represented as an end tag token with $token->{tag_name} flag set
  ## to an empty string.
  
  ## ------ Character reference mappings ------
  
  my $InvalidCharRefs = {};
  
  for (0x0000, 0xD800..0xDFFF) {
    $InvalidCharRefs->{0}->{$_} =
    $InvalidCharRefs->{1.0}->{$_} =
    $InvalidCharRefs->{1.1}->{$_} = [0xFFFD, 'must'];
  }
  for (0x0001..0x0008, 0x000B, 0x000E..0x001F) {
    $InvalidCharRefs->{0}->{$_} =
    $InvalidCharRefs->{1.0}->{$_} = [$_, 'must'];
    $InvalidCharRefs->{1.1}->{$_} = [$_, 'warn'];
  }
  $InvalidCharRefs->{1.0}->{0x000C} = [0x000C, 'must'];
  $InvalidCharRefs->{1.1}->{0x000C} = [0x000C, 'warn'];
  $InvalidCharRefs->{0}->{0x007F} = [0x007F, 'must'];
  for (0x007F..0x009F) {
    $InvalidCharRefs->{1.0}->{$_} =
    $InvalidCharRefs->{1.1}->{$_} = [$_, 'warn'];
  }
  delete $InvalidCharRefs->{1.1}->{0x0085};
  for (keys %$Whatpm::HTML::ParserData::NoncharacterCodePoints) {
    $InvalidCharRefs->{0}->{$_} = [$_, 'must'];
    $InvalidCharRefs->{1.0}->{$_} =
    $InvalidCharRefs->{1.1}->{$_} = [$_, 'warn'];
  }
  for (0xFFFE, 0xFFFF) {
    $InvalidCharRefs->{1.0}->{$_} =
    $InvalidCharRefs->{1.1}->{$_} = [$_, 'must'];
  }
  for (keys %$Whatpm::HTML::ParserData::CharRefReplacements) {
    $InvalidCharRefs->{0}->{$_}
        = [$Whatpm::HTML::ParserData::CharRefReplacements->{$_}, 'must'];
  }
  
  ## ------ The tokenizer ------
  
  my $Action = [];
  my $XMLAction = [];
  
  sub _initialize_tokenizer ($) {
    my $self = shift;
  
    ## NOTE: Fields set by |new| constructor:
    #$self->{level}
    #$self->{set_nc}
    #$self->{parse_error}
    #$self->{is_xml} (if XML)
  
    $self->{state} = DATA_STATE; # MUST
    #$self->{kwd} = ''; # State-dependent keyword; initialized when used
    #$self->{entity__value}; # initialized when used
    #$self->{entity__match}; # initialized when used
    undef $self->{ct}; # current token
    undef $self->{ca}; # current attribute
    undef $self->{last_stag_name}; # last emitted start tag name
    #$self->{prev_state}; # initialized when used
    delete $self->{self_closing};
    #$self->{chars}
    $self->{chars_pos} = 0;
    delete $self->{chars_was_cr};
    $self->{char_buffer} = '';
    $self->{char_buffer_pos} = 0;
    $self->{nc} = -1; # next input character
    #$self->{next_nc}
    
      $self->_set_nc;
    
    $self->{token} = [];
    # $self->{escape}
  
    if ($self->{is_xml}) {
      $self->{action_set} = $XMLAction;
    } else {
      $self->{action_set} = $Action;
    }
  } # _initialize_tokenizer
  
  ## A token has:
  ##   ->{type} == DOCTYPE_TOKEN, START_TAG_TOKEN, END_TAG_TOKEN, COMMENT_TOKEN,
  ##       CHARACTER_TOKEN, END_OF_FILE_TOKEN, PI_TOKEN, or ABORT_TOKEN
  ##   ->{name} (DOCTYPE_TOKEN)
  ##   ->{tag_name} (START_TAG_TOKEN, END_TAG_TOKEN)
  ##   ->{target} (PI_TOKEN)
  ##   ->{pubid} (DOCTYPE_TOKEN)
  ##   ->{sysid} (DOCTYPE_TOKEN)
  ##   ->{quirks} == 1 or 0 (DOCTYPE_TOKEN): "force-quirks" flag
  ##   ->{attributes} isa HASH (START_TAG_TOKEN, END_TAG_TOKEN)
  ##        ->{name}
  ##        ->{value}
  ##        ->{has_reference} == 1 or 0
  ##        ->{index}: Index of the attribute in a tag.
  ##   ->{data} (COMMENT_TOKEN, CHARACTER_TOKEN, PI_TOKEN)
  ##   ->{has_reference} == 1 or 0 (CHARACTER_TOKEN)
  ##   ->{last_index} (ELEMENT_TOKEN): Next attribute's index - 1.
  ##   ->{has_internal_subset} = 1 or 0 (DOCTYPE_TOKEN)
  
  ## NOTE: The "self-closing flag" is hold as |$self->{self_closing}|.
  ##     |->{self_closing}| is used to save the value of |$self->{self_closing}|
  ##     while the token is pushed back to the stack.
  
  ## Emitted token MUST immediately be handled by the tree construction state.
  
  ## Before each step, UA MAY check to see if either one of the scripts in
  ## "list of scripts that will execute as soon as possible" or the first
  ## script in the "list of scripts that will execute asynchronously",
  ## has completed loading.  If one has, then it MUST be executed
  ## and removed from the list.
  
  ## TODO: Polytheistic slash SHOULD NOT be used. (Applied only to atheists.)
  ## (This requirement was dropped from HTML5 spec, unfortunately.)
  
  my $is_space = {
    0x0009 => 1, # CHARACTER TABULATION (HT)
    0x000A => 1, # LINE FEED (LF)
    #0x000B => 0, # LINE TABULATION (VT)
    0x000C => 1, # FORM FEED (FF) ## XML5: Not a space character.
    0x000D => 1, # CARRIAGE RETURN (CR)
    0x0020 => 1, # SPACE (SP)
  };
  
  sub KEY_ELSE_CHAR () { 255 }
  sub KEY_ULATIN_CHAR () { 254 }
  sub KEY_LLATIN_CHAR () { 253 }
  sub KEY_EOF_CHAR () { 252 }
  sub KEY_SPACE_CHAR () { 251 }
  
  $Action->[DATA_STATE]->[0x0026] = {
    name => 'data &',
    state => ENTITY_STATE, # "entity data state" + "consume a character reference"
    state_set => {entity_add => -1, prev_state => DATA_STATE},
  };
  $Action->[DATA_STATE]->[0x003C] = {
    name => 'data <',
    state => TAG_OPEN_STATE,
  };
  $Action->[DATA_STATE]->[KEY_EOF_CHAR] = {
    name => 'data eof',
    emit => END_OF_FILE_TOKEN,
    reconsume => 1,
  };
  $Action->[DATA_STATE]->[0x0000] = {
    name => 'data null',
    emit => CHARACTER_TOKEN,
    error => 'NULL',
  };
  $Action->[DATA_STATE]->[KEY_ELSE_CHAR] = {
    name => 'data else',
    emit => CHARACTER_TOKEN,
    emit_data_read_until => qq{\x00<&},
  };
    $XMLAction->[DATA_STATE]->[0x005D] = { # ]
      name => 'data ]',
      state => DATA_MSE1_STATE,
      emit => CHARACTER_TOKEN,
    };
    $XMLAction->[DATA_STATE]->[KEY_ELSE_CHAR] = {
      name => 'data else xml',
      emit => CHARACTER_TOKEN,
      emit_data_read_until => qq{\x00<&\]},
    };
  $Action->[RCDATA_STATE]->[0x0026] = {
    name => 'rcdata &',
    state => ENTITY_STATE, # "entity data state" + "consume a character reference"
    state_set => {entity_add => -1, prev_state => RCDATA_STATE},
  };
  $Action->[RCDATA_STATE]->[0x003C] = {
    name => 'rcdata <',
    state => RCDATA_LT_STATE,
  };
  $Action->[RCDATA_STATE]->[KEY_EOF_CHAR] = $Action->[DATA_STATE]->[KEY_EOF_CHAR];
  $Action->[RCDATA_STATE]->[0x0000] = {
    name => 'rcdata null',
    emit => CHARACTER_TOKEN,
    emit_data => "\x{FFFD}",
    error => 'NULL',
  };
  $Action->[RCDATA_STATE]->[KEY_ELSE_CHAR] = {
    name => 'rcdata else',
    emit => CHARACTER_TOKEN,
    emit_data_read_until => qq{\x00<&},
  };
  $Action->[RAWTEXT_STATE]->[0x003C] = {
    name => 'rawtext <',
    state => RAWTEXT_LT_STATE,
  };
  $Action->[RAWTEXT_STATE]->[KEY_EOF_CHAR] = $Action->[DATA_STATE]->[KEY_EOF_CHAR];
  $Action->[RAWTEXT_STATE]->[0x0000] = $Action->[RCDATA_STATE]->[0x0000];
  $Action->[RAWTEXT_STATE]->[KEY_ELSE_CHAR] = {
    name => 'rawtext else',
    emit => CHARACTER_TOKEN,
    emit_data_read_until => qq{\x00<},
  };
  $Action->[SCRIPT_DATA_STATE]->[0x003C] = {
    name => 'script data <',
    state => SCRIPT_DATA_LT_STATE,
  };
  $Action->[SCRIPT_DATA_STATE]->[KEY_EOF_CHAR] = $Action->[DATA_STATE]->[KEY_EOF_CHAR];
  $Action->[SCRIPT_DATA_STATE]->[0x0000] = $Action->[RAWTEXT_STATE]->[0x0000];
  $Action->[SCRIPT_DATA_STATE]->[KEY_ELSE_CHAR] = $Action->[RAWTEXT_STATE]->[KEY_ELSE_CHAR];
  $Action->[PLAINTEXT_STATE]->[KEY_EOF_CHAR] = $Action->[DATA_STATE]->[KEY_EOF_CHAR];
  $Action->[PLAINTEXT_STATE]->[0x0000] = $Action->[RAWTEXT_STATE]->[0x0000];
  $Action->[PLAINTEXT_STATE]->[KEY_ELSE_CHAR] = {
    name => 'plaintext else',
    emit => CHARACTER_TOKEN,
    emit_data_read_until => qq{\x00},
  };
  # "Tag open state" is known as "tag state" in XML5.
  $Action->[TAG_OPEN_STATE]->[0x0021] = {
    name => 'tag open !',
    state => MARKUP_DECLARATION_OPEN_STATE,
  };
  $Action->[TAG_OPEN_STATE]->[0x002F] = {
    name => 'tag open /',
    state => CLOSE_TAG_OPEN_STATE,
  };
  $Action->[TAG_OPEN_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'tag open uc',
    ct => {
      type => START_TAG_TOKEN,
      delta => 1,
      append_tag_name => 0x0020, # UC -> lc
    },
    state => TAG_NAME_STATE,
  };
    $XMLAction->[TAG_OPEN_STATE]->[KEY_ULATIN_CHAR] = {
      name => 'tag open uc xml',
      ct => {
        type => START_TAG_TOKEN,
        delta => 1,
        append_tag_name => 0x0000,
      },
      state => TAG_NAME_STATE,
    };
  $Action->[TAG_OPEN_STATE]->[KEY_LLATIN_CHAR] = {
    name => 'tag open lc',
    ct => {
      type => START_TAG_TOKEN,
      delta => 1,
      append_tag_name => 0x0000,
    },
    state => TAG_NAME_STATE,
  };
  $Action->[TAG_OPEN_STATE]->[0x003F] = {
    name => 'tag open ?',
    state => BOGUS_COMMENT_STATE,
    error => 'pio',
    error_delta => 1,
    ct => {
      type => COMMENT_TOKEN,
    },
    reconsume => 1, ## $self->{nc} is intentionally left as is
  };
    $XMLAction->[TAG_OPEN_STATE]->[0x003F] = { # ?
      name => 'tag open ? xml',
      state => PI_STATE,
    };
  $Action->[TAG_OPEN_STATE]->[KEY_SPACE_CHAR] =
  $Action->[TAG_OPEN_STATE]->[0x003E] = { # >
    name => 'tag open else',
    error => 'bare stago',
    error_delta => 1,
    state => DATA_STATE,
    reconsume => 1,
    emit => CHARACTER_TOKEN,
    emit_data => '<',
    emit_delta => 1,
  };
  $Action->[TAG_OPEN_STATE]->[KEY_ELSE_CHAR] = $Action->[TAG_OPEN_STATE]->[0x003E];
    $XMLAction->[TAG_OPEN_STATE]->[0x0000] = {
      name => 'tag open null xml',
      ct => {
        type => START_TAG_TOKEN,
        delta => 1,
        append_tag_name => 0xFFFD,
      },
      error => 'NULL',
      state => TAG_NAME_STATE,
    };
    ## XML5: "<:" has a parse error.
    $XMLAction->[TAG_OPEN_STATE]->[KEY_ELSE_CHAR] = {
      name => 'tag open else xml',
      ct => {
        type => START_TAG_TOKEN,
        delta => 1,
        append_tag_name => 0x0000,
      },
      state => TAG_NAME_STATE,
    };
  $Action->[RCDATA_LT_STATE]->[0x002F] = {
    name => 'rcdata lt /',
    state => RCDATA_END_TAG_OPEN_STATE,
    buffer => {clear => 1},
  };
  $Action->[RAWTEXT_LT_STATE]->[0x002F] = {
    name => 'rawtext lt /',
    state => RAWTEXT_END_TAG_OPEN_STATE,
    buffer => {clear => 1},
  };
  $Action->[SCRIPT_DATA_LT_STATE]->[0x002F] = {
    name => 'script data lt /',
    state => SCRIPT_DATA_END_TAG_OPEN_STATE,
    buffer => {clear => 1},
  };
  $Action->[SCRIPT_DATA_ESCAPED_LT_STATE]->[0x002F] = {
    name => 'script data escaped lt /',
    state => SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE,
    buffer => {clear => 1},
  };
  $Action->[SCRIPT_DATA_LT_STATE]->[0x0021] = {
    name => 'script data lt !',
    state => SCRIPT_DATA_ESCAPE_START_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '<!',
  };
  $Action->[SCRIPT_DATA_ESCAPED_LT_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'script data escaped lt uc',
    emit => CHARACTER_TOKEN,
    emit_data => '<',
    emit_data_append => 1,
    buffer => {clear => 1, append => 0x0020}, # UC -> lc
    state => SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE,
  };
  $Action->[SCRIPT_DATA_ESCAPED_LT_STATE]->[KEY_LLATIN_CHAR] = {
    name => 'script data escaped lt lc',
    emit => CHARACTER_TOKEN,
    emit_data => '<',
    emit_data_append => 1,
    buffer => {clear => 1, append => 0x0000},
    state => SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE,
  };
  $Action->[RCDATA_LT_STATE]->[KEY_ELSE_CHAR] = {
    name => 'rcdata lt else',
    state => RCDATA_STATE,
    reconsume => 1,
    emit => CHARACTER_TOKEN,
    emit_data => '<',
  };
  $Action->[RAWTEXT_LT_STATE]->[KEY_ELSE_CHAR] = {
    name => 'rawtext lt else',
    state => RAWTEXT_STATE,
    reconsume => 1,
    emit => CHARACTER_TOKEN,
    emit_data => '<',
  };
  $Action->[SCRIPT_DATA_LT_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data lt else',
    state => SCRIPT_DATA_STATE,
    reconsume => 1,
    emit => CHARACTER_TOKEN,
    emit_data => '<',
  };
  $Action->[SCRIPT_DATA_ESCAPED_LT_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data escaped lt else',
    state => SCRIPT_DATA_ESCAPED_STATE,
    reconsume => 1,
    emit => CHARACTER_TOKEN,
    emit_data => '<',
  };
  ## XXX "End tag token" in latest HTML5 and in XML5.
  $Action->[CLOSE_TAG_OPEN_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'end tag open uc',
    ct => {
      type => END_TAG_TOKEN,
      delta => 2,
      append_tag_name => 0x0020, # UC -> lc
    },
    state => TAG_NAME_STATE,
  };
    $XMLAction->[CLOSE_TAG_OPEN_STATE]->[KEY_ULATIN_CHAR] = {
      name => 'end tag open uc xml',
      ct => {
        type => END_TAG_TOKEN,
        delta => 2,
        append_tag_name => 0x0000,
      },
      state => TAG_NAME_STATE,
    };
  $Action->[CLOSE_TAG_OPEN_STATE]->[KEY_LLATIN_CHAR] = {
    name => 'end tag open lc',
    ct => {
      type => END_TAG_TOKEN,
      delta => 2,
      append_tag_name => 0x0000,
    },
    state => TAG_NAME_STATE,
  };
  $Action->[CLOSE_TAG_OPEN_STATE]->[0x003E] = {
    name => 'end tag open >',
    error => 'empty end tag',
    error_delta => 2, # "<" in "</>"
    state => DATA_STATE,
  };
    ## XML5: No parse error.
    
    ## NOTE: This parser raises a parse error, since it supports XML1,
    ## not XML5.
    
    ## NOTE: A short end tag token.
  
    $XMLAction->[CLOSE_TAG_OPEN_STATE]->[0x003E] = {
      name => 'end tag open > xml',
      error => 'empty end tag',
      error_delta => 2, # "<" in "</>"
      state => DATA_STATE,
      ct => {
        type => END_TAG_TOKEN,
        delta => 2,
      },
      emit => '',
    };
  $Action->[CLOSE_TAG_OPEN_STATE]->[KEY_EOF_CHAR] = {
    name => 'end tag open eof',
    error => 'bare etago',
    state => DATA_STATE,
    reconsume => 1,
    emit => CHARACTER_TOKEN,
    emit_data => '</',
    emit_delta => 2,
  };
  $Action->[CLOSE_TAG_OPEN_STATE]->[KEY_SPACE_CHAR] = 
  $Action->[CLOSE_TAG_OPEN_STATE]->[KEY_ELSE_CHAR] = {
    name => 'end tag open else',
    error => 'bogus end tag',
    error_delta => 2, # "<" of "</"
    state => BOGUS_COMMENT_STATE,
    ct => {
      type => COMMENT_TOKEN,
      delta => 2, # "<" of "</"
    },
    reconsume => 1,
    ## NOTE: $self->{nc} is intentionally left as is.  Although the
    ## "anything else" case of the spec not explicitly states that the
    ## next input character is to be reconsumed, it will be included to
    ## the |data| of the comment token generated from the bogus end tag,
    ## as defined in the "bogus comment state" entry.
  };
    $XMLAction->[CLOSE_TAG_OPEN_STATE]->[0x0000] = {
      name => 'end tag open null xml',
      ct => {
        type => END_TAG_TOKEN,
        delta => 2,
        append_tag_name => 0xFFFD,
      },
      error => 'NULL',
      state => TAG_NAME_STATE, ## XML5: "end tag name state".
    };
    ## XML5: "</:" is a parse error.
    $XMLAction->[CLOSE_TAG_OPEN_STATE]->[KEY_ELSE_CHAR] = {
      name => 'end tag open else xml',
      ct => {
        type => END_TAG_TOKEN,
        delta => 2,
        append_tag_name => 0x0000,
      },
      state => TAG_NAME_STATE, ## XML5: "end tag name state".
    };
        ## This switch-case implements "tag name state", "RCDATA end tag
        ## name state", "RAWTEXT end tag name state", and "script data
        ## end tag name state" jointly with the implementation of
        ## "RCDATA end tag open state" and so on.
  $Action->[TAG_NAME_STATE]->[KEY_SPACE_CHAR] = {
    name => 'tag name sp',
    state => BEFORE_ATTRIBUTE_NAME_STATE,
  };
  $Action->[TAG_NAME_STATE]->[0x003E] = {
    name => 'tag name >',
    state => DATA_STATE,
    emit => '',
  };
  $Action->[TAG_NAME_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'tag name uc',
    ct => {
      append_tag_name => 0x0020, # UC -> lc
    },
  };
  $XMLAction->[TAG_NAME_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'tag name uc xml',
    ct => {
      append_tag_name => 0x0000,
    },
  };
  $Action->[TAG_NAME_STATE]->[KEY_EOF_CHAR] = {
    name => 'tag name eof',
    error => 'unclosed tag',
    state => DATA_STATE,
    reconsume => 1,
  };
  $Action->[TAG_NAME_STATE]->[0x002F] = {
    name => 'tag name /',
    state => SELF_CLOSING_START_TAG_STATE,
  };
  $Action->[TAG_NAME_STATE]->[0x0000] = {
    name => 'tag name null',
    ct => {
      append_tag_name => 0xFFFD,
    },
    error => 'NULL',
  };
  $Action->[TAG_NAME_STATE]->[KEY_ELSE_CHAR] = {
    name => 'tag name else',
    ct => {
      append_tag_name => 0x0000,
    },
  };
  $Action->[SCRIPT_DATA_ESCAPE_START_STATE]->[0x002D] = {
    name => 'script data escape start -',
    state => SCRIPT_DATA_ESCAPE_START_DASH_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '-',
  };
  $Action->[SCRIPT_DATA_ESCAPE_START_DASH_STATE]->[0x002D] = {
    name => 'script data escape start dash -',
    state => SCRIPT_DATA_ESCAPED_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '-',
  };
  $Action->[SCRIPT_DATA_ESCAPE_START_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data escape start else',
    state => SCRIPT_DATA_STATE,
    reconsume => 1,
  };
  $Action->[SCRIPT_DATA_ESCAPE_START_DASH_STATE]->[KEY_ELSE_CHAR] = $Action->[SCRIPT_DATA_ESCAPE_START_STATE]->[KEY_ELSE_CHAR];
  $Action->[SCRIPT_DATA_ESCAPED_STATE]->[0x002D] = {
    name => 'script data escaped -',
    state => SCRIPT_DATA_ESCAPED_DASH_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '-',
  };
  $Action->[SCRIPT_DATA_ESCAPED_DASH_STATE]->[0x002D] = {
    name => 'script data escaped dash -',
    state => SCRIPT_DATA_ESCAPED_DASH_DASH_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '-',
  };
  $Action->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE]->[0x002D] = {
    name => 'script data escaped dash dash -',
    emit => CHARACTER_TOKEN,
    emit_data => '-',
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE]->[0x002D] = {
    name => 'script data double escaped -',
    state => SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '-',
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE]->[0x002D] = {
    name => 'script data double escaped -',
    state => SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '-',
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE]->[0x002D] = {
    name => 'script data double escaped dash dash -',
    emit => CHARACTER_TOKEN,
    emit_data => '-',
  };
  $Action->[SCRIPT_DATA_ESCAPED_STATE]->[0x003C] = {
    name => 'script data escaped <',
    state => SCRIPT_DATA_ESCAPED_LT_STATE,
  };
  $Action->[SCRIPT_DATA_ESCAPED_DASH_STATE]->[0x003C] = {
    name => 'script data escaped dash <',
    state => SCRIPT_DATA_ESCAPED_LT_STATE,
  };
  $Action->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE]->[0x003C] = {
    name => 'script data escaped dash dash <',
    state => SCRIPT_DATA_ESCAPED_LT_STATE,
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE]->[0x003C] = {
    name => 'script data double escaped <',
    state => SCRIPT_DATA_DOUBLE_ESCAPED_LT_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '<',
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE]->[0x003C] = {
    name => 'script data double escaped dash <',
    state => SCRIPT_DATA_DOUBLE_ESCAPED_LT_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '<',
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE]->[0x003C] = {
    name => 'script data double escaped dash dash <',
    state => SCRIPT_DATA_DOUBLE_ESCAPED_LT_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '<',
  };
  $Action->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE]->[0x003E] = {
    name => 'script data escaped dash dash >',
    state => SCRIPT_DATA_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '>',
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE]->[0x003E] = $Action->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE]->[0x003E];
  $Action->[SCRIPT_DATA_ESCAPED_STATE]->[KEY_EOF_CHAR] =
  $Action->[SCRIPT_DATA_ESCAPED_DASH_STATE]->[KEY_EOF_CHAR] =
  $Action->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE]->[KEY_EOF_CHAR] = 
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE]->[KEY_EOF_CHAR] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE]->[KEY_EOF_CHAR] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE]->[KEY_EOF_CHAR] = {
    name => 'script data escaped eof',
    error => 'eof in escaped script data', # XXXdocumentation
    state => DATA_STATE,
    reconsume => 1,
  };
  $Action->[SCRIPT_DATA_ESCAPED_STATE]->[0x0000] =
  $Action->[SCRIPT_DATA_ESCAPED_DASH_STATE]->[0x0000] =
  $Action->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE]->[0x0000] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE]->[0x0000] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE]->[0x0000] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE]->[0x0000] = {
    name => 'script data escaped null',
    emit => CHARACTER_TOKEN,
    emit_data => "\x{FFFD}",
    error => 'NULL',
    state => SCRIPT_DATA_ESCAPED_STATE,
  };
  $Action->[SCRIPT_DATA_ESCAPED_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data escaped else',
    emit => CHARACTER_TOKEN,
    state => SCRIPT_DATA_ESCAPED_STATE,
  };
  $Action->[SCRIPT_DATA_ESCAPED_DASH_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data escaped dash else',
    emit => CHARACTER_TOKEN,
    state => SCRIPT_DATA_ESCAPED_STATE,
  };
  $Action->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data escaped dash dash else',
    emit => CHARACTER_TOKEN,
    state => SCRIPT_DATA_ESCAPED_STATE,
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data double escaped else',
    emit => CHARACTER_TOKEN,
    state => SCRIPT_DATA_DOUBLE_ESCAPED_STATE,
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data double escaped dash else',
    emit => CHARACTER_TOKEN,
    state => SCRIPT_DATA_DOUBLE_ESCAPED_STATE,
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data double escaped dash dash else',
    emit => CHARACTER_TOKEN,
    state => SCRIPT_DATA_DOUBLE_ESCAPED_STATE,
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE]->[KEY_SPACE_CHAR] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE]->[KEY_SPACE_CHAR] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE]->[0x003E] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE]->[0x003E] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE]->[0x002F] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE]->[0x002F] = {
    name => 'script data double escape start sp>/',
    skip => 1,
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE]->[KEY_ULATIN_CHAR] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'script data double escape start uc',
    emit => CHARACTER_TOKEN,
    buffer => {append => 0x0020}, # UC -> lc
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE]->[KEY_LLATIN_CHAR] =
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE]->[KEY_LLATIN_CHAR] = {
    name => 'script data double escape start lc',
    emit => CHARACTER_TOKEN,
    buffer => {append => 0x0000},
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data double escape start else',
    state => SCRIPT_DATA_ESCAPED_STATE,
    reconsume => 1,
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data double escape end else',
    state => SCRIPT_DATA_DOUBLE_ESCAPED_STATE,
    reconsume => 1,
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_LT_STATE]->[0x002F] = {
    name => 'script data double escaped lt /',
    buffer => {clear => 1},
    state => SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '/',
  };
  $Action->[SCRIPT_DATA_DOUBLE_ESCAPED_LT_STATE]->[KEY_ELSE_CHAR] = {
    name => 'script data double escaped lt else',
    state => SCRIPT_DATA_DOUBLE_ESCAPED_STATE,
    reconsume => 1,
  };
        ## XML5: Part of the "data state".
  $Action->[DATA_MSE1_STATE]->[0x005D] = {
    name => 'data mse1 ]',
    state => DATA_MSE2_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => ']',
  };
  $Action->[DATA_MSE1_STATE]->[KEY_ELSE_CHAR] = {
    name => 'data mse1 else',
    state => DATA_STATE,
    reconsume => 1,
  };
  $Action->[DATA_MSE2_STATE]->[0x003E] = {
    name => 'data mse2 >',
    error => 'unmatched mse', # XML5: Not a parse error. # XXXdocumentation
    error_delta => 2,
    state => DATA_STATE,
    emit => CHARACTER_TOKEN,
    emit_data => '>',
  };
  $Action->[DATA_MSE2_STATE]->[0x005D] = {
    name => 'data mse2 ]',
    emit => CHARACTER_TOKEN,
    emit_data => ']',
  };
  $Action->[DATA_MSE2_STATE]->[KEY_ELSE_CHAR] = {
    name => 'data mse2 else',
    state => DATA_STATE,
    reconsume => 1,
  };
        ## XML5: "Tag attribute name before state".
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[KEY_SPACE_CHAR] = {
    name => 'before attr name sp',
  };
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[0x003E] = {
    name => 'before attr name >',
    emit => '',
    state => DATA_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'before attr name uc',
    ca => {
      set_name => 0x0020, # UC -> lc
    },
    state => ATTRIBUTE_NAME_STATE,
  };
  $XMLAction->[BEFORE_ATTRIBUTE_NAME_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'before attr name uc xml',
    ca => {
      set_name => 0x0000,
    },
    state => ATTRIBUTE_NAME_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[0x002F] = {
    name => 'before attr name /',
    state => SELF_CLOSING_START_TAG_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[KEY_EOF_CHAR] = {
    name => 'before attr name eof',
    error => 'unclosed tag',
    state => DATA_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[0x0022] = 
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[0x0027] = 
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[0x003C] = 
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[0x003D] = {
    name => q[before attr name "'<=],
    error => 'bad attribute name', ## XML5: Not a parse error.
    ca => {set_name => 0x0000},
    state => ATTRIBUTE_NAME_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[0x0000] = {
    name => 'before attr name null',
    ca => {set_name => 0xFFFD},
    error => 'NULL',
    state => ATTRIBUTE_NAME_STATE,
  };
            ## XML5: ":" raises a parse error and is ignored.
  $Action->[BEFORE_ATTRIBUTE_NAME_STATE]->[KEY_ELSE_CHAR] = {
    name => 'before attr name else',
    ca => {set_name => 0x0000},
    state => ATTRIBUTE_NAME_STATE,
  };
  
        ## XML5: "Tag attribute name state".
  $Action->[ATTRIBUTE_NAME_STATE]->[KEY_SPACE_CHAR] = {
    name => 'attr name sp',
    ca => {leave => 1},
    state => AFTER_ATTRIBUTE_NAME_STATE,
  };
  $Action->[ATTRIBUTE_NAME_STATE]->[0x003D] = {
    name => 'attr name =',
    ca => {leave => 1},
    state => BEFORE_ATTRIBUTE_VALUE_STATE,
  };
  $Action->[ATTRIBUTE_NAME_STATE]->[0x003E] = {
    name => 'attr name >',
    ca => {leave => 1},
    emit => '',
    state => DATA_STATE,
  };
  $XMLAction->[ATTRIBUTE_NAME_STATE]->[0x003E] = {
    name => 'attr name > xml',
    error => 'no attr value', ## XML5: Not a parse error. # XXXdocumentation
    ca => {leave => 1},
    emit => '',
    state => DATA_STATE,
  };
  $Action->[ATTRIBUTE_NAME_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'attr name uc',
    ca => {name => 0x0020}, # UC -> lc
  };
  $XMLAction->[ATTRIBUTE_NAME_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'attr name uc',
    ca => {name => 0x0000},
  };
  $Action->[ATTRIBUTE_NAME_STATE]->[0x002F] = {
    name => 'attr name /',
    ca => {leave => 1},
    state => SELF_CLOSING_START_TAG_STATE,
  };
  $XMLAction->[ATTRIBUTE_NAME_STATE]->[0x002F] = {
    name => 'attr name / xml',
    error => 'no attr value', ## XML5: Not a parse error. # XXXdocumentation
    ca => {leave => 1},
    state => SELF_CLOSING_START_TAG_STATE,
  };
  $Action->[ATTRIBUTE_NAME_STATE]->[KEY_EOF_CHAR] = {
    name => 'attr name eof',
    error => 'unclosed tag',
    ca => {leave => 1},
    state => DATA_STATE,
    reconsume => 1,
  };
  $Action->[ATTRIBUTE_NAME_STATE]->[0x0022] =
  $Action->[ATTRIBUTE_NAME_STATE]->[0x0027] =
  $Action->[ATTRIBUTE_NAME_STATE]->[0x003C] = {
    name => q[attr name "'<],
    error => 'bad attribute name', ## XML5: Not a parse error.
    ca => {name => 0x0000},
  };
  $Action->[ATTRIBUTE_NAME_STATE]->[0x0000] = {
    name => 'attr name null',
    ca => {name => 0xFFFD},
    error => 'NULL',
  };
  $Action->[ATTRIBUTE_NAME_STATE]->[KEY_ELSE_CHAR] = {
    name => 'attr name else',
    ca => {name => 0x0000},
  };
        ## XML5: "Tag attribute name after state".
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[KEY_SPACE_CHAR] = {
    name => 'after attr name sp',
  };
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[0x003D] = {
    name => 'after attr name =',
    state => BEFORE_ATTRIBUTE_VALUE_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[0x003E] = {
    name => 'after attr name >',
    emit => '',
    state => DATA_STATE,
  };
  $XMLAction->[AFTER_ATTRIBUTE_NAME_STATE]->[0x003E] = {
    name => 'after attr name > xml',
    error => 'no attr value', ## XML5: Not a parse error. # XXXdocumentation
    emit => '',
    state => DATA_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'after attr name uc',
    ca => {set_name => 0x0020}, # UC -> lc
    state => ATTRIBUTE_NAME_STATE,
  };
  $XMLAction->[AFTER_ATTRIBUTE_NAME_STATE]->[KEY_ULATIN_CHAR] = {
    name => 'after attr name uc xml',
    ca => {set_name => 0x0000},
    state => ATTRIBUTE_NAME_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[0x002F] = {
    name => 'after attr name /',
    state => SELF_CLOSING_START_TAG_STATE,
  };
  $XMLAction->[AFTER_ATTRIBUTE_NAME_STATE]->[0x002F] = {
    name => 'after attr name / xml',
    error => 'no attr value', ## XML5: Not a parse error. # XXXdocumentation
    state => SELF_CLOSING_START_TAG_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[KEY_EOF_CHAR] = {
    name => 'after attr name eof',
    error => 'unclosed tag',
    state => DATA_STATE,
    reconsume => 1,
  };
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[0x0022] =
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[0x0027] =
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[0x003C] = {
    name => q[after attr name "'<],
    error => 'bad attribute name', ## XML5: Not a parse error.
    #error2(xml) => 'no attr value', ## XML5: Not a parse error.
    ca => {set_name => 0x0000},
    state => ATTRIBUTE_NAME_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[0x0000] = {
    name => q[after attr name else],
    ca => {set_name => 0xFFFD},
    error => 'NULL',
    #error2(xml) => 'no attr value', ## XML5: Not a parse error.
    state => ATTRIBUTE_NAME_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_NAME_STATE]->[KEY_ELSE_CHAR] = {
    name => q[after attr name else],
    ca => {set_name => 0x0000},
    state => ATTRIBUTE_NAME_STATE,
  };
  $XMLAction->[AFTER_ATTRIBUTE_NAME_STATE]->[KEY_ELSE_CHAR] = {
    name => q[after attr name else],
    error => 'no attr value', ## XML5: Not a parse error.
    ca => {set_name => 0x0000},
    state => ATTRIBUTE_NAME_STATE,
  };
        ## XML5: "Tag attribute value before state".
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[KEY_SPACE_CHAR] = {
    name => 'before attr value sp',
  };
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x0022] = {
    name => 'before attr value "',
    state => ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE,
  };
  $XMLAction->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x0026] = {
    name => 'before attr value &',
    error => 'unquoted attr value', ## XML5: Not a parse error.
    state => ATTRIBUTE_VALUE_UNQUOTED_STATE,
    reconsume => 1,
  };
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x0026] = {
    name => 'before attr value &',
    state => ATTRIBUTE_VALUE_UNQUOTED_STATE,
    reconsume => 1,
  };
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x0027] = {
    name => "before attr value '",
    state => ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x003E] = {
    name => 'before attr value >',
    error => 'empty unquoted attribute value',
    emit => '',
    state => DATA_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[KEY_EOF_CHAR] = {
    name => 'before attr value eof',
    error => 'unclosed tag',
    state => DATA_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x003C] =
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x003D] =
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x0060] = {
    name => 'before attr value <=`',
    error => 'bad attribute value', ## XML5: Not a parse error.
    #error2(xml) => 'unquoted attr value', ## XML5: Not a parse error.
    ca => {value => 1},
    state => ATTRIBUTE_VALUE_UNQUOTED_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[0x0000] = {
    name => 'before attr value null',
    ca => {value => "\x{FFFD}"},
    error => 'NULL',
    #error2(xml) => 'unquoted attr value', ## XML5: Not a parse error.
    state => ATTRIBUTE_VALUE_UNQUOTED_STATE,
  };
  $XMLAction->[BEFORE_ATTRIBUTE_VALUE_STATE]->[KEY_ELSE_CHAR] = {
    name => 'before attr value else xml',
    error => 'unquoted attr value', ## XML5: Not a parse error. # XXXdocumentation
    ca => {value => 1},
    state => ATTRIBUTE_VALUE_UNQUOTED_STATE,
  };
  $Action->[BEFORE_ATTRIBUTE_VALUE_STATE]->[KEY_ELSE_CHAR] = {
    name => 'before attr value else',
    ca => {value => 1},
    state => ATTRIBUTE_VALUE_UNQUOTED_STATE,
  };
  
  $Action->[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE]->[KEY_SPACE_CHAR] = {
    name => 'after attr value quoted sp',
    state => BEFORE_ATTRIBUTE_NAME_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE]->[0x003E] = {
    name => 'after attr value quoted >',
    emit => '',
    state => DATA_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE]->[0x002F] = {
    name => 'after attr value quoted /',
    state => SELF_CLOSING_START_TAG_STATE,
  };
  $Action->[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE]->[KEY_EOF_CHAR] = {
    name => 'after attr value quoted eof',
    error => 'unclosed tag',
    state => DATA_STATE,
    reconsume => 1,
  };
  $Action->[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE]->[KEY_ELSE_CHAR] = {
    name => 'after attr value quoted else',
    error => 'no space between attributes',
    state => BEFORE_ATTRIBUTE_NAME_STATE,
    reconsume => 1,
  };
  $Action->[SELF_CLOSING_START_TAG_STATE]->[0x003E] = {
    name => 'self closing start tag >',
    skip => 1,
  };
  $Action->[SELF_CLOSING_START_TAG_STATE]->[KEY_EOF_CHAR] = {
    name => 'self closing start tag eof',
    error => 'unclosed tag',
    state => DATA_STATE, ## XML5: "Tag attribute name before state".
    reconsume => 1,
  };
  $Action->[SELF_CLOSING_START_TAG_STATE]->[KEY_ELSE_CHAR] = {
    name => 'self closing start tag else',
    error => 'nestc', # XXX This error type is wrong.
    state => BEFORE_ATTRIBUTE_NAME_STATE,
    reconsume => 1,
  };
  $Action->[MD_HYPHEN_STATE]->[0x002D] = {
    name => 'md hyphen -',
    ct => {type => COMMENT_TOKEN, data => '', delta => 3},
    state => COMMENT_START_STATE, ## XML5: "comment state".
  };
  $Action->[MD_HYPHEN_STATE]->[KEY_ELSE_CHAR] = {
    name => 'md hyphen else',
    error => 'bogus comment',
    error_delta => 3,
    state => BOGUS_COMMENT_STATE,
    reconsume => 1,
    ct => {type => COMMENT_TOKEN, data => '-', delta => 3},
  };
  
  ## This class method can be used to create a custom tokenizer based on
  ## the HTML tokenizer.  The argument to the method must be an
  ## (incomplete) action set, whose missing definitions are completed by
  ## the method.  The action set is then used as the value of the
  ## |$self->{action_set}| of the tokenizer object.
  sub complete_action_def ($$) {
    my (undef, $actions) = @_;
    for my $state (0..$#$Action) {
      for my $char (0..$#{$Action->[$state]}) {
        $actions->[$state]->[$char] ||= $Action->[$state]->[$char];
      }
    }
    return $actions;
  } # complete_action_def
  
  __PACKAGE__->complete_action_def ($XMLAction);
  
  my $c_to_key = [];
  $c_to_key->[255] = KEY_EOF_CHAR; # EOF_CHAR
  $c_to_key->[$_] = $_ for 0x0000..0x007F;
  $c_to_key->[$_] = KEY_SPACE_CHAR for keys %$is_space;
  $c_to_key->[$_] = KEY_ULATIN_CHAR for 0x0041..0x005A;
  $c_to_key->[$_] = KEY_LLATIN_CHAR for 0x0061..0x007A;
  
  sub _get_next_token ($) {
    my $self = shift;
  
    if ($self->{self_closing}) {
      ## NOTE: The |$self->{self_closing}| flag can never be set to
      ## tokens except for start tag tokens.  A start tag token is
      ## always set to |$self->{ct}| before it is emitted.
      $self->{parse_error}->(level => $self->{level}->{must}, type => 'nestc', token => $self->{ct});
      delete $self->{self_closing};
    }
  
    if (@{$self->{token}}) {
      $self->{self_closing} = $self->{token}->[0]->{self_closing};
      return shift @{$self->{token}};
    }
  
    A: {
      my $nc = $self->{nc};
  
      if ($nc == ABORT_CHAR) {
        $self->_set_nc;
        $nc = $self->{nc};
        return {type => ABORT_TOKEN} if $nc == ABORT_CHAR;
      }
  
      my $state = $self->{state};
  
      
  
      my $c = $nc > 0x007F ? KEY_ELSE_CHAR : $c_to_key->[$nc];
      my $action = $self->{action_set}->[$state]->[$c]
          || $self->{action_set}->[$state]->[KEY_ELSE_CHAR];
  
      if ($action and not $action->{skip}) {
        
  
        if (defined $action->{error}) {
          if ($action->{error_delta}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => $action->{error},
                            line => $self->{line_prev},
                            column => $self->{column_prev} - $action->{error_delta} + 1);
          } else {
            $self->{parse_error}->(level => $self->{level}->{must}, type => $action->{error});
          }
        }
  
        if (defined $action->{state}) {
          $self->{state} = $action->{state};
          
          if ($action->{state_set}) {
            for (keys %{$action->{state_set}}) {
              $self->{$_} = $action->{state_set}->{$_};
            }
          }
        }
  
        if (my $act = $action->{ct}) {
          if (defined $act->{type}) {
            $self->{ct} = {type => $act->{type},
                           tag_name => '', data => $act->{data}};
            if ($act->{delta}) {
              $self->{ct}->{line} = $self->{line_prev};
              $self->{ct}->{column} = $self->{column_prev} - $act->{delta} + 1;
            } else {
              $self->{ct}->{line} = $self->{line};
              $self->{ct}->{column} = $self->{column};
            }
          }
          
          if (defined $act->{append_tag_name}) {
            $self->{ct}->{tag_name} .= chr ($nc + $act->{append_tag_name});
          }
        }
        
        if (my $aca = $action->{ca}) {
          if ($aca->{value}) {
            $self->{ca}->{value} .= $aca->{value} ne '1' ? $aca->{value} : chr $nc;
          } elsif (defined $aca->{name}) {
            $self->{ca}->{name} .= chr ($nc + $aca->{name});
          } elsif (defined $aca->{set_name}) {
            $self->{ca} = {
              name => chr ($nc + $aca->{set_name}),
              value => '',
              line => $self->{line}, column => $self->{column},
            };
          } elsif ($aca->{leave}) {
            if (exists $self->{ct}->{attributes}->{$self->{ca}->{name}}) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'duplicate attribute', text => $self->{ca}->{name}, line => $self->{ca}->{line}, column => $self->{ca}->{column});
              ## Discard $self->{ca}.
            } else {
              
              $self->{ct}->{attributes}->{$self->{ca}->{name}} = $self->{ca};
              $self->{ca}->{index} = ++$self->{ct}->{last_index};
            }
          }
        }
  
        if (defined $action->{buffer}) {
          $self->{kwd} = '' if $action->{buffer}->{clear};
          $self->{kwd} .= chr ($nc + $action->{buffer}->{append})
              if defined $action->{buffer}->{append};
  
          
        }
  
        if (defined $action->{emit}) {
          if ($action->{emit} eq '') {
            if ($self->{ct}->{type} == START_TAG_TOKEN) {
              
              $self->{last_stag_name} = $self->{ct}->{tag_name};
            } elsif ($self->{ct}->{type} == END_TAG_TOKEN) {
              if ($self->{ct}->{attributes}) {
                
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'end tag attribute');
              } else {
                
              }
            } else {
              die "$0: $self->{ct}->{type}: Unknown token type";
            }
            
            if ($action->{reconsume}) {
              #
            } else {
              
      $self->_set_nc;
    
            }
            return  ($self->{ct});
          } else {
            my $token = {type => $action->{emit}};
            if (defined $action->{emit_data}) {
              $token->{data} = $action->{emit_data};
              if ($action->{emit_data_append}) {
                $token->{data} .= chr $nc;
              }
            } elsif ($action->{emit} == CHARACTER_TOKEN) {
              $token->{data} .= chr $nc;
            }
            if ($action->{emit_delta}) {
              $token->{line} = $self->{line_prev};
              $token->{column} = $self->{column_prev} - $action->{emit_delta} + 1;
            } else {
              $token->{line} = $self->{line};
              $token->{column} = $self->{column};
            }
            if (defined $action->{emit_data_read_until}) {
              $token->{data} .= $self->_read_chars
                  ({map { $_ => 1 } split //, $action->{emit_data_read_until}});
  
              #$self->{read_until}->($token->{data},
              #                      $action->{emit_data_read_until},
              #                      length $token->{data});
            }
            
            if ($action->{reconsume}) {
              #
            } else {
              
      $self->_set_nc;
    
            }
            return  ($token);
          }
        } else {
          if ($action->{reconsume}) {
            #
          } else {
            
      $self->_set_nc;
    
          }
        }
  
        redo A;
      }
  
      if ({
        (RCDATA_END_TAG_OPEN_STATE) => 1,
        (RAWTEXT_END_TAG_OPEN_STATE) => 1,
        (SCRIPT_DATA_END_TAG_OPEN_STATE) => 1,
        (SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE) => 1,
      }->{$state}) {
        ## This switch-case implements "RCDATA end tag open state",
        ## "RAWTEXT end tag open state", "script data end tag open
        ## state", "RCDATA end tag name state", "RAWTEXT end tag name
        ## state", and "script end tag name state" jointly with the
        ## implementation of the "tag name" state.
  
        my ($l, $c) = ($self->{line_prev}, $self->{column_prev} - 1); # "<"of"</"
  
        if (defined $self->{last_stag_name}) {
          #
        } else {
          ## No start tag token has ever been emitted
          ## NOTE: See <http://krijnhoetmer.nl/irc-logs/whatwg/20070626#l-564>.
          
          $self->{state} = {
            (RCDATA_END_TAG_OPEN_STATE) => RCDATA_STATE,
            (RAWTEXT_END_TAG_OPEN_STATE) => RAWTEXT_STATE,
            (SCRIPT_DATA_END_TAG_OPEN_STATE) => SCRIPT_DATA_STATE,
            (SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE)
                => SCRIPT_DATA_ESCAPED_STATE,
          }->{$state} or die "${state}'s next state not found";
          ## Reconsume.
          return  ({type => CHARACTER_TOKEN, data => '</',
                    line => $l, column => $c});
          redo A;
        }
  
        my $ch = substr $self->{last_stag_name}, length $self->{kwd}, 1;
        if (length $ch) {
          my $CH = $ch;
          $ch =~ tr/a-z/A-Z/;
          my $nch = chr $nc;
          if ($nch eq $ch or $nch eq $CH) {
            
            ## Stay in the state.
            $self->{kwd} .= $nch;
            
      $self->_set_nc;
    
            redo A;
          } else {
            
            $self->{state} = {
              (RCDATA_END_TAG_OPEN_STATE) => RCDATA_STATE,
              (RAWTEXT_END_TAG_OPEN_STATE) => RAWTEXT_STATE,
              (SCRIPT_DATA_END_TAG_OPEN_STATE) => SCRIPT_DATA_STATE,
              (SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE)
                  => SCRIPT_DATA_ESCAPED_STATE,
            }->{$state} or die "${state}'s next state not found";
            ## Reconsume.
            return  ({type => CHARACTER_TOKEN,
                      data => '</' . $self->{kwd},
                      line => $self->{line_prev},
                      column => $self->{column_prev} - 1 - length $self->{kwd},
                     });
            redo A;
          }
        } else { # after "</{tag-name}"
          unless ($is_space->{$nc} or
  	        {
                   0x003E => 1, # >
                   0x002F => 1, # /
                  }->{$nc}) {
            
            ## Reconsume.
            $self->{state} = {
              (RCDATA_END_TAG_OPEN_STATE) => RCDATA_STATE,
              (RAWTEXT_END_TAG_OPEN_STATE) => RAWTEXT_STATE,
              (SCRIPT_DATA_END_TAG_OPEN_STATE) => SCRIPT_DATA_STATE,
              (SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE)
                  => SCRIPT_DATA_ESCAPED_STATE,
            }->{$self->{state}} or die "${state}'s next state not found";
            return  ({type => CHARACTER_TOKEN,
                      data => '</' . $self->{kwd},
                      line => $self->{line_prev},
                      column => $self->{column_prev} - 1 - length $self->{kwd},
                     });
            redo A;
          } else {
            
            $self->{ct}
                = {type => END_TAG_TOKEN,
                   tag_name => $self->{last_stag_name},
                   line => $self->{line_prev},
                   column => $self->{column_prev} - 1 - length $self->{kwd}};
            $self->{state} = TAG_NAME_STATE;
            ## Reconsume.
            redo A;
          }
        }
      } elsif ($state == SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE or
               $state == SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE) {
        if ($is_space->{$nc} or
            $nc == 0x002F or # /
            $nc == 0x003E) { # >
          my $token = {type => CHARACTER_TOKEN,
                       data => chr $nc,
                       line => $self->{line}, column => $self->{column}};
          if ($state == SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE) {
            $self->{state} = $self->{kwd} eq 'script' # "temporary buffer"
                ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE
                : SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $self->{state} = $self->{kwd} eq 'script' # "temporary buffer"
                ? SCRIPT_DATA_ESCAPED_STATE
                : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
          
      $self->_set_nc;
    
          return  ($token);
          redo A;
        } else {
          die "$state/$nc is implemented";
        }
      } elsif ($state == ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE) {
        ## XML5: "Tag attribute value double quoted state" and "DOCTYPE
        ## ATTLIST attribute value double quoted state".
        
        if ($nc == 0x0022) { # "
          if ($self->{ct}->{type} == ATTLIST_TOKEN) {
            
            ## XML5: "DOCTYPE ATTLIST name after state".
            push @{$self->{ct}->{attrdefs}}, $self->{ca};
            $self->{state} = AFTER_ATTLIST_ATTR_VALUE_QUOTED_STATE;
          } else {
            
            ## XML5: "Tag attribute name before state".
            $self->{state} = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
          }
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0026) { # &
          
          ## XML5: Not defined yet.
  
          ## NOTE: In the spec, the tokenizer is switched to the 
          ## "entity in attribute value state".  In this implementation, the
          ## tokenizer is switched to the |ENTITY_STATE|, which is an
          ## implementation of the "consume a character reference" algorithm.
          $self->{prev_state} = $state;
          $self->{entity_add} = 0x0022; # "
          $self->{state} = ENTITY_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($self->{is_xml} and 
                 $is_space->{$nc}) {
          
          $self->{ca}->{value} .= ' ';
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed attribute value');
          if ($self->{ct}->{type} == START_TAG_TOKEN or
              $self->{ct}->{type} == END_TAG_TOKEN) {
            $self->{state} = DATA_STATE;
            ## Reconsume the current input character.
            ## Discard the current token, including attributes.
            redo A;
          } elsif ($self->{ct}->{type} == ATTLIST_TOKEN) {
            ## XML5: No parse error above; not defined yet.
            push @{$self->{ct}->{attrdefs}}, $self->{ca};
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
            ## Reconsume the current input character.
            ## Discard the current token, including attributes.
            redo A;
          } else {
            die "$0: $self->{ct}->{type}: Unknown token type";
          }
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ca}->{value} .= "\x{FFFD}";
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        } else {
          ## XML5 [ATTLIST]: Not defined yet.
          if ($self->{is_xml} and $nc == 0x003C) { # <
            
            ## XML5: Not a parse error.
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lt in attr value'); ## TODO: type
          } else {
            
          }
          $self->{ca}->{value} .= chr ($nc);
  
          $self->{ca}->{value} .= $self->_read_chars
              ({"\x00" => 1, q<"> => 1, q<&> => 1, "<" => 1,
                "\x09" => 1, "\x0C" => 1, "\x20" => 1});
          #$self->{read_until}->($self->{ca}->{value},
          #                      qq[\x00"&<\x09\x0C\x20],
          #                      length $self->{ca}->{value});
  
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE) {
        ## XML5: "Tag attribute value single quoted state" and "DOCTYPE
        ## ATTLIST attribute value single quoted state".
  
        if ($nc == 0x0027) { # '
          if ($self->{ct}->{type} == ATTLIST_TOKEN) {
            
            ## XML5: "DOCTYPE ATTLIST name after state".
            push @{$self->{ct}->{attrdefs}}, $self->{ca};
            $self->{state} = AFTER_ATTLIST_ATTR_VALUE_QUOTED_STATE;
          } else {
            
            ## XML5: "Before attribute name state" (sic).
            $self->{state} = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
          }
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0026) { # &
          
          ## XML5: Not defined yet.
  
          ## NOTE: In the spec, the tokenizer is switched to the 
          ## "entity in attribute value state".  In this implementation, the
          ## tokenizer is switched to the |ENTITY_STATE|, which is an
          ## implementation of the "consume a character reference" algorithm.
          $self->{entity_add} = 0x0027; # '
          $self->{prev_state} = $state;
          $self->{state} = ENTITY_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($self->{is_xml} and 
                 $is_space->{$nc}) {
          
          $self->{ca}->{value} .= ' ';
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed attribute value');
          if ($self->{ct}->{type} == START_TAG_TOKEN or
              $self->{ct}->{type} == END_TAG_TOKEN) {
            $self->{state} = DATA_STATE;
            ## Reconsume the current input character.
            ## Discard the current token, including attributes.
            redo A;
          } elsif ($self->{ct}->{type} == ATTLIST_TOKEN) {
            ## XML5: No parse error above; not defined yet.
            push @{$self->{ct}->{attrdefs}}, $self->{ca};
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
            ## Reconsume the current input character.
            ## Discard the current token, including attributes.
            redo A;
          } else {
            die "$0: $self->{ct}->{type}: Unknown token type";
          }
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ca}->{value} .= "\x{FFFD}";
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        } else {
          ## XML5 [ATTLIST]: Not defined yet.
          if ($self->{is_xml} and $nc == 0x003C) { # <
            
            ## XML5: Not a parse error.
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lt in attr value'); ## TODO: type
          } else {
            
          }
          $self->{ca}->{value} .= chr ($nc);
          $self->{ca}->{value} .= $self->_read_chars
              ({"\x00" => 1, q<'> => 1, q<&> => 1, "<" => 1,
                "\x09" => 1, "\x0C" => 1, "\x20" => 1});
          #$self->{read_until}->($self->{ca}->{value},
          #                      qq[\x00'&<\x09\x0C\x20],
          #                      length $self->{ca}->{value});
  
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == ATTRIBUTE_VALUE_UNQUOTED_STATE) {
        ## XML5: "Tag attribute value unquoted state".
  
        if ($is_space->{$nc}) {
          if ($self->{ct}->{type} == ATTLIST_TOKEN) {
            
            push @{$self->{ct}->{attrdefs}}, $self->{ca};
            $self->{state} = DOCTYPE_ATTLIST_NAME_AFTER_STATE;
          } else {
            
            ## XML5: "Tag attribute name before state".
            $self->{state} = BEFORE_ATTRIBUTE_NAME_STATE;
          }
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0026) { # &
          
  
          ## XML5: Not defined yet.
  
          ## NOTE: In the spec, the tokenizer is switched to the
          ## "character reference in attribute value state".  In this
          ## implementation, the tokenizer is switched to the
          ## |ENTITY_STATE|, which is an implementation of the "consume
          ## a character reference" algorithm.
          $self->{entity_add} = 0x003E; # >
          $self->{prev_state} = $state;
          $self->{state} = ENTITY_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          if ($self->{ct}->{type} == START_TAG_TOKEN) {
            
            $self->{last_stag_name} = $self->{ct}->{tag_name};
  
            $self->{state} = DATA_STATE;
            
      $self->_set_nc;
    
            return  ($self->{ct}); # start tag
            redo A;
          } elsif ($self->{ct}->{type} == END_TAG_TOKEN) {
            if ($self->{ct}->{attributes}) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'end tag attribute');
            } else {
              ## NOTE: This state should never be reached.
              
            }
  
            $self->{state} = DATA_STATE;
            
      $self->_set_nc;
    
            return  ($self->{ct}); # end tag
            redo A;
          } elsif ($self->{ct}->{type} == ATTLIST_TOKEN) {
            push @{$self->{ct}->{attrdefs}}, $self->{ca};
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
            
      $self->_set_nc;
    
            return  ($self->{ct}); # ATTLIST
            redo A;
          } else {
            die "$0: $self->{ct}->{type}: Unknown token type";
          }
        } elsif ($nc == EOF_CHAR) {
          if ($self->{ct}->{type} == START_TAG_TOKEN) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed tag');
            $self->{last_stag_name} = $self->{ct}->{tag_name};
  
            $self->{state} = DATA_STATE;
            ## reconsume
  
            ## Discard the token.
            #return  ($self->{ct}); # start tag
            
            redo A;
          } elsif ($self->{ct}->{type} == END_TAG_TOKEN) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed tag');
            $self->{state} = DATA_STATE;
            ## Reconsume the current input character.
            ## Discard the current token, including attributes.
            redo A;
          } elsif ($self->{ct}->{type} == ATTLIST_TOKEN) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
            push @{$self->{ct}->{attrdefs}}, $self->{ca};
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
            ## Reconsume the current input character.
            ## Discard the current token, including attributes.
            redo A;
          } else {
            die "$0: $self->{ct}->{type}: Unknown token type";
          }
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ca}->{value} .= "\x{FFFD}";
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        } else {
          if ({
               0x0022 => 1, # "
               0x0027 => 1, # '
               0x003D => 1, # =
               0x003C => 1, # <
               0x0060 => 1, # `
              }->{$nc}) {
            
            ## XML5: Not a parse error.
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'bad attribute value');
          } else {
            
          }
          $self->{ca}->{value} .= chr ($nc);
          $self->{ca}->{value} .= $self->_read_chars
              ({"\x00" => 1, q<"> => 1, q<'> => 1, 
                q<=> => 1, q<&> => 1, q<`> => 1, "<" => 1, ">" => 1,
                "\x09" => 1, "\x0C" => 1, "\x20" => 1});
          #$self->{read_until}->($self->{ca}->{value},
          #                      qq[\x00"'=&` \x09\x0C<>],
          #                      length $self->{ca}->{value});
  
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == SELF_CLOSING_START_TAG_STATE) {
        ## XML5: "Empty tag state".
  
        if ($nc == 0x003E) { # >
          if ($self->{ct}->{type} == END_TAG_TOKEN) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'nestc', token => $self->{ct});
            ## XXX: Different type than slash in start tag
            if ($self->{ct}->{attributes}) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'end tag attribute');
            } else {
              
            }
            ## XXX: Test |<title></title/>|
          } else {
            
            $self->{self_closing} = 1;
          }
  
          $self->{state} = DATA_STATE;
          
      $self->_set_nc;
    
  
          return  ($self->{ct}); # start tag or end tag
  
          redo A;
        } else {
          die "$state/$nc is implemented";
        }
      } elsif ($state == BOGUS_COMMENT_STATE) {
        ## XML5: "Bogus comment state" and "DOCTYPE bogus comment state".
  
        ## NOTE: Unlike spec's "bogus comment state", this implementation
        ## consumes characters one-by-one basis.
        
        if ($nc == 0x003E) { # >
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          
      $self->_set_nc;
    
  
          return  ($self->{ct}); # comment
          redo A;
        } elsif ($nc == -1) { 
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          ## reconsume
  
          return  ($self->{ct}); # comment
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{ct}->{data} .= "\x{FFFD}"; # comment
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{data} .= chr ($nc); # comment
          $self->{ct}->{data} .= $self->_read_chars
              ({"\x00" => 1, ">" => 1});
          #$self->{read_until}->($self->{ct}->{data},
          #                      qq[\x00>],
          #                      length $self->{ct}->{data});
  
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == MARKUP_DECLARATION_OPEN_STATE) {
        ## XML5: "Markup declaration state".
        
        if ($nc == 0x002D) { # -
          
          $self->{state} = MD_HYPHEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0044 or # D
                 $nc == 0x0064) { # d
          ## ASCII case-insensitive.
          
          $self->{state} = MD_DOCTYPE_STATE;
          $self->{kwd} = chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((
                  ## Whatpm::XML::Parser
                  $self->{is_xml} or
  
                  ## Temma::Parser
                  $self->{enable_cdata_section} or
  
                  ## Whatpm::HTML::Parser
                  (@{$self->{open_elements} || []} and
                   ($self->{open_elements}->[-1]->[1] & FOREIGN_EL))
                 ) and
                 $nc == 0x005B) { # [
                          
          $self->{state} = MD_CDATA_STATE;
          $self->{kwd} = '[';
          
      $self->_set_nc;
    
          redo A;
        } else {
          
        }
  
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                        line => $self->{line_prev},
                        column => $self->{column_prev} - 1);
        ## Reconsume.
        $self->{state} = BOGUS_COMMENT_STATE;
        $self->{ct} = {type => COMMENT_TOKEN, data => '',
                                  line => $self->{line_prev},
                                  column => $self->{column_prev} - 1,
                                 };
        redo A;
      } elsif ($state == MD_DOCTYPE_STATE) {
        ## ASCII case-insensitive.
        if ($nc == [
              undef,
              0x004F, # O
              0x0043, # C
              0x0054, # T
              0x0059, # Y
              0x0050, # P
              NEVER_CHAR, # (E)
            ]->[length $self->{kwd}] or
            $nc == [
              undef,
              0x006F, # o
              0x0063, # c
              0x0074, # t
              0x0079, # y
              0x0070, # p
              NEVER_CHAR, # (e)
            ]->[length $self->{kwd}]) {
          
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((length $self->{kwd}) == 6 and
                 ($nc == 0x0045 or # E
                  $nc == 0x0065)) { # e
          if ($self->{is_xml} and
              ($self->{kwd} ne 'DOCTYP' or $nc == 0x0065)) {
            
            ## XML5: case-sensitive.
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lowercase keyword', ## TODO
                            text => 'DOCTYPE',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 5);
          } else {
            
          }
          $self->{state} = DOCTYPE_STATE;
          $self->{ct} = {type => DOCTYPE_TOKEN,
                                    quirks => 1,
                                    line => $self->{line_prev},
                                    column => $self->{column_prev} - 7,
                                   };
          
      $self->_set_nc;
    
          redo A;
        } else {
                  
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 1 - length $self->{kwd});
          $self->{state} = BOGUS_COMMENT_STATE;
          ## Reconsume.
          $self->{ct} = {type => COMMENT_TOKEN,
                                    data => $self->{kwd},
                                    line => $self->{line_prev},
                                    column => $self->{column_prev} - 1 - length $self->{kwd},
                                   };
          redo A;
        }
      } elsif ($state == MD_CDATA_STATE) {
        if ($nc == {
              '[' => 0x0043, # C
              '[C' => 0x0044, # D
              '[CD' => 0x0041, # A
              '[CDA' => 0x0054, # T
              '[CDAT' => 0x0041, # A
              '[CDATA' => NEVER_CHAR, # ([)
            }->{$self->{kwd}}) {
          
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($self->{kwd} eq '[CDATA' and
                 $nc == 0x005B) { # [
          if ($self->{is_xml} and 
              not $self->{tainted} and
              @{$self->{open_elements} or []} == 0) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'cdata outside of root element',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 7);
            $self->{tainted} = 1;
          } else {
            
          }
  
          $self->{ct} = {type => CHARACTER_TOKEN,
                                    data => '',
                                    line => $self->{line_prev},
                                    column => $self->{column_prev} - 7};
          $self->{state} = CDATA_SECTION_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 1 - length $self->{kwd});
          $self->{state} = BOGUS_COMMENT_STATE;
          ## Reconsume.
          $self->{ct} = {type => COMMENT_TOKEN,
                                    data => $self->{kwd},
                                    line => $self->{line_prev},
                                    column => $self->{column_prev} - 1 - length $self->{kwd},
                                   };
          redo A;
        }
      } elsif ($state == COMMENT_START_STATE) {
        if ($nc == 0x002D) { # -
          
          $self->{state} = COMMENT_START_DASH_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment');
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          
      $self->_set_nc;
    
  
          return  ($self->{ct}); # comment
  
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed comment');
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          ## reconsume
  
          return  ($self->{ct}); # comment
  
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{data} .= "\x{FFFD}"; # comment
          $self->{state} = COMMENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{data} # comment
              .= chr ($nc);
          $self->{state} = COMMENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == COMMENT_START_DASH_STATE) {
        if ($nc == 0x002D) { # -
          
          $self->{state} = COMMENT_END_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment');
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          
      $self->_set_nc;
    
  
          return  ($self->{ct}); # comment
  
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed comment');
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          ## reconsume
  
          return  ($self->{ct}); # comment
  
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{data} .= "-\x{FFFD}"; # comment
          $self->{state} = COMMENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{data} # comment
              .= '-' . chr ($nc);
          $self->{state} = COMMENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == COMMENT_STATE) {
        ## XML5: "Comment state" and "DOCTYPE comment state".
  
        if ($nc == 0x002D) { # -
          
          $self->{state} = COMMENT_END_DASH_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed comment');
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          ## reconsume
  
          return  ($self->{ct}); # comment
  
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{data} .= "\x{FFFD}"; # comment
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{data} .= chr ($nc); # comment
          $self->{ct}->{data} .= $self->_read_chars
              ({"\x00" => 1, "-" => 1});
          #$self->{read_until}->($self->{ct}->{data},
          #                      qq[-\x00],
          #                      length $self->{ct}->{data});
  
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == COMMENT_END_DASH_STATE) {
        ## XML5: "Comment dash state" and "DOCTYPE comment dash state".
  
        if ($nc == 0x002D) { # -
          
          $self->{state} = COMMENT_END_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed comment');
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          ## reconsume
  
          return  ($self->{ct}); # comment
  
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{data} .= "-\x{FFFD}"; # comment
          $self->{state} = COMMENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{data} .= '-' . chr ($nc); # comment
          $self->{state} = COMMENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == COMMENT_END_STATE or
               $state == COMMENT_END_BANG_STATE) {
        ## XML5: "Comment end state" and "DOCTYPE comment end state".
        ## (No comment end bang state.)
  
        if ($nc == 0x003E) { # >
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          
      $self->_set_nc;
    
  
          return  ($self->{ct}); # comment
  
          redo A;
        } elsif ($nc == 0x002D) { # -
          if ($state == COMMENT_END_BANG_STATE) {
            
            $self->{ct}->{data} .= '--!'; # comment
            $self->{state} = COMMENT_END_DASH_STATE;
          } else {
            
            ## XML5: Not a parse error.
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'dash in comment',
                            line => $self->{line_prev},
                            column => $self->{column_prev});
            $self->{ct}->{data} .= '-'; # comment
            ## Stay in the state
          }
          
      $self->_set_nc;
    
          redo A;
        } elsif ($state != COMMENT_END_BANG_STATE and
                 $nc == 0x0021) { # !
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'comment end bang'); # XXX error type
          $self->{state} = COMMENT_END_BANG_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed comment');
          if ($self->{in_subset}) {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            
            $self->{state} = DATA_STATE;
          }
          ## Reconsume.
  
          return  ($self->{ct}); # comment
  
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          if ($state == COMMENT_END_BANG_STATE) {
            $self->{ct}->{data} .= "--!\x{FFFD}"; # comment
          } else {
            $self->{ct}->{data} .= "--\x{FFFD}"; # comment
          }
          $self->{state} = COMMENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          if ($state == COMMENT_END_BANG_STATE) {
            $self->{ct}->{data} .= '--!' . chr ($nc); # comment
          } else {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'dash in comment',
                            line => $self->{line_prev},
                            column => $self->{column_prev});
            $self->{ct}->{data} .= '--' . chr ($nc); # comment
          }
          $self->{state} = COMMENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        } 
      } elsif ($state == DOCTYPE_STATE) {
        if ($is_space->{$nc}) {
          
          $self->{state} = BEFORE_DOCTYPE_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed DOCTYPE');
          $self->{ct}->{quirks} = 1;
  
          $self->{state} = DATA_STATE;
          ## Reconsume.
          return  ($self->{ct}); # DOCTYPE (quirks)
  
          redo A;
        } else {
          
          ## XML5: Swith to the bogus comment state.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before DOCTYPE name');
          $self->{state} = BEFORE_DOCTYPE_NAME_STATE;
          ## reconsume
          redo A;
        }
      } elsif ($state == BEFORE_DOCTYPE_NAME_STATE) {
        ## XML5: "DOCTYPE root name before state".
  
        if ($is_space->{$nc}) {
          
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no DOCTYPE name');
          $self->{state} = DATA_STATE;
          
      $self->_set_nc;
    
  
          return  ($self->{ct}); # DOCTYPE (quirks)
  
          redo A;
        } elsif (0x0041 <= $nc and $nc <= 0x005A) { # A..Z
          
          $self->{ct}->{name} # DOCTYPE
              = chr ($nc + ($self->{is_xml} ? 0 : 0x0020));
          delete $self->{ct}->{quirks};
          $self->{state} = DOCTYPE_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no DOCTYPE name');
          $self->{state} = DATA_STATE;
          ## reconsume
  
          return  ($self->{ct}); # DOCTYPE (quirks)
  
          redo A;
        } elsif ($self->{is_xml} and $nc == 0x005B) { # [
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no DOCTYPE name');
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          $self->{ct}->{has_internal_subset} = 1; # DOCTYPE
          $self->{in_subset} = 1;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{name} = "\x{FFFD}";
          delete $self->{ct}->{quirks};
          $self->{state} = DOCTYPE_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{name} = chr $nc;
          delete $self->{ct}->{quirks};
          $self->{state} = DOCTYPE_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_NAME_STATE) {
        ## XML5: "DOCTYPE root name state".
  
        if ($is_space->{$nc}) {
          
          $self->{state} = AFTER_DOCTYPE_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          
          $self->{state} = DATA_STATE;
          
      $self->_set_nc;
    
  
          return  ($self->{ct}); # DOCTYPE
  
          redo A;
        } elsif (0x0041 <= $nc and $nc <= 0x005A) { # A..Z
          
          $self->{ct}->{name} # DOCTYPE
              .= chr ($nc + ($self->{is_xml} ? 0 : 0x0020));
          delete $self->{ct}->{quirks};
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed DOCTYPE');
          $self->{state} = DATA_STATE;
          ## reconsume
  
          $self->{ct}->{quirks} = 1;
          return  ($self->{ct}); # DOCTYPE
  
          redo A;
        } elsif ($self->{is_xml} and $nc == 0x005B) { # [
          
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          $self->{ct}->{has_internal_subset} = 1; # DOCTYPE
          $self->{in_subset} = 1;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{name} .= "\x{FFFD}"; # DOCTYPE
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{name} .= chr ($nc); # DOCTYPE
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_DOCTYPE_NAME_STATE) {
        ## XML5: Corresponding to XML5's "DOCTYPE root name after
        ## state", but implemented differently.
  
        if ($is_space->{$nc}) {
          
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no md def'); ## TODO: type
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == -1) {
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed DOCTYPE');
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          ## Reconsume.
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == 0x0050 or # P
                 $nc == 0x0070) { # p
          
          $self->{state} = PUBLIC_STATE;
          $self->{kwd} = chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0053 or # S
                 $nc == 0x0073) { # s
          
          $self->{state} = SYSTEM_STATE;
          $self->{kwd} = chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022 and # "
                 ($self->{ct}->{type} == GENERAL_ENTITY_TOKEN or
                  $self->{ct}->{type} == PARAMETER_ENTITY_TOKEN)) {
          
          $self->{state} = DOCTYPE_ENTITY_VALUE_DOUBLE_QUOTED_STATE;
          $self->{ct}->{value} = ''; # ENTITY
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027 and # '
                 ($self->{ct}->{type} == GENERAL_ENTITY_TOKEN or
                  $self->{ct}->{type} == PARAMETER_ENTITY_TOKEN)) {
          
          $self->{state} = DOCTYPE_ENTITY_VALUE_SINGLE_QUOTED_STATE;
          $self->{ct}->{value} = ''; # ENTITY
          
      $self->_set_nc;
    
          redo A;
        } elsif ($self->{is_xml} and
                 $self->{ct}->{type} == DOCTYPE_TOKEN and
                 $nc == 0x005B) { # [
          
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          $self->{ct}->{has_internal_subset} = 1; # DOCTYPE
          $self->{in_subset} = 1;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after DOCTYPE name'); ## TODO: type
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{ct}->{quirks} = 1;
            $self->{state} = BOGUS_DOCTYPE_STATE;
          } else {
            
            $self->{state} = BOGUS_MD_STATE;
          }
  
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == PUBLIC_STATE) {
        ## ASCII case-insensitive
        if ($nc == [
              undef, 
              0x0055, # U
              0x0042, # B
              0x004C, # L
              0x0049, # I
              NEVER_CHAR, # (C)
            ]->[length $self->{kwd}] or
            $nc == [
              undef, 
              0x0075, # u
              0x0062, # b
              0x006C, # l
              0x0069, # i
              NEVER_CHAR, # (c)
            ]->[length $self->{kwd}]) {
          
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((length $self->{kwd}) == 5 and
                 ($nc == 0x0043 or # C
                  $nc == 0x0063)) { # c
          if ($self->{is_xml} and
              ($self->{kwd} ne 'PUBLI' or $nc == 0x0063)) { # c
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lowercase keyword', ## TODO: type
                            text => 'PUBLIC',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 4);
          } else {
            
          }
          $self->{state} = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after DOCTYPE name', ## TODO: type
                          line => $self->{line_prev},
                          column => $self->{column_prev} + 1 - length $self->{kwd});
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{ct}->{quirks} = 1;
            $self->{state} = BOGUS_DOCTYPE_STATE;
          } else {
            
            $self->{state} = BOGUS_MD_STATE;
          }
          ## Reconsume.
          redo A;
        }
      } elsif ($state == SYSTEM_STATE) {
        ## ASCII case-insensitive
        if ($nc == [
              undef, 
              0x0059, # Y
              0x0053, # S
              0x0054, # T
              0x0045, # E
              NEVER_CHAR, # (M)
            ]->[length $self->{kwd}] or
            $nc == [
              undef, 
              0x0079, # y
              0x0073, # s
              0x0074, # t
              0x0065, # e
              NEVER_CHAR, # (m)
            ]->[length $self->{kwd}]) {
          
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((length $self->{kwd}) == 5 and
                 ($nc == 0x004D or # M
                  $nc == 0x006D)) { # m
          if ($self->{is_xml} and
              ($self->{kwd} ne 'SYSTE' or $nc == 0x006D)) { # m
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lowercase keyword', ## TODO: type
                            text => 'SYSTEM',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 4);
          } else {
            
          }
          $self->{state} = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after DOCTYPE name', ## TODO: type
                          line => $self->{line_prev},
                          column => $self->{column_prev} + 1 - length $self->{kwd});
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{ct}->{quirks} = 1;
            $self->{state} = BOGUS_DOCTYPE_STATE;
          } else {
            
            $self->{state} = BOGUS_MD_STATE;
          }
          ## Reconsume.
          redo A;
        }
      } elsif ($state == AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE or
               $state == BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE) {
        if ($is_space->{$nc}) {
          
          ## Stay in or switch to the state.
          $self->{state} = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          if ($state == AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before pubid literal'); # XXX documentation
          } else {
            
          }
          $self->{ct}->{pubid} = ''; # DOCTYPE
          $self->{state} = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          if ($state == AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before pubid literal'); # XXX documentation
          } else {
            
          }
          $self->{ct}->{pubid} = ''; # DOCTYPE
          $self->{state} = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no PUBLIC literal');
          
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == EOF_CHAR) {
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed DOCTYPE');
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          ## Reconsume.
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } elsif ($self->{is_xml} and
                 $self->{ct}->{type} == DOCTYPE_TOKEN and
                 $nc == 0x005B) { # [
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no PUBLIC literal');
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          $self->{ct}->{has_internal_subset} = 1; # DOCTYPE
          $self->{in_subset} = 1;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after PUBLIC');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{ct}->{quirks} = 1;
            $self->{state} = BOGUS_DOCTYPE_STATE;
          } else {
            
            $self->{state} = BOGUS_MD_STATE;
          }
  
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE) {
        if ($nc == 0x0022) { # "
          
          $self->{state} = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed PUBLIC literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
  
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed PUBLIC literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          ## Reconsume.
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{pubid} .= "\x{FFFD}"; # DOCTYPE/ENTITY/NOTATION
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{pubid} .= chr $nc; # DOCTYPE/ENTITY/NOTATION
          $self->{ct}->{pubid} .= $self->_read_chars
              ({"\x00" => 1, q<"> => 1, ">" => 1});
          #$self->{read_until}->($self->{ct}->{pubid}, qq[\x00">],
          #                      length $self->{ct}->{pubid});
  
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE) {
        if ($nc == 0x0027) { # '
          
          $self->{state} = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed PUBLIC literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
  
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed PUBLIC literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
        
          ## reconsume
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{pubid} .= "\x{FFFD}"; # DOCTYPE/ENTITY/NOTATION
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{pubid} .= chr $nc; # DOCTYPE/ENTITY/NOTATION
          $self->{ct}->{pubid} .= $self->_read_chars
              ({"\x00" => 1, "'" => 1, ">" => 1});
          #$self->{read_until}->($self->{ct}->{pubid}, qq[\x00'>],
          #                      length $self->{ct}->{pubid});
  
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE or
               $state == BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE) {
        if ($is_space->{$nc}) {
          
          ## Stay in or switch to the state.
          $self->{state} = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          if ($state == AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before system literal'); # XXX documentation
          } else {
            
          }
          $self->{ct}->{sysid} = ''; # DOCTYPE/ENTITY/NOTATION
          $self->{state} = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          if ($state == AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before system literal'); # XXX documentation
          } else {
            
          }
          $self->{ct}->{sysid} = ''; # DOCTYPE/ENTITY/NOTATION
          $self->{state} = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            if ($self->{is_xml}) {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'no SYSTEM literal');
            } else {
              
            }
            $self->{state} = DATA_STATE;
          } else {
            if ($self->{ct}->{type} == NOTATION_TOKEN) {
              
            } else {
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'no SYSTEM literal');            
            }
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == EOF_CHAR) {
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed DOCTYPE');
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
  
          ## Reconsume.
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($self->{is_xml} and
                 $self->{ct}->{type} == DOCTYPE_TOKEN and
                 $nc == 0x005B) { # [
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no SYSTEM literal');
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          $self->{ct}->{has_internal_subset} = 1; # DOCTYPE
          $self->{in_subset} = 1;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after PUBLIC literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{ct}->{quirks} = 1;
            $self->{state} = BOGUS_DOCTYPE_STATE;
          } else {
            
            $self->{state} = BOGUS_MD_STATE;
          }
  
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE or
               $state == BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE) {
        if ($is_space->{$nc}) {
          
          ## Stay in or switch to the state.
          $self->{state} = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          if ($state == AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before system literal'); # XXX documentation
          } else {
            
          }
          $self->{ct}->{sysid} = ''; # DOCTYPE
          $self->{state} = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          if ($state == AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before system literal'); # XXX documentation
          } else {
            
          }
          $self->{ct}->{sysid} = ''; # DOCTYPE
          $self->{state} = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no SYSTEM literal');
          
      $self->_set_nc;
    
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
  
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == EOF_CHAR) {
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed DOCTYPE');
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          ## Reconsume.
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($self->{is_xml} and
                 $self->{ct}->{type} == DOCTYPE_TOKEN and
                 $nc == 0x005B) { # [
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no SYSTEM literal');
  
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          $self->{ct}->{has_internal_subset} = 1; # DOCTYPE
          $self->{in_subset} = 1;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after SYSTEM');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
                      
            $self->{ct}->{quirks} = 1;
            $self->{state} = BOGUS_DOCTYPE_STATE;
          } else {
            
            $self->{state} = BOGUS_MD_STATE;
          }
  
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE) {
        if ($nc == 0x0022) { # "
          
          $self->{state} = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif (not $self->{is_xml} and $nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed SYSTEM literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed SYSTEM literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
          
          ## reconsume
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{sysid} .= "\x{FFFD}"; # DOCTYPE/ENTITY/NOTATION
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{sysid} .= chr $nc; # DOCTYPE/ENTITY/NOTATION
          $self->{ct}->{sysid} .= $self->_read_chars
              ({"\x00" => 1, q<"> => 1, ">" => 1});
          #$self->{read_until}->($self->{ct}->{sysid}, qq[\x00">],
          #                      length $self->{ct}->{sysid});
  
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE) {
        if ($nc == 0x0027) { # '
          
          $self->{state} = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif (not $self->{is_xml} and $nc == 0x003E) { # >
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed SYSTEM literal');
  
          $self->{state} = DATA_STATE;
          
      $self->_set_nc;
    
  
          $self->{ct}->{quirks} = 1;
          return  ($self->{ct}); # DOCTYPE
  
          redo A;
        } elsif ($nc == -1) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed SYSTEM literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
  
          ## reconsume
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($nc == 0x0000) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          $self->{ct}->{sysid} .= "\x{FFFD}"; # DOCTYPE/ENTITY/NOTATION
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{sysid} .= chr $nc; # DOCTYPE/ENTITY/NOTATION
          $self->{ct}->{sysid} .= $self->_read_chars
              ({"\x00" => 1, "'" => 1, ">" => 1});
          #$self->{read_until}->($self->{ct}->{sysid}, qq[\x00'>],
          #                      length $self->{ct}->{sysid});
  
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE) {
        if ($is_space->{$nc}) {
          if ($self->{ct}->{type} == GENERAL_ENTITY_TOKEN) {
            
            $self->{state} = BEFORE_NDATA_STATE;
          } else {
            
            ## Stay in the state
          }
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{state} = DATA_STATE;
          } else {
            
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
  
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($self->{ct}->{type} == GENERAL_ENTITY_TOKEN and
                 ($nc == 0x004E or # N
                  $nc == 0x006E)) { # n
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before NDATA'); ## TODO: type
          $self->{state} = NDATA_STATE;
          $self->{kwd} = chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed DOCTYPE');
            $self->{state} = DATA_STATE;
            $self->{ct}->{quirks} = 1;
          } else {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          }
  
          ## reconsume
          return  ($self->{ct}); # DOCTYPE/ENTITY/NOTATION
          redo A;
        } elsif ($self->{is_xml} and
                 $self->{ct}->{type} == DOCTYPE_TOKEN and
                 $nc == 0x005B) { # [
          
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          $self->{ct}->{has_internal_subset} = 1; # DOCTYPE
          $self->{in_subset} = 1;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after SYSTEM literal');
  
          if ($self->{ct}->{type} == DOCTYPE_TOKEN) {
            
            #$self->{ct}->{quirks} = 1;
            $self->{state} = BOGUS_DOCTYPE_STATE;
          } else {
            
            $self->{state} = BOGUS_MD_STATE;
          }
  
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == BEFORE_NDATA_STATE) {
        if ($is_space->{$nc}) {
          
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ENTITY
          redo A;
        } elsif ($nc == 0x004E or # N
                 $nc == 0x006E) { # n
          
          $self->{state} = NDATA_STATE;
          $self->{kwd} = chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          ## reconsume
          return  ($self->{ct}); # ENTITY
          redo A;
        } else {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after SYSTEM literal');
          $self->{state} = BOGUS_MD_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == BOGUS_DOCTYPE_STATE) {
        if ($nc == 0x003E) { # >
          
          $self->{state} = DATA_STATE;
          
      $self->_set_nc;
    
  
          return  ($self->{ct}); # DOCTYPE
  
          redo A;
        } elsif ($self->{is_xml} and $nc == 0x005B) { # [
          
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          $self->{ct}->{has_internal_subset} = 1; # DOCTYPE
          $self->{in_subset} = 1;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # DOCTYPE
          redo A;
        } elsif ($nc == -1) {
          
          $self->{state} = DATA_STATE;
          ## reconsume
  
          return  ($self->{ct}); # DOCTYPE
  
          redo A;
        } else {
          
          my $s = '';
          $self->_read_chars ({"[" => 1, ">" => 1});
          #$self->{read_until}->($s, q{>[}, 0);
  
          ## Stay in the state
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == CDATA_SECTION_STATE) {
        ## NOTE: "CDATA section state" in the state is jointly implemented
        ## by three states, |CDATA_SECTION_STATE|, |CDATA_SECTION_MSE1_STATE|,
        ## and |CDATA_SECTION_MSE2_STATE|.
  
        ## XML5: "CDATA state".
        
        if ($nc == 0x005D) { # ]
          
          $self->{state} = CDATA_SECTION_MSE1_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == -1) {
          if ($self->{is_xml}) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no mse'); ## TODO: type
          } else {
            
          }
  
          $self->{state} = DATA_STATE;
          ## Reconsume.
          if (length $self->{ct}->{data}) { # character
            
            return  ($self->{ct}); # character
          } else {
            
            ## No token to emit. $self->{ct} is discarded.
          }        
          redo A;
        } else {
          
          $self->{ct}->{data} .= chr $nc;
          $self->{ct}->{data} .= $self->_read_chars
              ({"\x00" => 1, "]" => 1});
          #$self->{read_until}->($self->{ct}->{data},
          #                      qq<\x00]>,
          #                      length $self->{ct}->{data});
  
          ## NOTE: NULLs are left as is (see spec's comment).  However,
          ## a token cannot contain more than one U+0000 NULL character
          ## for the ease of processing in the tree constructor.
  
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
  
        ## ISSUE: "text tokens" in spec.
      } elsif ($state == CDATA_SECTION_MSE1_STATE) {
        ## XML5: "CDATA bracket state".
  
        if ($nc == 0x005D) { # ]
          
          $self->{state} = CDATA_SECTION_MSE2_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          ## XML5: If EOF, "]" is not appended and changed to the data state.
          $self->{ct}->{data} .= ']';
          $self->{state} = CDATA_SECTION_STATE; ## XML5: Stay in the state.
          ## Reconsume.
          redo A;
        }
      } elsif ($state == CDATA_SECTION_MSE2_STATE) {
        ## XML5: "CDATA end state".
  
        if ($nc == 0x003E) { # >
          $self->{state} = DATA_STATE;
          
      $self->_set_nc;
    
          if (length $self->{ct}->{data}) { # character
            
            return  ($self->{ct}); # character
          } else {
            
            ## No token to emit. $self->{ct} is discarded.
          }
          redo A;
        } elsif ($nc == 0x005D) { # ]
           # character
          $self->{ct}->{data} .= ']'; ## Add first "]" of "]]]".
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          $self->{ct}->{data} .= ']]'; # character
          $self->{state} = CDATA_SECTION_STATE;
          ## Reconsume. ## XML5: Emit.
          redo A;
        }
      } elsif ($state == ENTITY_STATE) {
        if ($is_space->{$nc} or
            {
              0x003C => 1, 0x0026 => 1, -1 => 1, # <, &
  
              ## Following characters are added here to detect parse
              ## error for "=" of "&=" in an unquoted attribute value.
              ## Though this disagree with the Web Applications 1.0
              ## spec, the result token sequences of both algorithms
              ## should be same, as these characters cannot form a part
              ## of character references.
              0x0022 => 1, 0x0027 => 1, 0x0060 => 1, # ", ', `
              0x003D => 1, # =
  
              ## As a result of the addition above, the following clause
              ## has no effect in fact.
              $self->{entity_add} => 1,
            }->{$nc}) {
          if ($self->{is_xml}) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'bare ero',
                            line => $self->{line_prev},
                            column => $self->{column_prev}
                                + ($nc == -1 ? 1 : 0));
          } else {
            
            ## No error
          }
          ## Don't consume
          ## Return nothing.
          #
        } elsif ($nc == 0x0023) { # #
          
          $self->{state} = ENTITY_HASH_STATE;
          $self->{kwd} = '#';
          
      $self->_set_nc;
    
          redo A;
        } elsif ($self->{is_xml} or
                 (0x0041 <= $nc and
                  $nc <= 0x005A) or # A..Z
                 (0x0061 <= $nc and
                  $nc <= 0x007A)) { # a..z
          
          require Whatpm::_NamedEntityList;
          $self->{state} = ENTITY_NAME_STATE;
          $self->{kwd} = chr $nc;
          $self->{entity__value} = $self->{kwd};
          $self->{entity__match} = 0;
          
      $self->_set_nc;
    
          redo A;
        } else {
          
          ## Return nothing.
          #
        }
  
        ## We implement the "consume a character reference" in a
        ## slightly different way from the spec's algorithm, though the
        ## end result should be exactly same.
  
        ## NOTE: No character is consumed by the "consume a character
        ## reference" algorithm.  In other word, there is an "&" character
        ## that does not introduce a character reference, which would be
        ## appended to the parent element or the attribute value in later
        ## process of the tokenizer.
  
        if ($self->{prev_state} == DATA_STATE or
            $self->{prev_state} == RCDATA_STATE) {
          
          $self->{state} = $self->{prev_state};
          ## Reconsume.
          return  ({type => CHARACTER_TOKEN, data => '&',
                    line => $self->{line_prev},
                    column => $self->{column_prev},
                   });
          redo A;
        } else {
          
          $self->{ca}->{value} .= '&';
          $self->{state} = $self->{prev_state};
          ## Reconsume.
          redo A;
        }
      } elsif ($state == ENTITY_HASH_STATE) {
        if ($nc == 0x0078) { # x
          
          $self->{state} = HEXREF_X_STATE;
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0058) { # X
          
          if ($self->{is_xml}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'uppercase hcro'); ## TODO: type
          }
          $self->{state} = HEXREF_X_STATE;
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif (0x0030 <= $nc and
                 $nc <= 0x0039) { # 0..9
          
          $self->{state} = NCR_NUM_STATE;
          $self->{kwd} = $nc - 0x0030;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bare nero',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 1);
  
          ## NOTE: According to the spec algorithm, nothing is returned,
          ## and then "&#" is appended to the parent element or the attribute 
          ## value in the later processing.
  
          if ($self->{prev_state} == DATA_STATE or
              $self->{prev_state} == RCDATA_STATE) {
            
            $self->{state} = $self->{prev_state};
            ## Reconsume.
            return  ({type => CHARACTER_TOKEN,
                      data => '&#',
                      line => $self->{line_prev},
                      column => $self->{column_prev} - 1,
                     });
            redo A;
          } else {
            
            $self->{ca}->{value} .= '&#';
            $self->{state} = $self->{prev_state};
            ## Reconsume.
            redo A;
          }
        }
      } elsif ($state == NCR_NUM_STATE) {
        if (0x0030 <= $nc and 
            $nc <= 0x0039) { # 0..9
          
          $self->{kwd} *= 10;
          $self->{kwd} += $nc - 0x0030;
          
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003B) { # ;
          
          
      $self->_set_nc;
    
          #
        } else {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no refc');
          ## Reconsume.
          #
        }
  
        my $code = $self->{kwd};
        my $l = $self->{line_prev};
        my $c = $self->{column_prev};
        if (my $replace = $InvalidCharRefs->{$self->{is_xml} || 0}->{$code}) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => $self->{level}->{$replace->[1]},
                          line => $l, column => $c);
          $code = $replace->[0];
        } elsif ($code > 0x10FFFF) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => $self->{level}->{must},
                          line => $l, column => $c);
          $code = 0xFFFD;
        }
  
        if ($self->{prev_state} == DATA_STATE or
            $self->{prev_state} == RCDATA_STATE) {
          
          $self->{state} = $self->{prev_state};
          ## Reconsume.
          return  ({type => CHARACTER_TOKEN, data => chr $code,
                    has_reference => 1,
                    line => $l, column => $c,
                   });
          redo A;
        } else {
          
          $self->{ca}->{value} .= chr $code;
          $self->{ca}->{has_reference} = 1;
          $self->{state} = $self->{prev_state};
          ## Reconsume.
          redo A;
        }
      } elsif ($state == HEXREF_X_STATE) {
        if ((0x0030 <= $nc and $nc <= 0x0039) or
            (0x0041 <= $nc and $nc <= 0x0046) or
            (0x0061 <= $nc and $nc <= 0x0066)) {
          # 0..9, A..F, a..f
          
          $self->{state} = HEXREF_HEX_STATE;
          $self->{kwd} = 0;
          ## Reconsume.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bare hcro',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 2);
  
          ## NOTE: According to the spec algorithm, nothing is returned,
          ## and then "&#" followed by "X" or "x" is appended to the parent
          ## element or the attribute value in the later processing.
  
          if ($self->{prev_state} == DATA_STATE or
              $self->{prev_state} == RCDATA_STATE) {
            
            $self->{state} = $self->{prev_state};
            ## Reconsume.
            return  ({type => CHARACTER_TOKEN,
                      data => '&' . $self->{kwd},
                      line => $self->{line_prev},
                      column => $self->{column_prev} - length $self->{kwd},
                     });
            redo A;
          } else {
            
            $self->{ca}->{value} .= '&' . $self->{kwd};
            $self->{state} = $self->{prev_state};
            ## Reconsume.
            redo A;
          }
        }
      } elsif ($state == HEXREF_HEX_STATE) {
        if (0x0030 <= $nc and $nc <= 0x0039) {
          # 0..9
          
          $self->{kwd} *= 0x10;
          $self->{kwd} += $nc - 0x0030;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif (0x0061 <= $nc and
                 $nc <= 0x0066) { # a..f
          
          $self->{kwd} *= 0x10;
          $self->{kwd} += $nc - 0x0060 + 9;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif (0x0041 <= $nc and
                 $nc <= 0x0046) { # A..F
          
          $self->{kwd} *= 0x10;
          $self->{kwd} += $nc - 0x0040 + 9;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003B) { # ;
          
          
      $self->_set_nc;
    
          #
        } else {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no refc',
                          line => $self->{line},
                          column => $self->{column});
          ## Reconsume.
          #
        }
  
        my $code = $self->{kwd};
        my $l = $self->{line_prev};
        my $c = $self->{column_prev};
        if (my $replace = $InvalidCharRefs->{$self->{is_xml} || 0}->{$code}) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'invalid character reference',
                          text => (sprintf 'U+%04X', $code),
                          level => $self->{level}->{$replace->[1]},
                          line => $l, column => $c);
          $code = $replace->[0];
        } elsif ($code > 0x10FFFF) {
          
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'invalid character reference',
                          text => (sprintf 'U-%08X', $code),
                          level => $self->{level}->{must},
                          line => $l, column => $c);
          $code = 0xFFFD;
        }
  
        if ($self->{prev_state} == DATA_STATE or
            $self->{prev_state} == RCDATA_STATE) {
          
          $self->{state} = $self->{prev_state};
          ## Reconsume.
          return  ({type => CHARACTER_TOKEN, data => chr $code,
                    has_reference => 1,
                    line => $l, column => $c,
                   });
          redo A;
        } else {
          
          $self->{ca}->{value} .= chr $code;
          $self->{ca}->{has_reference} = 1;
          $self->{state} = $self->{prev_state};
          ## Reconsume.
          redo A;
        }
      } elsif ($state == ENTITY_NAME_STATE) {
        if ((0x0041 <= $nc and # a
             $nc <= 0x005A) or # x
            (0x0061 <= $nc and # a
             $nc <= 0x007A) or # z
            (0x0030 <= $nc and # 0
             $nc <= 0x0039) or # 9
            $nc == 0x003B or # ;
            ($self->{is_xml} and
             not ($is_space->{$nc} or
                  {
                    0x003C => 1, 0x0026 => 1, -1 => 1, # <, &
  
                    ## See comment in the |ENTITY_STATE|'s |if|
                    ## statement for the rationale of addition of these
                    ## characters.
                    0x0022 => 1, 0x0027 => 1, 0x0060 => 1, # ", ', `
                    0x003D => 1, # =
  
                    ## This is redundant for the same reason.
                    $self->{entity_add} => 1,
                  }->{$nc}))) {
          $self->{kwd} .= chr $nc; ## Bare entity name.
          if (defined $Whatpm::HTML::EntityChar->{$self->{kwd}} or ## HTML charrefs.
              $self->{ge}->{$self->{kwd}}) { ## XML general entities.
            if ($nc == 0x003B) { # ;
              if (defined $self->{ge}->{$self->{kwd}}) {
                ## A declared XML entity.
                if ($self->{ge}->{$self->{kwd}}->{only_text}) {
                  
                  $self->{entity__value} = $self->{ge}->{$self->{kwd}}->{value};
                } else {
                  if (defined $self->{ge}->{$self->{kwd}}->{notation}) {
                    
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'unparsed entity', ## TODO: type
                                    value => $self->{kwd});
                  } else {
                    
                  }
                  $self->{entity__value} = '&' . $self->{kwd}; ## TODO: expand
                }
              } else {
                ## An HTML character reference.
                if ($self->{is_xml}) {
                  ## Not a declared XML entity.
                  
                  $self->{parse_error}->(level => $self->{level}->{must}, type => 'entity not declared', ## TODO: type
                                  value => $self->{kwd},
                                  level => {
                                            'amp;' => $self->{level}->{warn},
                                            'quot;' => $self->{level}->{warn},
                                            'lt;' => $self->{level}->{warn},
                                            'gt;' => $self->{level}->{warn},
                                            'apos;' => $self->{level}->{warn},
                                           }->{$self->{kwd}} ||
                                           $self->{level}->{must},
                                  line => $self->{line_prev},
                                  column => $self->{column} - length $self->{kwd});
                } else {
                  
                }
                $self->{entity__value} = $Whatpm::HTML::EntityChar->{$self->{kwd}};
              }
              $self->{entity__match} = 1; ## Matched exactly with ";" entity.
              
      $self->_set_nc;
    
              #
            } else {
              
              $self->{entity__value} = $Whatpm::HTML::EntityChar->{$self->{kwd}};
              $self->{entity__match} = -1; ## Exactly matched to non-";" entity.
              ## Stay in the state.
              
      $self->_set_nc;
    
              redo A;
            }
          } else {
            if ($nc == 0x003B) { # ;
              ## A reserved HTML character reference or an undeclared
              ## XML entity reference.
              
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'entity not declared', ## XXXtype
                              value => $self->{kwd},
                              level => $self->{level}->{must},
                              line => $self->{line_prev},
                              column => $self->{column} - length $self->{kwd});
              $self->{entity__value} .= chr $nc;
              $self->{entity__match} *= 2; ## Matched (positive) or not (zero)
              
      $self->_set_nc;
    
              #
            } else {
              
              $self->{entity__value} .= chr $nc;
              $self->{entity__match} *= 2; ## Matched (positive) or not (zero)
              ## Stay in the state.
              
      $self->_set_nc;
    
              redo A;
            }
          }
        } elsif ($nc == 0x003D) { # =
          if ($self->{entity__match} < 0 and
              $self->{prev_state} != DATA_STATE and # in attribute
              $self->{prev_state} != RCDATA_STATE) {
            $self->{entity__match} = 0;
          }
        }
  
        my $data;
        my $has_ref;
        if ($self->{entity__match} > 0) { ## A ";" entity.
          
          $data = $self->{entity__value};
          ## Strictly speaking the $has_ref flag should not be set if
          ## there is no matched entity.  However, this flag is used
          ## only in contexts where use of an
          ## unexpanded-entity-reference-like string is in no way
          ## allowed, so it should not make any difference in theory.
          $has_ref = 1;
          #
        } elsif ($self->{entity__match} < 0) { ## Matched to non-";" entity.
          if ($self->{prev_state} != DATA_STATE and # in attribute
              $self->{prev_state} != RCDATA_STATE and
              $self->{entity__match} < -1) {
            ## In attribute-value contexts, matched non-";" string is
            ## left as is if there is trailing alphabetical letters.
            
            $data = '&' . $self->{kwd};
            #
          } else {
            ## In attribute-value contexts, exactly matched non-";"
            ## string is replaced as a character reference.  In any
            ## context, matched non-";" string with or without trailing
            ## alphabetical letters is replaced as a character reference
            ## (with trailing letters).  Note that use of a no-";"
            ## character reference is always non-conforming.
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no refc');
            $data = $self->{entity__value};
            $has_ref = 1;
            #
          }
        } else { ## Unmatched string.
          if ($self->{is_xml} and not $self->{kwd} =~ /;$/) {
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'bare ero',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - length $self->{kwd});
          } else {
            
          }
          $data = '&' . $self->{kwd};
          #
        }
    
        ## NOTE: In these cases, when a character reference is found,
        ## it is consumed and a character token is returned, or, otherwise,
        ## nothing is consumed and returned, according to the spec algorithm.
        ## In this implementation, anything that has been examined by the
        ## tokenizer is appended to the parent element or the attribute value
        ## as string, either literal string when no character reference or
        ## entity-replaced string otherwise, in this stage, since any characters
        ## that would not be consumed are appended in the data state or in an
        ## appropriate attribute value state anyway.
   
        if ($self->{prev_state} == DATA_STATE or
            $self->{prev_state} == RCDATA_STATE) {
          
          $self->{state} = $self->{prev_state};
          ## Reconsume.
          return  ({type => CHARACTER_TOKEN,
                    data => $data,
                    has_reference => $has_ref,
                    line => $self->{line_prev},
                    column => $self->{column_prev} + 1 - length $self->{kwd},
                   });
          redo A;
        } else {
          
          $self->{ca}->{value} .= $data;
          $self->{ca}->{has_reference} = 1 if $has_ref;
          $self->{state} = $self->{prev_state};
          ## Reconsume.
          redo A;
        }
  
      ## ========== XML-only states ==========
  
      } elsif ($state == PI_STATE) {
        ## XML5: "Pi state" and "DOCTYPE pi state".
  
        if ($is_space->{$nc} or
            $nc == 0x003F or # ?
            $nc == -1) {
          ## XML5: U+003F: "pi state": Same as "Anything else"; "DOCTYPE
          ## pi state": Switch to the "DOCTYPE pi after state".  EOF:
          ## "DOCTYPE pi state": Parse error, switch to the "data
          ## state".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bare pio', ## TODO: type
                          line => $self->{line_prev},
                          column => $self->{column_prev}
                              - 1 * ($nc != -1));
          $self->{state} = BOGUS_COMMENT_STATE;
          ## Reconsume.
          $self->{ct} = {type => COMMENT_TOKEN,
                         data => '?',
                         line => $self->{line_prev},
                         column => $self->{column_prev}
                             - 1 * ($nc != -1),
                        };
          redo A;
        } else {
          ## XML5: "DOCTYPE pi state": Stay in the state.
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct} = {type => PI_TOKEN,
                         target => $nc == 0x0000 ? "\x{FFFD}" : chr $nc,
                         data => '',
                         line => $self->{line_prev},
                         column => $self->{column_prev} - 1,
                        };
          $self->{state} = PI_TARGET_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == PI_TARGET_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = PI_TARGET_AFTER_STATE;
          $self->{kwd} = chr $nc; # "temporary buffer"
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no pic'); ## TODO: type
          if ($self->{in_subset}) {
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            $self->{state} = DATA_STATE;
          }
          ## Reconsume.
          return  ({type => COMMENT_TOKEN,
                    data => '?' . $self->{ct}->{target},
                    line => $self->{ct}->{line},
                    column => $self->{ct}->{column}});
          redo A;
        } elsif ($nc == 0x003F) { # ?
          $self->{state} = PI_AFTER_STATE;
          $self->{kwd} = ''; # "temporary buffer"
          
      $self->_set_nc;
    
          redo A;
        } else {
          ## XML5: typo ("tag name" -> "target")
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{target} .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc; # pi
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == PI_TARGET_AFTER_STATE) {
        if ($is_space->{$nc}) {
          $self->{kwd} .= chr $nc; # "temporary buffer"
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{state} = PI_DATA_STATE;
          ## Reprocess.
          redo A;
        }
      } elsif ($state == PI_DATA_STATE) {
        if ($nc == 0x003F) { # ?
          $self->{state} = PI_DATA_AFTER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no pic'); ## TODO: type
          if ($self->{in_subset}) {
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state"
          } else {
            $self->{state} = DATA_STATE;
          }
          ## Reprocess.
          return  ({type => COMMENT_TOKEN,
                    data => '?' . $self->{ct}->{target} .
                        $self->{kwd} . # "temporary buffer"
                        $self->{ct}->{data},
                    line => $self->{ct}->{line},
                    column => $self->{ct}->{column}});
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{data} .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc; # pi
          $self->{ct}->{data} .= $self->_read_chars
              ({"\x00" => 1, "?" => 1});
          #$self->{read_until}->($self->{ct}->{data}, qq[\x00?],
          #                      length $self->{ct}->{data});
  
          ## Stay in the state.
          
      $self->_set_nc;
    
          ## Reprocess.
          redo A;
        }
      } elsif ($state == PI_AFTER_STATE) {
        ## XML5: Part of "Pi after state".
  
        if ($nc == 0x003E) { # >
          if ($self->{in_subset}) {
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            $self->{state} = DATA_STATE;
          }
          
      $self->_set_nc;
    
          return  ($self->{ct}); # pi
          redo A;
        } elsif ($nc == 0x003F) { # ?
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no s after target', ## TODO: type
                          line => $self->{line_prev},
                          column => $self->{column_prev}); ## XML5: no error
          $self->{ct}->{data} .= '?';
          $self->{state} = PI_DATA_AFTER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no s after target', ## TODO: type
                          line => $self->{line_prev},
                          column => $self->{column_prev}
                              + 1 * ($nc == -1)); ## XML5: no error
          $self->{ct}->{data} .= '?'; ## XML5: not appended
          $self->{state} = PI_DATA_STATE;
          ## Reprocess.
          redo A;
        }
      } elsif ($state == PI_DATA_AFTER_STATE) {
        ## XML5: Same as "pi after state" and "DOCTYPE pi after state".
  
        if ($nc == 0x003E) { # >
          if ($self->{in_subset}) {
            $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          } else {
            $self->{state} = DATA_STATE;
          }
          ## Don't read the next character in case the PI is in fact the
          ## XML (or text) declaration; If the version specified in the
          ## XML declaration is XML 1.1, interpretation of some
          ## characters differs from XML 1.0.
          #!!! next-input-character;
          $self->{nc} = ABORT_CHAR;
          return  ($self->{ct}); # pi
          redo A;
        } elsif ($nc == 0x003F) { # ?
          $self->{ct}->{data} .= '?';
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{ct}->{data} .= '?'; ## XML5: not appended
          $self->{state} = PI_DATA_STATE;
          ## Reprocess.
          redo A;
        }
  
      } elsif ($state == DOCTYPE_INTERNAL_SUBSET_STATE) {
        if ($nc == 0x003C) { # <
          $self->{state} = DOCTYPE_TAG_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0025) { # %
          ## XML5: Not defined yet.
  
          ## TODO: parameter entity expansion
  
          if (not $self->{stop_processing} and
              not $self->{document}->xml_standalone) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'stop processing', ## TODO: type
                            level => $self->{level}->{info});
            $self->{stop_processing} = 1;
          }
  
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x005D) { # ]
          delete $self->{in_subset};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_AFTER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed internal subset'); ## TODO: type
          delete $self->{in_subset};
          $self->{state} = DATA_STATE;
          ## Reconsume.
          return  ({type => END_OF_DOCTYPE_TOKEN});
          redo A;
        } else {
          unless ($self->{internal_subset_tainted}) {
            ## XML5: No parse error.
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'string in internal subset');
            $self->{internal_subset_tainted} = 1;
          }
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_INTERNAL_SUBSET_AFTER_STATE) {
        if ($nc == 0x003E) { # >
          $self->{state} = DATA_STATE;
          
      $self->_set_nc;
    
          return  ({type => END_OF_DOCTYPE_TOKEN});
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed DOCTYPE');
          $self->{state} = DATA_STATE;
          ## Reconsume.
          return  ({type => END_OF_DOCTYPE_TOKEN});
          redo A;
        } else {
          ## XML5: No parse error and stay in the state.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after internal subset'); ## TODO: type
  
          $self->{state} = BOGUS_DOCTYPE_INTERNAL_SUBSET_AFTER_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == BOGUS_DOCTYPE_INTERNAL_SUBSET_AFTER_STATE) {
        if ($nc == 0x003E) { # >
          $self->{state} = DATA_STATE;
          
      $self->_set_nc;
    
          return  ({type => END_OF_DOCTYPE_TOKEN});
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{state} = DATA_STATE;
          ## Reconsume.
          return  ({type => END_OF_DOCTYPE_TOKEN});
          redo A;
        } else {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_TAG_STATE) {
        if ($nc == 0x0021) { # !
          $self->{state} = DOCTYPE_MARKUP_DECLARATION_OPEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003F) { # ?
          $self->{state} = PI_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bare stago');
          $self->{state} = DATA_STATE;
          ## Reconsume.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bare stago', ## XML5: Not a parse error.
                          line => $self->{line_prev},
                          column => $self->{column_prev});
          $self->{state} = BOGUS_COMMENT_STATE;
          $self->{ct} = {type => COMMENT_TOKEN,
                         data => '',
                        }; ## NOTE: Will be discarded.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_MARKUP_DECLARATION_OPEN_STATE) {
        ## XML5: "DOCTYPE markup declaration state".
        
        if ($nc == 0x002D) { # -
          $self->{state} = MD_HYPHEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0045 or # E
                 $nc == 0x0065) { # e
          $self->{state} = MD_E_STATE;
          $self->{kwd} = chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0041 or # A
                 $nc == 0x0061) { # a
          $self->{state} = MD_ATTLIST_STATE;
          $self->{kwd} = chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x004E or # N
                 $nc == 0x006E) { # n
          $self->{state} = MD_NOTATION_STATE;
          $self->{kwd} = chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } else {
          #
        }
        
        ## XML5: No parse error.
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                        line => $self->{line_prev},
                        column => $self->{column_prev} - 1);
        ## Reconsume.
        $self->{state} = BOGUS_COMMENT_STATE;
        $self->{ct} = {type => COMMENT_TOKEN, data => ''}; ## Will be discarded.
        redo A;
      } elsif ($state == MD_E_STATE) {
        if ($nc == 0x004E or # N
            $nc == 0x006E) { # n
          $self->{state} = MD_ENTITY_STATE;
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x004C or # L
                 $nc == 0x006C) { # l
          ## XML5: <!ELEMENT> not supported.
          $self->{state} = MD_ELEMENT_STATE;
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } else {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 2
                              + 1 * ($nc == EOF_CHAR));
          ## Reconsume.
          $self->{state} = BOGUS_COMMENT_STATE;
          $self->{ct} = {type => COMMENT_TOKEN, data => ''}; ## Will be discarded
          redo A;
        }
      } elsif ($state == MD_ENTITY_STATE) {
        if ($nc == [
              undef,
              undef,
              0x0054, # T
              0x0049, # I
              0x0054, # T
              NEVER_CHAR, # (Y)
            ]->[length $self->{kwd}] or
            $nc == [
              undef,
              undef,
              0x0074, # t
              0x0069, # i
              0x0074, # t
              NEVER_CHAR, # (y)
            ]->[length $self->{kwd}]) {
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((length $self->{kwd}) == 5 and
                 ($nc == 0x0059 or # Y
                  $nc == 0x0079)) { # y
          if ($self->{kwd} ne 'ENTIT' or $nc == 0x0079) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lowercase keyword', ## TODO: type
                            text => 'ENTITY',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 4);
          }
          $self->{ct} = {type => GENERAL_ENTITY_TOKEN, name => '',
                         line => $self->{line_prev},
                         column => $self->{column_prev} - 6};
          $self->{state} = DOCTYPE_MD_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 1
                              - (length $self->{kwd})
                              + 1 * ($nc == EOF_CHAR));
          $self->{state} = BOGUS_COMMENT_STATE;
          ## Reconsume.
          $self->{ct} = {type => COMMENT_TOKEN, data => ''}; ## Will be discarded
          redo A;
        }
      } elsif ($state == MD_ELEMENT_STATE) {
        if ($nc == [
             undef,
             undef,
             0x0045, # E
             0x004D, # M
             0x0045, # E
             0x004E, # N
             NEVER_CHAR, # (T)
            ]->[length $self->{kwd}] or
            $nc == [
             undef,
             undef,
             0x0065, # e
             0x006D, # m
             0x0065, # e
             0x006E, # n
             NEVER_CHAR, # (t)
            ]->[length $self->{kwd}]) {
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((length $self->{kwd}) == 6 and
                 ($nc == 0x0054 or # T
                  $nc == 0x0074)) { # t
          if ($self->{kwd} ne 'ELEMEN' or $nc == 0x0074) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lowercase keyword', ## TODO: type
                            text => 'ELEMENT',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 5);
          }
          $self->{ct} = {type => ELEMENT_TOKEN, name => '',
                         line => $self->{line_prev},
                         column => $self->{column_prev} - 7};
          $self->{state} = DOCTYPE_MD_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 1
                              - (length $self->{kwd})
                              + 1 * ($nc == EOF_CHAR));
          $self->{state} = BOGUS_COMMENT_STATE;
          ## Reconsume.
          $self->{ct} = {type => COMMENT_TOKEN, data => ''}; ## Will be discarded
          redo A;
        }
      } elsif ($state == MD_ATTLIST_STATE) {
        if ($nc == [
             undef,
             0x0054, # T
             0x0054, # T
             0x004C, # L
             0x0049, # I
             0x0053, # S
             NEVER_CHAR, # (T)
            ]->[length $self->{kwd}] or
            $nc == [
             undef,
             0x0074, # t
             0x0074, # t
             0x006C, # l
             0x0069, # i
             0x0073, # s
             NEVER_CHAR, # (t)
            ]->[length $self->{kwd}]) {
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((length $self->{kwd}) == 6 and
                 ($nc == 0x0054 or # T
                  $nc == 0x0074)) { # t
          if ($self->{kwd} ne 'ATTLIS' or $nc == 0x0074) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lowercase keyword', ## TODO: type
                            text => 'ATTLIST',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 5);
          }
          $self->{ct} = {type => ATTLIST_TOKEN, name => '',
                         attrdefs => [],
                         line => $self->{line_prev},
                         column => $self->{column_prev} - 7};
          $self->{state} = DOCTYPE_MD_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 1
                               - (length $self->{kwd})
                               + 1 * ($nc == EOF_CHAR));
          $self->{state} = BOGUS_COMMENT_STATE;
          ## Reconsume.
          $self->{ct} = {type => COMMENT_TOKEN, data => ''}; ## Will be discarded
          redo A;
        }
      } elsif ($state == MD_NOTATION_STATE) {
        if ($nc == [
             undef,
             0x004F, # O
             0x0054, # T
             0x0041, # A
             0x0054, # T
             0x0049, # I
             0x004F, # O
             NEVER_CHAR, # (N)
            ]->[length $self->{kwd}] or
            $nc == [
             undef,
             0x006F, # o
             0x0074, # t
             0x0061, # a
             0x0074, # t
             0x0069, # i
             0x006F, # o
             NEVER_CHAR, # (n)
            ]->[length $self->{kwd}]) {
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((length $self->{kwd}) == 7 and
                 ($nc == 0x004E or # N
                  $nc == 0x006E)) { # n
          if ($self->{kwd} ne 'NOTATIO' or $nc == 0x006E) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lowercase keyword', ## TODO: type
                            text => 'NOTATION',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 6);
          }
          $self->{ct} = {type => NOTATION_TOKEN, name => '',
                         line => $self->{line_prev},
                         column => $self->{column_prev} - 8};
          $self->{state} = DOCTYPE_MD_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bogus comment',
                          line => $self->{line_prev},
                          column => $self->{column_prev} - 1
                              - (length $self->{kwd})
                              + 1 * ($nc == EOF_CHAR));
          $self->{state} = BOGUS_COMMENT_STATE;
          ## Reconsume.
          $self->{ct} = {type => COMMENT_TOKEN, data => ''}; ## Will be discarded
          redo A;
        }
      } elsif ($state == DOCTYPE_MD_STATE) {
        ## XML5: "DOCTYPE ENTITY state", "DOCTYPE ATTLIST state", and
        ## "DOCTYPE NOTATION state".
  
        if ($is_space->{$nc}) {
          ## XML5: [NOTATION] Switch to the "DOCTYPE NOTATION identifier state".
          $self->{state} = BEFORE_MD_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($self->{ct}->{type} == GENERAL_ENTITY_TOKEN and 
                 $nc == 0x0025) { # %
          ## XML5: Switch to the "DOCTYPE bogus comment state".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before md name'); ## TODO: type
          $self->{state} = DOCTYPE_ENTITY_PARAMETER_BEFORE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          ## Reconsume.
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Switch to the "DOCTYPE bogus comment state".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no md name'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          ## XML5: Switch to the "DOCTYPE bogus comment state".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before md name'); ## TODO: type
          $self->{state} = BEFORE_MD_NAME_STATE;
          redo A;
        }
      } elsif ($state == BEFORE_MD_NAME_STATE) {
        ## XML5: "DOCTYPE ENTITY parameter state", "DOCTYPE ENTITY type
        ## before state", "DOCTYPE ATTLIST name before state".
  
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($self->{ct}->{type} == GENERAL_ENTITY_TOKEN and 
                 $nc == 0x0025) { # %
          $self->{state} = DOCTYPE_ENTITY_PARAMETER_BEFORE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Same as "Anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no md name'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          ## Reconsume.
          redo A;
        } else {
          ## XML5: [ATTLIST] Not defined yet.
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{name} .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc;
          $self->{state} = MD_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ENTITY_PARAMETER_BEFORE_STATE) {
        if ($is_space->{$nc}) {
          ## XML5: Switch to the "DOCTYPE ENTITY parameter state".
          $self->{ct}->{type} = PARAMETER_ENTITY_TOKEN;
          $self->{state} = BEFORE_MD_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Same as "Anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no md name'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md');
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          ## Reconsume.
          redo A;
        } else {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space after ENTITY percent'); ## TODO: type
          $self->{state} = BOGUS_COMMENT_STATE;
          $self->{ct} = {type => COMMENT_TOKEN, data => ''}; ## Will be discarded
          ## Reconsume.
          redo A;
        }
      } elsif ($state == MD_NAME_STATE) {
        ## XML5: "DOCTYPE ENTITY name state" and "DOCTYPE ATTLIST name state".
        
        if ($is_space->{$nc}) {
          if ($self->{ct}->{type} == ATTLIST_TOKEN) {
            $self->{state} = DOCTYPE_ATTLIST_NAME_AFTER_STATE;
          } elsif ($self->{ct}->{type} == ELEMENT_TOKEN) {
            $self->{state} = AFTER_ELEMENT_NAME_STATE;
          } else { # ENTITY/NOTATION
            $self->{state} = AFTER_DOCTYPE_NAME_STATE;
          }
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          if ($self->{ct}->{type} == ATTLIST_TOKEN) {
            #
          } else {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'no md def'); ## TODO: type
          }
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ELEMENT/ENTITY/ATTLIST/NOTATION
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: [ATTLIST] No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md');
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          ## Reconsume.
          redo A;
        } else {
          ## XML5: [ATTLIST] Not defined yet.
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{name} .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ATTLIST_NAME_AFTER_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          ## Discard the current token.
          redo A;
        } else {
          ## XML5: Not defined yet.
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ca} = {name => $nc == 0x0000 ? "\x{FFFD}" : chr $nc, # attrdef
                         tokens => [],
                         line => $self->{line}, column => $self->{column}};
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ATTLIST_ATTRIBUTE_NAME_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_NAME_AFTER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no attr type'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == 0x0028) { # (
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before paren'); ## TODO: type
          $self->{state} = BEFORE_ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          ## XML5: Not defined yet.
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ca}->{name} .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ATTLIST_ATTRIBUTE_NAME_AFTER_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no attr type'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == 0x0028) { # (
          ## XML5: Same as "anything else".
          $self->{state} = BEFORE_ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the token.
          redo A;
        } else {
          ## XML5: Not defined yet.
          $self->{ca}->{type} = chr $nc;
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_TYPE_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ATTLIST_ATTRIBUTE_TYPE_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_TYPE_AFTER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0023) { # #
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before default value'); ## TODO: type
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_BEFORE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before default value'); ## TODO: type
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before default value'); ## TODO: type
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no attr default'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == 0x0028) { # (
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before paren'); ## TODO: type
          $self->{state} = BEFORE_ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the token.
          redo A;
        } else {
          ## XML5: Not defined yet.
          $self->{ca}->{type} .= chr $nc;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ATTLIST_ATTRIBUTE_TYPE_AFTER_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0028) { # (
          ## XML5: Same as "anything else".
          $self->{state} = BEFORE_ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0023) { # #
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_BEFORE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          ## XML5: Same as "anything else".
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          ## XML5: Same as "anything else".
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no attr default'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          ## XML5: Switch to the "DOCTYPE bogus comment state".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unquoted attr value'); ## TODO: type
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_UNQUOTED_STATE;
          ## Reconsume.
          redo A;
        }
      } elsif ($state == BEFORE_ALLOWED_TOKEN_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x007C) { # |
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'empty allowed token'); ## TODO: type
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0029) { # )
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'empty allowed token'); ## TODO: type
          $self->{state} = AFTER_ALLOWED_TOKENS_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed allowed tokens'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          if ($nc == 0x000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          push @{$self->{ca}->{tokens}}, $nc == 0x0000 ? "\x{FFFD}" : chr $nc;
          $self->{state} = ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == ALLOWED_TOKEN_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = AFTER_ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x007C) { # |
          $self->{state} = BEFORE_ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0029) { # )
          $self->{state} = AFTER_ALLOWED_TOKENS_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed allowed tokens'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ca}->{tokens}->[-1] .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_ALLOWED_TOKEN_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x007C) { # |
          $self->{state} = BEFORE_ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0029) { # )
          $self->{state} = AFTER_ALLOWED_TOKENS_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed allowed tokens'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'space in allowed token', ## TODO: type
                          line => $self->{line_prev},
                          column => $self->{column_prev});
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ca}->{tokens}->[-1] .= ' ' . ($nc == 0x0000 ? "\x{FFFD}" : chr $nc);
          $self->{state} = ALLOWED_TOKEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_ALLOWED_TOKENS_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = BEFORE_ATTR_DEFAULT_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0023) { # #
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before default value'); ## TODO: type
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_BEFORE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before default value'); ## TODO: type
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before default value'); ## TODO: type
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no attr default'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unquoted attr value'); ## TODO: type
          $self->{state} = ATTRIBUTE_VALUE_UNQUOTED_STATE;
          ## Reconsume.
          redo A;
        }
      } elsif ($state == BEFORE_ATTR_DEFAULT_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0023) { # #
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_BEFORE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no attr default'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unquoted attr value'); ## TODO: type
          $self->{state} = ATTRIBUTE_VALUE_UNQUOTED_STATE;
          ## Reconsume.
          redo A;
        }
      } elsif ($state == DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_BEFORE_STATE) {
        if ($is_space->{$nc}) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no default type'); ## TODO: type
          $self->{state} = BOGUS_MD_STATE;
          ## Reconsume.
          redo A;
        } elsif ($nc == 0x0022) { # "
          # XXX parse error?
          ## XML5: Same as "anything else".
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          # XXX parse error?
          ## XML5: Same as "anything else".
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no attr default'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          $self->{ca}->{default} = chr $nc;
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_AFTER_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before default value'); ## TODO: type
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          ## XML5: Same as "anything else".
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before default value'); ## TODO: type
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          ## XML5: Same as "anything else".
          push @{$self->{ct}->{attrdefs}}, $self->{ca};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          push @{$self->{ct}->{attrdefs}}, $self->{ca};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          $self->{ca}->{default} .= chr $nc;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ATTLIST_ATTRIBUTE_DECLARATION_AFTER_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0022) { # "
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0027) { # '
          $self->{ca}->{value} = '';
          $self->{state} = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          push @{$self->{ct}->{attrdefs}}, $self->{ca};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST
          redo A;
        } elsif ($nc == EOF_CHAR) {
          ## XML5: No parse error.
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          push @{$self->{ct}->{attrdefs}}, $self->{ca};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE; ## XML5: "Data state".
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          ## XML5: Not defined yet.
          if ($self->{ca}->{default} eq 'FIXED') {
            $self->{state} = ATTRIBUTE_VALUE_UNQUOTED_STATE;
          } else {
            push @{$self->{ct}->{attrdefs}}, $self->{ca};
            $self->{state} = DOCTYPE_ATTLIST_NAME_AFTER_STATE;
          }
          ## Reconsume.
          redo A;
        }
      } elsif ($state == AFTER_ATTLIST_ATTR_VALUE_QUOTED_STATE) {
        if ($is_space->{$nc} or
            $nc == EOF_CHAR or
            $nc == 0x003E) { # >
          $self->{state} = DOCTYPE_ATTLIST_NAME_AFTER_STATE;
          ## Reconsume.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no space before attr name'); ## TODO: type
          $self->{state} = DOCTYPE_ATTLIST_NAME_AFTER_STATE;
          ## Reconsume.
          redo A;
        }
      } elsif ($state == NDATA_STATE) {
        ## ASCII case-insensitive
        if ($nc == [
              undef, 
              0x0044, # D
              0x0041, # A
              0x0054, # T
              NEVER_CHAR, # (A)
            ]->[length $self->{kwd}] or
            $nc == [
              undef, 
              0x0064, # d
              0x0061, # a
              0x0074, # t
              NEVER_CHAR, # (a)
            ]->[length $self->{kwd}]) {
          
          ## Stay in the state.
          $self->{kwd} .= chr $nc;
          
      $self->_set_nc;
    
          redo A;
        } elsif ((length $self->{kwd}) == 4 and
                 ($nc == 0x0041 or # A
                  $nc == 0x0061)) { # a
          if ($self->{kwd} ne 'NDAT' or $nc == 0x0061) { # a
            
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'lowercase keyword', ## TODO: type
                            text => 'NDATA',
                            line => $self->{line_prev},
                            column => $self->{column_prev} - 4);
          } else {
            
          }
          $self->{state} = AFTER_NDATA_STATE;
          
      $self->_set_nc;
    
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after literal', ## TODO: type
                          line => $self->{line_prev},
                          column => $self->{column_prev} + 1
                              - length $self->{kwd});
          
          $self->{state} = BOGUS_MD_STATE;
          ## Reconsume.
          redo A;
        }
      } elsif ($state == AFTER_NDATA_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = BEFORE_NOTATION_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no notation name'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ENTITY
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after literal', ## TODO: type
                          line => $self->{line_prev},
                          column => $self->{column_prev} + 1
                              - length $self->{kwd});
          $self->{state} = BOGUS_MD_STATE;
          ## Reconsume.
          redo A;
        }
      } elsif ($state == BEFORE_NOTATION_NAME_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no notation name'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ENTITY
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{notation} = $nc == 0x0000 ? "\x{FFFD}" : chr $nc; # ENTITY
          $self->{state} = NOTATION_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == NOTATION_NAME_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = AFTER_MD_DEF_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ENTITY
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## The current token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{notation} .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc; # ENTITY
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ENTITY_VALUE_DOUBLE_QUOTED_STATE) {
        if ($nc == 0x0022) { # "
          $self->{state} = AFTER_MD_DEF_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0026) { # &
          $self->{prev_state} = $state;
          $self->{state} = ENTITY_VALUE_ENTITY_STATE;
          $self->{entity_add} = 0x0022; # "
          
      $self->_set_nc;
    
          redo A;
  ## TODO: %
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed entity value'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          ## Reconsume.
          ## Discard the current token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{value} .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc; # ENTITY
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == DOCTYPE_ENTITY_VALUE_SINGLE_QUOTED_STATE) {
        if ($nc == 0x0027) { # '
          $self->{state} = AFTER_MD_DEF_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0026) { # &
          $self->{prev_state} = $state;
          $self->{state} = ENTITY_VALUE_ENTITY_STATE;
          $self->{entity_add} = 0x0027; # '
          
      $self->_set_nc;
    
          redo A;
  ## TODO: %
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed entity value'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          ## Reconsume.
          ## Discard the current token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{value} .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc; # ENTITY
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == ENTITY_VALUE_ENTITY_STATE) {
        if ($is_space->{$nc} or
            {
              0x003C => 1, 0x0026 => 1, (EOF_CHAR) => 1, # <, &
              $self->{entity_add} => 1,
            }->{$nc}) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'bare ero',
                          line => $self->{line_prev},
                          column => $self->{column_prev}
                              + ($nc == EOF_CHAR ? 1 : 0));
          ## Don't consume
          ## Return nothing.
          #
        } elsif ($nc == 0x0023) { # #
          $self->{ca} = $self->{ct};
          $self->{state} = ENTITY_HASH_STATE;
          $self->{kwd} = '#';
          
      $self->_set_nc;
    
          redo A;
        } else {
          #
        }
  
        $self->{ct}->{value} .= '&';
        $self->{state} = $self->{prev_state};
        ## Reconsume.
        redo A;
      } elsif ($state == AFTER_ELEMENT_NAME_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = BEFORE_ELEMENT_CONTENT_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0028) { # (
          $self->{state} = AFTER_CM_GROUP_OPEN_STATE;
          $self->{ct}->{content} = ['('];
          $self->{group_depth} = 1;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'no md def'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ELEMENT
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{content} = [$nc == 0x0000 ? "\x{FFFD}" : chr $nc];
          $self->{state} = CONTENT_KEYWORD_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == CONTENT_KEYWORD_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = AFTER_MD_DEF_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ELEMENT
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{content}->[-1] .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc; # ELEMENT
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_CM_GROUP_OPEN_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0028) { # (
          $self->{group_depth}++;
          push @{$self->{ct}->{content}}, chr $nc;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x007C or # |
                 $nc == 0x002C) { # ,
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'empty element name'); ## TODO: type
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0029) { # )
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'empty element name'); ## TODO: type
          push @{$self->{ct}->{content}}, chr $nc;
          $self->{group_depth}--;
          $self->{state} = AFTER_CM_GROUP_CLOSE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed cm group'); ## TODO: type
          push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ELEMENT
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          #push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          push @{$self->{ct}->{content}}, $nc == 0x0000 ? "\x{FFFD}" : chr $nc;
          $self->{state} = CM_ELEMENT_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == CM_ELEMENT_NAME_STATE) {
        if ($is_space->{$nc}) {
          $self->{state} = AFTER_CM_ELEMENT_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x002A or # *
                 $nc == 0x002B or # +
                 $nc == 0x003F) { # ?
          push @{$self->{ct}->{content}}, chr $nc;
          $self->{state} = AFTER_CM_ELEMENT_NAME_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x007C or # |
                 $nc == 0x002C) { # ,
          push @{$self->{ct}->{content}}, $nc == 0x007C ? ' | ' : ', ';
          $self->{state} = AFTER_CM_GROUP_OPEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0029) { # )
          $self->{group_depth}--;
          push @{$self->{ct}->{content}}, chr $nc;
          $self->{state} = AFTER_CM_GROUP_CLOSE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed cm group'); ## TODO: type
          push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ELEMENT
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          #push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the token.
          redo A;
        } else {
          if ($nc == 0x0000) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL');
          }
          $self->{ct}->{content}->[-1] .= $nc == 0x0000 ? "\x{FFFD}" : chr $nc;
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_CM_ELEMENT_NAME_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x007C or # |
                 $nc == 0x002C) { # ,
          push @{$self->{ct}->{content}}, $nc == 0x007C ? ' | ' : ', ';
          $self->{state} = AFTER_CM_GROUP_OPEN_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0029) { # )
          $self->{group_depth}--;
          push @{$self->{ct}->{content}}, chr $nc;
          $self->{state} = AFTER_CM_GROUP_CLOSE_STATE;
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed cm group'); ## TODO: type
          push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ELEMENT
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          #push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'after element name'); ## TODO: type
          push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          $self->{state} = BOGUS_MD_STATE;
          
      $self->_set_nc;
    
          redo A;
        }
      } elsif ($state == AFTER_CM_GROUP_CLOSE_STATE) {
        if ($is_space->{$nc}) {
          if ($self->{group_depth}) {
            $self->{state} = AFTER_CM_ELEMENT_NAME_STATE;
          } else {
            $self->{state} = AFTER_MD_DEF_STATE;
          }
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x002A or # *
                 $nc == 0x002B or # +
                 $nc == 0x003F) { # ?
          push @{$self->{ct}->{content}}, chr $nc;
          if ($self->{group_depth}) {
            $self->{state} = AFTER_CM_ELEMENT_NAME_STATE;
          } else {
            $self->{state} = AFTER_MD_DEF_STATE;
          }
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x0029) { # )
          if ($self->{group_depth}) {
            $self->{group_depth}--;
            push @{$self->{ct}->{content}}, chr $nc;
            ## Stay in the state.
            
      $self->_set_nc;
    
            redo A;
          } else {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after md def'); ## TODO: type
            $self->{state} = BOGUS_MD_STATE;
            ## Reconsume.
            redo A;
          }
        } elsif ($nc == 0x003E) { # >
          if ($self->{group_depth}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed cm group'); ## TODO: type
            push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          }
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ELEMENT
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          #push @{$self->{ct}->{content}}, (')') x $self->{group_depth};
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          if ($self->{group_depth}) {
            $self->{state} = AFTER_CM_ELEMENT_NAME_STATE;
          } else {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after md def'); ## TODO: type
            $self->{state} = BOGUS_MD_STATE;
          }
          ## Reconsume.
          redo A;
        }
      } elsif ($state == AFTER_MD_DEF_STATE) {
        if ($is_space->{$nc}) {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        } elsif ($nc == 0x003E) { # >
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ENTITY/ELEMENT
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unclosed md'); ## TODO: type
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          ## Discard the current token.
          redo A;
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'string after md def'); ## TODO: type
          $self->{state} = BOGUS_MD_STATE;
          ## Reconsume.
          redo A;
        }
      } elsif ($state == BOGUS_MD_STATE) {
        if ($nc == 0x003E) { # >
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          
      $self->_set_nc;
    
          return  ($self->{ct}); # ATTLIST/ENTITY/NOTATION
          redo A;
        } elsif ($nc == EOF_CHAR) {
          $self->{state} = DOCTYPE_INTERNAL_SUBSET_STATE;
          ## Reconsume.
          ## Discard the current token.
          redo A;
        } else {
          ## Stay in the state.
          
      $self->_set_nc;
    
          redo A;
        }
      } else {
        die "$0: $state: Unknown state";
      }
    } # A   
  
    die "$0: _get_next_token: unexpected case";
  } # _get_next_token
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WHATPM_HTML_TOKENIZER

$fatpacked{"Whatpm/XML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_XML_PARSER';
  package Whatpm::XML::Parser; # -*- Perl -*-
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '3.0';
  use Whatpm::HTML::Defs;
  use Whatpm::HTML::InputStream;
  use Whatpm::HTML::Tokenizer;
  push our @ISA, qw(Whatpm::HTML::Tokenizer);
  
  sub parse_char_string ($$$;$$) {
    #my ($self, $string, $document, $onerror, $get_wrapper) = @_;
    my $self = ref $_[0] ? $_[0] : $_[0]->new;
    my $doc = $self->{document} = $_[2];
    @{$self->{document}->child_nodes} = ();
  
    ## Confidence: irrelevant.
    $self->{confident} = 1 unless exists $self->{confident};
  
    $self->{line_prev} = $self->{line} = 1;
    $self->{column_prev} = -1;
    $self->{column} = 0;
  
    $self->{chars} = [split //, $_[1]];
    $self->{chars_pos} = 0;
    $self->{chars_pull_next} = sub { 0 };
    delete $self->{chars_was_cr};
  
    my $onerror = $_[3] || $self->onerror;
    $self->{parse_error} = sub {
      $onerror->(line => $self->{line}, column => $self->{column}, @_);
    };
  
    $self->{is_xml} = 1;
  
    $self->_initialize_tokenizer;
    $self->_initialize_tree_constructor;
    $self->{t} = $self->_get_next_token;
    $self->_construct_tree;
    $self->_terminate_tree_constructor;
    $self->_clear_refs;
  
    return $doc;
  } # parse_char_string
  
  ## DEPRECATED
  sub parse_char_stream ($$$;$$) {
    #my ($self, $handle, $document, $onerror, $get_wrapper) = @_;
    my $self = ref $_[0] ? $_[0] : $_[0]->new;
    my $doc = $self->{document} = $_[2];
    @{$self->{document}->child_nodes} = ();
  
    ## Confidence: irrelevant.
    $self->{confident} = 1 unless exists $self->{confident};
  
    $self->{line_prev} = $self->{line} = 1;
    $self->{column_prev} = -1;
    $self->{column} = 0;
  
    my $handle = $_[1];
    $self->{chars} = [];
    $self->{chars_pos} = 0;
    $self->{chars_pull_next} = sub {
      $self->{chars} = [];
      $self->{chars_pos} = 0;
      my $i = 0;
      my $char = '';
      while ($handle->read ($char, 1, 0)) {
        push @{$self->{chars}}, $char;
        last if $i++ == 1024;
      }
      return $i > 0;
    };
    delete $self->{chars_was_cr};
  
    my $onerror = $_[3] || $self->onerror;
    $self->{parse_error} = sub {
      $onerror->(line => $self->{line}, column => $self->{column}, @_);
    };
  
    $self->{is_xml} = 1;
  
    $self->_initialize_tokenizer;
    $self->_initialize_tree_constructor;
    $self->{t} = $self->_get_next_token;
    {
      $self->_construct_tree;
      redo if $self->{nc} != EOF_CHAR;
    }
    $self->_terminate_tree_constructor;
    $self->_clear_refs;
  
    return $doc;
  } # parse_char_stream
  
  ## ------ Tree construction ------
  
  ## Insertion modes
  sub BEFORE_XML_DECL_IM () { 0 }
  sub AFTER_XML_DECL_IM () { 1 }
  sub BEFORE_ROOT_ELEMENT_IM () { 2 }
  sub IN_ELEMENT_IM () { 3 }
  sub AFTER_ROOT_ELEMENT_IM () { 4 }
  sub IN_SUBSET_IM () { 5 }
  
  sub _initialize_tree_constructor ($) {
    my $self = shift;
    ## NOTE: $self->{document} MUST be specified before this method is called
    $self->{document}->strict_error_checking (0);
    ## TODO: Turn mutation events off # MUST
    $self->{document}->dom_config
        ->{'http://suika.fam.cx/www/2006/dom-config/strict-document-children'}
        = 0;
    $self->{document}->manakai_is_html (0);
    $self->{document}->set_user_data (manakai_source_line => 1);
    $self->{document}->set_user_data (manakai_source_column => 1);
  
    $self->{ge}->{'amp;'} = {value => '&', only_text => 1};
    $self->{ge}->{'apos;'} = {value => "'", only_text => 1};
    $self->{ge}->{'gt;'} = {value => '>', only_text => 1};
    $self->{ge}->{'lt;'} = {value => '<', only_text => 1};
    $self->{ge}->{'quot;'} = {value => '"', only_text => 1};
  
    delete $self->{tainted};
    $self->{open_elements} = [];
    $self->{insertion_mode} = BEFORE_XML_DECL_IM;
  } # _initialize_tree_constructor
  
  sub _terminate_tree_constructor ($) {
    my $self = shift;
    $self->{document}->strict_error_checking (1);
    $self->{document}->dom_config
        ->{'http://suika.fam.cx/www/2006/dom-config/strict-document-children'}
        = 1;
    ## TODO: Turn mutation events on
  } # _terminate_tree_constructor
  
  ## Tree construction stage
  
  
  ## NOTE: Differences from the XML5 draft are marked as "XML5:".
  
  ## XML5: No namespace support.
  
  ## XML5: Start, main, end phases.  In this implementation, they are
  ## represented by insertion modes.
  
  sub _construct_tree ($) {
    my ($self) = @_;
    while (1) {
      if ($self->{insertion_mode} == IN_ELEMENT_IM) {
        $self->_tree_in_element;
      } elsif ($self->{insertion_mode} == IN_SUBSET_IM) {
        $self->_tree_in_subset;
      } elsif ($self->{insertion_mode} == AFTER_ROOT_ELEMENT_IM) {
        $self->_tree_after_root_element;
      } elsif ($self->{insertion_mode} == BEFORE_ROOT_ELEMENT_IM) {
        $self->_tree_before_root_element;
      } elsif ($self->{insertion_mode} == AFTER_XML_DECL_IM) {
        $self->_tree_after_xml_decl;
      } elsif ($self->{insertion_mode} == BEFORE_XML_DECL_IM) {
        $self->_tree_before_xml_decl;
      } else {
        die "$0: Unknown XML insertion mode: $self->{insertion_mode}";
      }
  
      last if $self->{t}->{type} == ABORT_TOKEN;
    }
  } # _construct_tree
  
  sub _tree_before_xml_decl ($) {
    my $self = $_[0];
    
    ## XML5: No support for the XML declaration
    if ($self->{t}->{type} == PI_TOKEN and
        $self->{t}->{target} eq 'xml' and
        $self->{t}->{data} =~ /\Aversion[\x09\x0A\x20]*=[\x09\x0A\x20]*
                           (?>"([^"]*)"|'([^']*)')
                           (?:[\x09\x0A\x20]+
                              encoding[\x09\x0A\x20]*=[\x09\x0A\x20]*
                              (?>"([^"]*)"|'([^']*)')[\x09\x0A\x20]*)?
                           (?:[\x09\x0A\x20]+
                              standalone[\x09\x0A\x20]*=[\x09\x0A\x20]*
                              (?>"(yes|no)"|'(yes|no)'))?
                           [\x09\x0A\x20]*\z/x) {
      $self->{document}->xml_version (defined $1 ? $1 : $2);
      $self->{is_xml} = 1.1 if defined $1 and $1 eq '1.1';
      $self->{document}->xml_encoding (defined $3 ? $3 : $4); # possibly undef
      $self->{document}->xml_standalone (($5 || $6 || 'no') ne 'no');
  
      $self->{insertion_mode} = AFTER_XML_DECL_IM;
      $self->{t} = $self->_get_next_token;
      return;
    } elsif ($self->{t}->{type} == ABORT_TOKEN) {
      return;
    } else {
      $self->{document}->xml_version ('1.0');
      $self->{document}->xml_encoding (undef);
      $self->{document}->xml_standalone (0);
      $self->{insertion_mode} = AFTER_XML_DECL_IM;
      ## Reconsume the token,
      return;
    }
  } # _tree_before_xml_decl
  
  sub _tree_after_xml_decl ($) {
    my $self = shift;
  
    B: while (1) {
      if ($self->{t}->{type} == DOCTYPE_TOKEN) {
        ## XML5: No "DOCTYPE" token.
        
        my $doctype = $self->{document}->create_document_type_definition
            (defined $self->{t}->{name} ? $self->{t}->{name} : '');
        
        ## NOTE: Default value for both |public_id| and |system_id| attributes
        ## are empty strings, so that we don't set any value in missing cases.
        $doctype->public_id ($self->{t}->{pubid}) if defined $self->{t}->{pubid};
        $doctype->system_id ($self->{t}->{sysid}) if defined $self->{t}->{sysid};
        
        ## TODO: internal_subset
        
        $self->{document}->append_child ($doctype);
  
        $self->{ge} = {};
  
        ## XML5: No "has internal subset" flag.
        if ($self->{t}->{has_internal_subset}) {
          $self->{doctype} = $doctype;
          $self->{insertion_mode} = IN_SUBSET_IM;
        } else {
          $self->{insertion_mode} = BEFORE_ROOT_ELEMENT_IM;
        }
        $self->{t} = $self->_get_next_token;
        return;
      } elsif ($self->{t}->{type} == START_TAG_TOKEN or
               $self->{t}->{type} == END_OF_FILE_TOKEN) {
        $self->{insertion_mode} = BEFORE_ROOT_ELEMENT_IM;
        ## Reprocess.
        return;
      } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
        my $comment = $self->{document}->create_comment ($self->{t}->{data});
        $self->{document}->append_child ($comment);
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == PI_TOKEN) {
        my $pi = $self->{document}->create_processing_instruction
            ($self->{t}->{target}, $self->{t}->{data});
        $self->{document}->append_child ($pi);
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == CHARACTER_TOKEN) {
        while ($self->{t}->{data} =~ s/\x00/\x{FFFD}/) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL', token => $self->{t});
        }
  
        if (not $self->{tainted} and
            not $self->{t}->{has_reference} and
            $self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          #
        }
        
        if (length $self->{t}->{data}) {
          ## XML5: Ignore the token.
  
          unless ($self->{tainted}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'text outside of root element',
                            token => $self->{t});
            $self->{tainted} = 1;
          }
  
          $self->{document}->manakai_append_text ($self->{t}->{data});
        }
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                        text => $self->{t}->{tag_name},
                        token => $self->{t});
        ## Ignore the token.
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == ABORT_TOKEN) {
        return;
      } else {
        die "$0: XML parser initial: Unknown token type $self->{t}->{type}";
      }
    } # B
  } # _tree_initial
  
  sub _tree_before_root_element ($) {
    my $self = shift;
  
    B: while (1) {
      if ($self->{t}->{type} == START_TAG_TOKEN) {
        my $nsmap = {
          xml => q<http://www.w3.org/XML/1998/namespace>,
          xmlns => q<http://www.w3.org/2000/xmlns/>,
        };
  
        my $attrs = $self->{t}->{attributes};
        my $attrdefs = $self->{attrdef}->{$self->{t}->{tag_name}};
        for my $attr_name (keys %{$attrdefs}) {
          if ($attrs->{$attr_name}) {
            $attrs->{$attr_name}->{type} = $attrdefs->{$attr_name}->{type} || 0;
            if ($attrdefs->{$attr_name}->{tokenize}) {
              $attrs->{$attr_name}->{value} =~ s/  +/ /g;
              $attrs->{$attr_name}->{value} =~ s/\A //;
              $attrs->{$attr_name}->{value} =~ s/ \z//;
            }
          } elsif (defined $attrdefs->{$attr_name}->{default}) {
            $attrs->{$attr_name} = {
                                    value => $attrdefs->{$attr_name}->{default},
                                    type => $attrdefs->{$attr_name}->{type} || 0,
                                    not_specified => 1,
                                    line => $attrdefs->{$attr_name}->{line},
                                    column => $attrdefs->{$attr_name}->{column},
                                    index => 1 + keys %{$attrs},
                                   };
          }
        }
        
        for (keys %{$attrs}) {
          if (/^xmlns:./s) {
            my $prefix = substr $_, 6;
            my $value = $attrs->{$_}->{value};
            if ($prefix eq 'xml' or $prefix eq 'xmlns' or
                $value eq q<http://www.w3.org/XML/1998/namespace> or
                $value eq q<http://www.w3.org/2000/xmlns/>) {
              ## NOTE: Error should be detected at the DOM layer.
              #
            } elsif (length $value) {
              $nsmap->{$prefix} = $value;
            } else {
              delete $nsmap->{$prefix};
            }
          } elsif ($_ eq 'xmlns') {
            my $value = $attrs->{$_}->{value};
            if ($value eq q<http://www.w3.org/XML/1998/namespace> or
                $value eq q<http://www.w3.org/2000/xmlns/>) {
              ## NOTE: Error should be detected at the DOM layer.
              #
            } elsif (length $value) {
              $nsmap->{''} = $value;
            } else {
              delete $nsmap->{''};
            }
          }
        }
        
        my $ns;
        my ($prefix, $ln) = split /:/, $self->{t}->{tag_name}, 2;
        
        if (defined $ln and $prefix ne '' and $ln ne '') { # prefixed
          if (defined $nsmap->{$prefix}) {
            $ns = $nsmap->{$prefix};
          } else {
            ($prefix, $ln) = (undef, $self->{t}->{tag_name});
          }
        } else {
          $ns = $nsmap->{''} if $prefix ne '' and not defined $ln;
          ($prefix, $ln) = (undef, $self->{t}->{tag_name});
        }
  
        my $el = $self->{document}->create_element_ns ($ns, [$prefix, $ln]);
        $el->set_user_data (manakai_source_line => $self->{t}->{line});
        $el->set_user_data (manakai_source_column => $self->{t}->{column});
  
        my $has_attr;
        for my $attr_name (sort {$attrs->{$a}->{index} <=> $attrs->{$b}->{index}}
                           keys %{$attrs}) {
          my $ns;
          my ($p, $l) = split /:/, $attr_name, 2;
  
          if ($attr_name eq 'xmlns:xmlns') {
            ($p, $l) = (undef, $attr_name);
          } elsif (defined $l and $p ne '' and $l ne '') { # prefixed
            if (defined $nsmap->{$p}) {
              $ns = $nsmap->{$p};
            } else {
              ## NOTE: Error should be detected at the DOM-layer.
              ($p, $l) = (undef, $attr_name);
            }
          } else {
            if ($attr_name eq 'xmlns') {
              $ns = $nsmap->{xmlns};
            }
            ($p, $l) = (undef, $attr_name);
          }
          
          if ($has_attr->{defined $ns ? $ns : ''}->{$l}) {
            $ns = undef;
            ($p, $l) = (undef, $attr_name);
          } else {
            $has_attr->{defined $ns ? $ns : ''}->{$l} = 1;
          }
          
          my $attr_t = $attrs->{$attr_name};
          my $attr = $self->{document}->create_attribute_ns ($ns, [$p, $l]);
          $attr->value ($attr_t->{value});
          if (defined $attr_t->{type}) {
            $attr->manakai_attribute_type ($attr_t->{type});
          } elsif ($self->{document}->all_declarations_processed) {
            $attr->manakai_attribute_type (0); # no value
          } else {
            $attr->manakai_attribute_type (11); # unknown
          }
          $attr->set_user_data (manakai_source_line => $attr_t->{line});
          $attr->set_user_data (manakai_source_column => $attr_t->{column});
          $el->set_attribute_node_ns ($attr);
          $attr->specified (0) if $attr_t->{not_specified};
        }
  
        $self->{document}->append_child ($el);
  
        if ($self->{self_closing}) {
          delete $self->{self_closing};
          $self->{insertion_mode} = AFTER_ROOT_ELEMENT_IM;
        } else {
          push @{$self->{open_elements}}, [$el, $self->{t}->{tag_name}, $nsmap];
          $self->{insertion_mode} = IN_ELEMENT_IM;
        }
  
        #delete $self->{tainted};
  
        $self->{t} = $self->_get_next_token;
        return;
      } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
        my $comment = $self->{document}->create_comment ($self->{t}->{data});
        $self->{document}->append_child ($comment);
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == PI_TOKEN) {
        my $pi = $self->{document}->create_processing_instruction
            ($self->{t}->{target}, $self->{t}->{data});
        $self->{document}->append_child ($pi);
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == CHARACTER_TOKEN) {
        while ($self->{t}->{data} =~ s/\x00/\x{FFFD}/) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL', token => $self->{t});
        }
  
        if (not $self->{tainted} and
            not $self->{t}->{has_reference} and
            $self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          #
        }
        
        if (length $self->{t}->{data}) {
          ## XML5: Ignore the token.
  
          unless ($self->{tainted}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'text outside of root element',
                            token => $self->{t});
            $self->{tainted} = 1;
          }
  
          $self->{document}->manakai_append_text ($self->{t}->{data});
        }
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'no root element',
                        token => $self->{t});
        
        $self->{insertion_mode} = AFTER_ROOT_ELEMENT_IM;
        ## Reprocess.
        return;
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                        text => $self->{t}->{tag_name},
                        token => $self->{t});
        ## Ignore the token.
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == DOCTYPE_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'in html:#doctype',
                        token => $self->{t});
        ## Ignore the token.
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == ABORT_TOKEN) {
        return;
      } else {
        die "$0: XML parser initial: Unknown token type $self->{t}->{type}";
      }
    } # B
  } # _tree_before_root_element
  
  sub _tree_in_element ($) {
    my $self = shift;
    
    B: while (1) {
      if ($self->{t}->{type} == CHARACTER_TOKEN) {
        while ($self->{t}->{data} =~ s/\x00/\x{FFFD}/) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL', token => $self->{t});
        }
        $self->{open_elements}->[-1]->[0]->manakai_append_text ($self->{t}->{data});
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
        my $nsmap = {%{$self->{open_elements}->[-1]->[2]}};
  
        my $attrs = $self->{t}->{attributes};
        my $attrdefs = $self->{attrdef}->{$self->{t}->{tag_name}};
        for my $attr_name (keys %{$attrdefs}) {
          if ($attrs->{$attr_name}) {
            $attrs->{$attr_name}->{type} = $attrdefs->{$attr_name}->{type} || 0;
            if ($attrdefs->{$attr_name}->{tokenize}) {
              $attrs->{$attr_name}->{value} =~ s/  +/ /g;
              $attrs->{$attr_name}->{value} =~ s/\A //;
              $attrs->{$attr_name}->{value} =~ s/ \z//;
            }
          } elsif (defined $attrdefs->{$attr_name}->{default}) {
            $attrs->{$attr_name} = {
                                    value => $attrdefs->{$attr_name}->{default},
                                    type => $attrdefs->{$attr_name}->{type} || 0,
                                    not_specified => 1,
                                    line => $attrdefs->{$attr_name}->{line},
                                    column => $attrdefs->{$attr_name}->{column},
                                    index => 1 + keys %{$attrs},
                                   };
          }
        }
        
        for (keys %{$attrs}) {
          if (/^xmlns:./s) {
            my $prefix = substr $_, 6;
            my $value = $attrs->{$_}->{value};
            if ($prefix eq 'xml' or $prefix eq 'xmlns' or
                $value eq q<http://www.w3.org/XML/1998/namespace> or
                $value eq q<http://www.w3.org/2000/xmlns/>) {
              ## NOTE: Error should be detected at the DOM layer.
              #
            } elsif (length $value) {
              $nsmap->{$prefix} = $value;
            } else {
              delete $nsmap->{$prefix};
            }
          } elsif ($_ eq 'xmlns') {
            my $value = $attrs->{$_}->{value};
            if ($value eq q<http://www.w3.org/XML/1998/namespace> or
                $value eq q<http://www.w3.org/2000/xmlns/>) {
              ## NOTE: Error should be detected at the DOM layer.
              #
            } elsif (length $value) {
              $nsmap->{''} = $value;
            } else {
              delete $nsmap->{''};
            }
          }
        }
        
        my $ns;
        my ($prefix, $ln) = split /:/, $self->{t}->{tag_name}, 2;
        
        if (defined $ln and $prefix ne '' and $ln ne '') { # prefixed
          if (defined $nsmap->{$prefix}) {
            $ns = $nsmap->{$prefix};
          } else {
            ## NOTE: Error should be detected at the DOM layer.
            ($prefix, $ln) = (undef, $self->{t}->{tag_name});
          }
        } else {
          $ns = $nsmap->{''} if $prefix ne '' and not defined $ln;
          ($prefix, $ln) = (undef, $self->{t}->{tag_name});
        }
  
        my $el = $self->{document}->create_element_ns ($ns, [$prefix, $ln]);
        $el->set_user_data (manakai_source_line => $self->{t}->{line});
        $el->set_user_data (manakai_source_column => $self->{t}->{column});
  
        my $has_attr;
        for my $attr_name (sort {$attrs->{$a}->{index} <=> $attrs->{$b}->{index}}
                           keys %{$attrs}) {
          my $ns;
          my ($p, $l) = split /:/, $attr_name, 2;
  
          if ($attr_name eq 'xmlns:xmlns') {
            ($p, $l) = (undef, $attr_name);
          } elsif (defined $l and $p ne '' and $l ne '') { # prefixed
            if (defined $nsmap->{$p}) {
              $ns = $nsmap->{$p};
            } else {
              ## NOTE: Error should be detected at the DOM-layer.
              ($p, $l) = (undef, $attr_name);
            }
          } else {
            if ($attr_name eq 'xmlns') {
              $ns = $nsmap->{xmlns};
            }
            ($p, $l) = (undef, $attr_name);
          }
          
          if ($has_attr->{defined $ns ? $ns : ''}->{$l}) {
            $ns = undef;
            ($p, $l) = (undef, $attr_name);
          } else {
            $has_attr->{defined $ns ? $ns : ''}->{$l} = 1;
          }
  
          my $attr_t = $attrs->{$attr_name};
          my $attr = $self->{document}->create_attribute_ns ($ns, [$p, $l]);
          $attr->value ($attr_t->{value});
          if (defined $attr_t->{type}) {
            $attr->manakai_attribute_type ($attr_t->{type});
          } elsif ($self->{document}->all_declarations_processed) {
            $attr->manakai_attribute_type (0); # no value
          } else {
            $attr->manakai_attribute_type (11); # unknown
          }
          $attr->set_user_data (manakai_source_line => $attr_t->{line});
          $attr->set_user_data (manakai_source_column => $attr_t->{column});
          $el->set_attribute_node_ns ($attr);
          $attr->specified (0) if $attr_t->{not_specified};
        }
  
        $self->{open_elements}->[-1]->[0]->append_child ($el);
  
        if ($self->{self_closing}) {
          delete $self->{self_closing};
        } else {
          push @{$self->{open_elements}}, [$el, $self->{t}->{tag_name}, $nsmap];
        }
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq '') {
          ## Short end tag token.
          pop @{$self->{open_elements}};
        } elsif ($self->{open_elements}->[-1]->[1] eq $self->{t}->{tag_name}) {
          pop @{$self->{open_elements}};
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                          text => $self->{t}->{tag_name},
                          token => $self->{t});
          
          ## Has an element in scope
          INSCOPE: for my $i (reverse 0..$#{$self->{open_elements}}) {
            if ($self->{open_elements}->[$i]->[1] eq $self->{t}->{tag_name}) {
              splice @{$self->{open_elements}}, $i;
              last INSCOPE;
            }
          } # INSCOPE
        }
        
        unless (@{$self->{open_elements}}) {
          $self->{insertion_mode} = AFTER_ROOT_ELEMENT_IM;
          $self->{t} = $self->_get_next_token;
          return;
        } else {
          ## Stay in the state.
          $self->{t} = $self->_get_next_token;
          redo B;
        }
      } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
        my $comment = $self->{document}->create_comment ($self->{t}->{data});
        $self->{open_elements}->[-1]->[0]->append_child ($comment);
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == PI_TOKEN) {
        my $pi = $self->{document}->create_processing_instruction
            ($self->{t}->{target}, $self->{t}->{data});
        $self->{open_elements}->[-1]->[0]->append_child ($pi);
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'in body:#eof',
                        token => $self->{t});
        
        $self->{insertion_mode} = AFTER_ROOT_ELEMENT_IM;
        $self->{t} = $self->_get_next_token;
        return;
      } elsif ($self->{t}->{type} == DOCTYPE_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'in html:#doctype',
                        token => $self->{t});
        ## Ignore the token.
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == ABORT_TOKEN) {
        return;
      } else {
        die "$0: XML parser initial: Unknown token type $self->{t}->{type}";
      }
    } # B
  } # _tree_in_element
  
  sub _tree_after_root_element ($) {
    my $self = shift;
  
    B: while (1) {
      if ($self->{t}->{type} == START_TAG_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'second root element',
                        token => $self->{t});
  
        ## XML5: Ignore the token.
  
        $self->{insertion_mode} = BEFORE_ROOT_ELEMENT_IM;
        ## Reprocess.
        return;
      } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
        my $comment = $self->{document}->create_comment ($self->{t}->{data});
        $self->{document}->append_child ($comment);
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == PI_TOKEN) {
        my $pi = $self->{document}->create_processing_instruction
            ($self->{t}->{target}, $self->{t}->{data});
        $self->{document}->append_child ($pi);
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == CHARACTER_TOKEN) {
        while ($self->{t}->{data} =~ s/\x00/\x{FFFD}/) {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'NULL', token => $self->{t});
        }
  
        if (not $self->{tainted} and
            not $self->{t}->{has_reference} and
            $self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          #
        }
        
        if (length $self->{t}->{data}) {
          ## XML5: Ignore the token.
  
          unless ($self->{tainted}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'text outside of root element',
                            token => $self->{t});
            $self->{tainted} = 1;
          }
  
          $self->{document}->manakai_append_text ($self->{t}->{data});
        }
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        ## Stop parsing.
  
        ## TODO: implement "stop parsing".
  
        $self->{t} = {type => ABORT_TOKEN};
        return;
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'unmatched end tag',
                        text => $self->{t}->{tag_name},
                        token => $self->{t});
        ## Ignore the token.
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == DOCTYPE_TOKEN) {
        $self->{parse_error}->(level => $self->{level}->{must}, type => 'in html:#doctype',
                        token => $self->{t});
        ## Ignore the token.
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == ABORT_TOKEN) {
        return;
      } else {
        die "$0: XML parser initial: Unknown token type $self->{t}->{type}";
      }
    } # B
  } # _tree_after_root_element
  
  sub _tree_in_subset ($) {
    my $self = shift;
  
    B: while (1) {
      if ($self->{t}->{type} == COMMENT_TOKEN) {
        ## Ignore the token.
  
        ## Stay in the state.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == ELEMENT_TOKEN) {
        unless ($self->{has_element_decl}->{$self->{t}->{name}}) {
          my $node = $self->{doctype}->get_element_type_definition_node
              ($self->{t}->{name});
          unless ($node) {
            $node = $self->{document}->create_element_type_definition
                ($self->{t}->{name});
            $self->{doctype}->set_element_type_definition_node ($node);
          }
          
          $node->set_user_data (manakai_source_line => $self->{t}->{line});
          $node->set_user_data (manakai_source_column => $self->{t}->{column});
          
          $node->content_model_text (join '', @{$self->{t}->{content}})
              if $self->{t}->{content};
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'duplicate element decl', ## TODO: type
                          value => $self->{t}->{name},
                          token => $self->{t});
          
          ## TODO: $self->{t}->{content} syntax check.
        }
        $self->{has_element_decl}->{$self->{t}->{name}} = 1;
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == ATTLIST_TOKEN) {
        if ($self->{stop_processing}) {
          ## TODO: syntax validation
        } else {
          my $ed = $self->{doctype}->get_element_type_definition_node
              ($self->{t}->{name});
          unless ($ed) {
            $ed = $self->{document}->create_element_type_definition
                ($self->{t}->{name});
            $ed->set_user_data (manakai_source_line => $self->{t}->{line});
            $ed->set_user_data (manakai_source_column => $self->{t}->{column});
            $self->{doctype}->set_element_type_definition_node ($ed);
          } elsif ($self->{has_attlist}->{$self->{t}->{name}}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'duplicate attlist decl', ## TODO: type
                            value => $self->{t}->{name},
                            token => $self->{t},
                            level => $self->{level}->{warn});
          }
          $self->{has_attlist}->{$self->{t}->{name}} = 1;
          
          unless (@{$self->{t}->{attrdefs}}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'empty attlist decl', ## TODO: type
                            value => $self->{t}->{name},
                            token => $self->{t},
                            level => $self->{level}->{warn});
          }
          
          for my $at (@{$self->{t}->{attrdefs}}) {
            unless ($ed->get_attribute_definition_node ($at->{name})) {
              my $node = $self->{document}->create_attribute_definition
                  ($at->{name});
              $node->set_user_data (manakai_source_line => $at->{line});
              $node->set_user_data (manakai_source_column => $at->{column});
              
              my $type = defined $at->{type} ? {
                CDATA => 1, ID => 2, IDREF => 3, IDREFS => 4, ENTITY => 5,
                ENTITIES => 6, NMTOKEN => 7, NMTOKENS => 8, NOTATION => 9,
              }->{$at->{type}} : 10;
              if (defined $type) {
                $node->declared_type ($type);
              } else {
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'unknown declared type', ## TODO: type
                                value => $at->{type},
                                token => $at);
              }
              
              push @{$node->allowed_tokens}, @{$at->{tokens}};
              
              my $default = defined $at->{default} ? {
                FIXED => 1, REQUIRED => 2, IMPLIED => 3,
              }->{$at->{default}} : 4;
              if (defined $default) {
                $node->default_type ($default);
                if (defined $at->{value}) {
                  if ($default == 1 or $default == 4) {
                    #
                  } elsif (length $at->{value}) {
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'default value not allowed', ## TODO: type
                                    token => $at);
                  }
                } else {
                  if ($default == 1 or $default == 4) {
                    $self->{parse_error}->(level => $self->{level}->{must}, type => 'default value not provided', ## TODO: type
                                    token => $at);
                  }
                }
              } else {
                $self->{parse_error}->(level => $self->{level}->{must}, type => 'unknown default type', ## TODO: type
                                value => $at->{default},
                                token => $at);
              }
  
              $type ||= 0;
              my $tokenize = (2 <= $type and $type <= 10);
  
              if (defined $at->{value}) {
                if ($tokenize) {
                  $at->{value} =~ s/  +/ /g;
                  $at->{value} =~ s/\A //;
                  $at->{value} =~ s/ \z//;
                }
                $node->text_content ($at->{value});
              }
              
              $ed->set_attribute_definition_node ($node);
  
              ## For tree construction
              $self->{attrdef}->{$self->{t}->{name}}->{$at->{name}}
                  = {
                     type => $type,
                     tokenize => $tokenize,
                     default => (($default and ($default == 1 or $default == 4))
                                   ? defined $at->{value} ? $at->{value} : ''
                                   : undef),
                    };
            } else {
              $self->{parse_error}->(level => $self->{level}->{must}, type => 'duplicate attrdef', ## TODO: type
                              value => $at->{name},
                              token => $at,
                              level => $self->{level}->{warn});
              
              ## TODO: syntax validation
            }
          } # $at
        }
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == GENERAL_ENTITY_TOKEN) {
        if ($self->{stop_processing}) {
          ## TODO: syntax validation
        } elsif ({
                  amp => 1, apos => 1, quot => 1, lt => 1, gt => 1,
                 }->{$self->{t}->{name}}) {
          if (not defined $self->{t}->{value} or
              $self->{t}->{value} !~
              {
               amp => qr/\A&#(?:x0*26|0*38);\z/,
               lt => qr/\A&#(?:x0*3[Cc]|0*60);\z/,
               gt => qr/\A(?>&#(?:x0*3[Ee]|0*62);|>)\z/,
               quot => qr/\A(?>&#(?:x0*22|0*34);|")\z/,
               apos => qr/\A(?>&#(?:x0*27|0*39);|')\z/,
              }->{$self->{t}->{name}}) {
            $self->{parse_error}->(level => $self->{level}->{must}, type => 'bad predefined entity decl', ## TODO: type
                            value => $self->{t}->{name},
                            token => $self->{t});
          }
  
          $self->{ge}->{$self->{t}->{name}.';'} = {name => $self->{t}->{name},
                                               value => {
                                                         amp => '&',
                                                         lt => '<',
                                                         gt => '>',
                                                         quot => '"',
                                                         apos => "'",
                                                        }->{$self->{t}->{name}},
                                               only_text => 1};
        } elsif (not $self->{ge}->{$self->{t}->{name}.';'}) {
          ## For parser.
          $self->{ge}->{$self->{t}->{name}.';'} = $self->{t};
          if (defined $self->{t}->{value} and
              $self->{t}->{value} !~ /[&<]/) {
            $self->{t}->{only_text} = 1;
          }
          
          ## For DOM.
          if (defined $self->{t}->{notation}) {
            my $node = $self->{document}->create_general_entity ($self->{t}->{name});
            $node->set_user_data (manakai_source_line => $self->{t}->{line});
            $node->set_user_data (manakai_source_column => $self->{t}->{column});
            
            $node->public_id ($self->{t}->{pubid}); # may be undef
            $node->system_id ($self->{t}->{sysid}); # may be undef
            $node->notation_name ($self->{t}->{notation});
            
            $self->{doctype}->set_general_entity_node ($node);
          } else {
            ## TODO: syntax validation
          }
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'duplicate general entity decl', ## TODO: type
                          value => $self->{t}->{name},
                          token => $self->{t},
                          level => $self->{level}->{warn});
  
          ## TODO: syntax validation        
        }
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == PARAMETER_ENTITY_TOKEN) {
        if ($self->{stop_processing}) {
          ## TODO: syntax validation
        } elsif (not $self->{pe}->{$self->{t}->{name}}) {
          ## For parser.
          $self->{pe}->{$self->{t}->{name}} = $self->{t};
  
          ## TODO: syntax validation
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'duplicate para entity decl', ## TODO: type
                          value => $self->{t}->{name},
                          token => $self->{t},
                          level => $self->{level}->{warn});
  
          ## TODO: syntax validation        
        }
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == NOTATION_TOKEN) {
        unless ($self->{doctype}->get_notation_node
                  ($self->{t}->{name})) {
          my $node = $self->{document}->create_notation ($self->{t}->{name});
          $node->set_user_data (manakai_source_line => $self->{t}->{line});
          $node->set_user_data (manakai_source_column => $self->{t}->{column});
          
          $node->public_id ($self->{t}->{pubid}); # may be undef
          $node->system_id ($self->{t}->{sysid}); # may be undef
          
          $self->{doctype}->set_notation_node ($node);
        } else {
          $self->{parse_error}->(level => $self->{level}->{must}, type => 'duplicate notation decl', ## TODO: type
                          value => $self->{t}->{name},
                          token => $self->{t});
  
          ## TODO: syntax validation
        }
  
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == PI_TOKEN) {
        my $pi = $self->{document}->create_processing_instruction
            ($self->{t}->{target}, $self->{t}->{data});
        $self->{doctype}->append_child ($pi);
        ## TODO: line/col
        
        ## Stay in the mode.
        $self->{t} = $self->_get_next_token;
        next B;
      } elsif ($self->{t}->{type} == END_OF_DOCTYPE_TOKEN) {
        $self->{insertion_mode} = BEFORE_ROOT_ELEMENT_IM;
        $self->{t} = $self->_get_next_token;
        return;
      } elsif ($self->{t}->{type} == ABORT_TOKEN) {
        return;
      } else {
        die "$0: XML parser subset im: Unknown token type $self->{t}->{type}";
      }
    } # B
  
  } # _tree_in_subset
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2012 Wakaba <w@suika.fam.cx>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WHATPM_XML_PARSER

$fatpacked{"Whatpm/XMLSerializer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM_XMLSERIALIZER';
  package Whatpm::XMLSerializer;
  use strict;
  
  sub get_outer_xml ($$;$) {
    my $r = '';
    my @src = ($_[1]);
    my $onerror = $_[2] || sub { };
    my $nsbind = [{'' => '', xml => q<http://www.w3.org/XML/1998/namespace>,
                   xmlns => q<http://suika.fam.cx/~wakaba/-temp/2003/09/27/undef>}];
    my $xescape = sub ($) {
      my $s = shift;
      $s =~ s/&/&amp;/g;
      $s =~ s/</&lt;/g;
      $s =~ s/>/&gt;/g;
      $s =~ s/"/&quot;/g;
      return $s;
    };
    while (defined (my $src = shift @src)) {
      if (ref $src eq 'ARRAY') {
        pop @$nsbind;  ## End tag
      } elsif (ref $src) {
        my $srcnt = $src->node_type;
        if ($srcnt == 1) { # ELEMENT_NODE
          my @csrc;
          my $etag;
          push @$nsbind, my $ns = {%{$nsbind->[-1]}};
          my %attrr;
  
          my @attrs = @{$src->attributes};
          my @nsattrs;
          my @gattrs;
          my @lattrs;
  
          for my $attr (@attrs) {
            my $nsuri = $attr->namespace_uri;
            if (not defined $nsuri) {
              push @lattrs, $attr;
            } elsif ($nsuri eq q<http://www.w3.org/2000/xmlns/>) {
              push @nsattrs, $attr;
            } else {
              push @gattrs, $attr;
            }
          }
  
          ## Implied namespace prefixes
          my $etns = $src->namespace_uri;
          my $etpfx = $src->prefix;
          if (defined $etns and defined $etpfx and
              not (defined $ns->{$etpfx} and $ns->{$etpfx} eq $etns)) {
            $ns->{$etpfx} = $etns;
            $attrr{'xmlns:'.$etpfx} = [$xescape->($etns)];
          }
  
          for my $attr (@gattrs) {
            my $atns = $attr->namespace_uri;
            my $atpfx = $attr->prefix;
            if (defined $atpfx and
                not (defined $ns->{$atpfx} and $ns->{$atpfx} eq $atns)) {
              $ns->{$atpfx} = $atns;
              $attrr{'xmlns:'.$atpfx} = [$xescape->($atns)];
            }
          }
  
          ## Namespace attributes
          XA: for my $attr (@nsattrs) {
            my $attrval = $attr->value;
            my $lname = $attr->local_name;
            if ($lname eq 'xmlns') {
              $ns->{''} = $attrval;
              $attrr{xmlns} = [@{$attr->child_nodes}];
            } else {
              if (length $attrval) {
                $ns->{$lname} = $attrval;
              } else {
                $ns->{$lname} = q<http://suika.fam.cx/~wakaba/-temp/2003/09/27/undef>;
              }
              $attrr{'xmlns:'.$lname} = [@{$attr->child_nodes}];
            }
          } # XA
  
          ## Per-element partition attributes
          for my $attr (@lattrs) {
            $attrr{$attr->local_name} = [@{$attr->child_nodes}];
          }
  
          ## Global partition attributes
          my $dns = $ns->{''};
          delete $ns->{''};
          my $nsrev = {reverse %$ns};
          $ns->{''} = $dns;
          delete $nsrev->{q<http://suika.fam.cx/~wakaba/-temp/2003/09/27/undef>}; # for security reason
          for my $attr (@gattrs) {
            my $atns = $attr->namespace_uri;
            my $atpfx = $attr->prefix;
            if (not defined $atpfx or
                $ns->{$atpfx} ne $atns) {
              if (defined $nsrev->{$atns}) {
                $atpfx = $nsrev->{$atns};
              } else {
                ## Prefix is not registered
                my @uritxt = grep {/\A[A-Za-z][A-Za-z0-9_.-]*\z/}
                             split /\W+/, $atns;
                P: {
                  for my $pfx (reverse @uritxt) {
                    if (not defined $ns->{$pfx}) {
                      $atpfx = $pfx;
                      $ns->{$pfx} = $atns;
                      $nsrev->{$atns} = $atpfx;
                      $attrr{'xmlns:'.$atpfx} = [$xescape->($atns)];
                      last P;
                    }
                  }
  
                  my $i = 1;
                  $i++ while exists $ns->{'ns'.$i};
                  $atpfx = 'ns'.$i;
                  $ns->{$atpfx} = $atns;
                  $nsrev->{$atns} = $atpfx;
                  $attrr{'xmlns:ns'.$i} = [$xescape->($atns)];
                } # P
              }
            }
  
            $attrr{$atpfx.':'.$attr->local_name} = [@{$attr->child_nodes}];
          }
  
          ## Element type name
          if (defined $etns) {
            if (not defined $etpfx or
                (defined $ns->{$etpfx} and $ns->{$etpfx} ne $etns)) {
              if ($ns->{''} eq $etns) {
                $etpfx = undef;
              } else {
                $etpfx = $nsrev->{$etns};
                unless (defined $etpfx) {
                  ## Prefix is not registered
                  my @uritxt = grep {/\A[A-Za-z][A-Za-z0-9_.-]*\z/}
                               split /\W+/, $etns;
                  P: {
                    for my $pfx (reverse @uritxt) {
                      if (not defined $ns->{$pfx}) {
                        $etpfx = $pfx;
                        $ns->{$pfx} = $etns;
                        $nsrev->{$etns} = $etpfx;
                        $attrr{'xmlns:'.$etpfx} = [$xescape->($etns)];
                        last P;
                      }
                    }
    
                    my $i = 1;
                    $i++ while exists $ns->{'ns'.$i};
                    $etpfx = 'ns'.$i;
                    $ns->{$etpfx} = $etns;
                    $nsrev->{$etns} = $etpfx;
                    $attrr{'xmlns:ns'.$i} = [$xescape->($etns)];
                  } # P
                }
              }
            }
          } else {
            if ($ns->{''} ne '') {
              $ns->{''} = '';
              $attrr{xmlns} = [''];
            }
          }
  
          $r .= '<';
          $etag = '</';
          if (defined $etpfx and defined $etns) {
            $r .= $etpfx . ':';
            $etag .= $etpfx . ':';
          }
          my $etln = $src->local_name;
          $r .= $etln;
          $etag .= $etln . '>';
                
          ## Attribute specifications
          for my $an (sort keys %attrr) {
            push @csrc, ' ' . $an . '="', @{$attrr{$an}}, '"';
          }
  
          ## Children
          push @csrc, '>', @{$src->child_nodes}, $etag, [];
          unshift @src, @csrc;
        } elsif ($srcnt == 3) { # TEXT_NODE
          $r .= $xescape->($src->node_value);
        } elsif ($srcnt == 4) { # CDATA_SECTION_NODE
          my $text = $src->node_value;
          $text =~ s/]]>/]]]]>&gt;<![CDATA[/g;
          $r .= '<![CDATA[' . $text . ']]>';
        } elsif ($srcnt == 5) { # ENTITY_REFERENCE_NODE
          if ($src->manakai_expanded) {
            push @src, @{$src->child_nodes};
          } else {
            $r .= '&' . $src->node_name . ';';
          }
        } elsif ($srcnt == 7) { # PROCESSING_INSTRUCTION_NODE
          $r .= '<?' . $src->node_name;
          my $data = $src->node_value;
          if (length $data) {
            $data =~ s/\?>/?&gt;/g;
            $r .= ' ' . $data;
          }
          $r .= '?>';
        } elsif ($srcnt == 8) { # COMMENT_NODE
          my $data = $src->node_value;
          $data =~ s/--/- - /g;
          $r .= '<!--' . $data . '-->';
        } elsif ($srcnt == 9) { # DOCUMENT_NODE
          unshift @src, map {$_, "\x0A"} @{$src->child_nodes};
          ## ISSUE: |cfg:strict-document-children| cparam
        }
        # document type, entity, notation, etdef, atdef, df
      } else {
        $r .= $src;
      }
    }
  
    return \$r;
  } # get_outer_xml
  
  1;
  ## $Date: 2007/07/15 06:15:04 $
WHATPM_XMLSERIALIZER

$fatpacked{"Whatpm/_NamedEntityList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WHATPM__NAMEDENTITYLIST';
  $Whatpm::HTML::EntityChar = {
            "AElig" => "\x{c6}",
            "AElig;" => "\x{c6}",
            "AMP" => "&",
            "AMP;" => "&",
            "Aacute" => "\x{c1}",
            "Aacute;" => "\x{c1}",
            "Abreve;" => "\x{102}",
            "Acirc" => "\x{c2}",
            "Acirc;" => "\x{c2}",
            "Acy;" => "\x{410}",
            "Afr;" => "\x{1d504}",
            "Agrave" => "\x{c0}",
            "Agrave;" => "\x{c0}",
            "Alpha;" => "\x{391}",
            "Amacr;" => "\x{100}",
            "And;" => "\x{2a53}",
            "Aogon;" => "\x{104}",
            "Aopf;" => "\x{1d538}",
            "ApplyFunction;" => "\x{2061}",
            "Aring" => "\x{c5}",
            "Aring;" => "\x{c5}",
            "Ascr;" => "\x{1d49c}",
            "Assign;" => "\x{2254}",
            "Atilde" => "\x{c3}",
            "Atilde;" => "\x{c3}",
            "Auml" => "\x{c4}",
            "Auml;" => "\x{c4}",
            "Backslash;" => "\x{2216}",
            "Barv;" => "\x{2ae7}",
            "Barwed;" => "\x{2306}",
            "Bcy;" => "\x{411}",
            "Because;" => "\x{2235}",
            "Bernoullis;" => "\x{212c}",
            "Beta;" => "\x{392}",
            "Bfr;" => "\x{1d505}",
            "Bopf;" => "\x{1d539}",
            "Breve;" => "\x{2d8}",
            "Bscr;" => "\x{212c}",
            "Bumpeq;" => "\x{224e}",
            "CHcy;" => "\x{427}",
            "COPY" => "\x{a9}",
            "COPY;" => "\x{a9}",
            "Cacute;" => "\x{106}",
            "Cap;" => "\x{22d2}",
            "CapitalDifferentialD;" => "\x{2145}",
            "Cayleys;" => "\x{212d}",
            "Ccaron;" => "\x{10c}",
            "Ccedil" => "\x{c7}",
            "Ccedil;" => "\x{c7}",
            "Ccirc;" => "\x{108}",
            "Cconint;" => "\x{2230}",
            "Cdot;" => "\x{10a}",
            "Cedilla;" => "\x{b8}",
            "CenterDot;" => "\x{b7}",
            "Cfr;" => "\x{212d}",
            "Chi;" => "\x{3a7}",
            "CircleDot;" => "\x{2299}",
            "CircleMinus;" => "\x{2296}",
            "CirclePlus;" => "\x{2295}",
            "CircleTimes;" => "\x{2297}",
            "ClockwiseContourIntegral;" => "\x{2232}",
            "CloseCurlyDoubleQuote;" => "\x{201d}",
            "CloseCurlyQuote;" => "\x{2019}",
            "Colon;" => "\x{2237}",
            "Colone;" => "\x{2a74}",
            "Congruent;" => "\x{2261}",
            "Conint;" => "\x{222f}",
            "ContourIntegral;" => "\x{222e}",
            "Copf;" => "\x{2102}",
            "Coproduct;" => "\x{2210}",
            "CounterClockwiseContourIntegral;" => "\x{2233}",
            "Cross;" => "\x{2a2f}",
            "Cscr;" => "\x{1d49e}",
            "Cup;" => "\x{22d3}",
            "CupCap;" => "\x{224d}",
            "DD;" => "\x{2145}",
            "DDotrahd;" => "\x{2911}",
            "DJcy;" => "\x{402}",
            "DScy;" => "\x{405}",
            "DZcy;" => "\x{40f}",
            "Dagger;" => "\x{2021}",
            "Darr;" => "\x{21a1}",
            "Dashv;" => "\x{2ae4}",
            "Dcaron;" => "\x{10e}",
            "Dcy;" => "\x{414}",
            "Del;" => "\x{2207}",
            "Delta;" => "\x{394}",
            "Dfr;" => "\x{1d507}",
            "DiacriticalAcute;" => "\x{b4}",
            "DiacriticalDot;" => "\x{2d9}",
            "DiacriticalDoubleAcute;" => "\x{2dd}",
            "DiacriticalGrave;" => "`",
            "DiacriticalTilde;" => "\x{2dc}",
            "Diamond;" => "\x{22c4}",
            "DifferentialD;" => "\x{2146}",
            "Dopf;" => "\x{1d53b}",
            "Dot;" => "\x{a8}",
            "DotDot;" => "\x{20dc}",
            "DotEqual;" => "\x{2250}",
            "DoubleContourIntegral;" => "\x{222f}",
            "DoubleDot;" => "\x{a8}",
            "DoubleDownArrow;" => "\x{21d3}",
            "DoubleLeftArrow;" => "\x{21d0}",
            "DoubleLeftRightArrow;" => "\x{21d4}",
            "DoubleLeftTee;" => "\x{2ae4}",
            "DoubleLongLeftArrow;" => "\x{27f8}",
            "DoubleLongLeftRightArrow;" => "\x{27fa}",
            "DoubleLongRightArrow;" => "\x{27f9}",
            "DoubleRightArrow;" => "\x{21d2}",
            "DoubleRightTee;" => "\x{22a8}",
            "DoubleUpArrow;" => "\x{21d1}",
            "DoubleUpDownArrow;" => "\x{21d5}",
            "DoubleVerticalBar;" => "\x{2225}",
            "DownArrow;" => "\x{2193}",
            "DownArrowBar;" => "\x{2913}",
            "DownArrowUpArrow;" => "\x{21f5}",
            "DownBreve;" => "\x{311}",
            "DownLeftRightVector;" => "\x{2950}",
            "DownLeftTeeVector;" => "\x{295e}",
            "DownLeftVector;" => "\x{21bd}",
            "DownLeftVectorBar;" => "\x{2956}",
            "DownRightTeeVector;" => "\x{295f}",
            "DownRightVector;" => "\x{21c1}",
            "DownRightVectorBar;" => "\x{2957}",
            "DownTee;" => "\x{22a4}",
            "DownTeeArrow;" => "\x{21a7}",
            "Downarrow;" => "\x{21d3}",
            "Dscr;" => "\x{1d49f}",
            "Dstrok;" => "\x{110}",
            "ENG;" => "\x{14a}",
            "ETH" => "\x{d0}",
            "ETH;" => "\x{d0}",
            "Eacute" => "\x{c9}",
            "Eacute;" => "\x{c9}",
            "Ecaron;" => "\x{11a}",
            "Ecirc" => "\x{ca}",
            "Ecirc;" => "\x{ca}",
            "Ecy;" => "\x{42d}",
            "Edot;" => "\x{116}",
            "Efr;" => "\x{1d508}",
            "Egrave" => "\x{c8}",
            "Egrave;" => "\x{c8}",
            "Element;" => "\x{2208}",
            "Emacr;" => "\x{112}",
            "EmptySmallSquare;" => "\x{25fb}",
            "EmptyVerySmallSquare;" => "\x{25ab}",
            "Eogon;" => "\x{118}",
            "Eopf;" => "\x{1d53c}",
            "Epsilon;" => "\x{395}",
            "Equal;" => "\x{2a75}",
            "EqualTilde;" => "\x{2242}",
            "Equilibrium;" => "\x{21cc}",
            "Escr;" => "\x{2130}",
            "Esim;" => "\x{2a73}",
            "Eta;" => "\x{397}",
            "Euml" => "\x{cb}",
            "Euml;" => "\x{cb}",
            "Exists;" => "\x{2203}",
            "ExponentialE;" => "\x{2147}",
            "Fcy;" => "\x{424}",
            "Ffr;" => "\x{1d509}",
            "FilledSmallSquare;" => "\x{25fc}",
            "FilledVerySmallSquare;" => "\x{25aa}",
            "Fopf;" => "\x{1d53d}",
            "ForAll;" => "\x{2200}",
            "Fouriertrf;" => "\x{2131}",
            "Fscr;" => "\x{2131}",
            "GJcy;" => "\x{403}",
            "GT" => ">",
            "GT;" => ">",
            "Gamma;" => "\x{393}",
            "Gammad;" => "\x{3dc}",
            "Gbreve;" => "\x{11e}",
            "Gcedil;" => "\x{122}",
            "Gcirc;" => "\x{11c}",
            "Gcy;" => "\x{413}",
            "Gdot;" => "\x{120}",
            "Gfr;" => "\x{1d50a}",
            "Gg;" => "\x{22d9}",
            "Gopf;" => "\x{1d53e}",
            "GreaterEqual;" => "\x{2265}",
            "GreaterEqualLess;" => "\x{22db}",
            "GreaterFullEqual;" => "\x{2267}",
            "GreaterGreater;" => "\x{2aa2}",
            "GreaterLess;" => "\x{2277}",
            "GreaterSlantEqual;" => "\x{2a7e}",
            "GreaterTilde;" => "\x{2273}",
            "Gscr;" => "\x{1d4a2}",
            "Gt;" => "\x{226b}",
            "HARDcy;" => "\x{42a}",
            "Hacek;" => "\x{2c7}",
            "Hat;" => "^",
            "Hcirc;" => "\x{124}",
            "Hfr;" => "\x{210c}",
            "HilbertSpace;" => "\x{210b}",
            "Hopf;" => "\x{210d}",
            "HorizontalLine;" => "\x{2500}",
            "Hscr;" => "\x{210b}",
            "Hstrok;" => "\x{126}",
            "HumpDownHump;" => "\x{224e}",
            "HumpEqual;" => "\x{224f}",
            "IEcy;" => "\x{415}",
            "IJlig;" => "\x{132}",
            "IOcy;" => "\x{401}",
            "Iacute" => "\x{cd}",
            "Iacute;" => "\x{cd}",
            "Icirc" => "\x{ce}",
            "Icirc;" => "\x{ce}",
            "Icy;" => "\x{418}",
            "Idot;" => "\x{130}",
            "Ifr;" => "\x{2111}",
            "Igrave" => "\x{cc}",
            "Igrave;" => "\x{cc}",
            "Im;" => "\x{2111}",
            "Imacr;" => "\x{12a}",
            "ImaginaryI;" => "\x{2148}",
            "Implies;" => "\x{21d2}",
            "Int;" => "\x{222c}",
            "Integral;" => "\x{222b}",
            "Intersection;" => "\x{22c2}",
            "InvisibleComma;" => "\x{2063}",
            "InvisibleTimes;" => "\x{2062}",
            "Iogon;" => "\x{12e}",
            "Iopf;" => "\x{1d540}",
            "Iota;" => "\x{399}",
            "Iscr;" => "\x{2110}",
            "Itilde;" => "\x{128}",
            "Iukcy;" => "\x{406}",
            "Iuml" => "\x{cf}",
            "Iuml;" => "\x{cf}",
            "Jcirc;" => "\x{134}",
            "Jcy;" => "\x{419}",
            "Jfr;" => "\x{1d50d}",
            "Jopf;" => "\x{1d541}",
            "Jscr;" => "\x{1d4a5}",
            "Jsercy;" => "\x{408}",
            "Jukcy;" => "\x{404}",
            "KHcy;" => "\x{425}",
            "KJcy;" => "\x{40c}",
            "Kappa;" => "\x{39a}",
            "Kcedil;" => "\x{136}",
            "Kcy;" => "\x{41a}",
            "Kfr;" => "\x{1d50e}",
            "Kopf;" => "\x{1d542}",
            "Kscr;" => "\x{1d4a6}",
            "LJcy;" => "\x{409}",
            "LT" => "<",
            "LT;" => "<",
            "Lacute;" => "\x{139}",
            "Lambda;" => "\x{39b}",
            "Lang;" => "\x{27ea}",
            "Laplacetrf;" => "\x{2112}",
            "Larr;" => "\x{219e}",
            "Lcaron;" => "\x{13d}",
            "Lcedil;" => "\x{13b}",
            "Lcy;" => "\x{41b}",
            "LeftAngleBracket;" => "\x{27e8}",
            "LeftArrow;" => "\x{2190}",
            "LeftArrowBar;" => "\x{21e4}",
            "LeftArrowRightArrow;" => "\x{21c6}",
            "LeftCeiling;" => "\x{2308}",
            "LeftDoubleBracket;" => "\x{27e6}",
            "LeftDownTeeVector;" => "\x{2961}",
            "LeftDownVector;" => "\x{21c3}",
            "LeftDownVectorBar;" => "\x{2959}",
            "LeftFloor;" => "\x{230a}",
            "LeftRightArrow;" => "\x{2194}",
            "LeftRightVector;" => "\x{294e}",
            "LeftTee;" => "\x{22a3}",
            "LeftTeeArrow;" => "\x{21a4}",
            "LeftTeeVector;" => "\x{295a}",
            "LeftTriangle;" => "\x{22b2}",
            "LeftTriangleBar;" => "\x{29cf}",
            "LeftTriangleEqual;" => "\x{22b4}",
            "LeftUpDownVector;" => "\x{2951}",
            "LeftUpTeeVector;" => "\x{2960}",
            "LeftUpVector;" => "\x{21bf}",
            "LeftUpVectorBar;" => "\x{2958}",
            "LeftVector;" => "\x{21bc}",
            "LeftVectorBar;" => "\x{2952}",
            "Leftarrow;" => "\x{21d0}",
            "Leftrightarrow;" => "\x{21d4}",
            "LessEqualGreater;" => "\x{22da}",
            "LessFullEqual;" => "\x{2266}",
            "LessGreater;" => "\x{2276}",
            "LessLess;" => "\x{2aa1}",
            "LessSlantEqual;" => "\x{2a7d}",
            "LessTilde;" => "\x{2272}",
            "Lfr;" => "\x{1d50f}",
            "Ll;" => "\x{22d8}",
            "Lleftarrow;" => "\x{21da}",
            "Lmidot;" => "\x{13f}",
            "LongLeftArrow;" => "\x{27f5}",
            "LongLeftRightArrow;" => "\x{27f7}",
            "LongRightArrow;" => "\x{27f6}",
            "Longleftarrow;" => "\x{27f8}",
            "Longleftrightarrow;" => "\x{27fa}",
            "Longrightarrow;" => "\x{27f9}",
            "Lopf;" => "\x{1d543}",
            "LowerLeftArrow;" => "\x{2199}",
            "LowerRightArrow;" => "\x{2198}",
            "Lscr;" => "\x{2112}",
            "Lsh;" => "\x{21b0}",
            "Lstrok;" => "\x{141}",
            "Lt;" => "\x{226a}",
            "Map;" => "\x{2905}",
            "Mcy;" => "\x{41c}",
            "MediumSpace;" => "\x{205f}",
            "Mellintrf;" => "\x{2133}",
            "Mfr;" => "\x{1d510}",
            "MinusPlus;" => "\x{2213}",
            "Mopf;" => "\x{1d544}",
            "Mscr;" => "\x{2133}",
            "Mu;" => "\x{39c}",
            "NJcy;" => "\x{40a}",
            "Nacute;" => "\x{143}",
            "Ncaron;" => "\x{147}",
            "Ncedil;" => "\x{145}",
            "Ncy;" => "\x{41d}",
            "NegativeMediumSpace;" => "\x{200b}",
            "NegativeThickSpace;" => "\x{200b}",
            "NegativeThinSpace;" => "\x{200b}",
            "NegativeVeryThinSpace;" => "\x{200b}",
            "NestedGreaterGreater;" => "\x{226b}",
            "NestedLessLess;" => "\x{226a}",
            "NewLine;" => "\n",
            "Nfr;" => "\x{1d511}",
            "NoBreak;" => "\x{2060}",
            "NonBreakingSpace;" => "\x{a0}",
            "Nopf;" => "\x{2115}",
            "Not;" => "\x{2aec}",
            "NotCongruent;" => "\x{2262}",
            "NotCupCap;" => "\x{226d}",
            "NotDoubleVerticalBar;" => "\x{2226}",
            "NotElement;" => "\x{2209}",
            "NotEqual;" => "\x{2260}",
            "NotEqualTilde;" => "\x{2242}\x{338}",
            "NotExists;" => "\x{2204}",
            "NotGreater;" => "\x{226f}",
            "NotGreaterEqual;" => "\x{2271}",
            "NotGreaterFullEqual;" => "\x{2267}\x{338}",
            "NotGreaterGreater;" => "\x{226b}\x{338}",
            "NotGreaterLess;" => "\x{2279}",
            "NotGreaterSlantEqual;" => "\x{2a7e}\x{338}",
            "NotGreaterTilde;" => "\x{2275}",
            "NotHumpDownHump;" => "\x{224e}\x{338}",
            "NotHumpEqual;" => "\x{224f}\x{338}",
            "NotLeftTriangle;" => "\x{22ea}",
            "NotLeftTriangleBar;" => "\x{29cf}\x{338}",
            "NotLeftTriangleEqual;" => "\x{22ec}",
            "NotLess;" => "\x{226e}",
            "NotLessEqual;" => "\x{2270}",
            "NotLessGreater;" => "\x{2278}",
            "NotLessLess;" => "\x{226a}\x{338}",
            "NotLessSlantEqual;" => "\x{2a7d}\x{338}",
            "NotLessTilde;" => "\x{2274}",
            "NotNestedGreaterGreater;" => "\x{2aa2}\x{338}",
            "NotNestedLessLess;" => "\x{2aa1}\x{338}",
            "NotPrecedes;" => "\x{2280}",
            "NotPrecedesEqual;" => "\x{2aaf}\x{338}",
            "NotPrecedesSlantEqual;" => "\x{22e0}",
            "NotReverseElement;" => "\x{220c}",
            "NotRightTriangle;" => "\x{22eb}",
            "NotRightTriangleBar;" => "\x{29d0}\x{338}",
            "NotRightTriangleEqual;" => "\x{22ed}",
            "NotSquareSubset;" => "\x{228f}\x{338}",
            "NotSquareSubsetEqual;" => "\x{22e2}",
            "NotSquareSuperset;" => "\x{2290}\x{338}",
            "NotSquareSupersetEqual;" => "\x{22e3}",
            "NotSubset;" => "\x{2282}\x{20d2}",
            "NotSubsetEqual;" => "\x{2288}",
            "NotSucceeds;" => "\x{2281}",
            "NotSucceedsEqual;" => "\x{2ab0}\x{338}",
            "NotSucceedsSlantEqual;" => "\x{22e1}",
            "NotSucceedsTilde;" => "\x{227f}\x{338}",
            "NotSuperset;" => "\x{2283}\x{20d2}",
            "NotSupersetEqual;" => "\x{2289}",
            "NotTilde;" => "\x{2241}",
            "NotTildeEqual;" => "\x{2244}",
            "NotTildeFullEqual;" => "\x{2247}",
            "NotTildeTilde;" => "\x{2249}",
            "NotVerticalBar;" => "\x{2224}",
            "Nscr;" => "\x{1d4a9}",
            "Ntilde" => "\x{d1}",
            "Ntilde;" => "\x{d1}",
            "Nu;" => "\x{39d}",
            "OElig;" => "\x{152}",
            "Oacute" => "\x{d3}",
            "Oacute;" => "\x{d3}",
            "Ocirc" => "\x{d4}",
            "Ocirc;" => "\x{d4}",
            "Ocy;" => "\x{41e}",
            "Odblac;" => "\x{150}",
            "Ofr;" => "\x{1d512}",
            "Ograve" => "\x{d2}",
            "Ograve;" => "\x{d2}",
            "Omacr;" => "\x{14c}",
            "Omega;" => "\x{3a9}",
            "Omicron;" => "\x{39f}",
            "Oopf;" => "\x{1d546}",
            "OpenCurlyDoubleQuote;" => "\x{201c}",
            "OpenCurlyQuote;" => "\x{2018}",
            "Or;" => "\x{2a54}",
            "Oscr;" => "\x{1d4aa}",
            "Oslash" => "\x{d8}",
            "Oslash;" => "\x{d8}",
            "Otilde" => "\x{d5}",
            "Otilde;" => "\x{d5}",
            "Otimes;" => "\x{2a37}",
            "Ouml" => "\x{d6}",
            "Ouml;" => "\x{d6}",
            "OverBar;" => "\x{203e}",
            "OverBrace;" => "\x{23de}",
            "OverBracket;" => "\x{23b4}",
            "OverParenthesis;" => "\x{23dc}",
            "PartialD;" => "\x{2202}",
            "Pcy;" => "\x{41f}",
            "Pfr;" => "\x{1d513}",
            "Phi;" => "\x{3a6}",
            "Pi;" => "\x{3a0}",
            "PlusMinus;" => "\x{b1}",
            "Poincareplane;" => "\x{210c}",
            "Popf;" => "\x{2119}",
            "Pr;" => "\x{2abb}",
            "Precedes;" => "\x{227a}",
            "PrecedesEqual;" => "\x{2aaf}",
            "PrecedesSlantEqual;" => "\x{227c}",
            "PrecedesTilde;" => "\x{227e}",
            "Prime;" => "\x{2033}",
            "Product;" => "\x{220f}",
            "Proportion;" => "\x{2237}",
            "Proportional;" => "\x{221d}",
            "Pscr;" => "\x{1d4ab}",
            "Psi;" => "\x{3a8}",
            "QUOT" => "\"",
            "QUOT;" => "\"",
            "Qfr;" => "\x{1d514}",
            "Qopf;" => "\x{211a}",
            "Qscr;" => "\x{1d4ac}",
            "RBarr;" => "\x{2910}",
            "REG" => "\x{ae}",
            "REG;" => "\x{ae}",
            "Racute;" => "\x{154}",
            "Rang;" => "\x{27eb}",
            "Rarr;" => "\x{21a0}",
            "Rarrtl;" => "\x{2916}",
            "Rcaron;" => "\x{158}",
            "Rcedil;" => "\x{156}",
            "Rcy;" => "\x{420}",
            "Re;" => "\x{211c}",
            "ReverseElement;" => "\x{220b}",
            "ReverseEquilibrium;" => "\x{21cb}",
            "ReverseUpEquilibrium;" => "\x{296f}",
            "Rfr;" => "\x{211c}",
            "Rho;" => "\x{3a1}",
            "RightAngleBracket;" => "\x{27e9}",
            "RightArrow;" => "\x{2192}",
            "RightArrowBar;" => "\x{21e5}",
            "RightArrowLeftArrow;" => "\x{21c4}",
            "RightCeiling;" => "\x{2309}",
            "RightDoubleBracket;" => "\x{27e7}",
            "RightDownTeeVector;" => "\x{295d}",
            "RightDownVector;" => "\x{21c2}",
            "RightDownVectorBar;" => "\x{2955}",
            "RightFloor;" => "\x{230b}",
            "RightTee;" => "\x{22a2}",
            "RightTeeArrow;" => "\x{21a6}",
            "RightTeeVector;" => "\x{295b}",
            "RightTriangle;" => "\x{22b3}",
            "RightTriangleBar;" => "\x{29d0}",
            "RightTriangleEqual;" => "\x{22b5}",
            "RightUpDownVector;" => "\x{294f}",
            "RightUpTeeVector;" => "\x{295c}",
            "RightUpVector;" => "\x{21be}",
            "RightUpVectorBar;" => "\x{2954}",
            "RightVector;" => "\x{21c0}",
            "RightVectorBar;" => "\x{2953}",
            "Rightarrow;" => "\x{21d2}",
            "Ropf;" => "\x{211d}",
            "RoundImplies;" => "\x{2970}",
            "Rrightarrow;" => "\x{21db}",
            "Rscr;" => "\x{211b}",
            "Rsh;" => "\x{21b1}",
            "RuleDelayed;" => "\x{29f4}",
            "SHCHcy;" => "\x{429}",
            "SHcy;" => "\x{428}",
            "SOFTcy;" => "\x{42c}",
            "Sacute;" => "\x{15a}",
            "Sc;" => "\x{2abc}",
            "Scaron;" => "\x{160}",
            "Scedil;" => "\x{15e}",
            "Scirc;" => "\x{15c}",
            "Scy;" => "\x{421}",
            "Sfr;" => "\x{1d516}",
            "ShortDownArrow;" => "\x{2193}",
            "ShortLeftArrow;" => "\x{2190}",
            "ShortRightArrow;" => "\x{2192}",
            "ShortUpArrow;" => "\x{2191}",
            "Sigma;" => "\x{3a3}",
            "SmallCircle;" => "\x{2218}",
            "Sopf;" => "\x{1d54a}",
            "Sqrt;" => "\x{221a}",
            "Square;" => "\x{25a1}",
            "SquareIntersection;" => "\x{2293}",
            "SquareSubset;" => "\x{228f}",
            "SquareSubsetEqual;" => "\x{2291}",
            "SquareSuperset;" => "\x{2290}",
            "SquareSupersetEqual;" => "\x{2292}",
            "SquareUnion;" => "\x{2294}",
            "Sscr;" => "\x{1d4ae}",
            "Star;" => "\x{22c6}",
            "Sub;" => "\x{22d0}",
            "Subset;" => "\x{22d0}",
            "SubsetEqual;" => "\x{2286}",
            "Succeeds;" => "\x{227b}",
            "SucceedsEqual;" => "\x{2ab0}",
            "SucceedsSlantEqual;" => "\x{227d}",
            "SucceedsTilde;" => "\x{227f}",
            "SuchThat;" => "\x{220b}",
            "Sum;" => "\x{2211}",
            "Sup;" => "\x{22d1}",
            "Superset;" => "\x{2283}",
            "SupersetEqual;" => "\x{2287}",
            "Supset;" => "\x{22d1}",
            "THORN" => "\x{de}",
            "THORN;" => "\x{de}",
            "TRADE;" => "\x{2122}",
            "TSHcy;" => "\x{40b}",
            "TScy;" => "\x{426}",
            "Tab;" => "\t",
            "Tau;" => "\x{3a4}",
            "Tcaron;" => "\x{164}",
            "Tcedil;" => "\x{162}",
            "Tcy;" => "\x{422}",
            "Tfr;" => "\x{1d517}",
            "Therefore;" => "\x{2234}",
            "Theta;" => "\x{398}",
            "ThickSpace;" => "\x{205f}\x{200a}",
            "ThinSpace;" => "\x{2009}",
            "Tilde;" => "\x{223c}",
            "TildeEqual;" => "\x{2243}",
            "TildeFullEqual;" => "\x{2245}",
            "TildeTilde;" => "\x{2248}",
            "Topf;" => "\x{1d54b}",
            "TripleDot;" => "\x{20db}",
            "Tscr;" => "\x{1d4af}",
            "Tstrok;" => "\x{166}",
            "Uacute" => "\x{da}",
            "Uacute;" => "\x{da}",
            "Uarr;" => "\x{219f}",
            "Uarrocir;" => "\x{2949}",
            "Ubrcy;" => "\x{40e}",
            "Ubreve;" => "\x{16c}",
            "Ucirc" => "\x{db}",
            "Ucirc;" => "\x{db}",
            "Ucy;" => "\x{423}",
            "Udblac;" => "\x{170}",
            "Ufr;" => "\x{1d518}",
            "Ugrave" => "\x{d9}",
            "Ugrave;" => "\x{d9}",
            "Umacr;" => "\x{16a}",
            "UnderBar;" => "_",
            "UnderBrace;" => "\x{23df}",
            "UnderBracket;" => "\x{23b5}",
            "UnderParenthesis;" => "\x{23dd}",
            "Union;" => "\x{22c3}",
            "UnionPlus;" => "\x{228e}",
            "Uogon;" => "\x{172}",
            "Uopf;" => "\x{1d54c}",
            "UpArrow;" => "\x{2191}",
            "UpArrowBar;" => "\x{2912}",
            "UpArrowDownArrow;" => "\x{21c5}",
            "UpDownArrow;" => "\x{2195}",
            "UpEquilibrium;" => "\x{296e}",
            "UpTee;" => "\x{22a5}",
            "UpTeeArrow;" => "\x{21a5}",
            "Uparrow;" => "\x{21d1}",
            "Updownarrow;" => "\x{21d5}",
            "UpperLeftArrow;" => "\x{2196}",
            "UpperRightArrow;" => "\x{2197}",
            "Upsi;" => "\x{3d2}",
            "Upsilon;" => "\x{3a5}",
            "Uring;" => "\x{16e}",
            "Uscr;" => "\x{1d4b0}",
            "Utilde;" => "\x{168}",
            "Uuml" => "\x{dc}",
            "Uuml;" => "\x{dc}",
            "VDash;" => "\x{22ab}",
            "Vbar;" => "\x{2aeb}",
            "Vcy;" => "\x{412}",
            "Vdash;" => "\x{22a9}",
            "Vdashl;" => "\x{2ae6}",
            "Vee;" => "\x{22c1}",
            "Verbar;" => "\x{2016}",
            "Vert;" => "\x{2016}",
            "VerticalBar;" => "\x{2223}",
            "VerticalLine;" => "|",
            "VerticalSeparator;" => "\x{2758}",
            "VerticalTilde;" => "\x{2240}",
            "VeryThinSpace;" => "\x{200a}",
            "Vfr;" => "\x{1d519}",
            "Vopf;" => "\x{1d54d}",
            "Vscr;" => "\x{1d4b1}",
            "Vvdash;" => "\x{22aa}",
            "Wcirc;" => "\x{174}",
            "Wedge;" => "\x{22c0}",
            "Wfr;" => "\x{1d51a}",
            "Wopf;" => "\x{1d54e}",
            "Wscr;" => "\x{1d4b2}",
            "Xfr;" => "\x{1d51b}",
            "Xi;" => "\x{39e}",
            "Xopf;" => "\x{1d54f}",
            "Xscr;" => "\x{1d4b3}",
            "YAcy;" => "\x{42f}",
            "YIcy;" => "\x{407}",
            "YUcy;" => "\x{42e}",
            "Yacute" => "\x{dd}",
            "Yacute;" => "\x{dd}",
            "Ycirc;" => "\x{176}",
            "Ycy;" => "\x{42b}",
            "Yfr;" => "\x{1d51c}",
            "Yopf;" => "\x{1d550}",
            "Yscr;" => "\x{1d4b4}",
            "Yuml;" => "\x{178}",
            "ZHcy;" => "\x{416}",
            "Zacute;" => "\x{179}",
            "Zcaron;" => "\x{17d}",
            "Zcy;" => "\x{417}",
            "Zdot;" => "\x{17b}",
            "ZeroWidthSpace;" => "\x{200b}",
            "Zeta;" => "\x{396}",
            "Zfr;" => "\x{2128}",
            "Zopf;" => "\x{2124}",
            "Zscr;" => "\x{1d4b5}",
            "aacute" => "\x{e1}",
            "aacute;" => "\x{e1}",
            "abreve;" => "\x{103}",
            "ac;" => "\x{223e}",
            "acE;" => "\x{223e}\x{333}",
            "acd;" => "\x{223f}",
            "acirc" => "\x{e2}",
            "acirc;" => "\x{e2}",
            "acute" => "\x{b4}",
            "acute;" => "\x{b4}",
            "acy;" => "\x{430}",
            "aelig" => "\x{e6}",
            "aelig;" => "\x{e6}",
            "af;" => "\x{2061}",
            "afr;" => "\x{1d51e}",
            "agrave" => "\x{e0}",
            "agrave;" => "\x{e0}",
            "alefsym;" => "\x{2135}",
            "aleph;" => "\x{2135}",
            "alpha;" => "\x{3b1}",
            "amacr;" => "\x{101}",
            "amalg;" => "\x{2a3f}",
            "amp" => "&",
            "amp;" => "&",
            "and;" => "\x{2227}",
            "andand;" => "\x{2a55}",
            "andd;" => "\x{2a5c}",
            "andslope;" => "\x{2a58}",
            "andv;" => "\x{2a5a}",
            "ang;" => "\x{2220}",
            "ange;" => "\x{29a4}",
            "angle;" => "\x{2220}",
            "angmsd;" => "\x{2221}",
            "angmsdaa;" => "\x{29a8}",
            "angmsdab;" => "\x{29a9}",
            "angmsdac;" => "\x{29aa}",
            "angmsdad;" => "\x{29ab}",
            "angmsdae;" => "\x{29ac}",
            "angmsdaf;" => "\x{29ad}",
            "angmsdag;" => "\x{29ae}",
            "angmsdah;" => "\x{29af}",
            "angrt;" => "\x{221f}",
            "angrtvb;" => "\x{22be}",
            "angrtvbd;" => "\x{299d}",
            "angsph;" => "\x{2222}",
            "angst;" => "\x{c5}",
            "angzarr;" => "\x{237c}",
            "aogon;" => "\x{105}",
            "aopf;" => "\x{1d552}",
            "ap;" => "\x{2248}",
            "apE;" => "\x{2a70}",
            "apacir;" => "\x{2a6f}",
            "ape;" => "\x{224a}",
            "apid;" => "\x{224b}",
            "apos;" => "'",
            "approx;" => "\x{2248}",
            "approxeq;" => "\x{224a}",
            "aring" => "\x{e5}",
            "aring;" => "\x{e5}",
            "ascr;" => "\x{1d4b6}",
            "ast;" => "*",
            "asymp;" => "\x{2248}",
            "asympeq;" => "\x{224d}",
            "atilde" => "\x{e3}",
            "atilde;" => "\x{e3}",
            "auml" => "\x{e4}",
            "auml;" => "\x{e4}",
            "awconint;" => "\x{2233}",
            "awint;" => "\x{2a11}",
            "bNot;" => "\x{2aed}",
            "backcong;" => "\x{224c}",
            "backepsilon;" => "\x{3f6}",
            "backprime;" => "\x{2035}",
            "backsim;" => "\x{223d}",
            "backsimeq;" => "\x{22cd}",
            "barvee;" => "\x{22bd}",
            "barwed;" => "\x{2305}",
            "barwedge;" => "\x{2305}",
            "bbrk;" => "\x{23b5}",
            "bbrktbrk;" => "\x{23b6}",
            "bcong;" => "\x{224c}",
            "bcy;" => "\x{431}",
            "bdquo;" => "\x{201e}",
            "becaus;" => "\x{2235}",
            "because;" => "\x{2235}",
            "bemptyv;" => "\x{29b0}",
            "bepsi;" => "\x{3f6}",
            "bernou;" => "\x{212c}",
            "beta;" => "\x{3b2}",
            "beth;" => "\x{2136}",
            "between;" => "\x{226c}",
            "bfr;" => "\x{1d51f}",
            "bigcap;" => "\x{22c2}",
            "bigcirc;" => "\x{25ef}",
            "bigcup;" => "\x{22c3}",
            "bigodot;" => "\x{2a00}",
            "bigoplus;" => "\x{2a01}",
            "bigotimes;" => "\x{2a02}",
            "bigsqcup;" => "\x{2a06}",
            "bigstar;" => "\x{2605}",
            "bigtriangledown;" => "\x{25bd}",
            "bigtriangleup;" => "\x{25b3}",
            "biguplus;" => "\x{2a04}",
            "bigvee;" => "\x{22c1}",
            "bigwedge;" => "\x{22c0}",
            "bkarow;" => "\x{290d}",
            "blacklozenge;" => "\x{29eb}",
            "blacksquare;" => "\x{25aa}",
            "blacktriangle;" => "\x{25b4}",
            "blacktriangledown;" => "\x{25be}",
            "blacktriangleleft;" => "\x{25c2}",
            "blacktriangleright;" => "\x{25b8}",
            "blank;" => "\x{2423}",
            "blk12;" => "\x{2592}",
            "blk14;" => "\x{2591}",
            "blk34;" => "\x{2593}",
            "block;" => "\x{2588}",
            "bne;" => "=\x{20e5}",
            "bnequiv;" => "\x{2261}\x{20e5}",
            "bnot;" => "\x{2310}",
            "bopf;" => "\x{1d553}",
            "bot;" => "\x{22a5}",
            "bottom;" => "\x{22a5}",
            "bowtie;" => "\x{22c8}",
            "boxDL;" => "\x{2557}",
            "boxDR;" => "\x{2554}",
            "boxDl;" => "\x{2556}",
            "boxDr;" => "\x{2553}",
            "boxH;" => "\x{2550}",
            "boxHD;" => "\x{2566}",
            "boxHU;" => "\x{2569}",
            "boxHd;" => "\x{2564}",
            "boxHu;" => "\x{2567}",
            "boxUL;" => "\x{255d}",
            "boxUR;" => "\x{255a}",
            "boxUl;" => "\x{255c}",
            "boxUr;" => "\x{2559}",
            "boxV;" => "\x{2551}",
            "boxVH;" => "\x{256c}",
            "boxVL;" => "\x{2563}",
            "boxVR;" => "\x{2560}",
            "boxVh;" => "\x{256b}",
            "boxVl;" => "\x{2562}",
            "boxVr;" => "\x{255f}",
            "boxbox;" => "\x{29c9}",
            "boxdL;" => "\x{2555}",
            "boxdR;" => "\x{2552}",
            "boxdl;" => "\x{2510}",
            "boxdr;" => "\x{250c}",
            "boxh;" => "\x{2500}",
            "boxhD;" => "\x{2565}",
            "boxhU;" => "\x{2568}",
            "boxhd;" => "\x{252c}",
            "boxhu;" => "\x{2534}",
            "boxminus;" => "\x{229f}",
            "boxplus;" => "\x{229e}",
            "boxtimes;" => "\x{22a0}",
            "boxuL;" => "\x{255b}",
            "boxuR;" => "\x{2558}",
            "boxul;" => "\x{2518}",
            "boxur;" => "\x{2514}",
            "boxv;" => "\x{2502}",
            "boxvH;" => "\x{256a}",
            "boxvL;" => "\x{2561}",
            "boxvR;" => "\x{255e}",
            "boxvh;" => "\x{253c}",
            "boxvl;" => "\x{2524}",
            "boxvr;" => "\x{251c}",
            "bprime;" => "\x{2035}",
            "breve;" => "\x{2d8}",
            "brvbar" => "\x{a6}",
            "brvbar;" => "\x{a6}",
            "bscr;" => "\x{1d4b7}",
            "bsemi;" => "\x{204f}",
            "bsim;" => "\x{223d}",
            "bsime;" => "\x{22cd}",
            "bsol;" => "\\",
            "bsolb;" => "\x{29c5}",
            "bsolhsub;" => "\x{27c8}",
            "bull;" => "\x{2022}",
            "bullet;" => "\x{2022}",
            "bump;" => "\x{224e}",
            "bumpE;" => "\x{2aae}",
            "bumpe;" => "\x{224f}",
            "bumpeq;" => "\x{224f}",
            "cacute;" => "\x{107}",
            "cap;" => "\x{2229}",
            "capand;" => "\x{2a44}",
            "capbrcup;" => "\x{2a49}",
            "capcap;" => "\x{2a4b}",
            "capcup;" => "\x{2a47}",
            "capdot;" => "\x{2a40}",
            "caps;" => "\x{2229}\x{fe00}",
            "caret;" => "\x{2041}",
            "caron;" => "\x{2c7}",
            "ccaps;" => "\x{2a4d}",
            "ccaron;" => "\x{10d}",
            "ccedil" => "\x{e7}",
            "ccedil;" => "\x{e7}",
            "ccirc;" => "\x{109}",
            "ccups;" => "\x{2a4c}",
            "ccupssm;" => "\x{2a50}",
            "cdot;" => "\x{10b}",
            "cedil" => "\x{b8}",
            "cedil;" => "\x{b8}",
            "cemptyv;" => "\x{29b2}",
            "cent" => "\x{a2}",
            "cent;" => "\x{a2}",
            "centerdot;" => "\x{b7}",
            "cfr;" => "\x{1d520}",
            "chcy;" => "\x{447}",
            "check;" => "\x{2713}",
            "checkmark;" => "\x{2713}",
            "chi;" => "\x{3c7}",
            "cir;" => "\x{25cb}",
            "cirE;" => "\x{29c3}",
            "circ;" => "\x{2c6}",
            "circeq;" => "\x{2257}",
            "circlearrowleft;" => "\x{21ba}",
            "circlearrowright;" => "\x{21bb}",
            "circledR;" => "\x{ae}",
            "circledS;" => "\x{24c8}",
            "circledast;" => "\x{229b}",
            "circledcirc;" => "\x{229a}",
            "circleddash;" => "\x{229d}",
            "cire;" => "\x{2257}",
            "cirfnint;" => "\x{2a10}",
            "cirmid;" => "\x{2aef}",
            "cirscir;" => "\x{29c2}",
            "clubs;" => "\x{2663}",
            "clubsuit;" => "\x{2663}",
            "colon;" => ":",
            "colone;" => "\x{2254}",
            "coloneq;" => "\x{2254}",
            "comma;" => ",",
            "commat;" => "\@",
            "comp;" => "\x{2201}",
            "compfn;" => "\x{2218}",
            "complement;" => "\x{2201}",
            "complexes;" => "\x{2102}",
            "cong;" => "\x{2245}",
            "congdot;" => "\x{2a6d}",
            "conint;" => "\x{222e}",
            "copf;" => "\x{1d554}",
            "coprod;" => "\x{2210}",
            "copy" => "\x{a9}",
            "copy;" => "\x{a9}",
            "copysr;" => "\x{2117}",
            "crarr;" => "\x{21b5}",
            "cross;" => "\x{2717}",
            "cscr;" => "\x{1d4b8}",
            "csub;" => "\x{2acf}",
            "csube;" => "\x{2ad1}",
            "csup;" => "\x{2ad0}",
            "csupe;" => "\x{2ad2}",
            "ctdot;" => "\x{22ef}",
            "cudarrl;" => "\x{2938}",
            "cudarrr;" => "\x{2935}",
            "cuepr;" => "\x{22de}",
            "cuesc;" => "\x{22df}",
            "cularr;" => "\x{21b6}",
            "cularrp;" => "\x{293d}",
            "cup;" => "\x{222a}",
            "cupbrcap;" => "\x{2a48}",
            "cupcap;" => "\x{2a46}",
            "cupcup;" => "\x{2a4a}",
            "cupdot;" => "\x{228d}",
            "cupor;" => "\x{2a45}",
            "cups;" => "\x{222a}\x{fe00}",
            "curarr;" => "\x{21b7}",
            "curarrm;" => "\x{293c}",
            "curlyeqprec;" => "\x{22de}",
            "curlyeqsucc;" => "\x{22df}",
            "curlyvee;" => "\x{22ce}",
            "curlywedge;" => "\x{22cf}",
            "curren" => "\x{a4}",
            "curren;" => "\x{a4}",
            "curvearrowleft;" => "\x{21b6}",
            "curvearrowright;" => "\x{21b7}",
            "cuvee;" => "\x{22ce}",
            "cuwed;" => "\x{22cf}",
            "cwconint;" => "\x{2232}",
            "cwint;" => "\x{2231}",
            "cylcty;" => "\x{232d}",
            "dArr;" => "\x{21d3}",
            "dHar;" => "\x{2965}",
            "dagger;" => "\x{2020}",
            "daleth;" => "\x{2138}",
            "darr;" => "\x{2193}",
            "dash;" => "\x{2010}",
            "dashv;" => "\x{22a3}",
            "dbkarow;" => "\x{290f}",
            "dblac;" => "\x{2dd}",
            "dcaron;" => "\x{10f}",
            "dcy;" => "\x{434}",
            "dd;" => "\x{2146}",
            "ddagger;" => "\x{2021}",
            "ddarr;" => "\x{21ca}",
            "ddotseq;" => "\x{2a77}",
            "deg" => "\x{b0}",
            "deg;" => "\x{b0}",
            "delta;" => "\x{3b4}",
            "demptyv;" => "\x{29b1}",
            "dfisht;" => "\x{297f}",
            "dfr;" => "\x{1d521}",
            "dharl;" => "\x{21c3}",
            "dharr;" => "\x{21c2}",
            "diam;" => "\x{22c4}",
            "diamond;" => "\x{22c4}",
            "diamondsuit;" => "\x{2666}",
            "diams;" => "\x{2666}",
            "die;" => "\x{a8}",
            "digamma;" => "\x{3dd}",
            "disin;" => "\x{22f2}",
            "div;" => "\x{f7}",
            "divide" => "\x{f7}",
            "divide;" => "\x{f7}",
            "divideontimes;" => "\x{22c7}",
            "divonx;" => "\x{22c7}",
            "djcy;" => "\x{452}",
            "dlcorn;" => "\x{231e}",
            "dlcrop;" => "\x{230d}",
            "dollar;" => "\$",
            "dopf;" => "\x{1d555}",
            "dot;" => "\x{2d9}",
            "doteq;" => "\x{2250}",
            "doteqdot;" => "\x{2251}",
            "dotminus;" => "\x{2238}",
            "dotplus;" => "\x{2214}",
            "dotsquare;" => "\x{22a1}",
            "doublebarwedge;" => "\x{2306}",
            "downarrow;" => "\x{2193}",
            "downdownarrows;" => "\x{21ca}",
            "downharpoonleft;" => "\x{21c3}",
            "downharpoonright;" => "\x{21c2}",
            "drbkarow;" => "\x{2910}",
            "drcorn;" => "\x{231f}",
            "drcrop;" => "\x{230c}",
            "dscr;" => "\x{1d4b9}",
            "dscy;" => "\x{455}",
            "dsol;" => "\x{29f6}",
            "dstrok;" => "\x{111}",
            "dtdot;" => "\x{22f1}",
            "dtri;" => "\x{25bf}",
            "dtrif;" => "\x{25be}",
            "duarr;" => "\x{21f5}",
            "duhar;" => "\x{296f}",
            "dwangle;" => "\x{29a6}",
            "dzcy;" => "\x{45f}",
            "dzigrarr;" => "\x{27ff}",
            "eDDot;" => "\x{2a77}",
            "eDot;" => "\x{2251}",
            "eacute" => "\x{e9}",
            "eacute;" => "\x{e9}",
            "easter;" => "\x{2a6e}",
            "ecaron;" => "\x{11b}",
            "ecir;" => "\x{2256}",
            "ecirc" => "\x{ea}",
            "ecirc;" => "\x{ea}",
            "ecolon;" => "\x{2255}",
            "ecy;" => "\x{44d}",
            "edot;" => "\x{117}",
            "ee;" => "\x{2147}",
            "efDot;" => "\x{2252}",
            "efr;" => "\x{1d522}",
            "eg;" => "\x{2a9a}",
            "egrave" => "\x{e8}",
            "egrave;" => "\x{e8}",
            "egs;" => "\x{2a96}",
            "egsdot;" => "\x{2a98}",
            "el;" => "\x{2a99}",
            "elinters;" => "\x{23e7}",
            "ell;" => "\x{2113}",
            "els;" => "\x{2a95}",
            "elsdot;" => "\x{2a97}",
            "emacr;" => "\x{113}",
            "empty;" => "\x{2205}",
            "emptyset;" => "\x{2205}",
            "emptyv;" => "\x{2205}",
            "emsp13;" => "\x{2004}",
            "emsp14;" => "\x{2005}",
            "emsp;" => "\x{2003}",
            "eng;" => "\x{14b}",
            "ensp;" => "\x{2002}",
            "eogon;" => "\x{119}",
            "eopf;" => "\x{1d556}",
            "epar;" => "\x{22d5}",
            "eparsl;" => "\x{29e3}",
            "eplus;" => "\x{2a71}",
            "epsi;" => "\x{3b5}",
            "epsilon;" => "\x{3b5}",
            "epsiv;" => "\x{3f5}",
            "eqcirc;" => "\x{2256}",
            "eqcolon;" => "\x{2255}",
            "eqsim;" => "\x{2242}",
            "eqslantgtr;" => "\x{2a96}",
            "eqslantless;" => "\x{2a95}",
            "equals;" => "=",
            "equest;" => "\x{225f}",
            "equiv;" => "\x{2261}",
            "equivDD;" => "\x{2a78}",
            "eqvparsl;" => "\x{29e5}",
            "erDot;" => "\x{2253}",
            "erarr;" => "\x{2971}",
            "escr;" => "\x{212f}",
            "esdot;" => "\x{2250}",
            "esim;" => "\x{2242}",
            "eta;" => "\x{3b7}",
            "eth" => "\x{f0}",
            "eth;" => "\x{f0}",
            "euml" => "\x{eb}",
            "euml;" => "\x{eb}",
            "euro;" => "\x{20ac}",
            "excl;" => "!",
            "exist;" => "\x{2203}",
            "expectation;" => "\x{2130}",
            "exponentiale;" => "\x{2147}",
            "fallingdotseq;" => "\x{2252}",
            "fcy;" => "\x{444}",
            "female;" => "\x{2640}",
            "ffilig;" => "\x{fb03}",
            "fflig;" => "\x{fb00}",
            "ffllig;" => "\x{fb04}",
            "ffr;" => "\x{1d523}",
            "filig;" => "\x{fb01}",
            "fjlig;" => "fj",
            "flat;" => "\x{266d}",
            "fllig;" => "\x{fb02}",
            "fltns;" => "\x{25b1}",
            "fnof;" => "\x{192}",
            "fopf;" => "\x{1d557}",
            "forall;" => "\x{2200}",
            "fork;" => "\x{22d4}",
            "forkv;" => "\x{2ad9}",
            "fpartint;" => "\x{2a0d}",
            "frac12" => "\x{bd}",
            "frac12;" => "\x{bd}",
            "frac13;" => "\x{2153}",
            "frac14" => "\x{bc}",
            "frac14;" => "\x{bc}",
            "frac15;" => "\x{2155}",
            "frac16;" => "\x{2159}",
            "frac18;" => "\x{215b}",
            "frac23;" => "\x{2154}",
            "frac25;" => "\x{2156}",
            "frac34" => "\x{be}",
            "frac34;" => "\x{be}",
            "frac35;" => "\x{2157}",
            "frac38;" => "\x{215c}",
            "frac45;" => "\x{2158}",
            "frac56;" => "\x{215a}",
            "frac58;" => "\x{215d}",
            "frac78;" => "\x{215e}",
            "frasl;" => "\x{2044}",
            "frown;" => "\x{2322}",
            "fscr;" => "\x{1d4bb}",
            "gE;" => "\x{2267}",
            "gEl;" => "\x{2a8c}",
            "gacute;" => "\x{1f5}",
            "gamma;" => "\x{3b3}",
            "gammad;" => "\x{3dd}",
            "gap;" => "\x{2a86}",
            "gbreve;" => "\x{11f}",
            "gcirc;" => "\x{11d}",
            "gcy;" => "\x{433}",
            "gdot;" => "\x{121}",
            "ge;" => "\x{2265}",
            "gel;" => "\x{22db}",
            "geq;" => "\x{2265}",
            "geqq;" => "\x{2267}",
            "geqslant;" => "\x{2a7e}",
            "ges;" => "\x{2a7e}",
            "gescc;" => "\x{2aa9}",
            "gesdot;" => "\x{2a80}",
            "gesdoto;" => "\x{2a82}",
            "gesdotol;" => "\x{2a84}",
            "gesl;" => "\x{22db}\x{fe00}",
            "gesles;" => "\x{2a94}",
            "gfr;" => "\x{1d524}",
            "gg;" => "\x{226b}",
            "ggg;" => "\x{22d9}",
            "gimel;" => "\x{2137}",
            "gjcy;" => "\x{453}",
            "gl;" => "\x{2277}",
            "glE;" => "\x{2a92}",
            "gla;" => "\x{2aa5}",
            "glj;" => "\x{2aa4}",
            "gnE;" => "\x{2269}",
            "gnap;" => "\x{2a8a}",
            "gnapprox;" => "\x{2a8a}",
            "gne;" => "\x{2a88}",
            "gneq;" => "\x{2a88}",
            "gneqq;" => "\x{2269}",
            "gnsim;" => "\x{22e7}",
            "gopf;" => "\x{1d558}",
            "grave;" => "`",
            "gscr;" => "\x{210a}",
            "gsim;" => "\x{2273}",
            "gsime;" => "\x{2a8e}",
            "gsiml;" => "\x{2a90}",
            "gt" => ">",
            "gt;" => ">",
            "gtcc;" => "\x{2aa7}",
            "gtcir;" => "\x{2a7a}",
            "gtdot;" => "\x{22d7}",
            "gtlPar;" => "\x{2995}",
            "gtquest;" => "\x{2a7c}",
            "gtrapprox;" => "\x{2a86}",
            "gtrarr;" => "\x{2978}",
            "gtrdot;" => "\x{22d7}",
            "gtreqless;" => "\x{22db}",
            "gtreqqless;" => "\x{2a8c}",
            "gtrless;" => "\x{2277}",
            "gtrsim;" => "\x{2273}",
            "gvertneqq;" => "\x{2269}\x{fe00}",
            "gvnE;" => "\x{2269}\x{fe00}",
            "hArr;" => "\x{21d4}",
            "hairsp;" => "\x{200a}",
            "half;" => "\x{bd}",
            "hamilt;" => "\x{210b}",
            "hardcy;" => "\x{44a}",
            "harr;" => "\x{2194}",
            "harrcir;" => "\x{2948}",
            "harrw;" => "\x{21ad}",
            "hbar;" => "\x{210f}",
            "hcirc;" => "\x{125}",
            "hearts;" => "\x{2665}",
            "heartsuit;" => "\x{2665}",
            "hellip;" => "\x{2026}",
            "hercon;" => "\x{22b9}",
            "hfr;" => "\x{1d525}",
            "hksearow;" => "\x{2925}",
            "hkswarow;" => "\x{2926}",
            "hoarr;" => "\x{21ff}",
            "homtht;" => "\x{223b}",
            "hookleftarrow;" => "\x{21a9}",
            "hookrightarrow;" => "\x{21aa}",
            "hopf;" => "\x{1d559}",
            "horbar;" => "\x{2015}",
            "hscr;" => "\x{1d4bd}",
            "hslash;" => "\x{210f}",
            "hstrok;" => "\x{127}",
            "hybull;" => "\x{2043}",
            "hyphen;" => "\x{2010}",
            "iacute" => "\x{ed}",
            "iacute;" => "\x{ed}",
            "ic;" => "\x{2063}",
            "icirc" => "\x{ee}",
            "icirc;" => "\x{ee}",
            "icy;" => "\x{438}",
            "iecy;" => "\x{435}",
            "iexcl" => "\x{a1}",
            "iexcl;" => "\x{a1}",
            "iff;" => "\x{21d4}",
            "ifr;" => "\x{1d526}",
            "igrave" => "\x{ec}",
            "igrave;" => "\x{ec}",
            "ii;" => "\x{2148}",
            "iiiint;" => "\x{2a0c}",
            "iiint;" => "\x{222d}",
            "iinfin;" => "\x{29dc}",
            "iiota;" => "\x{2129}",
            "ijlig;" => "\x{133}",
            "imacr;" => "\x{12b}",
            "image;" => "\x{2111}",
            "imagline;" => "\x{2110}",
            "imagpart;" => "\x{2111}",
            "imath;" => "\x{131}",
            "imof;" => "\x{22b7}",
            "imped;" => "\x{1b5}",
            "in;" => "\x{2208}",
            "incare;" => "\x{2105}",
            "infin;" => "\x{221e}",
            "infintie;" => "\x{29dd}",
            "inodot;" => "\x{131}",
            "int;" => "\x{222b}",
            "intcal;" => "\x{22ba}",
            "integers;" => "\x{2124}",
            "intercal;" => "\x{22ba}",
            "intlarhk;" => "\x{2a17}",
            "intprod;" => "\x{2a3c}",
            "iocy;" => "\x{451}",
            "iogon;" => "\x{12f}",
            "iopf;" => "\x{1d55a}",
            "iota;" => "\x{3b9}",
            "iprod;" => "\x{2a3c}",
            "iquest" => "\x{bf}",
            "iquest;" => "\x{bf}",
            "iscr;" => "\x{1d4be}",
            "isin;" => "\x{2208}",
            "isinE;" => "\x{22f9}",
            "isindot;" => "\x{22f5}",
            "isins;" => "\x{22f4}",
            "isinsv;" => "\x{22f3}",
            "isinv;" => "\x{2208}",
            "it;" => "\x{2062}",
            "itilde;" => "\x{129}",
            "iukcy;" => "\x{456}",
            "iuml" => "\x{ef}",
            "iuml;" => "\x{ef}",
            "jcirc;" => "\x{135}",
            "jcy;" => "\x{439}",
            "jfr;" => "\x{1d527}",
            "jmath;" => "\x{237}",
            "jopf;" => "\x{1d55b}",
            "jscr;" => "\x{1d4bf}",
            "jsercy;" => "\x{458}",
            "jukcy;" => "\x{454}",
            "kappa;" => "\x{3ba}",
            "kappav;" => "\x{3f0}",
            "kcedil;" => "\x{137}",
            "kcy;" => "\x{43a}",
            "kfr;" => "\x{1d528}",
            "kgreen;" => "\x{138}",
            "khcy;" => "\x{445}",
            "kjcy;" => "\x{45c}",
            "kopf;" => "\x{1d55c}",
            "kscr;" => "\x{1d4c0}",
            "lAarr;" => "\x{21da}",
            "lArr;" => "\x{21d0}",
            "lAtail;" => "\x{291b}",
            "lBarr;" => "\x{290e}",
            "lE;" => "\x{2266}",
            "lEg;" => "\x{2a8b}",
            "lHar;" => "\x{2962}",
            "lacute;" => "\x{13a}",
            "laemptyv;" => "\x{29b4}",
            "lagran;" => "\x{2112}",
            "lambda;" => "\x{3bb}",
            "lang;" => "\x{27e8}",
            "langd;" => "\x{2991}",
            "langle;" => "\x{27e8}",
            "lap;" => "\x{2a85}",
            "laquo" => "\x{ab}",
            "laquo;" => "\x{ab}",
            "larr;" => "\x{2190}",
            "larrb;" => "\x{21e4}",
            "larrbfs;" => "\x{291f}",
            "larrfs;" => "\x{291d}",
            "larrhk;" => "\x{21a9}",
            "larrlp;" => "\x{21ab}",
            "larrpl;" => "\x{2939}",
            "larrsim;" => "\x{2973}",
            "larrtl;" => "\x{21a2}",
            "lat;" => "\x{2aab}",
            "latail;" => "\x{2919}",
            "late;" => "\x{2aad}",
            "lates;" => "\x{2aad}\x{fe00}",
            "lbarr;" => "\x{290c}",
            "lbbrk;" => "\x{2772}",
            "lbrace;" => "{",
            "lbrack;" => "[",
            "lbrke;" => "\x{298b}",
            "lbrksld;" => "\x{298f}",
            "lbrkslu;" => "\x{298d}",
            "lcaron;" => "\x{13e}",
            "lcedil;" => "\x{13c}",
            "lceil;" => "\x{2308}",
            "lcub;" => "{",
            "lcy;" => "\x{43b}",
            "ldca;" => "\x{2936}",
            "ldquo;" => "\x{201c}",
            "ldquor;" => "\x{201e}",
            "ldrdhar;" => "\x{2967}",
            "ldrushar;" => "\x{294b}",
            "ldsh;" => "\x{21b2}",
            "le;" => "\x{2264}",
            "leftarrow;" => "\x{2190}",
            "leftarrowtail;" => "\x{21a2}",
            "leftharpoondown;" => "\x{21bd}",
            "leftharpoonup;" => "\x{21bc}",
            "leftleftarrows;" => "\x{21c7}",
            "leftrightarrow;" => "\x{2194}",
            "leftrightarrows;" => "\x{21c6}",
            "leftrightharpoons;" => "\x{21cb}",
            "leftrightsquigarrow;" => "\x{21ad}",
            "leftthreetimes;" => "\x{22cb}",
            "leg;" => "\x{22da}",
            "leq;" => "\x{2264}",
            "leqq;" => "\x{2266}",
            "leqslant;" => "\x{2a7d}",
            "les;" => "\x{2a7d}",
            "lescc;" => "\x{2aa8}",
            "lesdot;" => "\x{2a7f}",
            "lesdoto;" => "\x{2a81}",
            "lesdotor;" => "\x{2a83}",
            "lesg;" => "\x{22da}\x{fe00}",
            "lesges;" => "\x{2a93}",
            "lessapprox;" => "\x{2a85}",
            "lessdot;" => "\x{22d6}",
            "lesseqgtr;" => "\x{22da}",
            "lesseqqgtr;" => "\x{2a8b}",
            "lessgtr;" => "\x{2276}",
            "lesssim;" => "\x{2272}",
            "lfisht;" => "\x{297c}",
            "lfloor;" => "\x{230a}",
            "lfr;" => "\x{1d529}",
            "lg;" => "\x{2276}",
            "lgE;" => "\x{2a91}",
            "lhard;" => "\x{21bd}",
            "lharu;" => "\x{21bc}",
            "lharul;" => "\x{296a}",
            "lhblk;" => "\x{2584}",
            "ljcy;" => "\x{459}",
            "ll;" => "\x{226a}",
            "llarr;" => "\x{21c7}",
            "llcorner;" => "\x{231e}",
            "llhard;" => "\x{296b}",
            "lltri;" => "\x{25fa}",
            "lmidot;" => "\x{140}",
            "lmoust;" => "\x{23b0}",
            "lmoustache;" => "\x{23b0}",
            "lnE;" => "\x{2268}",
            "lnap;" => "\x{2a89}",
            "lnapprox;" => "\x{2a89}",
            "lne;" => "\x{2a87}",
            "lneq;" => "\x{2a87}",
            "lneqq;" => "\x{2268}",
            "lnsim;" => "\x{22e6}",
            "loang;" => "\x{27ec}",
            "loarr;" => "\x{21fd}",
            "lobrk;" => "\x{27e6}",
            "longleftarrow;" => "\x{27f5}",
            "longleftrightarrow;" => "\x{27f7}",
            "longmapsto;" => "\x{27fc}",
            "longrightarrow;" => "\x{27f6}",
            "looparrowleft;" => "\x{21ab}",
            "looparrowright;" => "\x{21ac}",
            "lopar;" => "\x{2985}",
            "lopf;" => "\x{1d55d}",
            "loplus;" => "\x{2a2d}",
            "lotimes;" => "\x{2a34}",
            "lowast;" => "\x{2217}",
            "lowbar;" => "_",
            "loz;" => "\x{25ca}",
            "lozenge;" => "\x{25ca}",
            "lozf;" => "\x{29eb}",
            "lpar;" => "(",
            "lparlt;" => "\x{2993}",
            "lrarr;" => "\x{21c6}",
            "lrcorner;" => "\x{231f}",
            "lrhar;" => "\x{21cb}",
            "lrhard;" => "\x{296d}",
            "lrm;" => "\x{200e}",
            "lrtri;" => "\x{22bf}",
            "lsaquo;" => "\x{2039}",
            "lscr;" => "\x{1d4c1}",
            "lsh;" => "\x{21b0}",
            "lsim;" => "\x{2272}",
            "lsime;" => "\x{2a8d}",
            "lsimg;" => "\x{2a8f}",
            "lsqb;" => "[",
            "lsquo;" => "\x{2018}",
            "lsquor;" => "\x{201a}",
            "lstrok;" => "\x{142}",
            "lt" => "<",
            "lt;" => "<",
            "ltcc;" => "\x{2aa6}",
            "ltcir;" => "\x{2a79}",
            "ltdot;" => "\x{22d6}",
            "lthree;" => "\x{22cb}",
            "ltimes;" => "\x{22c9}",
            "ltlarr;" => "\x{2976}",
            "ltquest;" => "\x{2a7b}",
            "ltrPar;" => "\x{2996}",
            "ltri;" => "\x{25c3}",
            "ltrie;" => "\x{22b4}",
            "ltrif;" => "\x{25c2}",
            "lurdshar;" => "\x{294a}",
            "luruhar;" => "\x{2966}",
            "lvertneqq;" => "\x{2268}\x{fe00}",
            "lvnE;" => "\x{2268}\x{fe00}",
            "mDDot;" => "\x{223a}",
            "macr" => "\x{af}",
            "macr;" => "\x{af}",
            "male;" => "\x{2642}",
            "malt;" => "\x{2720}",
            "maltese;" => "\x{2720}",
            "map;" => "\x{21a6}",
            "mapsto;" => "\x{21a6}",
            "mapstodown;" => "\x{21a7}",
            "mapstoleft;" => "\x{21a4}",
            "mapstoup;" => "\x{21a5}",
            "marker;" => "\x{25ae}",
            "mcomma;" => "\x{2a29}",
            "mcy;" => "\x{43c}",
            "mdash;" => "\x{2014}",
            "measuredangle;" => "\x{2221}",
            "mfr;" => "\x{1d52a}",
            "mho;" => "\x{2127}",
            "micro" => "\x{b5}",
            "micro;" => "\x{b5}",
            "mid;" => "\x{2223}",
            "midast;" => "*",
            "midcir;" => "\x{2af0}",
            "middot" => "\x{b7}",
            "middot;" => "\x{b7}",
            "minus;" => "\x{2212}",
            "minusb;" => "\x{229f}",
            "minusd;" => "\x{2238}",
            "minusdu;" => "\x{2a2a}",
            "mlcp;" => "\x{2adb}",
            "mldr;" => "\x{2026}",
            "mnplus;" => "\x{2213}",
            "models;" => "\x{22a7}",
            "mopf;" => "\x{1d55e}",
            "mp;" => "\x{2213}",
            "mscr;" => "\x{1d4c2}",
            "mstpos;" => "\x{223e}",
            "mu;" => "\x{3bc}",
            "multimap;" => "\x{22b8}",
            "mumap;" => "\x{22b8}",
            "nGg;" => "\x{22d9}\x{338}",
            "nGt;" => "\x{226b}\x{20d2}",
            "nGtv;" => "\x{226b}\x{338}",
            "nLeftarrow;" => "\x{21cd}",
            "nLeftrightarrow;" => "\x{21ce}",
            "nLl;" => "\x{22d8}\x{338}",
            "nLt;" => "\x{226a}\x{20d2}",
            "nLtv;" => "\x{226a}\x{338}",
            "nRightarrow;" => "\x{21cf}",
            "nVDash;" => "\x{22af}",
            "nVdash;" => "\x{22ae}",
            "nabla;" => "\x{2207}",
            "nacute;" => "\x{144}",
            "nang;" => "\x{2220}\x{20d2}",
            "nap;" => "\x{2249}",
            "napE;" => "\x{2a70}\x{338}",
            "napid;" => "\x{224b}\x{338}",
            "napos;" => "\x{149}",
            "napprox;" => "\x{2249}",
            "natur;" => "\x{266e}",
            "natural;" => "\x{266e}",
            "naturals;" => "\x{2115}",
            "nbsp" => "\x{a0}",
            "nbsp;" => "\x{a0}",
            "nbump;" => "\x{224e}\x{338}",
            "nbumpe;" => "\x{224f}\x{338}",
            "ncap;" => "\x{2a43}",
            "ncaron;" => "\x{148}",
            "ncedil;" => "\x{146}",
            "ncong;" => "\x{2247}",
            "ncongdot;" => "\x{2a6d}\x{338}",
            "ncup;" => "\x{2a42}",
            "ncy;" => "\x{43d}",
            "ndash;" => "\x{2013}",
            "ne;" => "\x{2260}",
            "neArr;" => "\x{21d7}",
            "nearhk;" => "\x{2924}",
            "nearr;" => "\x{2197}",
            "nearrow;" => "\x{2197}",
            "nedot;" => "\x{2250}\x{338}",
            "nequiv;" => "\x{2262}",
            "nesear;" => "\x{2928}",
            "nesim;" => "\x{2242}\x{338}",
            "nexist;" => "\x{2204}",
            "nexists;" => "\x{2204}",
            "nfr;" => "\x{1d52b}",
            "ngE;" => "\x{2267}\x{338}",
            "nge;" => "\x{2271}",
            "ngeq;" => "\x{2271}",
            "ngeqq;" => "\x{2267}\x{338}",
            "ngeqslant;" => "\x{2a7e}\x{338}",
            "nges;" => "\x{2a7e}\x{338}",
            "ngsim;" => "\x{2275}",
            "ngt;" => "\x{226f}",
            "ngtr;" => "\x{226f}",
            "nhArr;" => "\x{21ce}",
            "nharr;" => "\x{21ae}",
            "nhpar;" => "\x{2af2}",
            "ni;" => "\x{220b}",
            "nis;" => "\x{22fc}",
            "nisd;" => "\x{22fa}",
            "niv;" => "\x{220b}",
            "njcy;" => "\x{45a}",
            "nlArr;" => "\x{21cd}",
            "nlE;" => "\x{2266}\x{338}",
            "nlarr;" => "\x{219a}",
            "nldr;" => "\x{2025}",
            "nle;" => "\x{2270}",
            "nleftarrow;" => "\x{219a}",
            "nleftrightarrow;" => "\x{21ae}",
            "nleq;" => "\x{2270}",
            "nleqq;" => "\x{2266}\x{338}",
            "nleqslant;" => "\x{2a7d}\x{338}",
            "nles;" => "\x{2a7d}\x{338}",
            "nless;" => "\x{226e}",
            "nlsim;" => "\x{2274}",
            "nlt;" => "\x{226e}",
            "nltri;" => "\x{22ea}",
            "nltrie;" => "\x{22ec}",
            "nmid;" => "\x{2224}",
            "nopf;" => "\x{1d55f}",
            "not" => "\x{ac}",
            "not;" => "\x{ac}",
            "notin;" => "\x{2209}",
            "notinE;" => "\x{22f9}\x{338}",
            "notindot;" => "\x{22f5}\x{338}",
            "notinva;" => "\x{2209}",
            "notinvb;" => "\x{22f7}",
            "notinvc;" => "\x{22f6}",
            "notni;" => "\x{220c}",
            "notniva;" => "\x{220c}",
            "notnivb;" => "\x{22fe}",
            "notnivc;" => "\x{22fd}",
            "npar;" => "\x{2226}",
            "nparallel;" => "\x{2226}",
            "nparsl;" => "\x{2afd}\x{20e5}",
            "npart;" => "\x{2202}\x{338}",
            "npolint;" => "\x{2a14}",
            "npr;" => "\x{2280}",
            "nprcue;" => "\x{22e0}",
            "npre;" => "\x{2aaf}\x{338}",
            "nprec;" => "\x{2280}",
            "npreceq;" => "\x{2aaf}\x{338}",
            "nrArr;" => "\x{21cf}",
            "nrarr;" => "\x{219b}",
            "nrarrc;" => "\x{2933}\x{338}",
            "nrarrw;" => "\x{219d}\x{338}",
            "nrightarrow;" => "\x{219b}",
            "nrtri;" => "\x{22eb}",
            "nrtrie;" => "\x{22ed}",
            "nsc;" => "\x{2281}",
            "nsccue;" => "\x{22e1}",
            "nsce;" => "\x{2ab0}\x{338}",
            "nscr;" => "\x{1d4c3}",
            "nshortmid;" => "\x{2224}",
            "nshortparallel;" => "\x{2226}",
            "nsim;" => "\x{2241}",
            "nsime;" => "\x{2244}",
            "nsimeq;" => "\x{2244}",
            "nsmid;" => "\x{2224}",
            "nspar;" => "\x{2226}",
            "nsqsube;" => "\x{22e2}",
            "nsqsupe;" => "\x{22e3}",
            "nsub;" => "\x{2284}",
            "nsubE;" => "\x{2ac5}\x{338}",
            "nsube;" => "\x{2288}",
            "nsubset;" => "\x{2282}\x{20d2}",
            "nsubseteq;" => "\x{2288}",
            "nsubseteqq;" => "\x{2ac5}\x{338}",
            "nsucc;" => "\x{2281}",
            "nsucceq;" => "\x{2ab0}\x{338}",
            "nsup;" => "\x{2285}",
            "nsupE;" => "\x{2ac6}\x{338}",
            "nsupe;" => "\x{2289}",
            "nsupset;" => "\x{2283}\x{20d2}",
            "nsupseteq;" => "\x{2289}",
            "nsupseteqq;" => "\x{2ac6}\x{338}",
            "ntgl;" => "\x{2279}",
            "ntilde" => "\x{f1}",
            "ntilde;" => "\x{f1}",
            "ntlg;" => "\x{2278}",
            "ntriangleleft;" => "\x{22ea}",
            "ntrianglelefteq;" => "\x{22ec}",
            "ntriangleright;" => "\x{22eb}",
            "ntrianglerighteq;" => "\x{22ed}",
            "nu;" => "\x{3bd}",
            "num;" => "#",
            "numero;" => "\x{2116}",
            "numsp;" => "\x{2007}",
            "nvDash;" => "\x{22ad}",
            "nvHarr;" => "\x{2904}",
            "nvap;" => "\x{224d}\x{20d2}",
            "nvdash;" => "\x{22ac}",
            "nvge;" => "\x{2265}\x{20d2}",
            "nvgt;" => ">\x{20d2}",
            "nvinfin;" => "\x{29de}",
            "nvlArr;" => "\x{2902}",
            "nvle;" => "\x{2264}\x{20d2}",
            "nvlt;" => "<\x{20d2}",
            "nvltrie;" => "\x{22b4}\x{20d2}",
            "nvrArr;" => "\x{2903}",
            "nvrtrie;" => "\x{22b5}\x{20d2}",
            "nvsim;" => "\x{223c}\x{20d2}",
            "nwArr;" => "\x{21d6}",
            "nwarhk;" => "\x{2923}",
            "nwarr;" => "\x{2196}",
            "nwarrow;" => "\x{2196}",
            "nwnear;" => "\x{2927}",
            "oS;" => "\x{24c8}",
            "oacute" => "\x{f3}",
            "oacute;" => "\x{f3}",
            "oast;" => "\x{229b}",
            "ocir;" => "\x{229a}",
            "ocirc" => "\x{f4}",
            "ocirc;" => "\x{f4}",
            "ocy;" => "\x{43e}",
            "odash;" => "\x{229d}",
            "odblac;" => "\x{151}",
            "odiv;" => "\x{2a38}",
            "odot;" => "\x{2299}",
            "odsold;" => "\x{29bc}",
            "oelig;" => "\x{153}",
            "ofcir;" => "\x{29bf}",
            "ofr;" => "\x{1d52c}",
            "ogon;" => "\x{2db}",
            "ograve" => "\x{f2}",
            "ograve;" => "\x{f2}",
            "ogt;" => "\x{29c1}",
            "ohbar;" => "\x{29b5}",
            "ohm;" => "\x{3a9}",
            "oint;" => "\x{222e}",
            "olarr;" => "\x{21ba}",
            "olcir;" => "\x{29be}",
            "olcross;" => "\x{29bb}",
            "oline;" => "\x{203e}",
            "olt;" => "\x{29c0}",
            "omacr;" => "\x{14d}",
            "omega;" => "\x{3c9}",
            "omicron;" => "\x{3bf}",
            "omid;" => "\x{29b6}",
            "ominus;" => "\x{2296}",
            "oopf;" => "\x{1d560}",
            "opar;" => "\x{29b7}",
            "operp;" => "\x{29b9}",
            "oplus;" => "\x{2295}",
            "or;" => "\x{2228}",
            "orarr;" => "\x{21bb}",
            "ord;" => "\x{2a5d}",
            "order;" => "\x{2134}",
            "orderof;" => "\x{2134}",
            "ordf" => "\x{aa}",
            "ordf;" => "\x{aa}",
            "ordm" => "\x{ba}",
            "ordm;" => "\x{ba}",
            "origof;" => "\x{22b6}",
            "oror;" => "\x{2a56}",
            "orslope;" => "\x{2a57}",
            "orv;" => "\x{2a5b}",
            "oscr;" => "\x{2134}",
            "oslash" => "\x{f8}",
            "oslash;" => "\x{f8}",
            "osol;" => "\x{2298}",
            "otilde" => "\x{f5}",
            "otilde;" => "\x{f5}",
            "otimes;" => "\x{2297}",
            "otimesas;" => "\x{2a36}",
            "ouml" => "\x{f6}",
            "ouml;" => "\x{f6}",
            "ovbar;" => "\x{233d}",
            "par;" => "\x{2225}",
            "para" => "\x{b6}",
            "para;" => "\x{b6}",
            "parallel;" => "\x{2225}",
            "parsim;" => "\x{2af3}",
            "parsl;" => "\x{2afd}",
            "part;" => "\x{2202}",
            "pcy;" => "\x{43f}",
            "percnt;" => "%",
            "period;" => ".",
            "permil;" => "\x{2030}",
            "perp;" => "\x{22a5}",
            "pertenk;" => "\x{2031}",
            "pfr;" => "\x{1d52d}",
            "phi;" => "\x{3c6}",
            "phiv;" => "\x{3d5}",
            "phmmat;" => "\x{2133}",
            "phone;" => "\x{260e}",
            "pi;" => "\x{3c0}",
            "pitchfork;" => "\x{22d4}",
            "piv;" => "\x{3d6}",
            "planck;" => "\x{210f}",
            "planckh;" => "\x{210e}",
            "plankv;" => "\x{210f}",
            "plus;" => "+",
            "plusacir;" => "\x{2a23}",
            "plusb;" => "\x{229e}",
            "pluscir;" => "\x{2a22}",
            "plusdo;" => "\x{2214}",
            "plusdu;" => "\x{2a25}",
            "pluse;" => "\x{2a72}",
            "plusmn" => "\x{b1}",
            "plusmn;" => "\x{b1}",
            "plussim;" => "\x{2a26}",
            "plustwo;" => "\x{2a27}",
            "pm;" => "\x{b1}",
            "pointint;" => "\x{2a15}",
            "popf;" => "\x{1d561}",
            "pound" => "\x{a3}",
            "pound;" => "\x{a3}",
            "pr;" => "\x{227a}",
            "prE;" => "\x{2ab3}",
            "prap;" => "\x{2ab7}",
            "prcue;" => "\x{227c}",
            "pre;" => "\x{2aaf}",
            "prec;" => "\x{227a}",
            "precapprox;" => "\x{2ab7}",
            "preccurlyeq;" => "\x{227c}",
            "preceq;" => "\x{2aaf}",
            "precnapprox;" => "\x{2ab9}",
            "precneqq;" => "\x{2ab5}",
            "precnsim;" => "\x{22e8}",
            "precsim;" => "\x{227e}",
            "prime;" => "\x{2032}",
            "primes;" => "\x{2119}",
            "prnE;" => "\x{2ab5}",
            "prnap;" => "\x{2ab9}",
            "prnsim;" => "\x{22e8}",
            "prod;" => "\x{220f}",
            "profalar;" => "\x{232e}",
            "profline;" => "\x{2312}",
            "profsurf;" => "\x{2313}",
            "prop;" => "\x{221d}",
            "propto;" => "\x{221d}",
            "prsim;" => "\x{227e}",
            "prurel;" => "\x{22b0}",
            "pscr;" => "\x{1d4c5}",
            "psi;" => "\x{3c8}",
            "puncsp;" => "\x{2008}",
            "qfr;" => "\x{1d52e}",
            "qint;" => "\x{2a0c}",
            "qopf;" => "\x{1d562}",
            "qprime;" => "\x{2057}",
            "qscr;" => "\x{1d4c6}",
            "quaternions;" => "\x{210d}",
            "quatint;" => "\x{2a16}",
            "quest;" => "?",
            "questeq;" => "\x{225f}",
            "quot" => "\"",
            "quot;" => "\"",
            "rAarr;" => "\x{21db}",
            "rArr;" => "\x{21d2}",
            "rAtail;" => "\x{291c}",
            "rBarr;" => "\x{290f}",
            "rHar;" => "\x{2964}",
            "race;" => "\x{223d}\x{331}",
            "racute;" => "\x{155}",
            "radic;" => "\x{221a}",
            "raemptyv;" => "\x{29b3}",
            "rang;" => "\x{27e9}",
            "rangd;" => "\x{2992}",
            "range;" => "\x{29a5}",
            "rangle;" => "\x{27e9}",
            "raquo" => "\x{bb}",
            "raquo;" => "\x{bb}",
            "rarr;" => "\x{2192}",
            "rarrap;" => "\x{2975}",
            "rarrb;" => "\x{21e5}",
            "rarrbfs;" => "\x{2920}",
            "rarrc;" => "\x{2933}",
            "rarrfs;" => "\x{291e}",
            "rarrhk;" => "\x{21aa}",
            "rarrlp;" => "\x{21ac}",
            "rarrpl;" => "\x{2945}",
            "rarrsim;" => "\x{2974}",
            "rarrtl;" => "\x{21a3}",
            "rarrw;" => "\x{219d}",
            "ratail;" => "\x{291a}",
            "ratio;" => "\x{2236}",
            "rationals;" => "\x{211a}",
            "rbarr;" => "\x{290d}",
            "rbbrk;" => "\x{2773}",
            "rbrace;" => "}",
            "rbrack;" => "]",
            "rbrke;" => "\x{298c}",
            "rbrksld;" => "\x{298e}",
            "rbrkslu;" => "\x{2990}",
            "rcaron;" => "\x{159}",
            "rcedil;" => "\x{157}",
            "rceil;" => "\x{2309}",
            "rcub;" => "}",
            "rcy;" => "\x{440}",
            "rdca;" => "\x{2937}",
            "rdldhar;" => "\x{2969}",
            "rdquo;" => "\x{201d}",
            "rdquor;" => "\x{201d}",
            "rdsh;" => "\x{21b3}",
            "real;" => "\x{211c}",
            "realine;" => "\x{211b}",
            "realpart;" => "\x{211c}",
            "reals;" => "\x{211d}",
            "rect;" => "\x{25ad}",
            "reg" => "\x{ae}",
            "reg;" => "\x{ae}",
            "rfisht;" => "\x{297d}",
            "rfloor;" => "\x{230b}",
            "rfr;" => "\x{1d52f}",
            "rhard;" => "\x{21c1}",
            "rharu;" => "\x{21c0}",
            "rharul;" => "\x{296c}",
            "rho;" => "\x{3c1}",
            "rhov;" => "\x{3f1}",
            "rightarrow;" => "\x{2192}",
            "rightarrowtail;" => "\x{21a3}",
            "rightharpoondown;" => "\x{21c1}",
            "rightharpoonup;" => "\x{21c0}",
            "rightleftarrows;" => "\x{21c4}",
            "rightleftharpoons;" => "\x{21cc}",
            "rightrightarrows;" => "\x{21c9}",
            "rightsquigarrow;" => "\x{219d}",
            "rightthreetimes;" => "\x{22cc}",
            "ring;" => "\x{2da}",
            "risingdotseq;" => "\x{2253}",
            "rlarr;" => "\x{21c4}",
            "rlhar;" => "\x{21cc}",
            "rlm;" => "\x{200f}",
            "rmoust;" => "\x{23b1}",
            "rmoustache;" => "\x{23b1}",
            "rnmid;" => "\x{2aee}",
            "roang;" => "\x{27ed}",
            "roarr;" => "\x{21fe}",
            "robrk;" => "\x{27e7}",
            "ropar;" => "\x{2986}",
            "ropf;" => "\x{1d563}",
            "roplus;" => "\x{2a2e}",
            "rotimes;" => "\x{2a35}",
            "rpar;" => ")",
            "rpargt;" => "\x{2994}",
            "rppolint;" => "\x{2a12}",
            "rrarr;" => "\x{21c9}",
            "rsaquo;" => "\x{203a}",
            "rscr;" => "\x{1d4c7}",
            "rsh;" => "\x{21b1}",
            "rsqb;" => "]",
            "rsquo;" => "\x{2019}",
            "rsquor;" => "\x{2019}",
            "rthree;" => "\x{22cc}",
            "rtimes;" => "\x{22ca}",
            "rtri;" => "\x{25b9}",
            "rtrie;" => "\x{22b5}",
            "rtrif;" => "\x{25b8}",
            "rtriltri;" => "\x{29ce}",
            "ruluhar;" => "\x{2968}",
            "rx;" => "\x{211e}",
            "sacute;" => "\x{15b}",
            "sbquo;" => "\x{201a}",
            "sc;" => "\x{227b}",
            "scE;" => "\x{2ab4}",
            "scap;" => "\x{2ab8}",
            "scaron;" => "\x{161}",
            "sccue;" => "\x{227d}",
            "sce;" => "\x{2ab0}",
            "scedil;" => "\x{15f}",
            "scirc;" => "\x{15d}",
            "scnE;" => "\x{2ab6}",
            "scnap;" => "\x{2aba}",
            "scnsim;" => "\x{22e9}",
            "scpolint;" => "\x{2a13}",
            "scsim;" => "\x{227f}",
            "scy;" => "\x{441}",
            "sdot;" => "\x{22c5}",
            "sdotb;" => "\x{22a1}",
            "sdote;" => "\x{2a66}",
            "seArr;" => "\x{21d8}",
            "searhk;" => "\x{2925}",
            "searr;" => "\x{2198}",
            "searrow;" => "\x{2198}",
            "sect" => "\x{a7}",
            "sect;" => "\x{a7}",
            "semi;" => ";",
            "seswar;" => "\x{2929}",
            "setminus;" => "\x{2216}",
            "setmn;" => "\x{2216}",
            "sext;" => "\x{2736}",
            "sfr;" => "\x{1d530}",
            "sfrown;" => "\x{2322}",
            "sharp;" => "\x{266f}",
            "shchcy;" => "\x{449}",
            "shcy;" => "\x{448}",
            "shortmid;" => "\x{2223}",
            "shortparallel;" => "\x{2225}",
            "shy" => "\x{ad}",
            "shy;" => "\x{ad}",
            "sigma;" => "\x{3c3}",
            "sigmaf;" => "\x{3c2}",
            "sigmav;" => "\x{3c2}",
            "sim;" => "\x{223c}",
            "simdot;" => "\x{2a6a}",
            "sime;" => "\x{2243}",
            "simeq;" => "\x{2243}",
            "simg;" => "\x{2a9e}",
            "simgE;" => "\x{2aa0}",
            "siml;" => "\x{2a9d}",
            "simlE;" => "\x{2a9f}",
            "simne;" => "\x{2246}",
            "simplus;" => "\x{2a24}",
            "simrarr;" => "\x{2972}",
            "slarr;" => "\x{2190}",
            "smallsetminus;" => "\x{2216}",
            "smashp;" => "\x{2a33}",
            "smeparsl;" => "\x{29e4}",
            "smid;" => "\x{2223}",
            "smile;" => "\x{2323}",
            "smt;" => "\x{2aaa}",
            "smte;" => "\x{2aac}",
            "smtes;" => "\x{2aac}\x{fe00}",
            "softcy;" => "\x{44c}",
            "sol;" => "/",
            "solb;" => "\x{29c4}",
            "solbar;" => "\x{233f}",
            "sopf;" => "\x{1d564}",
            "spades;" => "\x{2660}",
            "spadesuit;" => "\x{2660}",
            "spar;" => "\x{2225}",
            "sqcap;" => "\x{2293}",
            "sqcaps;" => "\x{2293}\x{fe00}",
            "sqcup;" => "\x{2294}",
            "sqcups;" => "\x{2294}\x{fe00}",
            "sqsub;" => "\x{228f}",
            "sqsube;" => "\x{2291}",
            "sqsubset;" => "\x{228f}",
            "sqsubseteq;" => "\x{2291}",
            "sqsup;" => "\x{2290}",
            "sqsupe;" => "\x{2292}",
            "sqsupset;" => "\x{2290}",
            "sqsupseteq;" => "\x{2292}",
            "squ;" => "\x{25a1}",
            "square;" => "\x{25a1}",
            "squarf;" => "\x{25aa}",
            "squf;" => "\x{25aa}",
            "srarr;" => "\x{2192}",
            "sscr;" => "\x{1d4c8}",
            "ssetmn;" => "\x{2216}",
            "ssmile;" => "\x{2323}",
            "sstarf;" => "\x{22c6}",
            "star;" => "\x{2606}",
            "starf;" => "\x{2605}",
            "straightepsilon;" => "\x{3f5}",
            "straightphi;" => "\x{3d5}",
            "strns;" => "\x{af}",
            "sub;" => "\x{2282}",
            "subE;" => "\x{2ac5}",
            "subdot;" => "\x{2abd}",
            "sube;" => "\x{2286}",
            "subedot;" => "\x{2ac3}",
            "submult;" => "\x{2ac1}",
            "subnE;" => "\x{2acb}",
            "subne;" => "\x{228a}",
            "subplus;" => "\x{2abf}",
            "subrarr;" => "\x{2979}",
            "subset;" => "\x{2282}",
            "subseteq;" => "\x{2286}",
            "subseteqq;" => "\x{2ac5}",
            "subsetneq;" => "\x{228a}",
            "subsetneqq;" => "\x{2acb}",
            "subsim;" => "\x{2ac7}",
            "subsub;" => "\x{2ad5}",
            "subsup;" => "\x{2ad3}",
            "succ;" => "\x{227b}",
            "succapprox;" => "\x{2ab8}",
            "succcurlyeq;" => "\x{227d}",
            "succeq;" => "\x{2ab0}",
            "succnapprox;" => "\x{2aba}",
            "succneqq;" => "\x{2ab6}",
            "succnsim;" => "\x{22e9}",
            "succsim;" => "\x{227f}",
            "sum;" => "\x{2211}",
            "sung;" => "\x{266a}",
            "sup1" => "\x{b9}",
            "sup1;" => "\x{b9}",
            "sup2" => "\x{b2}",
            "sup2;" => "\x{b2}",
            "sup3" => "\x{b3}",
            "sup3;" => "\x{b3}",
            "sup;" => "\x{2283}",
            "supE;" => "\x{2ac6}",
            "supdot;" => "\x{2abe}",
            "supdsub;" => "\x{2ad8}",
            "supe;" => "\x{2287}",
            "supedot;" => "\x{2ac4}",
            "suphsol;" => "\x{27c9}",
            "suphsub;" => "\x{2ad7}",
            "suplarr;" => "\x{297b}",
            "supmult;" => "\x{2ac2}",
            "supnE;" => "\x{2acc}",
            "supne;" => "\x{228b}",
            "supplus;" => "\x{2ac0}",
            "supset;" => "\x{2283}",
            "supseteq;" => "\x{2287}",
            "supseteqq;" => "\x{2ac6}",
            "supsetneq;" => "\x{228b}",
            "supsetneqq;" => "\x{2acc}",
            "supsim;" => "\x{2ac8}",
            "supsub;" => "\x{2ad4}",
            "supsup;" => "\x{2ad6}",
            "swArr;" => "\x{21d9}",
            "swarhk;" => "\x{2926}",
            "swarr;" => "\x{2199}",
            "swarrow;" => "\x{2199}",
            "swnwar;" => "\x{292a}",
            "szlig" => "\x{df}",
            "szlig;" => "\x{df}",
            "target;" => "\x{2316}",
            "tau;" => "\x{3c4}",
            "tbrk;" => "\x{23b4}",
            "tcaron;" => "\x{165}",
            "tcedil;" => "\x{163}",
            "tcy;" => "\x{442}",
            "tdot;" => "\x{20db}",
            "telrec;" => "\x{2315}",
            "tfr;" => "\x{1d531}",
            "there4;" => "\x{2234}",
            "therefore;" => "\x{2234}",
            "theta;" => "\x{3b8}",
            "thetasym;" => "\x{3d1}",
            "thetav;" => "\x{3d1}",
            "thickapprox;" => "\x{2248}",
            "thicksim;" => "\x{223c}",
            "thinsp;" => "\x{2009}",
            "thkap;" => "\x{2248}",
            "thksim;" => "\x{223c}",
            "thorn" => "\x{fe}",
            "thorn;" => "\x{fe}",
            "tilde;" => "\x{2dc}",
            "times" => "\x{d7}",
            "times;" => "\x{d7}",
            "timesb;" => "\x{22a0}",
            "timesbar;" => "\x{2a31}",
            "timesd;" => "\x{2a30}",
            "tint;" => "\x{222d}",
            "toea;" => "\x{2928}",
            "top;" => "\x{22a4}",
            "topbot;" => "\x{2336}",
            "topcir;" => "\x{2af1}",
            "topf;" => "\x{1d565}",
            "topfork;" => "\x{2ada}",
            "tosa;" => "\x{2929}",
            "tprime;" => "\x{2034}",
            "trade;" => "\x{2122}",
            "triangle;" => "\x{25b5}",
            "triangledown;" => "\x{25bf}",
            "triangleleft;" => "\x{25c3}",
            "trianglelefteq;" => "\x{22b4}",
            "triangleq;" => "\x{225c}",
            "triangleright;" => "\x{25b9}",
            "trianglerighteq;" => "\x{22b5}",
            "tridot;" => "\x{25ec}",
            "trie;" => "\x{225c}",
            "triminus;" => "\x{2a3a}",
            "triplus;" => "\x{2a39}",
            "trisb;" => "\x{29cd}",
            "tritime;" => "\x{2a3b}",
            "trpezium;" => "\x{23e2}",
            "tscr;" => "\x{1d4c9}",
            "tscy;" => "\x{446}",
            "tshcy;" => "\x{45b}",
            "tstrok;" => "\x{167}",
            "twixt;" => "\x{226c}",
            "twoheadleftarrow;" => "\x{219e}",
            "twoheadrightarrow;" => "\x{21a0}",
            "uArr;" => "\x{21d1}",
            "uHar;" => "\x{2963}",
            "uacute" => "\x{fa}",
            "uacute;" => "\x{fa}",
            "uarr;" => "\x{2191}",
            "ubrcy;" => "\x{45e}",
            "ubreve;" => "\x{16d}",
            "ucirc" => "\x{fb}",
            "ucirc;" => "\x{fb}",
            "ucy;" => "\x{443}",
            "udarr;" => "\x{21c5}",
            "udblac;" => "\x{171}",
            "udhar;" => "\x{296e}",
            "ufisht;" => "\x{297e}",
            "ufr;" => "\x{1d532}",
            "ugrave" => "\x{f9}",
            "ugrave;" => "\x{f9}",
            "uharl;" => "\x{21bf}",
            "uharr;" => "\x{21be}",
            "uhblk;" => "\x{2580}",
            "ulcorn;" => "\x{231c}",
            "ulcorner;" => "\x{231c}",
            "ulcrop;" => "\x{230f}",
            "ultri;" => "\x{25f8}",
            "umacr;" => "\x{16b}",
            "uml" => "\x{a8}",
            "uml;" => "\x{a8}",
            "uogon;" => "\x{173}",
            "uopf;" => "\x{1d566}",
            "uparrow;" => "\x{2191}",
            "updownarrow;" => "\x{2195}",
            "upharpoonleft;" => "\x{21bf}",
            "upharpoonright;" => "\x{21be}",
            "uplus;" => "\x{228e}",
            "upsi;" => "\x{3c5}",
            "upsih;" => "\x{3d2}",
            "upsilon;" => "\x{3c5}",
            "upuparrows;" => "\x{21c8}",
            "urcorn;" => "\x{231d}",
            "urcorner;" => "\x{231d}",
            "urcrop;" => "\x{230e}",
            "uring;" => "\x{16f}",
            "urtri;" => "\x{25f9}",
            "uscr;" => "\x{1d4ca}",
            "utdot;" => "\x{22f0}",
            "utilde;" => "\x{169}",
            "utri;" => "\x{25b5}",
            "utrif;" => "\x{25b4}",
            "uuarr;" => "\x{21c8}",
            "uuml" => "\x{fc}",
            "uuml;" => "\x{fc}",
            "uwangle;" => "\x{29a7}",
            "vArr;" => "\x{21d5}",
            "vBar;" => "\x{2ae8}",
            "vBarv;" => "\x{2ae9}",
            "vDash;" => "\x{22a8}",
            "vangrt;" => "\x{299c}",
            "varepsilon;" => "\x{3f5}",
            "varkappa;" => "\x{3f0}",
            "varnothing;" => "\x{2205}",
            "varphi;" => "\x{3d5}",
            "varpi;" => "\x{3d6}",
            "varpropto;" => "\x{221d}",
            "varr;" => "\x{2195}",
            "varrho;" => "\x{3f1}",
            "varsigma;" => "\x{3c2}",
            "varsubsetneq;" => "\x{228a}\x{fe00}",
            "varsubsetneqq;" => "\x{2acb}\x{fe00}",
            "varsupsetneq;" => "\x{228b}\x{fe00}",
            "varsupsetneqq;" => "\x{2acc}\x{fe00}",
            "vartheta;" => "\x{3d1}",
            "vartriangleleft;" => "\x{22b2}",
            "vartriangleright;" => "\x{22b3}",
            "vcy;" => "\x{432}",
            "vdash;" => "\x{22a2}",
            "vee;" => "\x{2228}",
            "veebar;" => "\x{22bb}",
            "veeeq;" => "\x{225a}",
            "vellip;" => "\x{22ee}",
            "verbar;" => "|",
            "vert;" => "|",
            "vfr;" => "\x{1d533}",
            "vltri;" => "\x{22b2}",
            "vnsub;" => "\x{2282}\x{20d2}",
            "vnsup;" => "\x{2283}\x{20d2}",
            "vopf;" => "\x{1d567}",
            "vprop;" => "\x{221d}",
            "vrtri;" => "\x{22b3}",
            "vscr;" => "\x{1d4cb}",
            "vsubnE;" => "\x{2acb}\x{fe00}",
            "vsubne;" => "\x{228a}\x{fe00}",
            "vsupnE;" => "\x{2acc}\x{fe00}",
            "vsupne;" => "\x{228b}\x{fe00}",
            "vzigzag;" => "\x{299a}",
            "wcirc;" => "\x{175}",
            "wedbar;" => "\x{2a5f}",
            "wedge;" => "\x{2227}",
            "wedgeq;" => "\x{2259}",
            "weierp;" => "\x{2118}",
            "wfr;" => "\x{1d534}",
            "wopf;" => "\x{1d568}",
            "wp;" => "\x{2118}",
            "wr;" => "\x{2240}",
            "wreath;" => "\x{2240}",
            "wscr;" => "\x{1d4cc}",
            "xcap;" => "\x{22c2}",
            "xcirc;" => "\x{25ef}",
            "xcup;" => "\x{22c3}",
            "xdtri;" => "\x{25bd}",
            "xfr;" => "\x{1d535}",
            "xhArr;" => "\x{27fa}",
            "xharr;" => "\x{27f7}",
            "xi;" => "\x{3be}",
            "xlArr;" => "\x{27f8}",
            "xlarr;" => "\x{27f5}",
            "xmap;" => "\x{27fc}",
            "xnis;" => "\x{22fb}",
            "xodot;" => "\x{2a00}",
            "xopf;" => "\x{1d569}",
            "xoplus;" => "\x{2a01}",
            "xotime;" => "\x{2a02}",
            "xrArr;" => "\x{27f9}",
            "xrarr;" => "\x{27f6}",
            "xscr;" => "\x{1d4cd}",
            "xsqcup;" => "\x{2a06}",
            "xuplus;" => "\x{2a04}",
            "xutri;" => "\x{25b3}",
            "xvee;" => "\x{22c1}",
            "xwedge;" => "\x{22c0}",
            "yacute" => "\x{fd}",
            "yacute;" => "\x{fd}",
            "yacy;" => "\x{44f}",
            "ycirc;" => "\x{177}",
            "ycy;" => "\x{44b}",
            "yen" => "\x{a5}",
            "yen;" => "\x{a5}",
            "yfr;" => "\x{1d536}",
            "yicy;" => "\x{457}",
            "yopf;" => "\x{1d56a}",
            "yscr;" => "\x{1d4ce}",
            "yucy;" => "\x{44e}",
            "yuml" => "\x{ff}",
            "yuml;" => "\x{ff}",
            "zacute;" => "\x{17a}",
            "zcaron;" => "\x{17e}",
            "zcy;" => "\x{437}",
            "zdot;" => "\x{17c}",
            "zeetrf;" => "\x{2128}",
            "zeta;" => "\x{3b6}",
            "zfr;" => "\x{1d537}",
            "zhcy;" => "\x{436}",
            "zigrarr;" => "\x{21dd}",
            "zopf;" => "\x{1d56b}",
            "zscr;" => "\x{1d4cf}",
            "zwj;" => "\x{200d}",
            "zwnj;" => "\x{200c}"
          };
  1;
  __DATA__
  
  =head1 NAME
  
  mkentitylist.pl - Generate a named entity list for HTML parser
  
  _NamedEntityList.pm - A named entity list for HTML parser
  
  =head1 DESCRIPTION
  
  The C<Whatpm/_NamedEntityList.pm> file contains the list of the named
  character references taht can be used in HTML documents, as defined by
  the Web Applications 1.0 specification, both conforming and
  non-conforming.  The file is referenced by the HTML tokenizer
  implementation, L<Whatpm::HTML::Tokenizer>.
  
  The C<mkentitylist.pl> script is used to generate the
  C<_NamedEntityList.pm> file from the table of the named character
  references in the Web Applications 1.0 specification.
  
  =head1 SEE ALSO
  
  L<Whatpm::HTML::Tokenizer>.
  
  Web Applications 1.0 - Named character references
  <http://www.whatwg.org/specs/web-apps/current-work/complete.html#named-character-references>.
  
  =head1 LICENSE
  
  (C) Copyright 2004-2007 Apple Computer, Inc., Mozilla Foundation, and
  Opera Software ASA.
  
  Copyright 2007-2010 Wakaba <w@suika.fam.cx>.
  
  You are granted a license to use, reproduce and create derivative
  works of this document.
  
  =cut
  
WHATPM__NAMEDENTITYLIST

$fatpacked{"encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENCODING';
  # $Id: encoding.pm,v 3.00 2020/04/19 10:56:28 dankogai Exp $
  package encoding;
  our $VERSION = sprintf "%d.%02d", q$Revision: 3.00 $ =~ /(\d+)/g;
  
  use Encode;
  use strict;
  use warnings;
  use Config;
  
  use constant {
      DEBUG => !!$ENV{PERL_ENCODE_DEBUG},
      HAS_PERLIO => eval { require PerlIO::encoding; PerlIO::encoding->VERSION(0.02) },
      PERL_5_21_7 => $^V && $^V ge v5.21.7, # lexically scoped
  };
  
  sub _exception {
      my $name = shift;
      $] > 5.008 and return 0;    # 5.8.1 or higher then no
      my %utfs = map { $_ => 1 }
        qw(utf8 UCS-2BE UCS-2LE UTF-16 UTF-16BE UTF-16LE
        UTF-32 UTF-32BE UTF-32LE);
      $utfs{$name} or return 0;    # UTFs or no
      require Config;
      Config->import();
      our %Config;
      return $Config{perl_patchlevel} ? 0 : 1    # maintperl then no
  }
  
  sub in_locale { $^H & ( $locale::hint_bits || 0 ) }
  
  sub _get_locale_encoding {
      my $locale_encoding;
  
      if ($^O eq 'MSWin32') {
          my @tries = (
              # First try to get the OutputCP. This will work only if we
              # are attached to a console
              'Win32.pm' => 'Win32::GetConsoleOutputCP',
              'Win32/Console.pm' => 'Win32::Console::OutputCP',
              # If above failed, this means that we are a GUI app
              # Let's assume that the ANSI codepage is what matters
              'Win32.pm' => 'Win32::GetACP',
          );
          while (@tries) {
              my $cp = eval {
                  require $tries[0];
                  no strict 'refs';
                  &{$tries[1]}()
              };
              if ($cp) {
                  if ($cp == 65001) { # Code page for UTF-8
                      $locale_encoding = 'UTF-8';
                  } else {
                      $locale_encoding = 'cp' . $cp;
                  }
                  return $locale_encoding;
              }
              splice(@tries, 0, 2)
          }
      }
  
      # I18N::Langinfo isn't available everywhere
      $locale_encoding = eval {
          require I18N::Langinfo;
          find_encoding(
              I18N::Langinfo::langinfo( I18N::Langinfo::CODESET() )
          )->name
      };
      return $locale_encoding if defined $locale_encoding;
  
      eval {
          require POSIX;
          # Get the current locale
          # Remember that MSVCRT impl is quite different from Unixes
          my $locale = POSIX::setlocale(POSIX::LC_CTYPE());
          if ( $locale =~ /^([^.]+)\.([^.@]+)(?:@.*)?$/ ) {
              my $country_language;
              ( $country_language, $locale_encoding ) = ( $1, $2 );
  
              # Could do more heuristics based on the country and language
              # since we have Locale::Country and Locale::Language available.
              # TODO: get a database of Language -> Encoding mappings
              # (the Estonian database at http://www.eki.ee/letter/
              # would be excellent!) --jhi
              if (lc($locale_encoding) eq 'euc') {
                  if ( $country_language =~ /^ja_JP|japan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-jp';
                  }
                  elsif ( $country_language =~ /^ko_KR|korean?$/i ) {
                      $locale_encoding = 'euc-kr';
                  }
                  elsif ( $country_language =~ /^zh_CN|chin(?:a|ese)$/i ) {
                      $locale_encoding = 'euc-cn';
                  }
                  elsif ( $country_language =~ /^zh_TW|taiwan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-tw';
                  }
                  else {
                      require Carp;
                      Carp::croak(
                          "encoding: Locale encoding '$locale_encoding' too ambiguous"
                      );
                  }
              }
          }
      };
  
      return $locale_encoding;
  }
  
  sub import {
  
      if ( ord("A") == 193 ) {
          require Carp;
          Carp::croak("encoding: pragma does not support EBCDIC platforms");
      }
  
      my $deprecate =
          ($] >= 5.017 and !$Config{usecperl})
          ? "Use of the encoding pragma is deprecated" : 0;
  
      my $class = shift;
      my $name  = shift;
      if (!$name){
  	require Carp;
          Carp::croak("encoding: no encoding specified.");
      }
      if ( $name eq ':_get_locale_encoding' ) {    # used by lib/open.pm
          my $caller = caller();
          {
              no strict 'refs';
              *{"${caller}::_get_locale_encoding"} = \&_get_locale_encoding;
          }
          return;
      }
      $name = _get_locale_encoding() if $name eq ':locale';
      BEGIN { strict->unimport('hashpairs') if $] >= 5.027 and $^V =~ /c$/; }
      my %arg = @_;
      $name = $ENV{PERL_ENCODING} unless defined $name;
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("encoding: Unknown encoding '$name'");
      }
      $name = $enc->name;    # canonize
      unless ( $arg{Filter} ) {
          if ($] >= 5.025003 and !$Config{usecperl}) {
              require Carp;
              Carp::croak("The encoding pragma is no longer supported. Check cperl");
          }
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          DEBUG and warn "_exception($name) = ", _exception($name);
          if (! _exception($name)) {
              if (!PERL_5_21_7) {
                  ${^ENCODING} = $enc;
              }
              else {
                  # Starting with 5.21.7, this pragma uses a shadow variable
                  # designed explicitly for it, ${^E_NCODING}, to enforce
                  # lexical scope; instead of ${^ENCODING}.
                  $^H{'encoding'} = 1;
                  ${^E_NCODING} = $enc;
              }
          }
          if (! HAS_PERLIO ) {
              return 1;
          }
      }
      else {
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          defined( ${^ENCODING} ) and undef ${^ENCODING};
          undef ${^E_NCODING} if PERL_5_21_7;
  
          # implicitly 'use utf8'
          require utf8;      # to fetch $utf8::hint_bits;
          $^H |= $utf8::hint_bits;
  
              require Filter::Util::Call;
              Filter::Util::Call->import;
              filter_add(
                  sub {
                      my $status = filter_read();
                      if ( $status > 0 ) {
                          $_ = $enc->decode( $_, 1 );
                          DEBUG and warn $_;
                      }
                      $status;
                  }
              );
      }
      defined ${^UNICODE} and ${^UNICODE} != 0 and return 1;
      for my $h (qw(STDIN STDOUT)) {
          if ( $arg{$h} ) {
              unless ( defined find_encoding( $arg{$h} ) ) {
                  require Carp;
                  Carp::croak(
                      "encoding: Unknown encoding for $h, '$arg{$h}'");
              }
              binmode( $h, ":raw :encoding($arg{$h})" );
          }
          else {
              unless ( exists $arg{$h} ) {
                      no warnings 'uninitialized';
                      binmode( $h, ":raw :encoding($name)" );
              }
          }
      }
      return 1;    # I doubt if we need it, though
  }
  
  sub unimport {
      no warnings;
      undef ${^ENCODING};
      undef ${^E_NCODING} if PERL_5_21_7;
      if (HAS_PERLIO) {
          binmode( STDIN,  ":raw" );
          binmode( STDOUT, ":raw" );
      }
      else {
          binmode(STDIN);
          binmode(STDOUT);
      }
      if ( $INC{"Filter/Util/Call.pm"} ) {
          eval { filter_del() };
      }
  }
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  encoding - allows you to write your script in non-ASCII and non-UTF-8
  
  =head1 WARNING
  
  This module has been deprecated since perl v5.18.  See L</DESCRIPTION> and
  L</BUGS>.
  
  =head1 SYNOPSIS
  
    use encoding "greek";  # Perl like Greek to you?
    use encoding "euc-jp"; # Jperl!
  
    # or you can even do this if your shell supports your native encoding
  
    perl -Mencoding=latin2 -e'...' # Feeling centrally European?
    perl -Mencoding=euc-kr -e'...' # Or Korean?
  
    # more control
  
    # A simple euc-cn => utf-8 converter
    use encoding "euc-cn", STDOUT => "utf8";  while(<>){print};
  
    # "no encoding;" supported
    no encoding;
  
    # an alternate way, Filter
    use encoding "euc-jp", Filter=>1;
    # now you can use kanji identifiers -- in euc-jp!
  
    # encode based on the current locale - specialized purposes only;
    # fraught with danger!!
    use encoding ':locale';
  
  =head1 DESCRIPTION
  
  This pragma is used to enable a Perl script to be written in encodings that
  aren't strictly ASCII nor UTF-8.  It translates all or portions of the Perl
  program script from a given encoding into UTF-8, and changes the PerlIO layers
  of C<STDIN> and C<STDOUT> to the encoding specified.
  
  This pragma dates from the days when UTF-8-enabled editors were uncommon.  But
  that was long ago, and the need for it is greatly diminished.  That, coupled
  with the fact that it doesn't work with threads, along with other problems,
  (see L</BUGS>) have led to its being deprecated.  It is planned to remove this
  pragma in a future Perl version.  New code should be written in UTF-8, and the
  C<use utf8> pragma used instead (see L<perluniintro> and L<utf8> for details).
  Old code should be converted to UTF-8, via something like the recipe in the
  L</SYNOPSIS> (though this simple approach may require manual adjustments
  afterwards).
  
  If UTF-8 is not an option, it is recommended that one use a simple source
  filter, such as that provided by L<Filter::Encoding> on CPAN or this
  pragma's own C<Filter> option (see below).
  
  The only legitimate use of this pragma is almost certainly just one per file,
  near the top, with file scope, as the file is likely going to only be written
  in one encoding.  Further restrictions apply in Perls before v5.22 (see
  L</Prior to Perl v5.22>).
  
  There are two basic modes of operation (plus turning if off):
  
  =over 4
  
  =item C<use encoding ['I<ENCNAME>'] ;>
  
  Please note: This mode of operation is no longer supported as of Perl
  v5.26.
  
  This is the normal operation.  It translates various literals encountered in
  the Perl source file from the encoding I<ENCNAME> into UTF-8, and similarly
  converts character code points.  This is used when the script is a combination
  of ASCII (for the variable names and punctuation, I<etc>), but the literal
  data is in the specified encoding.
  
  I<ENCNAME> is optional.  If omitted, the encoding specified in the environment
  variable L<C<PERL_ENCODING>|perlrun/PERL_ENCODING> is used.  If this isn't
  set, or the resolved-to encoding is not known to C<L<Encode>>, the error
  C<Unknown encoding 'I<ENCNAME>'> will be thrown.
  
  Starting in Perl v5.8.6 (C<Encode> version 2.0.1), I<ENCNAME> may be the
  name C<:locale>.  This is for very specialized applications, and is documented
  in L</The C<:locale> sub-pragma> below.
  
  The literals that are converted are C<q//, qq//, qr//, qw///, qx//>, and
  starting in v5.8.1, C<tr///>.  Operations that do conversions include C<chr>,
  C<ord>, C<utf8::upgrade> (but not C<utf8::downgrade>), and C<chomp>.
  
  Also starting in v5.8.1, the C<DATA> pseudo-filehandle is translated from the
  encoding into UTF-8.
  
  For example, you can write code in EUC-JP as follows:
  
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
                 #<-char-><-char->   # 4 octets
    s/\bCamel\b/$Rakuda/;
  
  And with C<use encoding "euc-jp"> in effect, it is the same thing as
  that code in UTF-8:
  
    my $Rakuda = "\x{99F1}\x{99DD}"; # two Unicode Characters
    s/\bCamel\b/$Rakuda/;
  
  See L</EXAMPLE> below for a more complete example.
  
  Unless C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero, the
  PerlIO layers of C<STDIN> and C<STDOUT> are set to "C<:encoding(I<ENCNAME>)>".
  Therefore,
  
    use encoding "euc-jp";
    my $message = "Camel is the symbol of perl.\n";
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
    $message =~ s/\bCamel\b/$Rakuda/;
    print $message;
  
  will print
  
   "\xF1\xD1\xF1\xCC is the symbol of perl.\n"
  
  not
  
   "\x{99F1}\x{99DD} is the symbol of perl.\n"
  
  You can override this by giving extra arguments; see below.
  
  Note that C<STDERR> WILL NOT be changed, regardless.
  
  Also note that non-STD file handles remain unaffected.  Use C<use
  open> or C<binmode> to change the layers of those.
  
  =item C<use encoding I<ENCNAME>, Filter=E<gt>1;>
  
  This operates as above, but the C<Filter> argument with a non-zero
  value causes the entire script, and not just literals, to be translated from
  the encoding into UTF-8.  This allows identifiers in the source to be in that
  encoding as well.  (Problems may occur if the encoding is not a superset of
  ASCII; imagine all your semi-colons being translated into something
  different.)  One can use this form to make
  
   ${"\x{4eba}"}++
  
  work.  (This is equivalent to C<$I<human>++>, where I<human> is a single Han
  ideograph).
  
  This effectively means that your source code behaves as if it were written in
  UTF-8 with C<'use utf8>' in effect.  So even if your editor only supports
  Shift_JIS, for example, you can still try examples in Chapter 15 of
  C<Programming Perl, 3rd Ed.>.
  
  This option is significantly slower than the other one.
  
  =item C<no encoding;>
  
  Unsets the script encoding. The layers of C<STDIN>, C<STDOUT> are
  reset to "C<:raw>" (the default unprocessed raw stream of bytes).
  
  =back
  
  =head1 OPTIONS
  
  =head2 Setting C<STDIN> and/or C<STDOUT> individually
  
  The encodings of C<STDIN> and C<STDOUT> are individually settable by parameters to
  the pragma:
  
   use encoding 'euc-tw', STDIN => 'greek'  ...;
  
  In this case, you cannot omit the first I<ENCNAME>.  C<< STDIN => undef >>
  turns the I/O transcoding completely off for that filehandle.
  
  When C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero,
  these options will be completely ignored.  See L<perlvar/C<${^UNICODE}>> and
  L<"C<-C>" in perlrun|perlrun/-C [numberE<sol>list]> for details.
  
  =head2 The C<:locale> sub-pragma
  
  Starting in v5.8.6, the encoding name may be C<:locale>.  This means that the
  encoding is taken from the current locale, and not hard-coded by the pragma.
  Since a script really can only be encoded in exactly one encoding, this option
  is dangerous.  It makes sense only if the script itself is written in ASCII,
  and all the possible locales that will be in use when the script is executed
  are supersets of ASCII.  That means that the script itself doesn't get
  changed, but the I/O handles have the specified encoding added, and the
  operations like C<chr> and C<ord> use that encoding.
  
  The logic of finding which locale C<:locale> uses is as follows:
  
  =over 4
  
  =item 1.
  
  If the platform supports the C<langinfo(CODESET)> interface, the codeset
  returned is used as the default encoding for the open pragma.
  
  =item 2.
  
  If 1. didn't work but we are under the locale pragma, the environment
  variables C<LC_ALL> and C<LANG> (in that order) are matched for encodings
  (the part after "C<.>", if any), and if any found, that is used
  as the default encoding for the open pragma.
  
  =item 3.
  
  If 1. and 2. didn't work, the environment variables C<LC_ALL> and C<LANG>
  (in that order) are matched for anything looking like UTF-8, and if
  any found, C<:utf8> is used as the default encoding for the open
  pragma.
  
  =back
  
  If your locale environment variables (C<LC_ALL>, C<LC_CTYPE>, C<LANG>)
  contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
  the default encoding of your C<STDIN>, C<STDOUT>, and C<STDERR>, and of
  B<any subsequent file open>, is UTF-8.
  
  =head1 CAVEATS
  
  =head2 SIDE EFFECTS
  
  =over
  
  =item *
  
  If the C<encoding> pragma is in scope then the lengths returned are
  calculated from the length of C<$/> in Unicode characters, which is not
  always the same as the length of C<$/> in the native encoding.
  
  =item *
  
  Without this pragma, if strings operating under byte semantics and strings
  with Unicode character data are concatenated, the new string will
  be created by decoding the byte strings as I<ISO 8859-1 (Latin-1)>.
  
  The B<encoding> pragma changes this to use the specified encoding
  instead.  For example:
  
      use encoding 'utf8';
      my $string = chr(20000); # a Unicode string
      utf8::encode($string);   # now it's a UTF-8 encoded byte string
      # concatenate with another Unicode string
      print length($string . chr(20000));
  
  Will print C<2>, because C<$string> is upgraded as UTF-8.  Without
  C<use encoding 'utf8';>, it will print C<4> instead, since C<$string>
  is three octets when interpreted as Latin-1.
  
  =back
  
  =head2 DO NOT MIX MULTIPLE ENCODINGS
  
  Notice that only literals (string or regular expression) having only
  legacy code points are affected: if you mix data like this
  
      \x{100}\xDF
      \xDF\x{100}
  
  the data is assumed to be in (Latin 1 and) Unicode, not in your native
  encoding.  In other words, this will match in "greek":
  
      "\xDF" =~ /\x{3af}/
  
  but this will not
  
      "\xDF\x{100}" =~ /\x{3af}\x{100}/
  
  since the C<\xDF> (ISO 8859-7 GREEK SMALL LETTER IOTA WITH TONOS) on
  the left will B<not> be upgraded to C<\x{3af}> (Unicode GREEK SMALL
  LETTER IOTA WITH TONOS) because of the C<\x{100}> on the left.  You
  should not be mixing your legacy data and Unicode in the same string.
  
  This pragma also affects encoding of the 0x80..0xFF code point range:
  normally characters in that range are left as eight-bit bytes (unless
  they are combined with characters with code points 0x100 or larger,
  in which case all characters need to become UTF-8 encoded), but if
  the C<encoding> pragma is present, even the 0x80..0xFF range always
  gets UTF-8 encoded.
  
  After all, the best thing about this pragma is that you don't have to
  resort to \x{....} just to spell your name in a native encoding.
  So feel free to put your strings in your encoding in quotes and
  regexes.
  
  =head2 Prior to Perl v5.22
  
  The pragma was a per script, not a per block lexical.  Only the last
  C<use encoding> or C<no encoding> mattered, and it affected
  B<the whole script>.  However, the C<no encoding> pragma was supported and
  C<use encoding> could appear as many times as you want in a given script
  (though only the last was effective).
  
  Since the scope wasn't lexical, other modules' use of C<chr>, C<ord>, I<etc.>
  were affected.  This leads to spooky, incorrect action at a distance that is
  hard to debug.
  
  This means you would have to be very careful of the load order:
  
    # called module
    package Module_IN_BAR;
    use encoding "bar";
    # stuff in "bar" encoding here
    1;
  
    # caller script
    use encoding "foo"
    use Module_IN_BAR;
    # surprise! use encoding "bar" is in effect.
  
  The best way to avoid this oddity is to use this pragma RIGHT AFTER
  other modules are loaded.  i.e.
  
    use Module_IN_BAR;
    use encoding "foo";
  
  =head2 Prior to Encode version 1.87
  
  =over
  
  =item *
  
  C<STDIN> and C<STDOUT> were not set under the filter option.
  And C<< STDIN=>I<ENCODING> >> and C<< STDOUT=>I<ENCODING> >> didn't work like
  non-filter version.
  
  =item *
  
  C<use utf8> wasn't implicitly declared so you have to C<use utf8> to do
  
   ${"\x{4eba}"}++
  
  =back
  
  =head2 Prior to Perl v5.8.1
  
  =over
  
  =item "NON-EUC" doublebyte encodings
  
  Because perl needs to parse the script before applying this pragma, such
  encodings as Shift_JIS and Big-5 that may contain C<'\'> (BACKSLASH;
  C<\x5c>) in the second byte fail because the second byte may
  accidentally escape the quoting character that follows.
  
  =item C<tr///>
  
  The B<encoding> pragma works by decoding string literals in
  C<q//,qq//,qr//,qw///, qx//> and so forth.  In perl v5.8.0, this
  does not apply to C<tr///>.  Therefore,
  
    use encoding 'euc-jp';
    #....
    $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;
    #           -------- -------- -------- --------
  
  Does not work as
  
    $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;
  
  =over
  
  =item Legend of characters above
  
    utf8     euc-jp   charnames::viacode()
    -----------------------------------------
    \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A
    \x{3093} \xA4\xF3 HIRAGANA LETTER N
    \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A
    \x{30f3} \xA5\xF3 KATAKANA LETTER N
  
  =back
  
  This counterintuitive behavior has been fixed in perl v5.8.1.
  
  In perl v5.8.0, you can work around this as follows;
  
    use encoding 'euc-jp';
    #  ....
    eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };
  
  Note the C<tr//> expression is surrounded by C<qq{}>.  The idea behind
  this is the same as the classic idiom that makes C<tr///> 'interpolate':
  
     tr/$from/$to/;            # wrong!
     eval qq{ tr/$from/$to/ }; # workaround.
  
  =back
  
  =head1 EXAMPLE - Greekperl
  
      use encoding "iso 8859-7";
  
      # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.
  
      $a = "\xDF";
      $b = "\x{100}";
  
      printf "%#x\n", ord($a); # will print 0x3af, not 0xdf
  
      $c = $a . $b;
  
      # $c will be "\x{3af}\x{100}", not "\x{df}\x{100}".
  
      # chr() is affected, and ...
  
      print "mega\n"  if ord(chr(0xdf)) == 0x3af;
  
      # ... ord() is affected by the encoding pragma ...
  
      print "tera\n" if ord(pack("C", 0xdf)) == 0x3af;
  
      # ... as are eq and cmp ...
  
      print "peta\n" if "\x{3af}" eq  pack("C", 0xdf);
      print "exa\n"  if "\x{3af}" cmp pack("C", 0xdf) == 0;
  
      # ... but pack/unpack C are not affected, in case you still
      # want to go back to your native encoding
  
      print "zetta\n" if unpack("C", (pack("C", 0xdf))) == 0xdf;
  
  =head1 BUGS
  
  =over
  
  =item Thread safety
  
  C<use encoding ...> is not thread-safe (i.e., do not use in threaded
  applications).
  
  =item Can't be used by more than one module in a single program.
  
  Only one encoding is allowed.  If you combine modules in a program that have
  different encodings, only one will be actually used.
  
  =item Other modules using C<STDIN> and C<STDOUT> get the encoded stream
  
  They may be expecting something completely different.
  
  =item literals in regex that are longer than 127 bytes
  
  For native multibyte encodings (either fixed or variable length),
  the current implementation of the regular expressions may introduce
  recoding errors for regular expression literals longer than 127 bytes.
  
  =item EBCDIC
  
  The encoding pragma is not supported on EBCDIC platforms.
  
  =item C<format>
  
  This pragma doesn't work well with C<format> because PerlIO does not
  get along very well with it.  When C<format> contains non-ASCII
  characters it prints funny or gets "wide character warnings".
  To understand it, try the code below.
  
    # Save this one in utf8
    # replace *non-ascii* with a non-ascii string
    my $camel;
    format STDOUT =
    *non-ascii*@>>>>>>>
    $camel
    .
    $camel = "*non-ascii*";
    binmode(STDOUT=>':encoding(utf8)'); # bang!
    write;              # funny
    print $camel, "\n"; # fine
  
  Without binmode this happens to work but without binmode, print()
  fails instead of write().
  
  At any rate, the very use of C<format> is questionable when it comes to
  unicode characters since you have to consider such things as character
  width (i.e. double-width for ideographs) and directions (i.e. BIDI for
  Arabic and Hebrew).
  
  =item See also L</CAVEATS>
  
  =back
  
  =head1 HISTORY
  
  This pragma first appeared in Perl v5.8.0.  It has been enhanced in later
  releases as specified above.
  
  =head1 SEE ALSO
  
  L<perlunicode>, L<Encode>, L<open>, L<Filter::Util::Call>,
  
  Ch. 15 of C<Programming Perl (3rd Edition)>
  by Larry Wall, Tom Christiansen, Jon Orwant;
  O'Reilly & Associates; ISBN 0-596-00027-8
  
  =cut
ENCODING

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use Path::Class;
use lib glob file (__FILE__)->dir->parent->subdir ('modules')->subdir ('*')->subdir ('lib');

use Getopt::Long;
use Pod::Usage;

my $lang;

GetOptions (
  'lang=s' => \$lang,
  'help' => sub {
    pod2usage (-exitval => 0, -verbose => 2);
  },
) or pod2usage (-exitval => 1, -verbose => 1);

pod2usage (-exitval => 1, -verbose => 1,
           -msg => "Required argument --lang is not specified.\n")
      unless defined $lang;
$lang =~ tr/A-Z/a-z/; ## ASCII case-insensitive.

sub get_content_element ($) {
  my $container = shift;
  
  my $c_el;
  for my $e (@{$container->child_nodes}) {
    next unless $e->node_type == $e->ELEMENT_NODE;
    my $e_lang = $e->manakai_html_language;
    $e_lang =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
    if ($e_lang eq $lang) {
      $c_el = $e;
      last;
    } else {
      $c_el ||= $e;
    }
  }
  
  return $c_el;
} # get_content_element

require Message::DOM::DOMImplementation;
my $dom = Message::DOM::DOMImplementation->new;

my $doc = $dom->create_document;
$doc->manakai_is_html (1);

{
  binmode STDIN, ':encoding(utf8)';
  local $/ = undef;
  $doc->inner_html (scalar <STDIN>);
}

my @remove;

my $containers = $doc->query_selector_all
    ('[data-lang-container], [data-lang-content]');
for my $el (@$containers) {
  next unless $el->parent_node;

  if ($el->has_attribute ('data-lang-container')) {
    my $content = get_content_element ($el);
    next unless $content;
    if ($el->get_attribute ('data-lang-container') eq 'replace') {
      $el->parent_node->replace_child ($content, $el);
    } else {
      $el->text_content ('');
      $el->append_child ($content);
    }
  } elsif ($el->has_attribute ('data-lang-content')) {
    my $idref = $el->get_attribute ('data-lang-content');
    my $container = $doc->get_element_by_id ($idref);
    unless ($container) {
      warn "Element with ID $idref not found\n";
      next;
    }

    my $content = get_content_element ($container);
    $el->text_content ($content->text_content);
    $el->manakai_html_language ($content->manakai_html_language);
    
    if ($container->has_attribute ('data-lang-declaration')) {
      push @remove, $container;
    }
  }
}

for (@remove) {
  next unless $_->parent_node;
  $_->parent_node->remove_child ($_);
}

$doc->document_element->manakai_html_language ($lang);

binmode STDOUT, ':encoding(utf8)';
print STDOUT $doc->inner_html;

__END__

=head1 NAME

harusame - Multilingual Web page management tool

=head1 SYNOPSIS

  $ harusame --lang LANGCODE < input.html > output.html

  $ harusame --help

=head1 DESCRIPTION

The C<harusame> script extracts a version of the HTML document written
in the specified natural language, from a source HTML document that
contains paragraphs in multiple natural languages.

The document management of a multilingual Web site where there are
multiple versions of a (conceptually same) document is somewhat
difficult in general.  If the author of an HTML document wants to edit
a part of the document, then he or she has to ensure not to forget
updating translations at the same time, otherwise documents in
different language versions also differ in their content versions.

Using the C<harusame>, one can generate versions of an HTML document
in different language from one source HTML document that contains
paragraphs written in all of those languages, such that authors no
longer have to manage different content versions and different
language versions in separate files.

=head1 ARGUMENTS

The source document must be provided to the script using the
I<standard input>.  It must be encoded in UTF-8.

The script outputs the generated document encoded in UTF-8 to the
I<standard output>.

Following command-line options are available to this script:

=over 4

=item C<--help>

Show the help message and exit.

=item C<--lang I<LANGCODE>> (B<REQUIRED>)

The language of the version to generate.  This option must be
specified.  The value must be a value that is valid for HTML
C<lang=""> attribute.

=back

=head1 SEE ALSO

Readme L<https://suika.suikawiki.org/www/harusame/readme>.  How to
mark up the source HTML document is described in this document.

=head1 AUTHOR

Wakaba <wakaba@suikawiki.org>.

=head1 LICENSE

Copyright 2008, 2010 Wakaba <wakaba@suikawiki.org>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
